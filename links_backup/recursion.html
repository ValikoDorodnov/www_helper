<!DOCTYPE html><html lang="ru" data-theme-enabled="1"><head><script>window.currentUser = null;</script><script>window.rateUsdToNative = 98.8745;</script><title itemprop="name">Рекурсия и стек</title><link href="https://learn.javascript.ru/pack/styles.151c2ad2b575d09af8f5.css" rel="stylesheet"><meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=yes, minimum-scale=1.0"><meta name="apple-mobile-web-app-capable" content="yes"><!-- chrome autotranslate is enabled only for "en" main version--><meta name="google" content="notranslate"><script>if (window.devicePixelRatio > 1) document.cookie = 'pixelRatio=' + window.devicePixelRatio + ';path=/;expires=Tue, 19 Jan 2038 03:14:07 GMT';</script><link href="https://fonts.googleapis.com/css?family=Open+Sans:bold,italic,bolditalic" rel="stylesheet"><link rel="apple-touch-icon-precomposed" href="https://learn.javascript.ru/img/favicon/apple-touch-icon-precomposed.png"><link rel="canonical" href="recursion.html"><meta name="msapplication-TileColor" content="#222A2C"><meta name="msapplication-TileImage" content="/img/favicon/tileicon.png"><link rel="icon" href="https://learn.javascript.ru/img/favicon/favicon.png"><meta itemprop="image" content="https://learn.javascript.ru/img/site_preview_ru_512x512.png"><meta property="og:title" content="Рекурсия и стек"><meta property="og:image" content="https://learn.javascript.ru/img/site_preview_ru_1200x630.png"><meta property="og:image:type" content="image/png"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="630"><meta property="fb:admins" content="100001562528165"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Рекурсия и стек"><meta name="twitter:site" content="@iliakan"><meta name="twitter:creator" content="@iliakan"><meta name="twitter:image" content="https://learn.javascript.ru/img/site_preview_ru_512x512.png"><link rel="prev" href="https://learn.javascript.ru/advanced-functions"><link rel="next" href="https://learn.javascript.ru/rest-parameters-spread-operator"><script>window.GA_ID = "UA-2056213-16";</script><script>window.GTM_ID = 'GTM-WD2DZPG'</script><script>window.YANDEX_METRIKA_ID = 17649010;</script><script>window.GoogleAnalyticsObject="ga",window.ga=function(){window.ga.q.push(arguments)},window.ga.q=[],window.ga.l=Date.now(),ga("create",GA_ID,"auto"),window.GTM_ID&&ga("require",GTM_ID),window.currentUser?ga("set","&uid",currentUser.id):ga("set","anonymizeIp",!0),window.addEventListener("error",function(e){var r=(e.filename||e.errorUrl)+": "+(e.lineno||e.errorLine),n=e.stack||e.error&&e.error.stack;ga("send","exception",{exDescription:e.message+" "+r+" "+n,exFatal:!0})});</script><script src="https://www.google-analytics.com/analytics.js" async></script><script>ga('send', 'pageview');</script><script>window.metrika={reachGoal:function(){}},window.yandex_metrika_callbacks=[function(){try{window.metrika=new Ya.Metrika({id:YANDEX_METRIKA_ID,webvisor:!0,clickmap:!0,params:{user:window.currentUser&&window.currentUser.id}}),metrika.trackLinks({delay:150}),window.addEventListener("error",function(r){window.metrika.reachGoal("JSERROR",{src:(r.filename||r.errorUrl)+": "+(r.lineno||r.errorLine),stack:r.stack||r.error&&r.error.stack,message:r.message})})}catch(r){}}];</script><script src="https://mc.yandex.ru/metrika/watch.js" async></script><script>window.RECAPTCHA_ID = "6LfmLAEVAAAAAJMykMnf7aY8nkyTRmYi2ynx51R1";</script><script src="https://learn.javascript.ru/pack/init.f43ee4b37d6f76e4f838.js"></script><script src="https://learn.javascript.ru/pack/head.9546f64faccf13e736f6.js" defer></script><style>
.function-execution-context-list {
  margin: 0;
  padding: 0;
  overflow: auto;
}

.function-execution-context {
  border: 1px solid black;
  font-family: 'PT Mono', 'DejaVu Sans Mono', 'Lucida Console', 'Menlo', 'Monaco', monospace;
  padding: 4px 6px;
  margin: 0 4px;
}

.function-execution-context-call {
  color: gray;
}

.function-execution-context-call::before {
  content: ' вызов: ';
}

.function-execution-context-list li:first-child {
  font-weight: bold;
}
</style>
<meta property="og:title" content="Рекурсия и стек"><meta property="og:type" content="article"><script src="https://learn.javascript.ru/pack/tutorial.f792acb067a354bc7904.js" defer></script><script src="https://learn.javascript.ru/pack/footer.440ca4f81c63a09affe0.js" defer></script></head><body class="no-icons"><script>window.fontTest();</script><div class="page-wrapper page-wrapper_sidebar_on"><!--[if IE]><div style="color:red;text-align:center">Извините, Internet Explorer не поддерживается, пожалуйста используйте более новый браузер.</div><![endif]--><div class="sitetoolbar sitetoolbar_tutorial"><script>window.langs = [{"code":"ar","name":"Arabic"},{"code":"az","name":"Azerbaijani"},{"code":"bg","name":"Bulgarian"},{"code":"bn","name":"Bengali"},{"code":"bs","name":"Bosnian"},{"code":"ca","name":"Catalan"},{"code":"cs","name":"Czech"},{"code":"da","name":"Danish"},{"code":"de","name":"German"},{"code":"el","name":"Greek"},{"code":"en","name":"English"},{"code":"es","name":"Spanish"},{"code":"fa","name":"Persian (Farsi)"},{"code":"fi","name":"Finnish"},{"code":"fr","name":"French"},{"code":"he","name":"Hebrew"},{"code":"hi","name":"Hindi"},{"code":"hr","name":"Croatian"},{"code":"hu","name":"Hungarian"},{"code":"hy","name":"Armenian"},{"code":"id","name":"Indonesian"},{"code":"it","name":"Italian"},{"code":"ja","name":"Japanese"},{"code":"ka","name":"Georgian"},{"code":"kk","name":"Kazakh"},{"code":"km","name":"Central Khmer"},{"code":"ko","name":"Korean"},{"code":"lt","name":"Lithuanian"},{"code":"me","name":"Montenegrin"},{"code":"ml","name":"Malayalam"},{"code":"my","name":"Burmese"},{"code":"nl","name":"Dutch"},{"code":"no","name":"Norvegian"},{"code":"pa","name":"Punjabi"},{"code":"pl","name":"Polish"},{"code":"pt","name":"Portuguese"},{"code":"ro","name":"Romanian"},{"code":"ru","name":"Russian"},{"code":"si","name":"Sinhala"},{"code":"sk","name":"Slovak"},{"code":"sl","name":"Slovenian"},{"code":"sq","name":"Albanian"},{"code":"sr","name":"Serbian"},{"code":"ta","name":"Tamil"},{"code":"te","name":"Telugu"},{"code":"test","name":"Test"},{"code":"th","name":"Thai"},{"code":"tk","name":"Turkmen"},{"code":"tr","name":"Turkish"},{"code":"uk","name":"Ukrainian"},{"code":"ur","name":"Urdu"},{"code":"uz","name":"Uzbek"},{"code":"v2","name":"v2"},{"code":"vi","name":"Vietnamese"},{"code":"zh-hant","name":"Chinese Traditional"},{"code":"zh","name":"Chinese"}];</script><script>window.lang = "ru";</script><script>{let t=navigator.languages||[];t=t.map(t=>t.toLowerCase());let o,i,n=[];for(let o of window.langs)for(let i of t)if(i===o.code||i.startsWith(o.code+"-")){n.push(o);break}if(!o&&"ru"!=lang&&"en"!=lang){n.find(t=>"en"==t.code)&&(o=`\n            According to your browser headers, you know English. Please help to <a href="https://github.com/javascript-tutorial/${lang}.javascript.info#readme">translate the tutorial</a>.\n            Thank you!\n          `,i="notify-translate-tutorial-local")}if(o){let t=`<div class="notification notification_top notification_info sitetoolbar__notification" style="display:none" id="${i}">\n          <div class="notification__content">${o}</div>\n          <button class="notification__close" title="Close"></button>\n        </div>`;document.write(t),showTopNotification()}}</script><div class="sitetoolbar__content"><div class="sitetoolbar__lang-switcher"><button class="sitetoolbar__dropdown-button" data-dropdown-toggler>RU</button><div class="sitetoolbar__dropdown-wrap"><div class="sitetoolbar__dropdown-body"><div class="sitetoolbar__lang-switcher-body"><div class="supported-langs supported-langs_toolbar"><div class="supported-langs__container"><ul class="supported-langs__list" style="height:200px"><li class="supported-langs__item"><a class="supported-langs__link" href="https://ar.javascript.info/recursion"><span class="supported-langs__brief">AR</span><span class="supported-langs__title">عربي</span></a></li><li class="supported-langs__item"><a class="supported-langs__link" href="https://javascript.info/recursion"><span class="supported-langs__brief">EN</span><span class="supported-langs__title">English</span></a></li><li class="supported-langs__item"><a class="supported-langs__link" href="https://es.javascript.info/recursion"><span class="supported-langs__brief">ES</span><span class="supported-langs__title">Español</span></a></li><li class="supported-langs__item"><a class="supported-langs__link" href="https://fr.javascript.info/recursion"><span class="supported-langs__brief">FR</span><span class="supported-langs__title">Français</span></a></li><li class="supported-langs__item"><a class="supported-langs__link" href="https://id.javascript.info/recursion"><span class="supported-langs__brief">ID</span><span class="supported-langs__title">Indonesia</span></a></li><li class="supported-langs__item"><a class="supported-langs__link" href="https://it.javascript.info/recursion"><span class="supported-langs__brief">IT</span><span class="supported-langs__title">Italiano</span></a></li></ul><ul class="supported-langs__list" style="height:200px"><li class="supported-langs__item"><a class="supported-langs__link" href="https://ja.javascript.info/recursion"><span class="supported-langs__brief">JA</span><span class="supported-langs__title">日本語</span></a></li><li class="supported-langs__item"><a class="supported-langs__link" href="https://ko.javascript.info/recursion"><span class="supported-langs__brief">KO</span><span class="supported-langs__title">한국어</span></a></li><li class="supported-langs__item supported-langs__item_current"><a class="supported-langs__link" href="recursion.html"><span class="supported-langs__brief">RU</span><span class="supported-langs__title">Русский</span></a></li><li class="supported-langs__item"><a class="supported-langs__link" href="https://tr.javascript.info/recursion"><span class="supported-langs__brief">TR</span><span class="supported-langs__title">Türkçe</span></a></li><li class="supported-langs__item"><a class="supported-langs__link" href="https://uk.javascript.info/recursion"><span class="supported-langs__brief">UK</span><span class="supported-langs__title">Українська</span></a></li><li class="supported-langs__item"><a class="supported-langs__link" href="https://zh.javascript.info/recursion"><span class="supported-langs__brief">ZH</span><span class="supported-langs__title">简体中文</span></a></li></ul></div><div class="supported-langs__text">Мы хотим сделать этот проект с открытым исходным кодом доступным для людей во всем мире. Пожалуйста, <a href="https://github.com/javascript-tutorial/translate" rel="noopener noreferrer" target="_blank">помогите нам перевести</a> это руководство на свой язык</div></div></div></div></div></div><div class="sitetoolbar__logo-wrap"><a class="sitetoolbar__link sitetoolbar__link_logo" href="https://learn.javascript.ru/"><img class="sitetoolbar__logo sitetoolbar__logo_normal" src="https://learn.javascript.ru/img/sitetoolbar__logo_ru.svg" width="171" alt="" role="presentation"/><img class="sitetoolbar__logo sitetoolbar__logo_normal sitetoolbar__logo_dark" src="https://learn.javascript.ru/img/sitetoolbar__logo_ru-white.svg" width="171" alt="" role="presentation"/><img class="sitetoolbar__logo sitetoolbar__logo_small" src="https://learn.javascript.ru/img/sitetoolbar__logo_small_ru.svg" width="80" alt="" role="presentation"/><img class="sitetoolbar__logo sitetoolbar__logo_small sitetoolbar__logo_dark" src="https://learn.javascript.ru/img/sitetoolbar__logo_small_ru-white.svg" width="80" alt="" role="presentation"/><script>Array.prototype.forEach.call(document.querySelectorAll("img.sitetoolbar__logo"),function(e){let t=document.createElement("object");t.type="image/svg+xml",t.className=e.className,t.style.cssText="left:0;top:0;position:absolute",t.onload=function(){t.onload=null,e.style.visibility="hidden"},t.data=e.src,e.parentNode.insertBefore(t,e)});</script></a></div><div class="sitetoolbar__nav-toggle-wrap"><button class="sitetoolbar__nav-toggle" type="button"></button></div><nav class="sitetoolbar__sections"><ul class="sitetoolbar__sections-list"><li class="sitetoolbar__section sitetoolbar__section_current"><a class="sitetoolbar__link" href="https://learn.javascript.ru/">Учебник</a></li><li class="sitetoolbar__section"><a class="sitetoolbar__link" href="https://learn.javascript.ru/courses">Курсы</a></li><li class="sitetoolbar__section"><a class="sitetoolbar__link" href="https://javascript.ru/forum/">Форум</a></li><li class="sitetoolbar__section"><a class="sitetoolbar__link" href="https://learn.javascript.ru/quiz">Тесты знаний</a></li><li class="sitetoolbar__section sitetoolbar__section_dropdown"><button class="sitetoolbar__dropdown-button" data-dropdown-toggler>Скринкасты</button><div class="sitetoolbar__dropdown-wrap"><div class="sitetoolbar__dropdown-body"><ul class="sitetoolbar__dropdown-items"><li class="sitetoolbar__dropdown-item"><a class="sitetoolbar__secondary-link sitetoolbar__dropdown-link" href="https://learn.javascript.ru/screencast/nodejs">Node.js</a></li><li class="sitetoolbar__dropdown-item"><a class="sitetoolbar__secondary-link sitetoolbar__dropdown-link" href="https://learn.javascript.ru/screencast/webpack">Webpack</a></li><li class="sitetoolbar__dropdown-item"><a class="sitetoolbar__secondary-link sitetoolbar__dropdown-link" href="https://learn.javascript.ru/screencast/gulp">Gulp</a></li><li class="sitetoolbar__dropdown-item"><a class="sitetoolbar__secondary-link sitetoolbar__dropdown-link" href="https://learn.javascript.ru/screencast/react">React.js</a></li><li class="sitetoolbar__dropdown-item"><a class="sitetoolbar__secondary-link sitetoolbar__dropdown-link" href="https://learn.javascript.ru/screencast/angular">Angular</a></li><li class="sitetoolbar__dropdown-item"><a class="sitetoolbar__secondary-link sitetoolbar__dropdown-link" href="https://youtu.be/W4hoc24K93E?list=PLDyvV36pndZFHXjXuwA_NywNrVQO0aQqb">Git: курс</a></li><li class="sitetoolbar__dropdown-item"><a class="sitetoolbar__secondary-link sitetoolbar__dropdown-link" href="https://youtu.be/lHacJuru1bc?list=PLDyvV36pndZEB7kWWocU4QSn-G78LoaEE">Git: разное</a></li></ul></div></div></li></ul></nav><div class="sitetoolbar__book-wrap"><a class="buy-book-button" href="https://learn.javascript.ru/ebook"><span class="buy-book-button__extra-text">Купить</span>EPUB/PDF</a></div><div class="sitetoolbar__login-wrap"><button class="sitetoolbar__login sitetoolbar__login_unready" data-action-login></button></div><div class="sitetoolbar__theme-switcher"><div class="theme-changer"><label class="theme-changer__label" for="theme-changer-input" data-tooltip="Сменить тему оформления"><input class="theme-changer__input" type="checkbox" id="theme-changer-input" data-theme-changer="data-theme-changer"/><span class="theme-changer__icon theme-changer__icon_light-theme"></span><span class="theme-changer__icon theme-changer__icon_dark-theme"></span></label></div></div><div class="sitetoolbar__search-wrap"><div class="sitetoolbar__search-content"><button class="sitetoolbar__search-toggle" type="button"></button><form class="sitetoolbar__search" method="GET" action="https://learn.javascript.ru/search"><div class="sitetoolbar__search-input"><div class="text-input"><input class="text-input__control" name="query" placeholder="Искать на Javascript.ru" required="required" type="text"/></div><button class="sitetoolbar__find" type="submit">Найти</button></div></form></div></div></div><div class="tablet-menu"><div class="tablet-menu__line"><div class="tablet-menu__content"><select class="tablet-menu__nav input-select input-select input-select_small" onchange="if(this.value) window.location.href=this.value"><option value="/" selected>Учебник</option><option value="/courses">Курсы</option><option value="https://javascript.ru/forum/">Форум</option><option value="/quiz">Тесты знаний</option></select></div></div><div class="tablet-menu__line"><div class="tablet-menu__content"><form class="tablet-menu-search" action="https://learn.javascript.ru/search/"><input class="tablet-menu-search__input" type="search" name="query" placeholder="Поиск в учебнике" required="required"/><button class="tablet-menu-search__button" type="submit" name="type" value="articles">Поиск</button></form></div></div><div class="tablet-menu__line"><div class="tablet-menu__content"><a class="map" href="https://learn.javascript.ru/tutorial/map" data-action="tutorial-map"><span class="map__text">Карта учебника</span></a></div></div><div class="tablet-menu__line"><div class="tablet-menu__content"><div class="theme-changer theme-changer_tablet-menu theme-changer_has-label"><label class="theme-changer__label" for="theme-changer-input-tablet" data-tooltip="Сменить тему оформления"><input class="theme-changer__input" type="checkbox" id="theme-changer-input-tablet" data-theme-changer="data-theme-changer"/><span class="theme-changer__icon theme-changer__icon_light-theme"></span><span class="theme-changer__icon theme-changer__icon_dark-theme"></span><span class="theme-changer__label-text theme-changer__label-text_light-theme">Светлая тема</span><span class="theme-changer__label-text theme-changer__label-text_dark-theme">Тёмная тема</span></label></div></div></div><div class="tablet-menu__line"><div class="tablet-menu__content"><div class="share-icons"><span class="share-icons__title">Поделиться</span><a class="share share_tw" href="https://twitter.com/share?url=https%3A%2F%2Flearn.javascript.ru%2Frecursion" rel="nofollow"></a><a class="share share_fb" href="https://www.facebook.com/sharer/sharer.php?s=100&amp;p%5Burl%5D=https%3A%2F%2Flearn.javascript.ru%2Frecursion" rel="nofollow"></a><a class="share share_vk" href="https://vkontakte.ru/share.php?url=https%3A%2F%2Flearn.javascript.ru%2Frecursion" rel="nofollow"></a></div></div></div><div class="tablet-menu__line"><div class="tablet-menu__content"><select class="tablet-menu__nav input-select input-select input-select_small" onchange="if(this.value) window.location.href=this.value"><option value="https://ar.javascript.info/recursion">عربي</option><option value="https://javascript.info/recursion">English</option><option value="https://es.javascript.info/recursion">Español</option><option value="https://fr.javascript.info/recursion">Français</option><option value="https://id.javascript.info/recursion">Indonesia</option><option value="https://it.javascript.info/recursion">Italiano</option><option value="https://ja.javascript.info/recursion">日本語</option><option value="https://ko.javascript.info/recursion">한국어</option><option value="https://learn.javascript.ru/recursion" selected>Русский</option><option value="https://tr.javascript.info/recursion">Türkçe</option><option value="https://uk.javascript.info/recursion">Українська</option><option value="https://zh.javascript.info/recursion">简体中文</option></select></div></div></div><progress class="tutorial-progress" data-sticky value="49" max="93" data-tooltip="Урок 49 из 93"></progress></div><div class="page page_sidebar_on page_inner_padding"><script>if(localStorage.noSidebar){document.querySelector(".page").classList.remove("page_sidebar_on");let e=document.querySelector(".page-wrapper");e&&e.classList.remove("page-wrapper_sidebar_on")}setTimeout(function(){document.querySelector(".page").classList.add("page_sidebar-animation-on")});</script><div class="page__inner"><main class="main main_width-limit"><header class="main__header"><div class="main__header-inner"><div class="main__header-group"><ol class="breadcrumbs"><li class="breadcrumbs__item breadcrumbs__item_home"><a class="breadcrumbs__link" href="https://learn.javascript.ru/"><span class="breadcrumbs__hidden-text">Учебник</span></a></li><li class="breadcrumbs__item" id="breadcrumb-1"><a class="breadcrumbs__link" href="https://learn.javascript.ru/js"><span>Язык JavaScript</span></a></li><li class="breadcrumbs__item" id="breadcrumb-2"><a class="breadcrumbs__link" href="https://learn.javascript.ru/advanced-functions"><span>Продвинутая работа с функциями</span></a></li><script type="application/ld+json">{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Учебник","item":"https://learn.javascript.ru/"},{"@type":"ListItem","position":2,"name":"Язык JavaScript","item":"https://learn.javascript.ru/js"},{"@type":"ListItem","position":3,"name":"Продвинутая работа с функциями","item":"https://learn.javascript.ru/advanced-functions"}]}</script></ol><div class="updated-at" data-tooltip="Последнее обновление: 3-го февраля 2022"><div class="updated-at__content">3-го февраля 2022</div></div></div><h1 class="main__header-title">Рекурсия и стек</h1></div></header><div class="content"><article class="formatted" itemscope itemtype="http://schema.org/TechArticle"><meta itemprop="name" content="Рекурсия и стек"><div itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="email" content="iliakan@gmail.com"><meta itemprop="name" content="Ilya Kantor"></div><div itemprop="articleBody"><p>Вернёмся к функциям и изучим их более подробно.</p>
<p>Нашей первой темой будет <em>рекурсия</em>.</p>
<p>Если вы не новичок в программировании, то, возможно, уже знакомы с рекурсией и можете пропустить эту главу.</p>
<p>Рекурсия – это приём программирования, полезный в ситуациях, когда задача может быть естественно разделена на несколько аналогичных, но более простых задач. Или когда задача может быть упрощена до несложных действий плюс простой вариант той же задачи. Или, как мы скоро увидим, для работы с определёнными структурами данных.</p>
<p>В процессе выполнения задачи в теле функции могут быть вызваны другие функции для выполнения подзадач. Частный случай подвызова – когда функция вызывает <em>сама себя</em>. Это как раз и называется <em>рекурсией</em>.</p>
<h2><a class="main__anchor" name="dva-sposoba-myshleniya" href="recursion.html#dva-sposoba-myshleniya">Два способа мышления</a></h2><p>В качестве первого примера напишем функцию <code>pow(x, n)</code>, которая возводит <code>x</code> в натуральную степень <code>n</code>. Иначе говоря, умножает <code>x</code> на само себя <code>n</code> раз.</p>
<div id="cexswow37k" data-trusted="1" class="code-example">
      <div class="codebox code-example__codebox">
        
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code>pow(2, 2) = 4
pow(2, 3) = 8
pow(2, 4) = 16</code></pre>
        </div>
      </div>
      
      </div><p>Рассмотрим два способа её реализации.</p>
<ol>
<li>
<p>Итеративный способ: цикл <code>for</code>:</p>
<div id="9te0clroo8" data-trusted="1" class="code-example">
      <div class="codebox code-example__codebox">
        
        <div class="toolbar codebox__toolbar">
          <div class="toolbar__tool">
            <a href="recursion.html#" title="выполнить" data-action="run" class="toolbar__button toolbar__button_run"></a>
          </div>
          <div class="toolbar__tool">
            <a href="recursion.html#" title="открыть в песочнице" target="_blank" data-action="edit" class="toolbar__button toolbar__button_edit"></a>
          </div>
        </div>
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code>function pow(x, n) {
  let result = 1;

  // умножаем result на x n раз в цикле
  for (let i = 0; i &lt; n; i++) {
    result *= x;
  }

  return result;
}

alert( pow(2, 3) ); // 8</code></pre>
        </div>
      </div>
      
      </div></li>
<li>
<p>Рекурсивный способ: упрощение задачи и вызов функцией самой себя:</p>
<div id="xo67uutnnh" data-trusted="1" class="code-example">
      <div class="codebox code-example__codebox">
        
        <div class="toolbar codebox__toolbar">
          <div class="toolbar__tool">
            <a href="recursion.html#" title="выполнить" data-action="run" class="toolbar__button toolbar__button_run"></a>
          </div>
          <div class="toolbar__tool">
            <a href="recursion.html#" title="открыть в песочнице" target="_blank" data-action="edit" class="toolbar__button toolbar__button_edit"></a>
          </div>
        </div>
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code>function pow(x, n) {
  if (n == 1) {
    return x;
  } else {
    return x * pow(x, n - 1);
  }
}

alert( pow(2, 3) ); // 8</code></pre>
        </div>
      </div>
      
      </div></li>
</ol>
<p>Обратите внимание, что рекурсивный вариант отличается принципиально.</p>
<p>Когда функция <code>pow(x, n)</code> вызывается, исполнение делится на две ветви:</p>
<div id="6dw3y1m3fv" data-trusted="1" class="code-example">
      <div class="codebox code-example__codebox">
        
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code>              if n==1  = x
             /
pow(x, n) =
             \
              else     = x * pow(x, n - 1)</code></pre>
        </div>
      </div>
      
      </div><ol>
<li>Если <code>n == 1</code>, тогда всё просто. Эта ветвь называется <em>базой</em> рекурсии, потому что сразу же приводит к очевидному результату: <code>pow(x, 1)</code> равно <code>x</code>.</li>
<li>Мы можем представить <code>pow(x, n)</code> в виде: <code>x * pow(x, n - 1)</code>. Что в математике записывается как: <code>x<sup>n</sup> = x * x<sup>n-1</sup></code>. Эта ветвь –  <em>шаг рекурсии</em>: мы сводим задачу к более простому действию (умножение на <code>x</code>) и более простой аналогичной задаче (<code>pow</code> с меньшим <code>n</code>). Последующие шаги упрощают задачу всё больше и больше, пока <code>n</code> не достигает <code>1</code>.</li>
</ol>
<p>Говорят, что функция <code>pow</code> <em>рекурсивно вызывает саму себя</em> до <code>n == 1</code>.</p>
<figure><div class="image" style="width:502px">
      <div class="image__ratio" style="padding-top:44.820717131474105%"></div>
      <object type="image/svg+xml" data="https://learn.javascript.ru/article/recursion/recursion-pow.svg" width="502" height="225" class="image__image" data-use-theme>
        <img src="https://learn.javascript.ru/article/recursion/recursion-pow.svg" alt="" width="502" height="225">
      </object>
      </div></figure><p>Например, рекурсивный вариант вычисления <code>pow(2, 4)</code> состоит из шагов:</p>
<ol>
<li><code>pow(2, 4) = 2 * pow(2, 3)</code></li>
<li><code>pow(2, 3) = 2 * pow(2, 2)</code></li>
<li><code>pow(2, 2) = 2 * pow(2, 1)</code></li>
<li><code>pow(2, 1) = 2</code></li>
</ol>
<p>Итак, рекурсию используют, когда вычисление функции можно свести к её более простому вызову, а его – к ещё более простому и так далее, пока значение не станет очевидно.</p>
<div class="important important_smart">
            <div class="important__header"><span class="important__type">Рекурсивное решение обычно короче</span></div>
            <div class="important__content"><p>Рекурсивное решение задачи обычно короче, чем итеративное.</p>
<p>Используя условный оператор <code>?</code> вместо <code>if</code>, мы можем переписать <code>pow(x, n)</code>, делая код функции более лаконичным, но всё ещё легко читаемым:</p>
<div id="q3v2irgrla" data-trusted="1" class="code-example">
      <div class="codebox code-example__codebox">
        
        <div class="toolbar codebox__toolbar">
          <div class="toolbar__tool">
            <a href="recursion.html#" title="выполнить" data-action="run" class="toolbar__button toolbar__button_run"></a>
          </div>
          <div class="toolbar__tool">
            <a href="recursion.html#" title="открыть в песочнице" target="_blank" data-action="edit" class="toolbar__button toolbar__button_edit"></a>
          </div>
        </div>
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code>function pow(x, n) {
  return (n == 1) ? x : (x * pow(x, n - 1));
}</code></pre>
        </div>
      </div>
      
      </div></div></div>
<p>Общее количество вложенных вызовов (включая первый) называют <em>глубиной рекурсии</em>. В нашем случае она будет равна <code>n</code>.</p>
<p>Максимальная глубина рекурсии ограничена движком JavaScript. Точно можно рассчитывать на 10000 вложенных вызовов, некоторые интерпретаторы допускают и больше, но для большинства из них 100000 вызовов – за пределами возможностей. Существуют автоматические оптимизации, помогающие избежать переполнения стека вызовов («оптимизация хвостовой рекурсии»), но они ещё не поддерживаются везде и работают только для простых случаев.</p>
<p>Это ограничивает применение рекурсии, но она всё равно широко распространена: для решения большого числа задач рекурсивный способ решения даёт более простой код, который легче поддерживать.</p>
<h2><a class="main__anchor" name="kontekst-vypolneniya-stek" href="recursion.html#kontekst-vypolneniya-stek">Контекст выполнения, стек</a></h2><p>Теперь мы посмотрим, как работают рекурсивные вызовы. Для этого заглянем «под капот» функций.</p>
<p>Информация о процессе выполнения запущенной функции хранится в её <em>контексте выполнения</em> (execution context).</p>
<p><a href="https://tc39.github.io/ecma262/#sec-execution-contexts">Контекст выполнения</a> – специальная внутренняя структура данных, которая содержит информацию о вызове функции. Она включает в себя конкретное место в коде, на котором находится интерпретатор, локальные переменные функции, значение <code>this</code> (мы не используем его в данном примере) и прочую служебную информацию.</p>
<p>Один вызов функции имеет ровно один контекст выполнения, связанный с ним.</p>
<p>Когда функция производит вложенный вызов, происходит следующее:</p>
<ul>
<li>Выполнение текущей функции приостанавливается.</li>
<li>Контекст выполнения, связанный с ней, запоминается в специальной структуре данных – <em>стеке контекстов выполнения</em>.</li>
<li>Выполняются вложенные вызовы, для каждого из которых создаётся свой контекст выполнения.</li>
<li>После их завершения старый контекст достаётся из стека, и выполнение внешней функции возобновляется с того места, где она была остановлена.</li>
</ul>
<p>Разберёмся с контекстами более подробно на примере вызова функции <code>pow(2, 3)</code>.</p>
<h3><a class="main__anchor" name="pow-2-3" href="recursion.html#pow-2-3">pow(2, 3)</a></h3><p>В начале вызова <code>pow(2, 3)</code> контекст выполнения будет хранить переменные: <code>x = 2, n = 3</code>, выполнение находится на первой строке функции.</p>
<p>Можно схематически изобразить это так:</p>
<ul class="function-execution-context-list">
  <li>
    <span class="function-execution-context">Контекст: { x: 2, n: 3, строка 1 }</span>
    <span class="function-execution-context-call">pow(2, 3)</span>
  </li>
</ul>
<p>Это только начало выполнения функции. Условие <code>n == 1</code> ложно, поэтому выполнение идёт во вторую ветку <code>if</code>:</p>
<div id="p27v88nuu6" data-trusted="1" class="code-example" data-highlight="[{&quot;start&quot;:4,&quot;end&quot;:4}]">
      <div class="codebox code-example__codebox">
        
        <div class="toolbar codebox__toolbar">
          <div class="toolbar__tool">
            <a href="recursion.html#" title="выполнить" data-action="run" class="toolbar__button toolbar__button_run"></a>
          </div>
          <div class="toolbar__tool">
            <a href="recursion.html#" title="открыть в песочнице" target="_blank" data-action="edit" class="toolbar__button toolbar__button_edit"></a>
          </div>
        </div>
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code>function pow(x, n) {
  if (n == 1) {
    return x;
  } else {
    return x * pow(x, n - 1);
  }
}

alert( pow(2, 3) );</code></pre>
        </div>
      </div>
      
      </div><p>Значения переменных те же самые, но выполнение функции перешло к другой строке, актуальный контекст:</p>
<ul class="function-execution-context-list">
  <li>
    <span class="function-execution-context">Контекст: { x: 2, n: 3, строка 5 }</span>
    <span class="function-execution-context-call">pow(2, 3)</span>
  </li>
</ul>
<p>Чтобы вычислить выражение <code>x * pow(x, n - 1)</code>, требуется произвести запуск <code>pow</code> с новыми аргументами <code>pow(2, 2)</code>.</p>
<h3><a class="main__anchor" name="pow-2-2" href="recursion.html#pow-2-2">pow(2, 2)</a></h3><p>Для выполнения вложенного вызова JavaScript запоминает текущий контекст выполнения в <em>стеке контекстов выполнения</em>.</p>
<p>Здесь мы вызываем ту же функцию <code>pow</code>, однако это абсолютно неважно. Для любых функций процесс одинаков:</p>
<ol>
<li>Текущий контекст «запоминается» на вершине стека.</li>
<li>Создаётся новый контекст для вложенного вызова.</li>
<li>Когда выполнение вложенного вызова заканчивается – контекст предыдущего вызова восстанавливается, и выполнение соответствующей функции продолжается.</li>
</ol>
<p>Вид контекста в начале выполнения вложенного вызова <code>pow(2, 2)</code>:</p>
<ul class="function-execution-context-list">
  <li>
    <span class="function-execution-context">Контекст: { x: 2, n: 2, строка 1 }</span>
    <span class="function-execution-context-call">pow(2, 2)</span>
  </li>
  <li>
    <span class="function-execution-context">Контекст: { x: 2, n: 3, строка 5 }</span>
    <span class="function-execution-context-call">pow(2, 3)</span>
  </li>
</ul>
<p>Новый контекст выполнения находится на вершине стека (и выделен жирным), а предыдущие запомненные контексты – под ним.</p>
<p>Когда выполнение подвызова закончится, можно будет легко вернуться назад, потому что контекст сохраняет как переменные, так и точное место кода, в котором он остановился. Слово «строка» на рисунках условно, на самом деле запоминается более точное место в цепочке команд.</p>
<h3><a class="main__anchor" name="pow-2-1" href="recursion.html#pow-2-1">pow(2, 1)</a></h3><p>Процесс повторяется: производится новый вызов в строке <code>5</code>, теперь с аргументами <code>x=2</code>, <code>n=1</code>.</p>
<p>Создаётся новый контекст выполнения, предыдущий контекст добавляется в стек:</p>
<ul class="function-execution-context-list">
  <li>
    <span class="function-execution-context">Контекст: { x: 2, n: 1, строка 1 }</span>
    <span class="function-execution-context-call">pow(2, 1)</span>
  </li>
  <li>
    <span class="function-execution-context">Контекст: { x: 2, n: 2, строка 5 }</span>
    <span class="function-execution-context-call">pow(2, 2)</span>
  </li>
  <li>
    <span class="function-execution-context">Контекст: { x: 2, n: 3, строка 5 }</span>
    <span class="function-execution-context-call">pow(2, 3)</span>
  </li>
</ul>
<p>Теперь в стеке два старых контекста и один текущий для <code>pow(2, 1)</code>.</p>
<h3><a class="main__anchor" name="vyhod" href="recursion.html#vyhod">Выход</a></h3><p>При выполнении <code>pow(2, 1)</code>, в отличие от предыдущих запусков, условие <code>n == 1</code> истинно, поэтому выполняется первая ветка условия <code>if</code>:</p>
<div id="scj6ajvjjb" data-trusted="1" class="code-example" data-highlight="[{&quot;start&quot;:2,&quot;end&quot;:2}]">
      <div class="codebox code-example__codebox">
        
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code>function pow(x, n) {
  if (n == 1) {
    return x;
  } else {
    return x * pow(x, n - 1);
  }
}</code></pre>
        </div>
      </div>
      
      </div><p>Вложенных вызовов больше нет, поэтому функция завершается, возвращая <code>2</code>.</p>
<p>Когда функция заканчивается, контекст её выполнения больше не нужен, поэтому он удаляется из памяти, а из стека восстанавливается предыдущий:</p>
<ul class="function-execution-context-list">
  <li>
    <span class="function-execution-context">Контекст: { x: 2, n: 2, строка 5 }</span>
    <span class="function-execution-context-call">pow(2, 2)</span>
  </li>
  <li>
    <span class="function-execution-context">Контекст: { x: 2, n: 3, строка 5 }</span>
    <span class="function-execution-context-call">pow(2, 3)</span>
  </li>
</ul>
<p>Возобновляется обработка вызова <code>pow(2, 2)</code>. Имея результат <code>pow(2, 1)</code>, он может закончить свою работу <code>x * pow(x, n - 1)</code>, вернув <code>4</code>.</p>
<p>Восстанавливается контекст предыдущего вызова:</p>
<ul class="function-execution-context-list">
  <li>
    <span class="function-execution-context">Контекст: { x: 2, n: 3, строка 5 }</span>
    <span class="function-execution-context-call">pow(2, 3)</span>
  </li>
</ul>
<p>Самый внешний вызов заканчивает свою работу, его результат: <code>pow(2, 3) = 8</code>.</p>
<p>Глубина рекурсии в данном случае составила <strong>3</strong>.</p>
<p>Как видно из иллюстраций выше, глубина рекурсии равна максимальному числу контекстов, одновременно хранимых в стеке.</p>
<p>Обратим внимание на требования к памяти. Рекурсия приводит к хранению всех данных для неоконченных внешних вызовов в стеке, и в данном случае это приводит к тому, что возведение в степень <code>n</code> хранит в памяти <code>n</code> различных контекстов.</p>
<p>Реализация возведения в степень через цикл гораздо более экономна:</p>
<div id="ib5833mgt5" data-trusted="1" class="code-example">
      <div class="codebox code-example__codebox">
        
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code>function pow(x, n) {
  let result = 1;

  for (let i = 0; i &lt; n; i++) {
    result *= x;
  }

  return result;
}</code></pre>
        </div>
      </div>
      
      </div><p>Итеративный вариант функции <code>pow</code> использует один контекст, в котором будут последовательно меняться значения <code>i</code> и <code>result</code>. При этом объём затрачиваемой памяти небольшой, фиксированный и не зависит от <code>n</code>.</p>
<p><strong>Любая рекурсия может быть переделана в цикл. Как правило, вариант с циклом будет эффективнее.</strong></p>
<p>Но переделка рекурсии в цикл может быть нетривиальной, особенно когда в функции в зависимости от условий используются различные рекурсивные подвызовы, результаты которых объединяются, или когда ветвление более сложное. Оптимизация может быть ненужной и совершенно нестоящей усилий.</p>
<p>Часто код с использованием рекурсии более короткий, лёгкий для понимания и поддержки. Оптимизация требуется не везде, как правило, нам важен хороший код, поэтому она и используется.</p>
<h2><a class="main__anchor" name="rekursivnye-obhody" href="recursion.html#rekursivnye-obhody">Рекурсивные обходы</a></h2><p>Другим отличным применением рекурсии является рекурсивный обход.</p>
<p>Представьте, у нас есть компания. Структура персонала может быть представлена как объект:</p>
<div id="zdk1qcl0z2" data-trusted="1" class="code-example">
      <div class="codebox code-example__codebox">
        
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code>let company = {
  sales: [{
    name: 'John',
    salary: 1000
  }, {
    name: 'Alice',
    salary: 600
  }],

  development: {
    sites: [{
      name: 'Peter',
      salary: 2000
    }, {
      name: 'Alex',
      salary: 1800
    }],

    internals: [{
      name: 'Jack',
      salary: 1300
    }]
  }
};</code></pre>
        </div>
      </div>
      
      </div><p>Другими словами, в компании есть отделы.</p>
<ul>
<li>
<p>Отдел может состоять из массива работников. Например, в отделе <code>sales</code>  работают 2 сотрудника: Джон и Алиса.</p>
</li>
<li>
<p>Или отдел может быть разделён на подотделы, например, отдел <code>development</code> состоит из подотделов: <code>sites</code> и <code>internals</code>. В каждом подотделе есть свой персонал.</p>
</li>
<li>
<p>Также возможно, что при росте подотдела он делится на подразделения (или команды).</p>
<p>Например, подотдел <code>sites</code> в будущем может быть разделён на команды <code>siteA</code> и <code>siteB</code>. И потенциально они могут быть разделены ещё. Этого нет на картинке, просто нужно иметь это в виду.</p>
</li>
</ul>
<p>Теперь, допустим, нам нужна функция для получения суммы всех зарплат. Как мы можем это сделать?</p>
<p>Итеративный подход не прост, потому что структура довольно сложная. Первая идея заключается в том, чтобы сделать цикл <code>for</code> поверх объекта <code>company</code> с вложенным циклом над отделами 1-го уровня вложенности. Но затем нам нужно больше вложенных циклов для итераций над сотрудниками отделов второго уровня, таких как <code>sites</code>… А затем ещё один цикл по отделам 3-го уровня, которые могут появиться в будущем? Если мы поместим в код 3-4 вложенных цикла для обхода одного объекта, то это будет довольно некрасиво.</p>
<p>Давайте попробуем рекурсию.</p>
<p>Как мы видим, когда наша функция получает отдел для подсчёта суммы зарплат, есть два возможных случая:</p>
<ol>
<li>Либо это «простой» отдел с <em>массивом</em> – тогда мы сможем суммировать зарплаты в простом цикле.</li>
<li>Или это <em>объект</em> с <code>N</code> подотделами – тогда мы можем сделать <code>N</code> рекурсивных вызовов, чтобы получить сумму для каждого из подотделов, и объединить результаты.</li>
</ol>
<p>Случай (1), когда мы получили массив, является базой рекурсии, тривиальным случаем.</p>
<p>Случай (2), при получении объекта, является шагом рекурсии. Сложная задача разделяется на подзадачи для подотделов. Они могут, в свою очередь, снова разделиться на подотделы, но рано или поздно это разделение закончится, и решение сведётся к случаю (1).</p>
<p>Алгоритм даже проще читается в виде кода:</p>
<div id="tfhv8790sk" data-trusted="1" class="code-example" data-highlight="[{&quot;start&quot;:9,&quot;end&quot;:19}]">
      <div class="codebox code-example__codebox">
        
        <div class="toolbar codebox__toolbar">
          <div class="toolbar__tool">
            <a href="recursion.html#" title="выполнить" data-action="run" class="toolbar__button toolbar__button_run"></a>
          </div>
          <div class="toolbar__tool">
            <a href="recursion.html#" title="открыть в песочнице" target="_blank" data-action="edit" class="toolbar__button toolbar__button_edit"></a>
          </div>
        </div>
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code>let company = { // тот же самый объект, сжатый для краткости
  sales: [{name: 'John', salary: 1000}, {name: 'Alice', salary: 600 }],
  development: {
    sites: [{name: 'Peter', salary: 2000}, {name: 'Alex', salary: 1800 }],
    internals: [{name: 'Jack', salary: 1300}]
  }
};

// Функция для подсчёта суммы зарплат
function sumSalaries(department) {
  if (Array.isArray(department)) { // случай (1)
    return department.reduce((prev, current) =&gt; prev + current.salary, 0); // сумма элементов массива
  } else { // случай (2)
    let sum = 0;
    for (let subdep of Object.values(department)) {
      sum += sumSalaries(subdep); // рекурсивно вызывается для подотделов, суммируя результаты
    }
    return sum;
  }
}

alert(sumSalaries(company)); // 6700</code></pre>
        </div>
      </div>
      
      </div><p>Код краток и прост для понимания (надеюсь?). В этом сила рекурсии. Она работает на любом уровне вложенности отделов.</p>
<p>Схема вызовов:</p>
<figure><div class="image" style="width:293px">
      <div class="image__ratio" style="padding-top:149.1467576791809%"></div>
      <object type="image/svg+xml" data="https://learn.javascript.ru/article/recursion/recursive-salaries.svg" width="293" height="437" class="image__image" data-use-theme>
        <img src="https://learn.javascript.ru/article/recursion/recursive-salaries.svg" alt="" width="293" height="437">
      </object>
      </div></figure><p>Принцип прост: для объекта <code>{...}</code> используются рекурсивные вызовы, а массивы <code>[...]</code> являются «листьями» дерева рекурсии, они сразу дают результат.</p>
<p>Обратите внимание, что в коде используются возможности, о которых мы говорили ранее:</p>
<ul>
<li>Метод <code>arr.reduce</code> из главы <a href="https://learn.javascript.ru/array-methods">Методы массивов</a> для получения суммы элементов массива.</li>
<li>Цикл <code>for(val of Object.values(obj))</code> для итерации по значениям объекта: <code>Object.values</code> возвращает массив значений.</li>
</ul>
<h2><a class="main__anchor" name="rekursivnye-struktury" href="recursion.html#rekursivnye-struktury">Рекурсивные структуры</a></h2><p>Рекурсивная (рекурсивно определяемая) структура данных – это структура, которая повторяет саму себя в своих частях.</p>
<p>Мы только что видели это на примере структуры компании выше.</p>
<p><em>Отдел</em> компании – это:</p>
<ul>
<li>Либо массив людей.</li>
<li>Либо объект с <em>отделами</em>.</li>
</ul>
<p>Для веб-разработчиков существуют гораздо более известные примеры: HTML- и XML-документы.</p>
<p>В HTML-документе <em>HTML-тег</em> может содержать:</p>
<ul>
<li>Фрагменты текста.</li>
<li>HTML-комментарии.</li>
<li>Другие <em>HTML-теги</em> (которые, в свою очередь, могут содержать фрагменты текста/комментарии или другие теги и т.д.).</li>
</ul>
<p>Это снова рекурсивное определение.</p>
<p>Для лучшего понимания мы рассмотрим ещё одну рекурсивную структуру под названием «связанный список», которая в некоторых случаях может использоваться в качестве альтернативы массиву.</p>
<h3><a class="main__anchor" name="svyazannyy-spisok" href="recursion.html#svyazannyy-spisok">Связанный список</a></h3><p>Представьте себе, что мы хотим хранить упорядоченный список объектов.</p>
<p>Естественным выбором будет массив:</p>
<div id="ah3sp8veie" data-trusted="1" class="code-example">
      <div class="codebox code-example__codebox">
        
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code>let arr = [obj1, obj2, obj3];</code></pre>
        </div>
      </div>
      
      </div><p>…Но у массивов есть недостатки. Операции «удалить элемент» и «вставить элемент» являются дорогостоящими. Например, операция <code>arr.unshift(obj)</code> должна переиндексировать все элементы, чтобы освободить место для нового <code>obj</code>, и, если массив большой, на это потребуется время. То же самое с <code>arr.shift()</code>.</p>
<p>Единственные структурные изменения, не требующие массовой переиндексации – это изменения, которые выполняются с конца массива: <code>arr.push/pop</code>. Таким образом, массив может быть довольно медленным для больших очередей, когда нам приходится работать с его началом.</p>
<p>Или же, если нам действительно нужны быстрые вставка/удаление, мы можем выбрать другую структуру данных, называемую <a href="https://ru.wikipedia.org/wiki/%D0%A1%D0%B2%D1%8F%D0%B7%D0%BD%D1%8B%D0%B9_%D1%81%D0%BF%D0%B8%D1%81%D0%BE%D0%BA">связанный список</a>.</p>
<p>Элемент <em>связанного списка</em> определяется рекурсивно как объект с:</p>
<ul>
<li><code>value</code>,</li>
<li><code>next</code> – свойство, ссылающееся на следующий <em>элемент связанного списка</em> или <code>null</code>, если это последний элемент.</li>
</ul>
<p>Пример:</p>
<div id="504q1p3ne8" data-trusted="1" class="code-example">
      <div class="codebox code-example__codebox">
        
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code>let list = {
  value: 1,
  next: {
    value: 2,
    next: {
      value: 3,
      next: {
        value: 4,
        next: null
      }
    }
  }
};</code></pre>
        </div>
      </div>
      
      </div><p>Графическое представление списка:</p>
<figure><div class="image" style="width:652px">
      <div class="image__ratio" style="padding-top:11.809815950920246%"></div>
      <object type="image/svg+xml" data="https://learn.javascript.ru/article/recursion/linked-list.svg" width="652" height="77" class="image__image" data-use-theme>
        <img src="https://learn.javascript.ru/article/recursion/linked-list.svg" alt="" width="652" height="77">
      </object>
      </div></figure><p>Альтернативный код для создания:</p>
<div id="m6qsqkmehk" data-trusted="1" class="code-example">
      <div class="codebox code-example__codebox">
        
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code>let list = { value: 1 };
list.next = { value: 2 };
list.next.next = { value: 3 };
list.next.next.next = { value: 4 };</code></pre>
        </div>
      </div>
      
      </div><p>Здесь мы можем ещё лучше увидеть, что есть несколько объектов, каждый из которых имеет <code>value</code> и <code>next</code>, указывающий на соседа. Переменная <code>list</code> является первым объектом в цепочке, поэтому, следуя по указателям <code>next</code> из неё, мы можем попасть в любой элемент.</p>
<p>Список можно легко разделить на несколько частей и впоследствии объединить обратно:</p>
<div id="9qlj9x20sq" data-trusted="1" class="code-example">
      <div class="codebox code-example__codebox">
        
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code>let secondList = list.next.next;
list.next.next = null;</code></pre>
        </div>
      </div>
      
      </div><figure><div class="image" style="width:410px">
      <div class="image__ratio" style="padding-top:36.58536585365854%"></div>
      <object type="image/svg+xml" data="https://learn.javascript.ru/article/recursion/linked-list-split.svg" width="410" height="150" class="image__image" data-use-theme>
        <img src="https://learn.javascript.ru/article/recursion/linked-list-split.svg" alt="" width="410" height="150">
      </object>
      </div></figure><p>Для объединения:</p>
<div id="8p5pxkg1cd" data-trusted="1" class="code-example">
      <div class="codebox code-example__codebox">
        
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code>list.next.next = secondList;</code></pre>
        </div>
      </div>
      
      </div><p>И, конечно, мы можем вставить или удалить элементы из любого места.</p>
<p>Например, для добавления нового элемента нам нужно обновить первый элемент списка:</p>
<div id="z8raoj98ao" data-trusted="1" class="code-example" data-highlight="[{&quot;start&quot;:5,&quot;end&quot;:6}]">
      <div class="codebox code-example__codebox">
        
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code>let list = { value: 1 };
list.next = { value: 2 };
list.next.next = { value: 3 };
list.next.next.next = { value: 4 };

// добавление нового элемента в список
list = { value: &quot;new item&quot;, next: list };</code></pre>
        </div>
      </div>
      
      </div><figure><div class="image" style="width:816px">
      <div class="image__ratio" style="padding-top:13.23529411764706%"></div>
      <object type="image/svg+xml" data="https://learn.javascript.ru/article/recursion/linked-list-0.svg" width="816" height="108" class="image__image" data-use-theme>
        <img src="https://learn.javascript.ru/article/recursion/linked-list-0.svg" alt="" width="816" height="108">
      </object>
      </div></figure><p>Чтобы удалить элемент из середины списка, нужно изменить значение <code>next</code> предыдущего элемента:</p>
<div id="df0acflntl" data-trusted="1" class="code-example">
      <div class="codebox code-example__codebox">
        
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code>list.next = list.next.next;</code></pre>
        </div>
      </div>
      
      </div><figure><div class="image" style="width:670px">
      <div class="image__ratio" style="padding-top:21.343283582089555%"></div>
      <object type="image/svg+xml" data="https://learn.javascript.ru/article/recursion/linked-list-remove-1.svg" width="670" height="143" class="image__image" data-use-theme>
        <img src="https://learn.javascript.ru/article/recursion/linked-list-remove-1.svg" alt="" width="670" height="143">
      </object>
      </div></figure><p><code>list.next</code> перепрыгнуло с <code>1</code> на значение <code>2</code>. Значение <code>1</code> теперь исключено из цепочки. Если оно не хранится где-нибудь ещё, оно будет автоматически удалено из памяти.</p>
<p>В отличие от массивов, нет перенумерации, элементы легко переставляются.</p>
<p>Естественно, списки не всегда лучше массивов. В противном случае все пользовались бы только списками.</p>
<p>Главным недостатком является то, что мы не можем легко получить доступ к элементу по его индексу. В простом массиве: <code>arr[n]</code> является прямой ссылкой. Но в списке мы должны начать с первого элемента и перейти в <code>next</code> N раз, чтобы получить N-й элемент.</p>
<p>…Но нам не всегда нужны такие операции. Например, нам может быть нужна очередь или даже <a href="https://ru.wikipedia.org/wiki/%D0%94%D0%B2%D1%83%D1%85%D1%81%D1%82%D0%BE%D1%80%D0%BE%D0%BD%D0%BD%D1%8F%D1%8F_%D0%BE%D1%87%D0%B5%D1%80%D0%B5%D0%B4%D1%8C">двухсторонняя очередь</a> – это упорядоченная структура, которая позволяет очень быстро добавлять/удалять элементы с обоих концов, но там не нужен доступ в середину.</p>
<p>Списки могут быть улучшены:</p>
<ul>
<li>Можно добавить свойство <code>prev</code> в дополнение к <code>next</code> для ссылки на предыдущий элемент, чтобы легко двигаться по списку назад.</li>
<li>Можно также добавить переменную <code>tail</code>, которая будет ссылаться на последний элемент списка (и обновлять её при добавлении/удалении элементов с конца).</li>
<li>…Возможны другие изменения: главное, чтобы структура данных соответствовала нашим задачам с точки зрения производительности и удобства.</li>
</ul>
<h2><a class="main__anchor" name="itogo" href="recursion.html#itogo">Итого</a></h2><p>Термины:</p>
<ul>
<li>
<p><em>Рекурсия</em>  – это термин в программировании, означающий вызов функцией самой себя. Рекурсивные функции могут быть использованы для элегантного решения определённых задач.</p>
<p>Когда функция вызывает саму себя, это называется <em>шагом рекурсии</em>. <em>База</em> рекурсии – это такие аргументы функции, которые делают задачу настолько простой, что решение не требует дальнейших вложенных вызовов.</p>
</li>
<li>
<p><a href="https://en.wikipedia.org/wiki/Recursive_data_type">Рекурсивно определяемая</a> структура данных – это структура данных, которая может быть определена с использованием самой себя.</p>
<p>Например, связанный список может быть определён как структура данных, состоящая из объекта, содержащего ссылку на список (или null).</p>
<div id="fkmo8wkf7b" data-trusted="1" class="code-example">
      <div class="codebox code-example__codebox">
        
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code>list = { value, next -&gt; list }</code></pre>
        </div>
      </div>
      
      </div><p>Деревья, такие как дерево HTML-элементов или дерево отделов из этой главы, также являются рекурсивными: они разветвляются, и каждая ветвь может содержать другие ветви.</p>
<p>Как мы видели в примере <code>sumSalary</code>, рекурсивные функции могут быть использованы для прохода по ним.</p>
</li>
</ul>
<p>Любая рекурсивная функция может быть переписана в итеративную. И это иногда требуется для оптимизации работы. Но для многих задач рекурсивное решение достаточно быстрое и простое в написании и поддержке.</p>
</div></article><div class="tasks formatted"><h2 class="tasks__title" id="tasks"><a class="tasks__title-anchor main__anchor main__anchor main__anchor_noicon" href="recursion.html#tasks">Задачи</a></h2><div class="task tasks__task"><div class="task__header"><div class="task__title-wrap"><h3 class="task__title"><a class="main__anchor" href="recursion.html#vychislit-summu-chisel-do-dannogo" name="vychislit-summu-chisel-do-dannogo">Вычислить сумму чисел до данного</a></h3><a class="task__open-link" href="https://learn.javascript.ru/task/sum-to" target="_blank"></a></div><div class="task__header-note"><span class="task__importance" title="Насколько эта задача важна для освоения материала, от 1 до 5">важность: 5</span></div><div class="task__content"><div class="task__formatted"><p>Напишите функцию <code>sumTo(n)</code>, которая вычисляет сумму чисел <code>1 + 2 + ... + n</code>.</p>
<p>Например:</p>
<div id="jz2m1e49vm" data-trusted="1" class="code-example">
      <div class="codebox code-example__codebox">
        
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code>sumTo(1) = 1
sumTo(2) = 2 + 1 = 3
sumTo(3) = 3 + 2 + 1 = 6
sumTo(4) = 4 + 3 + 2 + 1 = 10
...
sumTo(100) = 100 + 99 + ... + 2 + 1 = 5050</code></pre>
        </div>
      </div>
      
      </div><p>Сделайте три варианта решения:</p>
<ol>
<li>С использованием цикла.</li>
<li>Через рекурсию, т.к. <code>sumTo(n) = n + sumTo(n-1)</code> for <code>n &gt; 1</code>.</li>
<li>С использованием формулы <a href="https://ru.wikipedia.org/wiki/%D0%90%D1%80%D0%B8%D1%84%D0%BC%D0%B5%D1%82%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B0%D1%8F_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B5%D1%81%D1%81%D0%B8%D1%8F">арифметической прогрессии</a>.</li>
</ol>
<p>Пример работы вашей функции:</p>
<div id="d0b2321vj4" data-trusted="1" class="code-example">
      <div class="codebox code-example__codebox">
        
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code>function sumTo(n) { /*... ваш код ... */ }

alert( sumTo(100) ); // 5050</code></pre>
        </div>
      </div>
      
      </div><p>P.S. Какой вариант решения самый быстрый? Самый медленный? Почему?</p>
<p>P.P.S. Можно ли при помощи рекурсии посчитать <code>sumTo(100000)</code>?</p>
</div><button class="task__solution" type="button">решение</button><div class="task__answer"><div class="task__answer-content"><div class="formatted"><p>Решение с помощью цикла:</p>
<div id="hk3xwpjhz5" data-trusted="1" class="code-example">
      <div class="codebox code-example__codebox">
        
        <div class="toolbar codebox__toolbar">
          <div class="toolbar__tool">
            <a href="recursion.html#" title="выполнить" data-action="run" class="toolbar__button toolbar__button_run"></a>
          </div>
          <div class="toolbar__tool">
            <a href="recursion.html#" title="открыть в песочнице" target="_blank" data-action="edit" class="toolbar__button toolbar__button_edit"></a>
          </div>
        </div>
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code>function sumTo(n) {
  let sum = 0;
  for (let i = 1; i &lt;= n; i++) {
    sum += i;
  }
  return sum;
}

alert( sumTo(100) );</code></pre>
        </div>
      </div>
      
      </div><p>Решение через рекурсию:</p>
<div id="9fapu6z9yi" data-trusted="1" class="code-example">
      <div class="codebox code-example__codebox">
        
        <div class="toolbar codebox__toolbar">
          <div class="toolbar__tool">
            <a href="recursion.html#" title="выполнить" data-action="run" class="toolbar__button toolbar__button_run"></a>
          </div>
          <div class="toolbar__tool">
            <a href="recursion.html#" title="открыть в песочнице" target="_blank" data-action="edit" class="toolbar__button toolbar__button_edit"></a>
          </div>
        </div>
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code>function sumTo(n) {
  if (n == 1) return 1;
  return n + sumTo(n - 1);
}

alert( sumTo(100) );</code></pre>
        </div>
      </div>
      
      </div><p>Решение по формуле: <code>sumTo(n) = n*(n+1)/2</code>:</p>
<div id="jcnuo9aomg" data-trusted="1" class="code-example">
      <div class="codebox code-example__codebox">
        
        <div class="toolbar codebox__toolbar">
          <div class="toolbar__tool">
            <a href="recursion.html#" title="выполнить" data-action="run" class="toolbar__button toolbar__button_run"></a>
          </div>
          <div class="toolbar__tool">
            <a href="recursion.html#" title="открыть в песочнице" target="_blank" data-action="edit" class="toolbar__button toolbar__button_edit"></a>
          </div>
        </div>
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code>function sumTo(n) {
  return n * (n + 1) / 2;
}

alert( sumTo(100) );</code></pre>
        </div>
      </div>
      
      </div><p>P.S. Надо ли говорить, что решение по формуле работает быстрее всех? Это очевидно. Оно использует всего три операции для любого n, а цикл и рекурсия требуют как минимум n операций сложения.</p>
<p>Вариант с циклом – второй по скорости. Он быстрее рекурсии, так как операций сложения столько же, но нет дополнительных вычислительных затрат на организацию вложенных вызовов. Поэтому рекурсия в данном случае работает медленнее всех.</p>
<p>P.P.S. Некоторые движки поддерживают оптимизацию «хвостового вызова»: если рекурсивный вызов является самым последним в функции (<code>sumTo</code> выше не будет оптимизирован, т.к. последним происходит сложение, а не рекурсивный вызов), то внешней функции не нужно будет возобновлять выполнение и не нужно запоминать контекст его выполнения. В итоге требования к памяти снижаются, и сумма <code>sumTo(100000)</code> будет успешно вычислена. Но если JavaScript-движок не поддерживает это (большинство не поддерживают), будет ошибка: максимальный размер стека превышен, так как обычно существует ограничение на максимальный размер стека.</p>
</div></div><button class="close-button task__answer-close" type="button" title="закрыть"></button></div></div></div></div><div class="task tasks__task"><div class="task__header"><div class="task__title-wrap"><h3 class="task__title"><a class="main__anchor" href="recursion.html#vychislit-faktorial" name="vychislit-faktorial">Вычислить факториал</a></h3><a class="task__open-link" href="https://learn.javascript.ru/task/factorial" target="_blank"></a></div><div class="task__header-note"><span class="task__importance" title="Насколько эта задача важна для освоения материала, от 1 до 5">важность: 4</span></div><div class="task__content"><div class="task__formatted"><p><a href="https://ru.wikipedia.org/wiki/%D0%A4%D0%B0%D0%BA%D1%82%D0%BE%D1%80%D0%B8%D0%B0%D0%BB">Факториал</a> натурального числа – это число, умноженное на <code>&quot;себя минус один&quot;</code>, затем на <code>&quot;себя минус два&quot;</code>, и так далее до <code>1</code>. Факториал <code>n</code> обозначается как <code>n!</code></p>
<p>Определение факториала можно записать как:</p>
<div id="wy1hhuodk1" data-trusted="1" class="code-example">
      <div class="codebox code-example__codebox">
        
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code>n! = n * (n - 1) * (n - 2) * ...*1</code></pre>
        </div>
      </div>
      
      </div><p>Примеры значений для разных <code>n</code>:</p>
<div id="hw05zd8kyo" data-trusted="1" class="code-example">
      <div class="codebox code-example__codebox">
        
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code>1! = 1
2! = 2 * 1 = 2
3! = 3 * 2 * 1 = 6
4! = 4 * 3 * 2 * 1 = 24
5! = 5 * 4 * 3 * 2 * 1 = 120</code></pre>
        </div>
      </div>
      
      </div><p>Задача – написать функцию <code>factorial(n)</code>, которая возвращает <code>n!</code>, используя рекурсию.</p>
<div id="fdt1wqfcam" data-trusted="1" class="code-example">
      <div class="codebox code-example__codebox">
        
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code>alert( factorial(5) ); // 120</code></pre>
        </div>
      </div>
      
      </div><p>P.S. Подсказка: <code>n!</code> можно записать как <code>n * (n-1)!</code> Например: <code>3! = 3*2! = 3*2*1! = 6</code></p>
</div><button class="task__solution" type="button">решение</button><div class="task__answer"><div class="task__answer-content"><div class="formatted"><p>По определению факториал <code>n!</code> можно записать как <code>n * (n-1)!</code>.</p>
<p>Другими словами, <code>factorial(n)</code> можно получить как <code>n</code> умноженное на результат <code>factorial(n-1)</code>. И результат для <code>n-1</code>, в свою очередь, может быть вычислен рекурсивно и так далее до <code>1</code>.</p>
<div id="dpxxi0ath2" data-trusted="1" class="code-example">
      <div class="codebox code-example__codebox">
        
        <div class="toolbar codebox__toolbar">
          <div class="toolbar__tool">
            <a href="recursion.html#" title="выполнить" data-action="run" class="toolbar__button toolbar__button_run"></a>
          </div>
          <div class="toolbar__tool">
            <a href="recursion.html#" title="открыть в песочнице" target="_blank" data-action="edit" class="toolbar__button toolbar__button_edit"></a>
          </div>
        </div>
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code>function factorial(n) {
  return (n != 1) ? n * factorial(n - 1) : 1;
}

alert( factorial(5) ); // 120</code></pre>
        </div>
      </div>
      
      </div><p>Базисом рекурсии является значение <code>1</code>. А можно было бы сделать базисом и <code>0</code>, однако это добавило рекурсии дополнительный шаг:</p>
<div id="onc8dlgkkw" data-trusted="1" class="code-example">
      <div class="codebox code-example__codebox">
        
        <div class="toolbar codebox__toolbar">
          <div class="toolbar__tool">
            <a href="recursion.html#" title="выполнить" data-action="run" class="toolbar__button toolbar__button_run"></a>
          </div>
          <div class="toolbar__tool">
            <a href="recursion.html#" title="открыть в песочнице" target="_blank" data-action="edit" class="toolbar__button toolbar__button_edit"></a>
          </div>
        </div>
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code>function factorial(n) {
  return n ? n * factorial(n - 1) : 1;
}

alert( factorial(5) ); // 120</code></pre>
        </div>
      </div>
      
      </div></div></div><button class="close-button task__answer-close" type="button" title="закрыть"></button></div></div></div></div><div class="task tasks__task"><div class="task__header"><div class="task__title-wrap"><h3 class="task__title"><a class="main__anchor" href="recursion.html#chisla-fibonachchi" name="chisla-fibonachchi">Числа Фибоначчи</a></h3><a class="task__open-link" href="https://learn.javascript.ru/task/fibonacci-numbers" target="_blank"></a></div><div class="task__header-note"><span class="task__importance" title="Насколько эта задача важна для освоения материала, от 1 до 5">важность: 5</span></div><div class="task__content"><div class="task__formatted"><p>Последовательность <a href="https://ru.wikipedia.org/wiki/%D0%A7%D0%B8%D1%81%D0%BB%D0%B0_%D0%A4%D0%B8%D0%B1%D0%BE%D0%BD%D0%B0%D1%87%D1%87%D0%B8">чисел Фибоначчи</a> определяется формулой <code>F<sub>n</sub> = F<sub>n-1</sub> + F<sub>n-2</sub></code>. То есть, следующее число получается как сумма двух предыдущих.</p>
<p>Первые два числа равны <code>1</code>, затем <code>2(1+1)</code>, затем <code>3(1+2)</code>, <code>5(2+3)</code> и так далее: <code>1, 1, 2, 3, 5, 8, 13, 21...</code>.</p>
<p>Числа Фибоначчи тесно связаны с <a href="https://ru.wikipedia.org/wiki/%D0%97%D0%BE%D0%BB%D0%BE%D1%82%D0%BE%D0%B5_%D1%81%D0%B5%D1%87%D0%B5%D0%BD%D0%B8%D0%B5">золотым сечением</a> и множеством природных явлений вокруг нас.</p>
<p>Напишите функцию <code>fib(n)</code> которая возвращает <code>n-е</code> число Фибоначчи.</p>
<p>Пример работы:</p>
<div id="5s2h4cz4sl" data-trusted="1" class="code-example">
      <div class="codebox code-example__codebox">
        
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code>function fib(n) { /* ваш код */ }

alert(fib(3)); // 2
alert(fib(7)); // 13
alert(fib(77)); // 5527939700884757</code></pre>
        </div>
      </div>
      
      </div><p>P.S. Все запуски функций из примера выше должны работать быстро. Вызов <code>fib(77)</code> должен занимать не более доли секунды.</p>
</div><button class="task__solution" type="button">решение</button><div class="task__answer"><div class="task__answer-content"><div class="formatted"><p>Сначала решим через рекурсию.</p>
<p>Числа Фибоначчи рекурсивны по определению:</p>
<div id="wcxtastvjk" data-trusted="1" class="code-example">
      <div class="codebox code-example__codebox">
        
        <div class="toolbar codebox__toolbar">
          <div class="toolbar__tool">
            <a href="recursion.html#" title="выполнить" data-action="run" class="toolbar__button toolbar__button_run"></a>
          </div>
          <div class="toolbar__tool">
            <a href="recursion.html#" title="открыть в песочнице" target="_blank" data-action="edit" class="toolbar__button toolbar__button_edit"></a>
          </div>
        </div>
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code>function fib(n) {
  return n &lt;= 1 ? n : fib(n - 1) + fib(n - 2);
}

alert( fib(3) ); // 2
alert( fib(7) ); // 13
// fib(77); // вычисляется очень долго</code></pre>
        </div>
      </div>
      
      </div><p>При больших значениях <code>n</code> такое решение будет работать очень долго. Например, <code>fib(77)</code> может повесить браузер на некоторое время, съев все ресурсы процессора.</p>
<p>Это потому, что функция порождает обширное дерево вложенных вызовов. При этом ряд значений вычисляется много раз снова и снова.</p>
<p>Например, посмотрим на отрывок вычислений для <code>fib(5)</code>:</p>
<div id="qiv51ki4rh" data-trusted="1" class="code-example">
      <div class="codebox code-example__codebox">
        
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code>...
fib(5) = fib(4) + fib(3)
fib(4) = fib(3) + fib(2)
...</code></pre>
        </div>
      </div>
      
      </div><p>Здесь видно, что значение  <code>fib(3)</code> нужно одновременно и для  <code>fib(5)</code> и для  <code>fib(4)</code>. В коде оно будет вычислено два раза, совершенно независимо.</p>
<p>Полное дерево рекурсии:</p>
<figure><div class="image" style="width:640px">
      <div class="image__ratio" style="padding-top:35.15625%"></div>
      <object type="image/svg+xml" data="https://learn.javascript.ru/task/fibonacci-numbers/fibonacci-recursion-tree.svg" width="640" height="225" class="image__image" data-use-theme>
        <img src="https://learn.javascript.ru/task/fibonacci-numbers/fibonacci-recursion-tree.svg" alt="" width="640" height="225">
      </object>
      </div></figure><p>Можно заметить, что <code>fib(3)</code> вычисляется дважды, а <code>fib(2)</code> – трижды. Общее количество вычислений растёт намного быстрее, чем <code>n</code>, что делает его огромным даже для <code>n=77</code>.</p>
<p>Можно это оптимизировать, запоминая уже вычисленные значения: если значение, скажем, <code>fib(3)</code> вычислено однажды, затем мы просто переиспользуем это значение для последующих вычислений.</p>
<p>Другим вариантом было бы отказаться от рекурсии и использовать совершенно другой алгоритм на основе цикла.</p>
<p>Вместо того, чтобы начинать с <code>n</code> и вычислять необходимые предыдущие значения, можно написать цикл, который начнёт с <code>1</code> и <code>2</code>, затем из них получит <code>fib(3)</code> как их сумму, затем <code>fib(4)</code>как сумму предыдущих значений, затем <code>fib(5)</code> и так далее, до финального результата. На каждом шаге нам нужно помнить только значения двух предыдущих чисел последовательности.</p>
<p>Вот детальные шаги нового алгоритма.</p>
<p>Начало:</p>
<div id="6oiv2lhw5u" data-trusted="1" class="code-example">
      <div class="codebox code-example__codebox">
        
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code>// a = fib(1), b = fib(2), эти значения по определению равны 1
let a = 1, b = 1;

// получим c = fib(3) как их сумму
let c = a + b;

/* теперь у нас есть fib(1), fib(2), fib(3)
a  b  c
1, 1, 2
*/</code></pre>
        </div>
      </div>
      
      </div><p>Теперь мы хотим получить <code>fib(4) = fib(2) + fib(3)</code>.</p>
<p>Переставим переменные: <code>a,b</code>, присвоим значения <code>fib(2),fib(3)</code>, тогда <code>c</code> можно получить как их сумму:</p>
<div id="62r4av5oe6" data-trusted="1" class="code-example">
      <div class="codebox code-example__codebox">
        
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code>a = b; // теперь a = fib(2)
b = c; // теперь b = fib(3)
c = a + b; // c = fib(4)

/* имеем последовательность:
   a  b  c
1, 1, 2, 3
*/</code></pre>
        </div>
      </div>
      
      </div><p>Следующий шаг даёт новое число последовательности:</p>
<div id="h88rq5a7xw" data-trusted="1" class="code-example">
      <div class="codebox code-example__codebox">
        
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code>a = b; // now a = fib(3)
b = c; // now b = fib(4)
c = a + b; // c = fib(5)

/* последовательность теперь (на одно число больше):
      a  b  c
1, 1, 2, 3, 5
*/</code></pre>
        </div>
      </div>
      
      </div><p>…И так далее, пока не получим искомое значение. Это намного быстрее рекурсии и не требует повторных вычислений.</p>
<p>Полный код:</p>
<div id="yd46ggqmah" data-trusted="1" class="code-example">
      <div class="codebox code-example__codebox">
        
        <div class="toolbar codebox__toolbar">
          <div class="toolbar__tool">
            <a href="recursion.html#" title="выполнить" data-action="run" class="toolbar__button toolbar__button_run"></a>
          </div>
          <div class="toolbar__tool">
            <a href="recursion.html#" title="открыть в песочнице" target="_blank" data-action="edit" class="toolbar__button toolbar__button_edit"></a>
          </div>
        </div>
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code>function fib(n) {
  let a = 1;
  let b = 1;
  for (let i = 3; i &lt;= n; i++) {
    let c = a + b;
    a = b;
    b = c;
  }
  return b;
}

alert( fib(3) ); // 2
alert( fib(7) ); // 13
alert( fib(77) ); // 5527939700884757</code></pre>
        </div>
      </div>
      
      </div><p>Цикл начинается с <code>i=3</code>, потому что первое и второе значения последовательности заданы <code>a=1</code>, <code>b=1</code>.</p>
<p>Такой способ называется <a href="https://ru.wikipedia.org/wiki/%D0%94%D0%B8%D0%BD%D0%B0%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5">динамическое программирование снизу вверх</a>.</p>
</div></div><button class="close-button task__answer-close" type="button" title="закрыть"></button></div></div></div></div><div class="task tasks__task"><div class="task__header"><div class="task__title-wrap"><h3 class="task__title"><a class="main__anchor" href="recursion.html#vyvod-odnosvyaznogo-spiska" name="vyvod-odnosvyaznogo-spiska">Вывод односвязного списка</a></h3><a class="task__open-link" href="https://learn.javascript.ru/task/output-single-linked-list" target="_blank"></a></div><div class="task__header-note"><span class="task__importance" title="Насколько эта задача важна для освоения материала, от 1 до 5">важность: 5</span></div><div class="task__content"><div class="task__formatted"><p>Допустим, у нас есть односвязный список (как описано в главе <a href="recursion.html">Рекурсия и стек</a>):</p>
<div id="905il2xhwh" data-trusted="1" class="code-example">
      <div class="codebox code-example__codebox">
        
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code>let list = {
  value: 1,
  next: {
    value: 2,
    next: {
      value: 3,
      next: {
        value: 4,
        next: null
      }
    }
  }
};</code></pre>
        </div>
      </div>
      
      </div><p>Напишите функцию <code>printList(list)</code>, которая выводит элементы списка по одному.</p>
<p>Сделайте два варианта решения: используя цикл и через рекурсию.</p>
<p>Как лучше: с рекурсией или без?</p>
</div><button class="task__solution" type="button">решение</button><div class="task__answer"><div class="task__step task__step_open"><button class="task__step-show" type="button" onclick="showStep(this)">Решение с использованием цикла</button><div class="task__answer-content"><h4 class="task__step-title">Решение с использованием цикла</h4><div class="formatted"><p>Решение с использованием цикла:</p>
<div id="tk99c23qdu" data-trusted="1" class="code-example">
      <div class="codebox code-example__codebox">
        
        <div class="toolbar codebox__toolbar">
          <div class="toolbar__tool">
            <a href="recursion.html#" title="выполнить" data-action="run" class="toolbar__button toolbar__button_run"></a>
          </div>
          <div class="toolbar__tool">
            <a href="recursion.html#" title="открыть в песочнице" target="_blank" data-action="edit" class="toolbar__button toolbar__button_edit"></a>
          </div>
        </div>
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code>let list = {
  value: 1,
  next: {
    value: 2,
    next: {
      value: 3,
      next: {
        value: 4,
        next: null
      }
    }
  }
};

function printList(list) {
  let tmp = list;

  while (tmp) {
    alert(tmp.value);
    tmp = tmp.next;
  }

}

printList(list);</code></pre>
        </div>
      </div>
      
      </div><p>Обратите внимание, что мы используем временную переменную <code>tmp</code> для перемещения по списку. Технически, мы могли бы использовать параметр функции <code>list</code> вместо неё:</p>
<div id="cfpplem44x" data-trusted="1" class="code-example" data-highlight="[{&quot;start&quot;:2,&quot;cols&quot;:[{&quot;start&quot;:8,&quot;end&quot;:12}]}]">
      <div class="codebox code-example__codebox">
        
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code>function printList(list) {

  while(list) {
    alert(list.value);
    list = list.next;
  }

}</code></pre>
        </div>
      </div>
      
      </div><p>…Но это было бы неблагоразумно. В будущем нам может понадобиться расширить функцию, сделать что-нибудь ещё со списком. Если мы меняем <code>list</code>, то теряем такую возможность.</p>
<p>Говоря о хороших именах для переменных, <code>list</code> здесь – это сам список, его первый элемент. Так и должно быть, это просто и понятно.</p>
<p>С другой стороны, <code>tmp</code> используется исключительно для обхода списка, как <code>i</code> в цикле <code>for</code>.</p>
</div></div></div><div class="task__step task__step_open"><button class="task__step-show" type="button" onclick="showStep(this)">Решение через рекурсию</button><div class="task__answer-content"><h4 class="task__step-title">Решение через рекурсию</h4><div class="formatted"><p>Рекурсивный вариант <code>printList(list)</code> следует простой логике: для вывода списка мы должны вывести текущий <code>list</code>, затем сделать то же самое для <code>list.next</code>:</p>
<div id="is6s0knu07" data-trusted="1" class="code-example">
      <div class="codebox code-example__codebox">
        
        <div class="toolbar codebox__toolbar">
          <div class="toolbar__tool">
            <a href="recursion.html#" title="выполнить" data-action="run" class="toolbar__button toolbar__button_run"></a>
          </div>
          <div class="toolbar__tool">
            <a href="recursion.html#" title="открыть в песочнице" target="_blank" data-action="edit" class="toolbar__button toolbar__button_edit"></a>
          </div>
        </div>
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code>let list = {
  value: 1,
  next: {
    value: 2,
    next: {
      value: 3,
      next: {
        value: 4,
        next: null
      }
    }
  }
};

function printList(list) {

  alert(list.value); // выводим текущий элемент

  if (list.next) {
    printList(list.next); // делаем то же самое для остальной части списка
  }

}

printList(list);</code></pre>
        </div>
      </div>
      
      </div><p>Какой способ лучше?</p>
<p>Технически, способ с циклом более эффективный. В обеих реализациях делается то же самое, но для цикла не тратятся ресурсы для вложенных вызовов.</p>
<p>С другой стороны, рекурсивный вариант более короткий и, возможно, более простой для понимания.</p>
</div></div></div><button class="close-button task__answer-close" type="button" title="закрыть"></button></div></div></div></div><div class="task tasks__task"><div class="task__header"><div class="task__title-wrap"><h3 class="task__title"><a class="main__anchor" href="recursion.html#vyvod-odnosvyaznogo-spiska-v-obratnom-poryadke" name="vyvod-odnosvyaznogo-spiska-v-obratnom-poryadke">Вывод односвязного списка в обратном порядке</a></h3><a class="task__open-link" href="https://learn.javascript.ru/task/output-single-linked-list-reverse" target="_blank"></a></div><div class="task__header-note"><span class="task__importance" title="Насколько эта задача важна для освоения материала, от 1 до 5">важность: 5</span></div><div class="task__content"><div class="task__formatted"><p>Выведите односвязный список из предыдущего задания <a href="https://learn.javascript.ru/task/output-single-linked-list">Вывод односвязного списка</a> в обратном порядке.</p>
<p>Сделайте два решения: с использованием цикла и через рекурсию.</p>
</div><button class="task__solution" type="button">решение</button><div class="task__answer"><div class="task__step task__step_open"><button class="task__step-show" type="button" onclick="showStep(this)">С использованием рекурсии</button><div class="task__answer-content"><h4 class="task__step-title">С использованием рекурсии</h4><div class="formatted"><p>Рекурсивная логика в этом случае немного сложнее.</p>
<p>Сначала надо вывести оставшуюся часть списка, а <em>затем</em> текущий элемент:</p>
<div id="ur9d4ajxhh" data-trusted="1" class="code-example">
      <div class="codebox code-example__codebox">
        
        <div class="toolbar codebox__toolbar">
          <div class="toolbar__tool">
            <a href="recursion.html#" title="выполнить" data-action="run" class="toolbar__button toolbar__button_run"></a>
          </div>
          <div class="toolbar__tool">
            <a href="recursion.html#" title="открыть в песочнице" target="_blank" data-action="edit" class="toolbar__button toolbar__button_edit"></a>
          </div>
        </div>
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code>let list = {
  value: 1,
  next: {
    value: 2,
    next: {
      value: 3,
      next: {
        value: 4,
        next: null
      }
    }
  }
};

function printReverseList(list) {

  if (list.next) {
    printReverseList(list.next);
  }

  alert(list.value);
}

printReverseList(list);</code></pre>
        </div>
      </div>
      
      </div></div></div></div><div class="task__step task__step_open"><button class="task__step-show" type="button" onclick="showStep(this)">С использованием цикла</button><div class="task__answer-content"><h4 class="task__step-title">С использованием цикла</h4><div class="formatted"><p>Вариант с использованием цикла сложнее, чем в предыдущей задаче.</p>
<p>Нет способа сразу получить последнее значение в списке <code>list</code>. Мы также не можем «вернуться назад», к предыдущему элементу списка.</p>
<p>Поэтому мы можем сначала перебрать элементы в прямом порядке и запомнить их в массиве, а затем вывести то, что мы запомнили, в обратном порядке:</p>
<div id="nxko6fvxwb" data-trusted="1" class="code-example">
      <div class="codebox code-example__codebox">
        
        <div class="toolbar codebox__toolbar">
          <div class="toolbar__tool">
            <a href="recursion.html#" title="выполнить" data-action="run" class="toolbar__button toolbar__button_run"></a>
          </div>
          <div class="toolbar__tool">
            <a href="recursion.html#" title="открыть в песочнице" target="_blank" data-action="edit" class="toolbar__button toolbar__button_edit"></a>
          </div>
        </div>
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code>let list = {
  value: 1,
  next: {
    value: 2,
    next: {
      value: 3,
      next: {
        value: 4,
        next: null
      }
    }
  }
};

function printReverseList(list) {
  let arr = [];
  let tmp = list;

  while (tmp) {
    arr.push(tmp.value);
    tmp = tmp.next;
  }

  for (let i = arr.length - 1; i &gt;= 0; i--) {
    alert( arr[i] );
  }
}

printReverseList(list);</code></pre>
        </div>
      </div>
      
      </div><p>Обратите внимание, что рекурсивное решение на самом деле делает то же самое: проходит список, запоминает элементы в цепочке вложенных вызовов (в контексте выполнения), а затем выводит их.</p>
</div></div></div><button class="close-button task__answer-close" type="button" title="закрыть"></button></div></div></div></div></div></div><div class="page__nav-wrap"><a class="page__nav page__nav_prev" href="https://learn.javascript.ru/advanced-functions" data-tooltip="Продвинутая работа с функциями"><span class="page__nav-text"><span class="page__nav-text-shortcut"></span></span><span class="page__nav-text-alternate">Предыдущий урок</span></a><a class="page__nav page__nav_next" href="https://learn.javascript.ru/rest-parameters-spread-operator" data-tooltip="Остаточные параметры и оператор расширения"><span class="page__nav-text"><span class="page__nav-text-shortcut"></span></span><span class="page__nav-text-alternate">Следующий урок</span></a></div><div class="article-tablet-foot tablet-only"><div class="article-tablet-foot__layout"><div class="share-icons"><span class="share-icons__title">Поделиться</span><a class="share share_tw" href="https://twitter.com/share?url=https%3A%2F%2Flearn.javascript.ru%2Frecursion" rel="nofollow"></a><a class="share share_fb" href="https://www.facebook.com/sharer/sharer.php?s=100&amp;p%5Burl%5D=https%3A%2F%2Flearn.javascript.ru%2Frecursion" rel="nofollow"></a><a class="share share_vk" href="https://vkontakte.ru/share.php?url=https%3A%2F%2Flearn.javascript.ru%2Frecursion" rel="nofollow"></a></div><div class="article-tablet-foot__map"><a class="map" href="https://learn.javascript.ru/tutorial/map" data-action="tutorial-map"><span class="map__text">Карта учебника</span></a></div></div></div><div class="banner-bottom"><div class="banner-bottom__text">Проводим <a href="https://learn.javascript.ru/courses">курсы по JavaScript и фреймворкам</a>.</div><button class="banner-bottom__close" data-banner-close="Courses" data-banner-close-message="Эта информация больше не будет выводиться." title="не показывать"></button></div><script>!!1&&"hideBannerCourses"in localStorage||(document.querySelector(".banner-bottom").style.display="flex");</script><div class="comments formatted" id="comments"><div class="comments__header"><h2 class="comments__header-title"><a href="recursion.html#comments" name="comments">Комментарии</a></h2><div class="comments__read-before"><span class="comments__read-before-link">перед тем как писать…</span><div class="comments__read-before-popup"><div class="comments__read-before-popup-i"><ul><li>Если вам кажется, что в статье что-то не так - вместо комментария напишите <a href="https://github.com/javascript-tutorial/ru.javascript.info/issues/new">на GitHub</a>.</li><li>Для одной строки кода используйте тег <code>&lt;code&gt;</code>, для нескольких строк кода&nbsp;&mdash; тег <code>&lt;pre&gt;</code>, если больше 10 строк&nbsp;&mdash; ссылку на песочницу (<a href='https://plnkr.co/edit/?p=preview'>plnkr</a>, <a href='http://jsbin.com'>JSBin</a>, <a href='http://codepen.io'>codepen</a>…)</li><li>Если что-то непонятно в статье&nbsp;&mdash; пишите, что именно и с какого места.</li></ul></div></div></div></div><div id="disqus_thread"></div><script>var disqus_config = function() { if (!this.page) this.page = {}; Object.assign(this.page, {"url":"https:\/\/learn.javascript.ru\/recursion","identifier":"\/recursion"}); };</script><script>var disqus_shortname = "learnjavascriptru";</script><script>var disqus_enabled = true;</script></div></main></div><div class="sidebar page__sidebar sidebar sidebar_sticky-footer"><button class="sidebar__toggle" data-sidebar-toggle></button><a class="map" href="https://learn.javascript.ru/tutorial/map" data-action="tutorial-map" data-tooltip="Карта учебника"></a><div class="sidebar__inner"><div class="sidebar__content"><div class="sidebar__section"><h4 class="sidebar__section-title">Раздел</h4><nav class="sidebar__navigation"><ul class="sidebar__navigation-links"><li class="sidebar__navigation-link"><a class="sidebar__link" href="https://learn.javascript.ru/advanced-functions">Продвинутая работа с функциями</a></li></ul></nav></div><div class="sidebar__section"><h4 class="sidebar__section-title">Навигация по уроку</h4><nav class="sidebar__navigation"><ul class="sidebar__navigation-links"><li class="sidebar__navigation-link"><a class="sidebar__link" href="recursion.html#dva-sposoba-myshleniya">Два способа мышления</a></li><li class="sidebar__navigation-link"><a class="sidebar__link" href="recursion.html#kontekst-vypolneniya-stek">Контекст выполнения, стек</a></li><li class="sidebar__navigation-link"><a class="sidebar__link" href="recursion.html#rekursivnye-obhody">Рекурсивные обходы</a></li><li class="sidebar__navigation-link"><a class="sidebar__link" href="recursion.html#rekursivnye-struktury">Рекурсивные структуры</a></li><li class="sidebar__navigation-link"><a class="sidebar__link" href="recursion.html#itogo">Итого</a></li></ul></nav></div><div class="sidebar__section"><nav class="sidebar__navigation"><ul class="sidebar__navigation-links"><li class="sidebar__navigation-link"><a class="sidebar__link" href="recursion.html#tasks">Задачи (5)</a></li><li class="sidebar__navigation-link"><a class="sidebar__link" href="recursion.html#comments">Комментарии</a></li></ul></nav></div><div class="sidebar__section"><div class="sidebar__section-title">Поделиться</div><a class="share share_tw sidebar__share" href="https://twitter.com/share?url=https%3A%2F%2Flearn.javascript.ru%2Frecursion" rel="nofollow"></a><a class="share share_fb sidebar__share" href="https://www.facebook.com/sharer/sharer.php?s=100&amp;p[url]=https%3A%2F%2Flearn.javascript.ru%2Frecursion" rel="nofollow"></a></div><div class="sidebar__section"><a class="sidebar__link" href="https://github.com/javascript-tutorial/ru.javascript.info/blob/master/1-js/06-advanced-functions/01-recursion" rel="nofollow">Редактировать на GitHub</a></div></div></div></div></div></div><div class="page-footer"><ul class="page-footer__list"><li class="page-footer__item page-footer__item_copy">©&nbsp;2007—2022&nbsp; Илья Кантор</li><li class="page-footer__item page-footer__item_about"><a class="page-footer__link" href="https://learn.javascript.ru/about">о проекте</a></li><li class="page-footer__item page-footer__item_contact"><a class="page-footer__link" href="https://learn.javascript.ru/about#contact-us">связаться с нами</a></li><li class="page-footer__item page-footer__item_terms"><a class="page-footer__link" href="https://learn.javascript.ru/terms">пользовательское соглашение</a></li><li class="page-footer__item page-footer__item_privacy"><a class="page-footer__link" href="https://learn.javascript.ru/privacy">политика конфиденциальности</a></li><li class="page-footer__item page-footer__item_slack"><a class="page-footer__slack" href="http://slack.javascript.ru">slack-чат</a></li></ul></div></body></html>