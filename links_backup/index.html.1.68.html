<!DOCTYPE html>
<html lang="ru" data-vue-meta="%7B%22lang%22:%7B%22ssr%22:%22ru%22%7D%7D">
<head >
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1.0,viewport-fit=cover">
  <meta name="referrer" content="unsafe-url">
  <title>Охота на мифический MVC. Обзор, возвращение к первоисточникам и про то, как анализировать и выводить шаблоны самому / Хабр</title>
  <style>
    /* cyrillic-ext */
    @font-face {
      font-family: 'Fira Sans';
      font-style: normal;
      font-weight: 500;
      font-display: swap;
      src: url(https://fonts.gstatic.com/s/firasans/v11/va9B4kDNxMZdWfMOD5VnZKveSxf6TF0.woff2) format('woff2');
      unicode-range: U+0460-052F, U+1C80-1C88, U+20B4, U+2DE0-2DFF, U+A640-A69F, U+FE2E-FE2F;
    }

    /* cyrillic */
    @font-face {
      font-family: 'Fira Sans';
      font-style: normal;
      font-weight: 500;
      font-display: swap;
      src: url(https://fonts.gstatic.com/s/firasans/v11/va9B4kDNxMZdWfMOD5VnZKveQhf6TF0.woff2) format('woff2');
      unicode-range: U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116;
    }

    /* latin-ext */
    @font-face {
      font-family: 'Fira Sans';
      font-style: normal;
      font-weight: 500;
      font-display: swap;
      src: url(https://fonts.gstatic.com/s/firasans/v11/va9B4kDNxMZdWfMOD5VnZKveSBf6TF0.woff2) format('woff2');
      unicode-range: U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;
    }

    /* latin */
    @font-face {
      font-family: 'Fira Sans';
      font-style: normal;
      font-weight: 500;
      font-display: swap;
      src: url(https://fonts.gstatic.com/s/firasans/v11/va9B4kDNxMZdWfMOD5VnZKveRhf6.woff2) format('woff2');
      unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
    }

    /* non-breaking hyphen */
    @font-face {
      font-family: 'Fira Sans';
      font-style: normal;
      font-weight: 500;
      font-display: swap;
      src: url(https://fonts.gstatic.com/l/font?kit=KFOlCnqEu92Fr1MmEU9vBh0_IsHAlmrO6g&skey=ee881451c540fdec&v=v29) format('woff2');
      unicode-range: U+02011;
    }
  </style>
  <link rel="preload" href="https://assets.habr.com/habr-web/css/chunk-vendors.e7843cc0.css" as="style"><link rel="preload" href="https://assets.habr.com/habr-web/js/chunk-vendors.da6c6b36.js" as="script"><link rel="preload" href="https://assets.habr.com/habr-web/css/app.4de4e95a.css" as="style"><link rel="preload" href="https://assets.habr.com/habr-web/js/app.92df6f6d.js" as="script">
  <link rel="stylesheet" href="https://assets.habr.com/habr-web/css/chunk-vendors.e7843cc0.css"><link rel="stylesheet" href="https://assets.habr.com/habr-web/css/app.4de4e95a.css">
  <script>window.i18nFetch = new Promise((res, rej) => {
          const xhr = new XMLHttpRequest();
          xhr.open('GET', '/js/i18n/ru-compiled.2822d469ec31a56409ac330bbcf7fcbf.json');
          xhr.responseType = 'json';
          xhr.onload = function(e) {
            if (this.status === 200) {
              res({ru: xhr.response});
            } else {
              rej(e);
            }
          };
          xhr.send();
        });</script>
  
  <script data-vue-meta="ssr" type="application/ld+json" data-vmid="ldjson-schema">{"@context":"http:\/\/schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/habr.com\/ru\/post\/321050\/"},"headline":"Охота на мифический MVC. Обзор, возвращение к первоисточникам и про то, как анализировать и выводить шаблоны самому","datePublished":"2017-02-07T04:48:41+03:00","dateModified":"2017-02-27T15:42:14+03:00","author":{"@type":"Person","name":"cobiot"},"publisher":{"@type":"Organization","name":"Habr","logo":{"@type":"ImageObject","url":"https:\/\/habrastorage.org\/webt\/a_\/lk\/9m\/a_lk9mjkccjox-zccjrpfolmkmq.png"}},"description":"&mdash; Не понимаю, почему люди так восхищаются этим Карузо? Косноязычен, гугнив, поёт &mdash; ничего не разберешь! &mdash; А вы слышали, как поёт Карузо? &mdash; Да, мне тут кое-что из...","url":"https:\/\/habr.com\/ru\/post\/321050\/#post-content-body","about":["h_analysis_design","h_refactoring","f_develop"],"image":["https:\/\/habr.com\/share\/publication\/321050\/8b69758434caccd606a0344f27aff6fd\/"]}</script>
  <script src="https://www.googletagservices.com/tag/js/gpt.js" async></script>
  <style>.grecaptcha-badge{visibility: hidden;}</style>
  <meta name="habr-version" content="2.64.0">
  
  <meta data-vue-meta="ssr" property="fb:app_id" content="444736788986613"><meta data-vue-meta="ssr" property="fb:pages" content="472597926099084"><meta data-vue-meta="ssr" name="twitter:card" content="summary_large_image"><meta data-vue-meta="ssr" name="twitter:site" content="@habr_com"><meta data-vue-meta="ssr" property="og:site_name" content="Хабр" data-vmid="og:site_name"><meta data-vue-meta="ssr" property="og:title" content="Охота на мифический MVC. Обзор, возвращение к первоисточникам и про то, как анализировать и выводить шаблоны самому" data-vmid="og:title"><meta data-vue-meta="ssr" name="twitter:title" content="Охота на мифический MVC. Обзор, возвращение к первоисточникам и про то, как анализировать и выводить шаблоны самому" data-vmid="twitter:title"><meta data-vue-meta="ssr" name="aiturec:title" content="Охота на мифический MVC. Обзор, возвращение к первоисточникам и про то, как анализировать и выводить шаблоны самому" data-vmid="aiturec:title"><meta data-vue-meta="ssr" name="description" content="— Не понимаю, почему люди так восхищаются этим Карузо? Косноязычен, гугнив, поёт — ничего не разберешь!
— А вы слышали, как поёт Карузо?
— Да, мне тут кое-что из его репертуара Рабинович напел по..." data-vmid="description"><meta data-vue-meta="ssr" itemprop="description" content="— Не понимаю, почему люди так восхищаются этим Карузо? Косноязычен, гугнив, поёт — ничего не разберешь!
— А вы слышали, как поёт Карузо?
— Да, мне тут кое-что из его репертуара Рабинович напел по..." data-vmid="description:itemprop"><meta data-vue-meta="ssr" property="og:description" content="— Не понимаю, почему люди так восхищаются этим Карузо? Косноязычен, гугнив, поёт — ничего не разберешь!
— А вы слышали, как поёт Карузо?
— Да, мне тут кое-что из его репертуара Рабинович напел по..." data-vmid="og:description"><meta data-vue-meta="ssr" name="twitter:description" content="— Не понимаю, почему люди так восхищаются этим Карузо? Косноязычен, гугнив, поёт — ничего не разберешь!
— А вы слышали, как поёт Карузо?
— Да, мне тут кое-что из его репертуара Рабинович напел по..." data-vmid="twitter:description"><meta data-vue-meta="ssr" property="aiturec:description" content="— Не понимаю, почему люди так восхищаются этим Карузо? Косноязычен, гугнив, поёт — ничего не разберешь!
— А вы слышали, как поёт Карузо?
— Да, мне тут кое-что из его репертуара Рабинович напел по..." data-vmid="aiturec:description"><meta data-vue-meta="ssr" itemprop="image" content="https://habr.com/share/publication/321050/8b69758434caccd606a0344f27aff6fd/" data-vmid="image:itemprop"><meta data-vue-meta="ssr" property="og:image" content="https://habr.com/share/publication/321050/8b69758434caccd606a0344f27aff6fd/" data-vmid="og:image"><meta data-vue-meta="ssr" property="og:image:width" content="1200" data-vmid="og:image:width"><meta data-vue-meta="ssr" property="og:image:height" content="630" data-vmid="og:image:height"><meta data-vue-meta="ssr" property="aiturec:image" content="https://habr.com/share/publication/321050/8b69758434caccd606a0344f27aff6fd/" data-vmid="aiturec:image"><meta data-vue-meta="ssr" name="twitter:image" content="https://habr.com/share/publication/321050/8b69758434caccd606a0344f27aff6fd/" data-vmid="twitter:image"><meta data-vue-meta="ssr" property="vk:image" content="https://habr.com/share/publication/321050/8b69758434caccd606a0344f27aff6fd/?format=vk" data-vmid="vk:image"><meta data-vue-meta="ssr" property="aiturec:item_id" content="321050" data-vmid="aiturec:item_id"><meta data-vue-meta="ssr" property="aiturec:datetime" content="2017-02-07T01:48:41.000Z" data-vmid="aiturec:datetime"><meta data-vue-meta="ssr" content="https://habr.com/ru/post/321050/" property="og:url" data-vmid="og:url"><meta data-vue-meta="ssr" property="og:type" content="article" data-vmid="og:type"><meta data-vue-meta="ssr" property="og:locale" content="ru_RU" data-vmid="og:locale"><meta data-vue-meta="ssr" name="keywords" content="MVC, архитектура приложений">
  <link data-vue-meta="ssr" href="https://habr.com/ru/rss/post/321050/?fl=ru" type="application/rss+xml" title="" rel="alternate" name="rss"><link data-vue-meta="ssr" href="index.html.1.68.html" rel="canonical" data-vmid="canonical"><link data-vue-meta="ssr" data-vmid="hreflang"><link data-vue-meta="ssr" image_src="image" href="https://habr.com/share/publication/321050/8b69758434caccd606a0344f27aff6fd/" data-vmid="image:href">
  <meta name="apple-mobile-web-app-status-bar-style" content="#303b44">
  <meta name="msapplication-TileColor" content="#629FBC">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="mobile-web-app-capable" content="yes">
  <link
    rel="shortcut icon"
    type="image/png"
    sizes="16x16"
    href="https://assets.habr.com/habr-web/img/favicons/favicon-16.png"
  >
  <link
    rel="shortcut icon"
    type="image/png"
    sizes="32x32"
    href="https://assets.habr.com/habr-web/img/favicons/favicon-32.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="76x76"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-76.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="120x120"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-120.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="152x152"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-152.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="180x180"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-180.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="256x256"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-256.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1136x640.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2436x1125.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1792x828.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_828x1792.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1334x750.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1242x2668.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 736px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2208x1242.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1125x2436.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 736px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1242x2208.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2732x2048.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2688x1242.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 834px) and (device-height: 1112px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2224x1668.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_750x1334.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2048x2732.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2388x1668.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 834px) and (device-height: 1112px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1668x2224.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_640x1136.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1668x2388.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2048x1536.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1536x2048.png"
  >
  <link
    rel="mask-icon"
    color="#77a2b6"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-120.svg"
  >
  <link
    crossorigin="use-credentials"
    href="https://habr.com/manifest.webmanifest"
    rel="manifest"
  >
</head>
<body>


<div id="app" data-server-rendered="true" data-async-called="true"><div class="tm-layout__wrapper"><!----> <div></div> <!----> <header class="tm-header"><div class="tm-page-width"><div class="tm-header__container"><!----> <span class="tm-header__logo-wrap"><a href="https://habr.com/ru/" class="tm-header__logo tm-header__logo_ru"><svg height="16" width="16" class="tm-svg-img tm-header__icon"><title>Хабр</title> <use xlink:href="/img/habr-logo-ru.svg#logo"></use></svg></a> <span class="tm-header__beta-sign" style="display:none;">β</span></span> <div class="tm-dropdown tm-header__projects"><div class="tm-dropdown__head"><button class="tm-header__dropdown-toggle"><svg height="16" width="16" class="tm-svg-img tm-header__icon tm-header__icon_dropdown"><title>Открыть список</title> <use xlink:href="/img/megazord-v25.4b679db1.svg#arrow-down"></use></svg></button></div> <!----></div> <a href="https://habr.com/ru/sandbox/start/" class="tm-header__become-author-btn">
            Как стать автором
          </a> <div class="tm-feature tm-header__feature tm-feature_variant-inline"><!----></div> <!----> <!----></div></div></header> <div class="tm-layout"><div class="tm-page-progress-bar"></div> <div data-menu-sticky="true" class="tm-base-layout__header tm-base-layout__header_is-sticky"><div class="tm-page-width"><div class="tm-base-layout__header-wrapper"><div class="tm-main-menu"><div class="tm-main-menu__section"><nav class="tm-main-menu__section-content"><!----> <a href="https://habr.com/ru/flows/all" class="tm-main-menu__item">
        Все потоки
      </a> <a href="https://habr.com/ru/flows/develop/" class="tm-main-menu__item">
          Разработка
        </a><a href="https://habr.com/ru/flows/admin/" class="tm-main-menu__item">
          Администрирование
        </a><a href="https://habr.com/ru/flows/design/" class="tm-main-menu__item">
          Дизайн
        </a><a href="https://habr.com/ru/flows/management/" class="tm-main-menu__item">
          Менеджмент
        </a><a href="https://habr.com/ru/flows/marketing/" class="tm-main-menu__item">
          Маркетинг
        </a><a href="https://habr.com/ru/flows/popsci/" class="tm-main-menu__item">
          Научпоп
        </a></nav></div></div> <div class="tm-header-user-menu tm-base-layout__user-menu"><a href="https://habr.com/ru/search/" class="tm-header-user-menu__item tm-header-user-menu__search"><svg height="24" width="24" class="tm-svg-img tm-header-user-menu__icon tm-header-user-menu__icon_search tm-header-user-menu__icon_dark"><title>Поиск</title> <use xlink:href="/img/megazord-v25.4b679db1.svg#search"></use></svg></a> <!----> <!----> <!----> <div class="tm-header-user-menu__item tm-header-user-menu__user_desktop"><div class="tm-dropdown"><div class="tm-dropdown__head"><svg height="24" width="24" data-test-id="menu-toggle-guest" class="tm-svg-img tm-header-user-menu__icon"><title>Профиль</title> <use xlink:href="/img/megazord-v25.4b679db1.svg#header-user"></use></svg> <!----></div> <!----></div> <!----></div> <!----></div></div></div></div> <!----> <div class="tm-page-width"></div> <main class="tm-layout__container"><div hl="ru" data-async-called="true" class="tm-page"><div class="tm-page-width"><!----> <div class="tm-page__wrapper"><div class="tm-page__main tm-page__main_has-sidebar"><div class="pull-down"><div class="pull-down__header" style="height:0px;"><div class="pull-down__content" style="bottom:10px;"><svg height="24" width="24" class="tm-svg-img pull-down__arrow"><title>Обновить</title> <use xlink:href="/img/megazord-v25.4b679db1.svg#pull-arrow"></use></svg></div></div> <div class="tm-article-presenter"> <div class="tm-article-presenter__body"><div class="tm-misprint-area"><div class="tm-misprint-area__wrapper"><article class="tm-article-presenter__content tm-article-presenter__content_narrow"><div class="tm-article-presenter__header"> <div class="tm-article-snippet tm-article-presenter__snippet"><div class="tm-article-snippet__meta-container"><div class="tm-article-snippet__meta"><span class="tm-user-info tm-article-snippet__author"><a href="https://habr.com/ru/users/cobiot/" title="cobiot" class="tm-user-info__userpic"><div class="tm-entity-image"><svg height="24" width="24" class="tm-svg-img tm-image-placeholder tm-image-placeholder_blue"><!----> <use xlink:href="/img/megazord-v25.4b679db1.svg#placeholder-user"></use></svg></div></a> <span class="tm-user-info__user"><a href="https://habr.com/ru/users/cobiot/" class="tm-user-info__username">
      cobiot
    </a> </span></span> <span class="tm-article-snippet__datetime-published"><time datetime="2017-02-07T01:48:41.000Z" title="2017-02-07, 04:48">7  февраля  2017 в 04:48</time></span></div> <!----></div> <h1 lang="ru" class="tm-article-snippet__title tm-article-snippet__title_h1"><span>Охота на мифический MVC. Обзор, возвращение к первоисточникам и про то, как анализировать и выводить шаблоны самому</span></h1> <div class="tm-article-snippet__hubs"><span class="tm-article-snippet__hubs-item"><a href="https://habr.com/ru/hub/analysis_design/" class="tm-article-snippet__hubs-item-link"><span>Анализ и проектирование систем</span> <span title="Профильный хаб" class="tm-article-snippet__profiled-hub">*</span></a></span><span class="tm-article-snippet__hubs-item"><a href="https://habr.com/ru/hub/refactoring/" class="tm-article-snippet__hubs-item-link"><span>Проектирование и рефакторинг</span> <span title="Профильный хаб" class="tm-article-snippet__profiled-hub">*</span></a></span></div> <!----> <!----> <!----></div></div> <!----> <div data-gallery-root="" lang="ru" class="tm-article-body"><div></div> <div id="post-content-body"><div><div class="article-formatted-body article-formatted-body_version-1"><div xmlns="http://www.w3.org/1999/xhtml"><blockquote><em>— Не понимаю, почему люди так восхищаются этим Карузо? Косноязычен, гугнив, поёт — ничего не разберешь!</em><br/>
<em>— А вы слышали, как поёт Карузо?</em><br/>
<em>— Да, мне тут кое-что из его репертуара Рабинович напел по телефону.</em></blockquote><br/>
<h2 id="detektiv-po-materialam-it-chast-pervaya">Детектив по материалам IT. Часть первая</h2><br/>
<p>Я осознаю, что писать очередную статью на тему Модель-Вид-Контроллер это глупо и вредно для «кармы». Однако с этим «паттерном» у меня слишком личные отношения – проваленный проект, полгода жизни и тяжелой работы «в корзину». </p><br/>
<p>Проект мы переписали, уже без MVC, просто руководствуясь принципами – код перестал быть похож на клубок спагетти и сократился наполовину (об этом позже, в обещанной статье про то, как мы применяли «принципы» в своем проекте). Но хотелось понять, что же мы сделали не так, в чем была ошибка? И в течении долгого времени изучалось все, что содержало аббревиатуру MVC. До тех пор пока не встретились исходные работы от создателя – Трюгве Реенскауга… </p><br/>
<p>И тогда все встало на свои места. Оказалось что фактически на основе принципов мы пере-изобретали «original MVC». А то, что зачастую преподносится как MVC, не имеет к нему никакого отношения… впрочем также как и к хорошей архитектуре. И судя по тому сколько людей пишет о несостоятельности «классического MVC», спорит о нем и изобретает его всевозможные модификации, не одни мы столкнулись с этой проблемой.</p><br/>
<p>Более 30 лет собранные в MVC идеи и решения остаются наиболее значимыми для разработки пользовательских интерфейсов. Но как ни странно, несмотря на существующую путаницу и обилие противоречивых трактовок, разработчики продолжают довольствоваться информацией «из вторых рук», черпая знания о MVC из википедии, небольших статей в интернете и фреймворков для разработки веб-приложений. Самые «продвинутые» читают Мартина Фаулера. И почему-то почти никто не обращается к первоисточникам. Вот этот пробел и хотелось бы заполнить. И заодно развеять некоторые мифы.</p><br/>
<a name="habracut"></a><br/>
<blockquote><strong>Мифы: MVC создавался для языка SmallTalk</strong></blockquote><p>Концепция MVC была сформулирована Трюгве Реенскаугом (Trygve Reenskaug) в результате его работы в Xerox PARC в 1978/79 годах. Как правило создание MVC связывают с языком SmallTalk, но это не совсем так. На самом деле Реенскауг работал в группе, занимавшейся разработкой портативного компьютера "для детей всех возрастов" <a href="https://ru.wikipedia.org/wiki/Dynabook">Dynabook</a> под руководством Алана Кэя (Alan Kay). </p><br/>
<p>Чтобы оценить масштаб и революционность того проекта, нужно иметь ввиду что это были годы, когда для работы с ЭВМ требовалось штудировать многостраничные мануалы и иметь ученую степень. Задача, которую пытался решить Алан Кэй, состояла в том, чтобы сблизить компьютер и рядового пользователя, «сломать» разделяющую их стену. Он хотел обеспечить пользователя средствами, которые были бы предельно простыми и удобными, но при этом давали бы возможность управлять компьютером и сложными приложениями.</p><br/>
<p>Именно тогда/там закладывались основы графического интерфейса, формировалось понятие "дружелюбного интерфейса". А также разрабатывался язык SmallTalk, вместе с концепциями объектно-ориентированного программирования, чтобы неподготовленный пользователь “мог понимать и писать программы”. Вот как описывает увиденное в Xerox PARC в 1979 году Стив Джобс – <a href="https://www.youtube.com/watch?v=J33pVRdxWbw">How Steve Jobs got the ideas of GUI from XEROX</a> (from 6.30)</p><br/>
<p>Проект велся около 10 лет, группой очень сильных разработчиков. Найденные в результате решения, подходы, принципы и в области пользовательских интерфейсов, и в области объектно ориентированного программирования и вообще в разработке больших и сложных компьютерных систем были в какой-то степени проссумированы Реенскаугом и составили основу MVC. Так что MVC это действительно прежде всего совокупность направляющих архитектурных идей. В SmallTalk-80 эти идеи всего лишь получили свою первую значимую реализацию. Причем сделано это было уже после ухода Реенскауга из Xerox PARC и без его участия. </p><br/>
<p>К сожалению в течении долго времени о «реальном MVC» не было практически никакой доступной информации. Первая серьезная публикация от создателей появилась лишь 10 лет спустя – "<a href="https://www.lri.fr/~mbl/ENS/FONDIHM/2013/papers/Krasner-JOOP88.pdf">A Cookbook for Using the Model-View-Controller User Interface Paradigm in Smalltalk-80</a>". Даже Фаулер упоминает, что он изучал MVC по работающей версии SmallTalk – <em>"у меня был доступ к работающей версии Smalltalk-80, чтобы я мог изучить MVC. Я не могу сказать, что это исследование было тщательным, но оно позволило мне понять некоторые аспекты решения, которые другие описания объяснить не смогли"</em>. </p><br/>
<p>Так что не удивительно появление «мифов» и разнообразных трактовок. Проблема заключается в том, что многие «вторичные» источники описывают MVC не только в искаженном, но еще и в обманчиво-упрощенном виде, как правило в виде некой формальной схемы. </p><br/>
<p>В результате многие действительно считают MVC схемой или паттерном (из-за чего постоянно возникает вопрос – какая же из множества существующих схем «правильная» и почему их так много?). В более продвинутом варианте MVC называют <strong>составным</strong> паттерном, то есть комбинацией нескольких паттернов, работающих совместно для реализации сложных приложений (тут обычно упоминаются Observer, Strategy и Composite). И лишь немногие понимают, что MVC это прежде всего набор архитектурных идей/принципов/подходов, которые могут быть реализованы различными способами с использованием различных шаблонов...</p><br/>
<p>К последним относится в частности Мартин Фаулер. Вот что он пишет: <em>“MVC часто называют паттерном, но я не вижу особой пользы воспринимать его как паттерн, поскольку он включает в себя множество различных идей. Разные люди читают про MVC в различных источниках и извлекают от туда разные идеи, но называют их одинаково — «MVC». Это приводит к большой путанице и кроме того служит источником недоразумений и непониманию MVC, как будто бы люди узнавали про него через «испорченный телефон»…. Я уже потерял счет сколько раз я видел что-то, описываемое как MVC, которое им не оказывалось.”</em>[ GUI Architectures] </p><br/>
<p>Рискну предположить, что одна из причин «испорченного телефона» заключается в том, что большинство вторичных источников «за кадром» оставляют самое главное – собственно сами архитектурные идеи, заложенные в MVC его создателями, и те задачи, которые они пытались решить. Как раз все то, что позволяет понять суть MVC и избежать огромного количества подводных камней и ошибок. Поэтому в данной статье я хочу рассказать о том, что обычно остается «за кадром» – MVC с точки зрения заложенных в него архитектурных принципов и идей. Хотя схемы тоже будут. Вернее с них и начнем.</p><br/>
<p>Но сначала ссылки. Исходный доклад Реенскауга – "<a href="http://folk.uio.no/trygver/2007/MVC_Originals.pdf">The original MVC reports</a>". Позже Реенскауг все это более четко сформулировал и оформил в своей последующей работе “<a href="http://heim.ifi.uio.no/~trygver/2003/javazone-jaoo/MVC_pattern.pdf">The Model-View-Controller (MVC ). </a><a href="http://heim.ifi.uio.no/~trygver/2003/javazone-jaoo/MVC_pattern.pdf">Its Past and Present</a>”. Возможно кому-то будет интересна страница, где собраны записи Ренскауга, относящиеся к тому периоду, с его комментариями -<a href="http://heim.ifi.uio.no/~trygver/themes/mvc/mvc-index.html"> MVC </a><a href="http://heim.ifi.uio.no/~trygver/themes/mvc/mvc-index.html">XEROX PARC 1978-79</a>. </p><br/>
<p>Уже упоминавшаяся первая публикация о MVC в языке SmallTalk-80 от разработчиков только в улучшенном качестве "<a href="http://www.create.ucsb.edu/~stp/PostScript/mvc.pdf">A Description of the Model-View-Controller User Interface Paradigm in the Smalltalk-80 System</a>" (Glenn Krasner и Stephen Pope). Хорошим дополнением служит также статья “<a href="http://www.math.sfedu.ru/smalltalk/gui/mvc.pdf">Applications Programming in Smalltalk-80.</a><a href="http://www.math.sfedu.ru/smalltalk/gui/mvc.pdf">How to use Model-View-Controller</a>” (автор SteveBurbeck учавствовал в разработке компилятора SmallTalk для IBM на основе Smalltalk-80, а также в разработке MacApp). Ну и если кто-то хочет полного погружения – “<a href="http://stephane.ducasse.free.fr/FreeBooks/TheInteractiveProgrammingEnv/TheInteractiveProgrammingEnv.pdf">Smalltalk-80. </a><a href="http://stephane.ducasse.free.fr/FreeBooks/TheInteractiveProgrammingEnv/TheInteractiveProgrammingEnv.pdf">The Interactive Programming Environment</a>” от знаменитой Адель Голдберг в дискуссиях с которой Реенскаугом и создавались термины Model, View, Controller.</p><br/>
<h2>Схемы MVC</h2><br/>
<p>Для того, чтобы стало понятно, о чем идет речь и в чем заключается проблема, давайте вначале все же разберем наиболее типичные «схемы» MVC. Это важно, поскольку часто к схемам не дается никаких пояснений и к тому-же бывает, что определения заимствуются из одного места, а схемы из другого. В результате можно встретить одинаковые описания MVC с совершенно разными диаграммами, что очень запутывает. </p><br/>
<p>Итак, несмотря на то, что MVC трактуется и изображается очень по разному, во всем этом многообразии все же можно выделить общее «ядро». Общим является то, что везде говорится о неких трех частях — Модели, Виде и Контроллере, которые связаны между собой определенным образом, а именно:</p><br/>
<ol>
<li><p>Модель ничего не знает ни о Виде, ни о Контроллере, что делает возможным ее разработку и тестирование как независимого компонента. И это является главным моментом MVC. </p><br/>
</li>
<li><p>Вид отображает Модель. И значит, он каким-то образом должен получать из нее нужные для отображения данные. Наиболее распространены следующие два варианта: 1) <strong>Активный Вид</strong>, который знает о Модели и сам берет из нее нужные данные. 2) <a href="http://martinfowler.com/eaaDev/PassiveScreen.html">Пассивный Вид</a>, которому данные поставляет Контроллер. В этом случае Вид с Моделью никак не связан. </p><br/>
<p>Видов может быть несколько — они могут по разному отображать одни и те же данные, например в виде таблицы или графика, или же отвечать за отображение разных частей данных из Модели. </p><br/>
</li>
<li>Контроллер является пожалуй самым неоднозначным компонентом. Тем не менее общим является то, что Контроллер всегда знает о Модели и может ее изменять (как правило в результате действий пользователя). </li>
</ol><br/>
<p>А также он может осуществлять управление Видом/Видами (особенно если их несколько) и соответственно знать о Видах, но это не обязательно. </p><br/>
<p>Отсюда мы получаем базовые (максимально упрощенные) схемы двух наиболее часто встречающихся разновидностей MVC. Перечеркнутой линией обозначена необязательная связь Контроллера с Видом. </p><br/>
<p><img src="https://habrastorage.org/r/w1560/files/0ad/9c6/cfe/0ad9c6cfeef04168a2fc0a73b8c32939.png" alt="Model View Controller" data-src="https://habrastorage.org/files/0ad/9c6/cfe/0ad9c6cfeef04168a2fc0a73b8c32939.png"/></p><br/>
<p><em>Вот так базовая схема выглядит у Фаулера: "Основные связи между Моделью, Видом и Контроллером. (Я называю их основными, потому что на самом деле Вид и Контроллер могут быть связанными друг с другом непосредственно. Однако, разработчики в основном не используют эту связь.)":</em></p><br/>
<p><img src="https://habrastorage.org/r/w1560/files/96c/25b/fc9/96c25bfc96cb495798a82efaced23a04.gif" alt="Model View Controller" data-src="https://habrastorage.org/files/96c/25b/fc9/96c25bfc96cb495798a82efaced23a04.gif"/></p><br/>
<p>Далее. Модель, как и Вид, тоже может быть Пассивной либо Активной. <strong>Пассивная Модель</strong> никак не воздействует ни на Вид ни на Контроллер. В этом случае все изменения Модели отслеживаются Контроллером и он же отвечает за перерисовку Вида, когда это необходимо. </p><br/>
<p>Но обычно, под MVC все таки подразумевают вариант с <strong>Активной Моделью</strong>. </p><br/>
<p>«Активная Модель» <strong>оповещает</strong> о том, что в ней произошли изменения. И делает она это посредством шаблона <em>Наблюдатель</em>, рассылая уведомления о изменениях всем своим «подписчикам». «Активный Вид» подписывается на эти сообщения сам и таким образом знает когда нужно заново считать из модели нужные ему данные и обновиться. В случае «Пассивного Вида», подписчиком является Контроллер, который затем уже обновляет Вид. </p><br/>
<p>Шаблон <em>Наблюдатель</em> позволяет Модели с одной стороны информировать Вид или Контроллер о том что в ней произошли изменения, а с другой фактически ничего о них «не знать» (кроме того что они реализуют некий заданный интерфейс «подписчика») и тем самым оставаться независимой. Это называется <strong>слабым связыванием</strong> и считается вторым ключевым моментом MVC. </p><br/>
<p>Именно поэтому, когда говорится, что MVC это составной шаблон, то в первую очередь в качестве одного из его компонентов упоминается паттерн <em>Наблюдатель</em>. На диаграммах слабое связывание принято рисовать пунктирной стрелкой, но многие это правило игнорируют.</p><br/>
<p>Таким образом, более продвинутые «схемы MVC» будут выглядеть так:</p><br/>
<p><img src="https://habrastorage.org/r/w1560/files/91c/952/6c6/91c9526c60fc467598d74317197e3ad1.png" alt="Model View Controller" data-src="https://habrastorage.org/files/91c/952/6c6/91c9526c60fc467598d74317197e3ad1.png"/></p><br/>
<p><strong><em>Замечание:</em></strong> <em>встречаются авторы, которые в термины Пассивная и Активная модель вкладывают совсем иной смысл. А именно то, что обычно принято называть Тонкой моделью (модель содержащая исключительно данные) и Толстой моделью (полноценная модель содержащая всю бизнес логику приложения).</em></p><br/>
<p>Ну и последнее. Вообще говоря MVC, в любой своей разновидности, это прежде всего шаблон для разработки приложений с пользовательским интерфейсом и его главное назначение – обеспечить взаимодействие приложения с пользователем. Поэтому в полноценной MVC схеме (явно или неявно) должен присутствовать <strong>пользователь</strong>. И тут в основном встречаются две трактовки:</p><br/>
<ol>
<li><p>Пользователь управляет приложением через Контроллер, а Вид служит исключительно для отображения информации о Модели, и пользователь его лишь видит</p><br/>
<p><img src="https://habrastorage.org/r/w1560/files/0be/ae1/fe0/0beae1fe0b98446cad4d399bce29908f.png" alt="Model View Controller" data-src="https://habrastorage.org/files/0be/ae1/fe0/0beae1fe0b98446cad4d399bce29908f.png"/></p><br/>
<p><em>Часто указывают/рисуют лишь то, что пользователь действует на Контроллер, а то что он видит Вид опускается</em>.</p><br/>
</li>
<li><p>Пользователь взаимодействует только с Видом. То есть Вид не только отражает Модель, но также принимает команды пользователя и передает их Контроллеру. В этом случае между Видом и Контроллером образуется еще одна связь: прямая (Вид знает о Контроллере и напрямую передает информацию) или, чаще всего, ослабленная (Вид просто рассылает информацию о действиях пользователя всем заинтересованным подписчикам а Контроллер на эту рассылку подписывается) </p><br/>
<p><img src="https://habrastorage.org/r/w1560/files/09e/595/6a8/09e5956a8a6a4c9697150a31cb1ac6ab.png" alt="Model View Controller" data-src="https://habrastorage.org/files/09e/595/6a8/09e5956a8a6a4c9697150a31cb1ac6ab.png"/></p><br/>
</li>
</ol><br/>
<p><em><strong>Замечание:</strong> нужно иметь ввиду, что вариант с <strong>Пассивным Видом</strong>, когда Вид никак не связан с Моделью и данные для отображения ему поставляет Контроллер, иногда называют MVC, а иногда выделяют в отдельную разновидность — MVP и тогда Контроллер переименовывают в <strong>Презентер</strong>.</em></p><br/>
<p>Для иллюстрации всего вышесказанного несколько диаграмм «из интернета» (надеюсь стало понятнее почему они такие разные): </p><br/>
<p><img src="https://habrastorage.org/r/w1560/files/b5c/6bf/3b9/b5c6bf3b990c48b3b0ba0fa7ddbfd119.png" alt="Model View Controller" data-src="https://habrastorage.org/files/b5c/6bf/3b9/b5c6bf3b990c48b3b0ba0fa7ddbfd119.png"/></p><br/>
<p>А теперь самое главное — как применяются, что обозначают и чему соответствует Модель Вид и Контроллер при написании приложений?</p><br/>
<p>Тут можно выделить два кардинально отличающихся подхода, в каждом из которых Модель, Вид и Контроллер трактуются весьма различным образом. </p><br/>
<h2>«Трехуровневый MVC» от веб</h2> <br/>
<p>Первый подход идет из веб-программирования, где MVC получил самое широкое распространение, и поэтому в нем максимально отразились свойственные веб-программированию черты. А именно, привязка к трехуровневой архитектуре «клиент–сервер–база данных» и преобладание скриптовых языков. В результате компоненты MVC формально привязываются к трем слоям архитектуры и получается что:</p><br/>
<ol>
<li><p><strong>Модель = База Данных</strong><br/>
Модель — это просто данные, которыми оперирует приложение </p><br/>
</li>
<li><p><strong>Контроллер = Сервер</strong><br/>
Контроллер — это бизнес-логика приложения. Иногда еще говорят что контроллер это центр обработки всех запросов и принятия решений, а также промежуточный слой обеспечивающий связь модели и представления.</p><br/>
</li>
<li><strong>Вид = Клиент</strong> (как правило тонкий)<br/>
Вид — это пользовательский интерфейс. Причем интерфейс в этом случае, как правило, понимается в основном исключительно как «дизайн», просто набор графических элементов. Логика же работы этого интерфейса, как и логика работы с данными, выносится в Контроллер</li>
</ol><br/>
<p><img src="https://habrastorage.org/r/w1560/files/1ed/f60/74f/1edf6074f07940db9b303403c601a610.png" alt="image alt text" data-src="https://habrastorage.org/files/1ed/f60/74f/1edf6074f07940db9b303403c601a610.png"/> </p><br/>
<p>Про неадекватность этого подхода написано уже так много, что это вошло даже в википедию (<a href="https://ru.wikipedia.org/wiki/Model-View-Controller#.D0.9D.D0.B0.D0.B8.D0.B1.D0.BE.D0.BB.D0.B5.D0.B5_.D1.87.D0.B0.D1.81.D1.82.D1.8B.D0.B5_.D0.BE.D1.88.D0.B8.D0.B1.D0.BA.D0.B8">MVC. Наиболее частые ошибки</a>). Хорошо и подробно возникающие при этом проблемы рассматриваются в статье, ставшей своего рода классикой "<a href="http://habrahabr.ru/post/175465/">M в MVC: почему модели непоняты и недооценены</a>". Поэтому постараюсь просто кратко просуммировать:</p><br/>
<ol>
<li><p>Независимость Модели является главным в MVC. Если Модель тонкая, то есть содержит лишь данные, то возможность ее независимой разработки имеет мало смысла. Соответственно при таком подходе теряет смысл и сам MVC </p><br/>
</li>
<li><p>Вся бизнес логика приложения, то есть большая часть кода, сосредотачивается в Контроллере и это при том что как раз Контроллер является самой зависимой частью в MVC – в общем случае он зависит и от Модели и от Вида. Вообще говоря в хорошо спроектированных приложениях стараются делать с точностью до наоборот – наиболее зависимые части должны быть минимальными, а не максимальными </p><br/>
</li>
<li><p>На практике Контроллеру в веб-приложении обычно соответствует один скрипт и вынесение всей бизнес-логики в Контроллер фактически означает еще и то, что большая часть приложения оказывается в одном скрипте. Отсюда и появился термин ТТУК — толстый тупой уродливый контроллер </p><br/>
</li>
<li>Поскольку, как правило, тонкой является не только Модель но также и Вид (тупой Вид или тупой интерфейс — Dumb GUI, Dumb View), то, как следствие, в Контроллер помимо всей бизнес-логики приложения помещается также еще и логика управления пользовательским интерфейсом. То есть, вместо разделения бизнес логики и логики представления при таком подходе получается их смешение. </li>
</ol><br/>
<p><img src="https://habrastorage.org/r/w1560/files/b94/39e/467/b9439e467c0a4f53969685ca8f35a824.png" alt="web MVC" data-src="https://habrastorage.org/files/b94/39e/467/b9439e467c0a4f53969685ca8f35a824.png"/></p><br/>
<p>Программа, конечно, разбивается на множество MVC, соответствующих страницам веб-приложения, и это спасает ситуацию но, увы, не меняет сути. Проблема эта известна, вот неплохая статья — "<a href="http://tutorials.jenkov.com/software-architecture/ria-architecture.html">RIA Architecture</a>". </p><br/>
<blockquote><strong>Типичные ошибки: смешение в Контроллере бизнесс-логики и GUI-логики</strong></blockquote><p>Хорошая новость заключается в том, что «веб-вариант MVC», всего несколько лет назад бывший самым распространенным, сейчас активно сдает позиции. Плохо то, что он по прежнему распространен, только теперь не в явном, а в замаскированном виде. Поскольку за фразы (цитирую): "<em>Модель это обмен данными с БД</em> и т.п. <em>Контроллер логика обработки этих данных и подготовка к View</em>" сейчас активно «минусуют», то стали писать:</p><br/>
<ul>
<li>Модель — это данные и методы работы с ними </li>
<li>Контроллер — обработка действий пользователя и вводимой им информации </li>
</ul><br/>
<p>Дело в том, что в объектно-ориентированном приложении нет данных, а есть множество объектов и каждый из них содержит какие-то данные и методы работы с ними. В том числе и объекы доступа к базе данных (если они имеются). Поэтому когда определение Модели начинается со слова «данные», то оно в сущности имеет мало смысла и нередко в завуалированной форме подразумевает все тот же самый доступ к базе данных. В <strong>обработку</strong> же <strong>действий пользователя</strong> нередко помещается львиная доля бизнес логики и в результате по прежнему вся, или почти вся, логика приложения часто оказывается в Контроллере.</p><br/>
<h2>«Архитектурный MVC»</h2><br/>
<p>Второй подход гораздо ближе к первоисточникам. Поэтому разберем его подробнее.</p><br/>
<p>Мартин Фаулер абсолютно прав, когда говорит что MVC это не паттерн, а набор архитектурных принципов и идей, используемых при построении пользовательских информационных систем (как правило сложных).</p><br/>
<p>Архитектурные принципы мы постарались собрать и описать в статье "<a href="https://habrahabr.ru/post/276593/">Создание архитектуры программы или как проектировать табуретку</a>". Если же говорить предельно кратко, то суть состоит в следующем: сложную систему нужно разбивать на модули. Причем декомпозицию желательно делать <strong>иерархически</strong>, а модули, на которые разбивается система, должны быть, по возможности, независимы или <strong>слабо связаны</strong> (<strong>Low coupling</strong>). Чем слабее связанность, тем легче писать/понимать/расширять/чинить программу. Поэтому одной из основных задач при декомпозиции является минимизация и ослабление связей между компонентами.</p><br/>
<p>Давайте посмотрим, как эти принципы применяются в MVC для создания первичной архитектуры (декомпозиции) пользовательских приложений. По сути в основе MVC лежат три довольно простые идеи:</p><br/>
<p><strong>«1» Отделение модели предметной области (бизнес логики) приложения от пользовательского интерфейса</strong> </p><br/>
<p>Первая и основная идея MVC заключается в том, что любое пользовательское приложение в первом приближении можно разделить на два модуля — один из которых обеспечивает основной функционал приложения, его бизнес логику, а второй отвечает за взаимодействие с пользователем: </p><br/>
<p><img src="https://habrastorage.org/r/w1560/files/0bd/003/42d/0bd00342d45c4515bd7d09e200a3cf02.png" alt="MVC" data-src="https://habrastorage.org/files/0bd/003/42d/0bd00342d45c4515bd7d09e200a3cf02.png"/></p><br/>
<p>Тем самым мы получаем возможность разрабатывать <strong>модель предметной области</strong>, содержащую бизнес-логику системы и составляющую функциональное ядро приложения, не думая о том как именно она будет взаимодействовать с пользователем. </p><br/>
<p>Задача же взаимодействия с пользователем выносится в отдельный модуль – <strong>пользовательский интерфейс</strong> и тоже может решаться относительно независимо. </p><br/>
<p>Именно модель предметной области (<a href="http://www.informit.com/articles/article.aspx?p=1398617&amp;seqNum=2">Доменная Модель</a> от английского <strong>domain model</strong>) считается <strong>Моделью</strong> в «архитектурном MVC» (отсюда и термин). Поэтому так важно чтобы она была независимой и могла независимо разрабатываться и тестироваться.</p><br/>
<p><em>"Сердцевиной идеей MVC, как и основной идеей для всех последующих каркасов, является то, что я называю «отделенное представление» (<a href="http://www.martinfowler.com/eaaDev/SeparatedPresentation.html">Separated Presentation</a>). Смысл отделенного представления в том, чтобы провести четкую границу между доменными объектами, которые отражают наш реальный мир, и объектами представления, которыми являются GUI-элементы на экране. Доменные объекты должны быть полностью независимы и работать без ссылок на представление, они должны обладать возможностью поддерживать (support) множественные представления, возможно даже одновременно. Этот подход, кстати, так же был одним из важных аспектов Unix-культуры, позволяющий даже сегодня работать во множестве приложений как через командную строку, так и через графический интерфейс (одновременно)."</em> — Фаулер</p><br/>
<p><strong>«2» Независимость Модели и синхронизация пользовательских интерфейсов за счет шаблона <em>Наблюдатель</em></strong></p><br/>
<p>Вторая ключевая идея заключается в том, что для того, чтобы иметь возможность разрабатывать Модель <strong>независимо</strong>, необходимо ослабить ее зависимость от пользовательского интерфейса. И делается это, как уже упоминалось выше, за счет шаблона <strong><em>Наблюдатель</em></strong>. </p><br/>
<p>Модель <strong>рассылает извещения об изменениях</strong>. Интерфейс подписывается на эти оповещения и таким образом знает, когда нужно заново считать данные из модели и обновиться. Благодаря этому мы получаем практически <strong>независимую Модель</strong>, которая ничего не знает о связанных с ней пользовательских интерфейсах, кроме того что они реализуют интерфейс «наблюдателя».</p><br/>
<p><strong>«3» Разделение Пользовательского Интерфейса на Вид и Контроллер.</strong></p><br/>
<p>Третья идея это просто второй шаг иерархической декомпозиции. После первичного разделения приложения на бизнес модель и интерфейс, декомпозиция продолжается на следующем иерархическом уровне и уже пользовательский интерфейс, в свою очередь, делится на Вид и Контроллер.</p><br/>
<p><img src="https://habrastorage.org/r/w1560/files/0d5/00d/0e5/0d500d0e5b35406a9f68022716ba807a.png" alt="MVC" data-src="https://habrastorage.org/files/0d5/00d/0e5/0d500d0e5b35406a9f68022716ba807a.png"/></p><br/>
<p>У меня сложилось впечатление, что суть этого деления мало кто понимает и соответственно может объяснить. Обычно приводят лишь стандартную обтекаемую формулировку, что Контроллер как-то реагирует на действия пользователя, а Вид отображает Модель (поэтому в большинстве реализаций именно Вид подписывается на извещения об изменениях Модели. Хотя, как уже говорилось, подписчиком может быть и Контроллер, либо Вид и Контроллер вместе).</p><br/>
<p>Поскольку деление пользовательского интерфейса на Вид и Контроллер относится ко <strong>второму уровню иерархии</strong>, оно гораздо менее значимо чем первичное разделения приложения на доменную модель и интерфейс. Очень часто (особенно когда дело касается простых виджетов) оно вообще не делается и используется «<strong>упрощенный MVC</strong>», в котором имеется только Модель и единый UI-компонент, представляющий собой объединенный ВидКонтроллер. Более подробно об этом речь пойдет чуть позже. </p><br/>
<p>«Архитектурный MVC» на первый взгляд выглядит вполне разумно. Но как только мы попытаемся применить его не к учебному примеру из трех классов а к реальной программе, то столкнемся с целым рядом проблем и вопросов, о которых редко пишут, но которые чрезвычайно важны. И касаются они не только пользовательского интерфейса, но и самой Модели. Так что предлагаю таки попробовать с ними разобраться и, наконец-то, "послушать Карузо", то есть обратиться к первоисточникам.</p><br/>
<h2>«Original MVC»: Реенскауг и SmallTalk-80</h2><br/>
<p>Мы привыкли к тому, что MVC почти всегда рассматривается на примере создания какого нибудь простейшего графического компонента, вся «бизнес логика» которого помещается в один класс с данными и парой методов для их изменения. Но что делать, когда речь идет о <strong>реальных</strong> приложениях, ядро которых состоит из многих взаимосвязанных объектов работающих совместно? </p><br/>
<p><strong>В общем случае <em>Модель</em> это один объект или множество объектов? И на самом ли деле <em>Модель</em> в «MVC-схеме» тождественна доменной модели, описывающей предметную область и бизнес-логику приложения?</strong></p><br/>
<p>То, что Модель реализует шаблон <em>Наблюдатель</em> явно указывает на то, что Модель это именно один объект. На это же указывает и то, что Вид и Контроллер должны знать о Модели (для того чтобы брать из нее данные и вносить изменения) и следовательно они должны содержать на нее ссылку. Но тогда, если считать, что под Моделью подразумевается доменная модель, мы вновь приходим к тому что все ядро приложения оказывается в одном объекте. Только теперь вместо толстого уродливого Контроллера, у нас появляется толстая Модель. Толстая Модель конечно лучше, поскольку она независима и в ней, по крайней мере, не смешивается бизнес логика с логикой GUI, но все равно такое решение сложно отнести к хорошей архитектуре. </p><br/>
<p>Остается второй вариант — Модель это множество доменных объектов, совместно реализующих бизнес логику. Это предположение подтверждает и сам Реенскауг: "<em>A model could be a single object (rather uninteresting), or it could be some structure of objects.</em>" Но тогда остается открытым вопрос – кто реализует шаблон <em>Наблюдатель</em>, откуда берет данные Вид, куда передает команды пользователя Контроллер? </p><br/>
<p>И вот здесь нередко встречается попытка обмануть самих себя путем примерно следующего рассуждения: "пусть Модель это множество доменных объектов, но… среди этого множества есть в том числе и «объект с данными», вот он-то и будет реализовывать шаблон Наблюдатель, а также служить источником данных для Вида." Эту уловку можно назвать «Модель в Модели». И по сути это еще один «завуалированный» вариант того, что «Модель это данные». </p><br/>
<p>Тут можно сказать лишь одно: архитектура, в которой один модуль (Вид или Контроллер), должен «лезть» <strong>внутрь</strong> другого модуля (доменной модели) и искать там для себя данные или объекты для изменения очень нехорошо «пахнет». Получается что Вид и Контроллер зависят от деталей реализации доменной модели, и если структура этой самой модели изменится, то придется переделывать весь пользовательский интерфейс.</p><br/>
<p>Для того же, чтобы понять «а как должно быть» предлагаю вновь обратится к «принципам». Когда говорилось о том, что систему надо разбивать на модули, <strong>слабо связанные</strong> друг с другом, мы не упомянули главное правило, позволяющее добится этой самой слабой связанности. А именно – модули друг для друга должны быть «черными ящиками». Ни при каких условиях один модуль не должен обращаться к объектам другого модуля напрямую и что либо знать о его внутренней структуре. Модули должны взаимодействовать друг с другом лишь на уровне абстрактных интерфейсов (Dependency Inversion Principle). А реализует интерфейс модуля как правило специальный объект — <strong>Фасад</strong>. </p><br/>
<p>И если поискать какие же паттерны позволяют добится слабой связанности, то на первом месте будет находится именно паттерн <em>Фасад</em>, и только затем <em>Наблюдатель</em> и тд. </p><br/>
<p>Ну а теперь схема из доклада Трюгве Реенскауга:</p><br/>
<p><img src="https://habrastorage.org/r/w1560/files/b04/f6f/022/b04f6f02268a41b28e317cd2bab38871.png" alt="MVC Reenskaug" data-src="https://habrastorage.org/files/b04/f6f/022/b04f6f02268a41b28e317cd2bab38871.png"/></p><br/>
<p><strong><em>Пояснение:</em></strong> <em>Поскольку во времена создания MVC интерфейсы компьютерных программ были в основном текстовыми, то есть, по сути представляли собой простейший вид редактора, то вместо термина «Пользовательский Интерфейс», который появился позже, Трюгве Реенскауг использует термин «Editor» (редактор).</em> </p><br/>
<p>Таким образом, ключевая идея MVC действительно состоит в том, что пользовательское приложение делится на два модуля – один из которых моделирует предметную область и реализует бизнес логику (<em>доменная модель</em>), а второй отвечает за взаимодействие с пользователем (<em>пользовательский интерфейс</em>). Но при этом <strong>Модель</strong> в «MVC схеме» вовсе <strong>не тождественна доменной модели</strong> (которая может быть сколь угодно сложной и состоять из множества объектов), а является всего лишь ее <strong>интерфейсом</strong> и <strong>фасадом</strong>. </p><br/>
<p>Так что ни Вид ни Контроллер разумеется не должны знать о том, как устроен модуль предметной области (доменная модель), где и в каком формате там храняться данные, и как именно осуществляется управление. Они взаимодействуют лишь с <strong>интерфейсом</strong> и реализующим его <strong>объектом-фасадом</strong>, который предоставляет все нужные данные в нужном формате и удобный набор высокоуровневых команд для управления подсистемой, а также реализует шаблон Наблюдатель, для извещения о <strong>значимых</strong> изменениях в подсистеме. И если мы захотим поменять базу данных, использовать облако, или вообще собирать нужные нам данные из различных источников в сети… если внесем какие угодно изменения в бизнес логику приложения, но при этом оставим неизменным интерфейс-фасад, то ни Вид, ни Контроллер это никак не затронет. Мы имеем архитектуру <strong>устойчивую</strong> к изменениям. </p><br/>
<p>И если уж рисовать схему MVC, то выглядеть она должна следующим образом:</p><br/>
<p><img src="https://habrastorage.org/r/w1560/files/08f/a79/c2b/08fa79c2b3664daead48c60eeaf7ebe3.png" alt="MVC" data-src="https://habrastorage.org/files/08f/a79/c2b/08fa79c2b3664daead48c60eeaf7ebe3.png"/></p><br/>
<p>Давайте рассмотрим данную схему подробнее. Традиционно в клиент серверных приложениях главным считается сервер. Он предоставляет услуги/сервисы и решает в каком виде это должно быть реализовано. Соответственно интерфейс и фасад, как правило, определяются с точки зрения сервера. А клиенты под этот заданный формат подстраиваются.</p><br/>
<p>На практике же более адекватной оказывается не сервер-ориентированная архитектура, а клиент-ориентированная. В ней фокус с сервера смещается в сторону клиента и интерфейс, вернее интерфейсы (и фасад или фасады), определяются исходя из потребностей клиентов. Вместо <strong>Предоставляемого Интерфейса</strong> (<em>Provided Interface</em>) используются <strong>Требуемые Интерфейсы</strong> (<a href="http://martinfowler.com/bliki/RequiredInterface.html">RequiredInterface</a>). </p><br/>
<p><img src="https://habrastorage.org/r/w1560/files/e2e/f2f/71f/e2ef2f71f62b4f4b842385979e46a991.png" alt="RequiredInterface" data-src="https://habrastorage.org/files/e2e/f2f/71f/e2ef2f71f62b4f4b842385979e46a991.png"/></p><br/>
<p>Конкретные реализации могут варьироваться, но это не суть важно</p><br/>
<p><img src="https://habrastorage.org/r/w1560/files/7c5/ec1/aa4/7c5ec1aa4b654f1fbd9038a47e85c7db.png" alt="RequiredInterface" data-src="https://habrastorage.org/files/7c5/ec1/aa4/7c5ec1aa4b654f1fbd9038a47e85c7db.png"/> </p><br/>
<p>Клиент ориентированный подход гораздо лучше соответствует <em>Принципу разделения интерфейсов</em> (<em>Interface Segregation Principle</em>) поскольку в нем вместо единого для всех толстого <strong>ProvidedInterface</strong> используется множество тонких <strong>RequiredInterface</strong>.</p><br/>
<p>Если я не ошибаюсь, именно такой подход используется в архитектуре микросервисов. Там для взаимодействия с множеством сервисов введено понятие шлюза, который является ни чем иным как фасадом — “<em>An API Gateway is a server that is the single entry point into the system. It is similar to the Facade pattern from object-oriented design. The API Gateway encapsulates the internal system architecture and provides an API that is tailored to each client</em>. ” <a href="https://www.nginx.com/blog/building-microservices-using-an-api-gateway/">Building Microservices: Using an API Gateway</a>. </p><br/>
<p>Причем шлюз этот "<em>вместо того чтобы обеспечивать общий единый для всех API, предоставляет различные API для каждого клиента (Rather than provide a one-size-fits-all style API, the API gateway can expose a different API for each client. For example, the Netflix API gateway runs client-specific adapter code that provides each client with an API that’s best suited to it’s requirements)</em>" <a href="http://microservices.io/patterns/apigateway.html">API Gateway</a>.</p><br/>
<p>Как мы увидим дальше клиент-ориентированный подход применялся также и в SmallTalk-80. Но вначале давайте просто пере-рисуем схему MVC с учетом вышесказанного:</p><br/>
<p><img src="https://habrastorage.org/r/w1560/files/0db/5aa/0b4/0db5aa0b47764f9d93ceac2658253fb4.png" alt="MVC" data-src="https://habrastorage.org/files/0db/5aa/0b4/0db5aa0b47764f9d93ceac2658253fb4.png"/></p><br/>
<p>Смотрим на фасад… Вот он тот самый клей (glue), объект посредник, прокси, фильтр, адаптер… связывающий между собой доменную модель и пользовательский интерфейс и поставляющий нужные данные в нужном/удобном формате. </p><br/>
<p>Удивительно то, что кроме Реенскауга об этом почти никто не пишет. Хотя некоторые пере-открывают эту идею самостоятельно (пример можно посмотреть <a href="http://docs.roguewave.com/stingray/11.2/html/sflug/8-9.html">тут</a> или <a href="http://web.archive.org/web/20050314095039/http://www.roguewave.com/products/whitepapers/mvcwp.pdf">тут</a> раздел "Interface-Based Programming Techniques"). </p><br/>
<p>Особенно хорошо тема Моделей-интерфейсов раскрыта в статье одного из JavaGuru — <a href="http://javadude.com/articles/vaddmvc2/mvc2.html">Advanced MVC Patterns</a>. Автор подчеркивает, что Модели это не данные, а исключительно интерфейсы/объекты-посредники/фильтры (Models as Proxies, Models as Filters), обеспечивающие удобный доступ к данным, которые могут находится где угодно – на разных машинах, в разных форматах: “<em>О чем большинство программистов не думает, так это о том, что модели являются всего лишь интерфейсами. Они не должны содержать никаких данных!.. Модели-посредники расширяют охват и позволяют использовать уже <strong>существующие данные</strong> где бы они не находились</em>”. </p><br/>
<p>Из-за того что фасад, присутствующий в original MVC, был «утерян», то его роль зачастую берет на себя Контроллер. Отсюда и проистекают представления что Контроллер находится «между Моделью и Видом», служит клеем между ними и обеспечивает нужные Виду данные. </p><br/>
<p>На форумах нередко встречается вопрос — "Чем контроллер отличается от фасада?". Не смотря на наивность этот вопрос вполне закономерен и на него сложно дать разумный ответ поскольку во многих MVC фреймворках Контроллер на самом деле фактически является фасадом — <strong>«Фронт-Контроллер»</strong>. </p><br/>
<p>Чем плохо такое решение? Если оно граммотно реализовано, то ничем. Но это в теории. А на практике нередко происходит путаница концепций и понятий и в результате Фронт-Контроллер с одной стороны злоупотребляет своими полномочиями и вместо <strong>делегирования команд</strong> начинает включать в себя <strong>реализацию</strong> бизнес логики. А с другой – продолжает одновременно выполнять функции пользовательского интерфейса и в результате в нем происходит уже упоминавшееся смешение «бизнес логики» и «GUI логики» (что собственно и делает его код похожим на огромную свалку). </p><br/>
<p>Думаю, что пришло время перейти к Smalltalk. Smalltalk-80 создавался очень талантливыми людьми. С документацией в нем действительно имелись проблемы (тем более что «шаблонов проектирования» тогда еще не существовало) но вот с реализацией в основном все было хорошо и пользовательские интерфейсы, конечно же, не взаимодействовали с доменной моделью напрямую. </p><br/>
<p>Между интерфейсом и доменной моделью (объектами языка SmallTalk) всегда располагался некий промежуточный класс/объект, который обеспечивал удобный интегральный доступ к доменным объектам их данным и методам. Вот эти-то промежуточные объекты (по сути выполняющие роль фасадов) и были в действительности Моделями в SmallTalk-80. </p><br/>
<p>Например, для работы с кодом в Smalltalk использовались следующие GUI интерфейсы: Inspector, Browser, Workspace,… </p><br/>
<p><img src="https://habrastorage.org/r/w1560/files/7ba/dc8/179/7badc8179d43404f937a7026e7f0ebdc.png" alt="smalltalk-80 MVC" data-src="https://habrastorage.org/files/7ba/dc8/179/7badc8179d43404f937a7026e7f0ebdc.png"/></p><br/>
<p>Вот что пишет об их устройстве Glenn Krasner:</p><br/>
<p><em>"Inspector в системе состоит из двух видов. ListView отображает список переменных (слева), а TextView показывает значение выбранной переменной (справа)… Моделью для этих видов служит экземпляр класса «<strong>Inspector</strong>»… Отдельный класс «<strong>Inspector</strong>» является <strong>посредником</strong> или <strong>фильтром</strong> для того чтобы обеспечивать доступ к любому свойству любого объекта. Использование промежуточных объектов между View и "<strong>actual</strong>" models является типичным способом изолировать поведение отображения от модели приложения...</em></p><br/>
<p><em>Как и в случае Inspector, промежуточные объекты использовались также в качестве моделей для системных браузеров. Экземпляр класса «<strong>Browser</strong>» является моделью-посредником для каждого системного браузера...</em>"</p><br/>
<p><strong>Замечание</strong>: название класса-посредника, описывающего промежуточный объект-фасад, обычно совпадало с названием отображающего его виджета. У Inspector промежуточная модель так и называлась «<em>Inspector</em>», а у Browser соответственно – «<em>Browser</em>».</p><br/>
<p>В случае Workspace, который был одним из простейших интерфейсов "<em>моделью служил экземпляр StringHolder, который просто предоставлял текст, то есть строку с информацией о форматировании".</em> </p><br/>
<p><img src="https://habrastorage.org/r/w1560/files/17a/ea1/079/17aea10795a944368b483e9803ad5ef8.png" alt="smalltalk-80 MVC" data-src="https://habrastorage.org/files/17a/ea1/079/17aea10795a944368b483e9803ad5ef8.png"/></p><br/>
<p>В конце своей статьи Krasner приводит список использовавшихся в SmallTalk Моделей (наследников базового класса Model): <strong>StringHolder</strong>, <strong>Browser</strong>, <strong>Inspector</strong>, <strong>FileModel</strong>, <strong>Icon</strong>… А также отмечает что "<em>the models were almost always some sort of filter class</em>".</p><br/>
<p>Позже в VisualWorks Smalltalk идея промежуточных Holder-ов была развита и реализована в полной мере. Там для доступа к каждой переменной, принадлежащей доменным объектам, используется свой интерфейс и фасад – <a href="http://c2.com/cgi/wiki?ValueModel">ValueModel</a> и ValueHolder. И, как не трудно догадаться, именно ValueModel реализует шаблон <em>Наблюдатель</em>, извещая GUI о происходящих «в домене» изменениях. </p><br/>
<p><img src="https://habrastorage.org/r/w1560/files/3aa/904/ba5/3aa904ba565c404f8fc71060e28501b9.png" alt="smalltalk Value-Model MVC" data-src="https://habrastorage.org/files/3aa/904/ba5/3aa904ba565c404f8fc71060e28501b9.png"/></p><br/>
<blockquote><strong>Типичные ошибки: обращение к доменным объектам напрямую</strong></blockquote><p>Поскольку на практике в любом сколько нибудь серьезном приложении сложно обойтись без фасадов, то не удивительно что во многих фреймворках и "модификациях MVC" аналоги фасада или объекта-посредника между GUI и доменной моделью пере-изобретаются под самыми разными именами. Помимо Front-Controller здесь можно упомянуть также ApplicationModel, <a href="https://ru.wikipedia.org/wiki/Model-View-ViewModel">ViewModel</a> (подробнее см. дискуссию <a href="http://c2.com/cgi/wiki?ModelModelViewController">Model-ModelView-Controller</a>) и <a href="https://doc.qt.io/archives/4.6/model-view-proxy-models.html">Proxy-model</a>. </p><br/>
<p>Из-за того, что разработчики не всегда хорошо понимают что стоит за всеми этими «моделями», а сами модели привыкли воспринимать как данные а не интерфейс, то это становится источником еще одной весьма распространенной и ресурсоемкой ошибки. Вместо того чтобы нужным образом всего лишь <strong>интерпретировать</strong> и адаптировать имеющиеся доменные данные с помощью моделей-посредников их начинают <strong>копировать</strong> в эти модели-посредники. </p><br/>
<p>Например, ValueHolder это, как правило, всего лишь обертка вокруг уже существующей доменной переменной, он не должен содержать данные, он содержит ссылку на данные. Вот что пишут: "<em>ValueModel does not need to actually store the value because it is already being stored by another model</em>" (<a href="http://c2.com/ppr/vmodels.html">Understanding and Using ValueModels</a>). </p><br/>
<p>А вот цитата из статьи <a href="http://javadude.com/articles/vaddmvc2/mvc2.html">Advanced MVC Patterns</a>: "<em>Одна из самых распространенных ошибок, которую совершают люди когда используют Swing компоненты, заключается в копировании данных в модели этих Swing компонент. Правильный же способ состоит в том чтобы использовать уже существующие данные, адаптируя их при помощи фильтра… Запомните: никогда не копируйте данные которые можно просто интерпретировать!</em>". </p><br/>
<p>Рассмотрим следующий простой пример. Если последовать интернет советам и для "добавления элементов в список" использовать код подобный этому (взято со StackOverflow и <a href="http://www.java2s.com/Tutorial/Java/0240__Swing/AddingandRemovinganIteminaJListComponent.htm">Adding and Removing an Item in a JList</a>), то будет происходить как раз то самое <strong>копирование</strong> данных в модель списка:</p><br/>
<pre><code class="java">Object[] items; // Доменный объект

DefaultListModel model = new DefaultListModel();
JList list = new JList(model);
for (int i = 0; i &lt; items.length; i++){
     // КОПИРОВАНИЕ доменных данных в модель списка!
     model.addElement(items[i]);  
}</code></pre><br/>
<p>Правильнее, конечно же, использовать данные массива просто обернув их в интерфейс ListModel (тем более что для этих целей создана уже почти готовая AbstractListModel):</p><br/>
<pre><code class="java">// создаем фасад-адаптер к доменным данным,
// который просто интерпретирует их нужным образом
ListModel model = new AbstractListModel() {
    public int getSize() {return items.length;}
    public Object getElementAt(int index) {return  items[index];}
};
// передаем созданный фасад списку в качестве модели
JList list = new JList(model);</code></pre><br/>
<p>И если надо объединить данные, отфильтровать или преобразовать каким-нибудь образом, то совершенно не нужны промежуточные массивы. Все делается непосредственно в модели-фасаде</p><br/>
<pre><code class="java">Object[] items1;  Object[] items2; // Доменные объекты

// модель-фасад которая объединяет массивы
ListModel model = new AbstractListModel() {
    public int getSize() { return items1.length + items2.length;}
    public Object getElementAt(int index) {
        return index&lt;items1.length ? items1[index] : items2[index-items1.length];
    }
};
JList list = new JList(model);</code></pre><br/>
<p>В случае небольших статических массивов преимущества не очевидны. Но в общем случае такой подход позволяет не только избегать копирования, но прежде всего защищает от проблем связанных с рассинхронизацией данных (если не полениться прописать методы извещающие слушателей об изменениях).</p><br/>
<p>Ну а если хочется краткости, то тогда уж лучше так:</p><br/>
<pre><code class="java">JList list = new JList(items);</code></pre><br/>
<p>В этом случае Джава сама сделает обертку-адаптер вместо копирования. </p><br/>
<blockquote><strong>Типичные ошибки: копирование доменных данных в модели GUI-компонент</strong></blockquote><p> <br/>
Ну и наконец мы может развеять главный миф, являющийся источником наибольшего количества проблем и ошибок.</p><br/>
<blockquote><strong>Мифы: Модель в «MVC схеме» тождественна доменной модели и данным</strong></blockquote><p>Путаница возникает из-за того что одно и то же слово «Модель» используется в разных контекстах. Когда речь идет о декомпозиции и отделении <em>бизнес-логики</em> от <em>пользовательского интерфейса</em>, то под Моделью действительно понимается именно <strong>доменная модель</strong>, содержащая данные и логику работы с ними и обеспечивающая основной функционал приложения. </p><br/>
<p>Но в контексте шаблонов и схем Модель это прежде всего <strong>интерфейс</strong> и реализующий его <strong>объект-посредник</strong> (фасад, адаптер, прокси) обеспечивающие удобный и безопасный доступ к доменным данным, которые могут находится где угодно. Реенскауг так и писал: "<em>model object with a façade that reflects the user’s mental model</em>". </p><br/>
<p>Когда MVC преподносится исключительно как «схема», то наличие «промежуточных моделей» кажется сложным и запутанным. Появляются вопросы ("Чем эти модели отличаются друг от друга?", “Как их правильно использовать?”), неоднозначные трактовки и множество возможностей сделать ошибку. </p><br/>
<p>Но если понимать заложенные в MVC архитектурные идеи, то все становится предельно ясным: пользовательский интерфейс не имеет права обращаться к объектам доменной модели напрямую. А значит между доменной моделью и пользовательским интерфейсом должнен находиться фасад/посредник/адаптер..., и взаимодействовать пользовательский интерфейс (Вид и Контроллер) может только с ним. Возможностей сделать ошибку – ноль. </p><br/>
<p>И по большому счету становится все равно каким термином этот объект-посредник называется и какая именно Model-View-Whatever разновидность MVC используется… Начинаешь видеть: какая задача решается, с помощью каких шаблонов и то, насколько хорошо или плохо это делается</p><br/>
<p>В принципе на этом статью можно и закончить. Как уже упоминалось деление пользовательского интерфейса на Вид и Контроллер является наименее значимым, даже вспомогательным моментом. Но с другой стороны пользовательский интерфейс присутствует в каждом пользовательском приложении и иметь представление о подходах и идеях наработанных в этой области часто бывает полезно. К тому же именно вокруг Контроллера ведутся основные споры. Поэтому – <a href="https://habrahabr.ru/post/322700/">вторая часть</a>, полностью посвященная именно этой теме.</p></div></div></div> <DIV class="v-portal" style="display:none;"></DIV></div> <!----> <!----></div> <div class="tm-article-presenter__meta"><div class="tm-separated-list tm-article-presenter__meta-list"><span class="tm-separated-list__title">Теги:</span> <ul class="tm-separated-list__list"><li class="tm-separated-list__item"><a href="https://habr.com/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5BMVC%5D" class="tm-tags-list__link">MVC</a></li><li class="tm-separated-list__item"><a href="https://habr.com/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5B%D0%B0%D1%80%D1%85%D0%B8%D1%82%D0%B5%D0%BA%D1%82%D1%83%D1%80%D0%B0%20%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D0%B9%5D" class="tm-tags-list__link">архитектура приложений</a></li></ul></div> <div class="tm-separated-list tm-article-presenter__meta-list"><span class="tm-separated-list__title">Хабы:</span> <ul class="tm-separated-list__list"><li class="tm-separated-list__item"><a href="https://habr.com/ru/hub/analysis_design/" class="tm-hubs-list__link">
    Анализ и проектирование систем
  </a></li><li class="tm-separated-list__item"><a href="https://habr.com/ru/hub/refactoring/" class="tm-hubs-list__link">
    Проектирование и рефакторинг
  </a></li></ul></div></div></article></div> <!----></div> <div class="tm-article-sticky-panel"><div class="tm-data-icons tm-article-sticky-panel__icons"><div class="tm-article-rating tm-data-icons__item"><div class="tm-votes-meter tm-article-rating__votes-switcher"><svg height="24" width="24" class="tm-svg-img tm-votes-meter__icon tm-votes-meter__icon_appearance-article"><title>Всего голосов 73: ↑71 и ↓2</title> <use xlink:href="/img/megazord-v25.4b679db1.svg#counter-rating"></use></svg> <span title="Всего голосов 73: ↑71 и ↓2" class="tm-votes-meter__value tm-votes-meter__value_positive tm-votes-meter__value_appearance-article tm-votes-meter__value_rating">+69</span></div> <DIV class="v-portal" style="display:none;"></DIV></div> <!----> <span title="Количество просмотров" class="tm-icon-counter tm-data-icons__item"><svg height="24" width="24" class="tm-svg-img tm-icon-counter__icon"><title>Просмотры</title> <use xlink:href="/img/megazord-v25.4b679db1.svg#counter-views"></use></svg> <span class="tm-icon-counter__value">114K</span></span> <button title="Добавить в закладки" type="button" class="bookmarks-button tm-data-icons__item"><span title="Добавить в закладки" class="tm-svg-icon__wrapper bookmarks-button__icon"><svg height="24" width="24" class="tm-svg-img tm-svg-icon"><title>Добавить в закладки</title> <use xlink:href="/img/megazord-v25.4b679db1.svg#counter-favorite"></use></svg></span> <span title="Количество пользователей, добавивших публикацию в закладки" class="bookmarks-button__counter">
    703
  </span></button> <!----> <div title="Поделиться" class="tm-sharing tm-data-icons__item"><button type="button" class="tm-sharing__button"><svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" class="tm-sharing__icon"><path fill="currentColor" d="M13.8 13.8V18l7.2-6.6L13.8 5v3.9C5 8.9 3 18.6 3 18.6c2.5-4.4 6-4.8 10.8-4.8z"></path></svg></button> <DIV class="v-portal" style="display:none;"></DIV></div> <DIV class="v-portal" style="display:none;"></DIV></div> </div></div> <DIV class="v-portal" style="display:none;"></DIV> <div class="tm-article-presenter__footer"><div class="tm-article-blocks"><!----> <section class="tm-block tm-block_spacing-bottom"><!----> <div class="tm-block__body tm-block__body_variant-balanced"><div class="tm-article-author"> <div class="tm-user-card tm-article-author__user-card tm-user-card_variant-article"><div class="tm-user-card__info-container"><div class="tm-user-card__header"><div class="tm-user-card__header-data"><a href="https://habr.com/ru/users/cobiot/" class="tm-user-card__userpic tm-user-card__userpic_size-40"><div class="tm-entity-image"><svg class="tm-svg-img tm-image-placeholder tm-image-placeholder_blue"><!----> <use xlink:href="/img/megazord-v25.4b679db1.svg#placeholder-user"></use></svg></div></a> <div class="tm-user-card__meta"><div title=" 105 голосов " class="tm-karma tm-user-card__karma"><div class="tm-karma__votes tm-karma__votes_positive">
    97
  </div> <div class="tm-karma__text">
    Карма
  </div></div> <div title="Рейтинг пользователя" class="tm-rating tm-user-card__rating"><div class="tm-rating__header"> <div class="tm-rating__counter">0</div></div> <div class="tm-rating__text">
    Рейтинг
  </div></div></div></div></div> <div class="tm-user-card__info tm-user-card__info_variant-article"><div class="tm-user-card__title tm-user-card__title_variant-article"><!----> <a href="https://habr.com/ru/users/cobiot/" class="tm-user-card__nickname tm-user-card__nickname_variant-article">
          @cobiot
        </a> <!----></div> <p class="tm-user-card__short-info tm-user-card__short-info_variant-article">Пользователь</p></div></div> <div class="tm-user-card__buttons tm-user-card__buttons_variant-article"><!----> <!----> <!----> <!----> <!----></div></div> <!----></div> <DIV class="v-portal" style="display:none;"></DIV></div> <!----></section> <div class="tm-article-blocks__comments"><div class="tm-article-page-comments"><div class="tm-article-comments-counter-link tm-article-comments-counter-button"><a href="https://habr.com/ru/post/321050/comments/" class="tm-article-comments-counter-link__link tm-article-comments-counter-link__link_button-style"><svg height="24" width="24" class="tm-svg-img tm-article-comments-counter-link__icon tm-article-comments-counter-link__icon_contrasted"><title>Комментарии</title> <use xlink:href="/img/megazord-v25.4b679db1.svg#counter-comments"></use></svg> <span class="tm-article-comments-counter-link__value tm-article-comments-counter-link__value_contrasted">
       Комментарии 387 
    </span></a> <!----></div></div></div> <div class="tm-ad-banner__container tm-page-article__banner"><!----> <div id="articleBottomBanner4746" class="tm-ad-banner"></div></div> <!----> <!----> <!----> <!----> </div></div></div></div></div> <div class="tm-page__sidebar"><div class="tm-layout-sidebar"><div class="tm-layout-sidebar__ads tm-layout-sidebar__ads_initial"><div class="tm-ad-banner__container tm-layout-sidebar__banner"><!----> <div id="sidebarBanner4747" class="tm-ad-banner"></div></div></div> <div class="tm-sexy-sidebar tm-sexy-sidebar_initial" style="margin-top:0px;"><!----> <section data-async-called="true" class="tm-block tm-block_spacing-bottom"><header class="tm-block__header"><h2 class="tm-block__title">Работа</h2> <!----></header> <div class="tm-block__body"><div class="tm-vacancies-block__item"><a href="https://career.habr.com/vacancies/sistemnij_analitik" target="_blank" class="tm-vacancies-block__vacancy-title">
        Cистемный аналитик
      </a> <div class="tm-vacancies-block__vacancies-count">
        415
    вакансий
      </div></div></div> <footer class="tm-block__footer"><a href="https://career.habr.com/catalog" class="tm-block-extralink">
      Все вакансии
    </a></footer></section></div></div></div></div></div></div></main> <!----></div> <div class="tm-footer-menu"><div class="tm-page-width"><div class="tm-footer-menu__container"><div class="tm-footer-menu__block"><h3 class="tm-footer-menu__block-title">
          Ваш аккаунт
        </h3> <div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><li class="tm-footer-menu__list-item"><a href="https://habr.com/kek/v1/auth/habrahabr/?back=/ru/post/321050/&amp;hl=ru" rel="nofollow" target="_self">
                Войти
              </a></li><li class="tm-footer-menu__list-item"><a href="https://habr.com/kek/v1/auth/habrahabr-register/?back=/ru/post/321050/&amp;hl=ru" rel="nofollow" target="_self">
                Регистрация
              </a></li></ul></div></div><div class="tm-footer-menu__block"><h3 class="tm-footer-menu__block-title">
          Разделы
        </h3> <div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><li class="tm-footer-menu__list-item"><a href="https://habr.com/ru/" class="footer-menu__item-link router-link-active">
                Публикации
              </a></li><li class="tm-footer-menu__list-item"><a href="https://habr.com/ru/news/" class="footer-menu__item-link">
                Новости
              </a></li><li class="tm-footer-menu__list-item"><a href="https://habr.com/ru/hubs/" class="footer-menu__item-link">
                Хабы
              </a></li><li class="tm-footer-menu__list-item"><a href="https://habr.com/ru/companies/" class="footer-menu__item-link">
                Компании
              </a></li><li class="tm-footer-menu__list-item"><a href="https://habr.com/ru/users/" class="footer-menu__item-link">
                Авторы
              </a></li><li class="tm-footer-menu__list-item"><a href="https://habr.com/ru/sandbox/" class="footer-menu__item-link">
                Песочница
              </a></li></ul></div></div><div class="tm-footer-menu__block"><h3 class="tm-footer-menu__block-title">
          Информация
        </h3> <div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><li class="tm-footer-menu__list-item"><a href="https://habr.com/ru/docs/help/" class="footer-menu__item-link">
                Устройство сайта
              </a></li><li class="tm-footer-menu__list-item"><a href="https://habr.com/ru/docs/authors/codex/" class="footer-menu__item-link">
                Для авторов
              </a></li><li class="tm-footer-menu__list-item"><a href="https://habr.com/ru/docs/companies/corpblogs/" class="footer-menu__item-link">
                Для компаний
              </a></li><li class="tm-footer-menu__list-item"><a href="https://habr.com/ru/docs/docs/transparency/" class="footer-menu__item-link">
                Документы
              </a></li><li class="tm-footer-menu__list-item"><a href="https://account.habr.com/info/agreement" target="_blank">
                Соглашение
              </a></li><li class="tm-footer-menu__list-item"><a href="https://account.habr.com/info/confidential/" target="_blank">
                Конфиденциальность
              </a></li></ul></div></div><div class="tm-footer-menu__block"><h3 class="tm-footer-menu__block-title">
          Услуги
        </h3> <div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><li class="tm-footer-menu__list-item"><a href="https://docs.google.com/presentation/d/e/2PACX-1vQLwRfQmXibiUlWaRg-BAc38s7oM3lJiaPju7qmdJsp8ysIvZ_G-Npem0njJLMozE2bPHMpDqiI5hhy/pub?start=false&amp;loop=false&amp;delayms=60000&amp;slide=id.g91a03369cd_4_297" target="_blank">
                Реклама
              </a></li><li class="tm-footer-menu__list-item"><a href="https://habrastorage.org/storage/stuff/habr/service_price.pdf" target="_blank">
                Тарифы
              </a></li><li class="tm-footer-menu__list-item"><a href="https://docs.google.com/presentation/d/e/2PACX-1vQJJds8-Di7BQSP_guHxICN7woVYoN5NP_22ra-BIo4bqnTT9FR6fB-Ku2P0AoRpX0Ds-LRkDeAoD8F/pub?start=false&amp;loop=false&amp;delayms=60000" target="_blank">
                Контент
              </a></li><li class="tm-footer-menu__list-item"><a href="https://tmtm.timepad.ru/" target="_blank">
                Семинары
              </a></li><li class="tm-footer-menu__list-item"><a href="https://habr.com/ru/megaprojects/" class="footer-menu__item-link">
                Мегапроекты
              </a></li></ul></div></div></div></div></div> <div class="tm-footer"><div class="tm-page-width"><div class="tm-footer__container"><!----> <div class="tm-footer__social"><a href="https://www.facebook.com/habrahabr.ru" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Facebook</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-facebook"></use></svg></a><a href="https://twitter.com/habr_com" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Twitter</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-twitter"></use></svg></a><a href="https://vk.com/habr" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>VK</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-vkontakte"></use></svg></a><a href="https://telegram.me/habr_com" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Telegram</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-telegram"></use></svg></a><a href="https://www.youtube.com/channel/UCd_sTwKqVrweTt4oAKY5y4w" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Youtube</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-youtube"></use></svg></a><a href="https://zen.yandex.ru/habr" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Яндекс Дзен</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-zen"></use></svg></a></div> <DIV class="v-portal" style="display:none;"></DIV> <button class="tm-footer__link"><!---->
        Настройка языка
      </button> <a href="https://habr.com/ru/about" class="tm-footer__link">
        О сайте
      </a> <a href="https://habr.com/ru/feedback/" class="tm-footer__link">
        Техническая поддержка
      </a> <!----> <a href="https://habr.com/berserk-mode-nope" class="tm-footer__link">
        Вернуться на старую версию
      </a> <div class="tm-footer-copyright"><span class="tm-copyright"><span class="tm-copyright__years">© 2006–2022 </span> <span class="tm-copyright__name">«<a href="https://company.habr.com/" rel="noopener" target="_blank" class="tm-copyright__link">Habr</a>»</span></span></div></div></div></div> <!----> <!----></div> <div class="vue-portal-target"></div></div>
<script>window.__INITIAL_STATE__={"adblock":{"hasAcceptableAdsFilter":false,"hasAdblock":false},"articlesList":{"articlesList":{"321050":{"id":"321050","timePublished":"2017-02-07T01:48:41+00:00","isCorporative":false,"lang":"ru","titleHtml":"Охота на мифический MVC. Обзор, возвращение к первоисточникам и про то, как анализировать и выводить шаблоны самому","leadData":{"textHtml":"\u003Cblockquote\u003E\u003Cem\u003E— Не понимаю, почему люди так восхищаются этим Карузо? Косноязычен, гугнив, поёт — ничего не разберешь!\u003C\u002Fem\u003E\u003Cbr\u002F\u003E\r\n\u003Cem\u003E— А вы слышали, как поёт Карузо?\u003C\u002Fem\u003E\u003Cbr\u002F\u003E\r\n\u003Cem\u003E— Да, мне тут кое-что из его репертуара Рабинович напел по телефону.\u003C\u002Fem\u003E\u003C\u002Fblockquote\u003E\u003Cbr\u002F\u003E\r\n\u003Ch2 id=\"detektiv-po-materialam-it-chast-pervaya\"\u003EДетектив по материалам IT. Часть первая\u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EЯ осознаю, что писать очередную статью на тему Модель-Вид-Контроллер это глупо и вредно для «кармы». Однако с этим «паттерном» у меня слишком личные отношения – проваленный проект, полгода жизни и тяжелой работы «в корзину». \u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EПроект мы переписали, уже без MVC, просто руководствуясь принципами – код перестал быть похож на клубок спагетти и сократился наполовину (об этом позже, в обещанной статье про то, как мы применяли «принципы» в своем проекте). Но хотелось понять, что же мы сделали не так, в чем была ошибка? И в течении долгого времени изучалось все, что содержало аббревиатуру MVC. До тех пор пока не встретились исходные работы от создателя – Трюгве Реенскауга… \u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EИ тогда все встало на свои места. Оказалось что фактически на основе принципов мы пере-изобретали «original MVC». А то, что зачастую преподносится как MVC, не имеет к нему никакого отношения… впрочем также как и к хорошей архитектуре. И судя по тому сколько людей пишет о несостоятельности «классического MVC», спорит о нем и изобретает его всевозможные модификации, не одни мы столкнулись с этой проблемой.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EБолее 30 лет собранные в MVC идеи и решения остаются наиболее значимыми для разработки пользовательских интерфейсов. Но как ни странно, несмотря на существующую путаницу и обилие противоречивых трактовок, разработчики продолжают довольствоваться информацией «из вторых рук», черпая знания о MVC из википедии, небольших статей в интернете и фреймворков для разработки веб-приложений. Самые «продвинутые» читают Мартина Фаулера. И почему-то почти никто не обращается к первоисточникам. Вот этот пробел и хотелось бы заполнить. И заодно развеять некоторые мифы.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n","imageUrl":null,"buttonTextHtml":"Читать дальше &rarr;","image":null},"editorVersion":"1.0","postType":"article","postLabels":[],"author":{"scoreStats":{"score":97,"votesCount":105},"rating":0,"relatedData":null,"contacts":[],"authorContacts":[],"paymentDetails":{"paymentYandexMoney":null,"paymentPayPalMe":null,"paymentWebmoney":null},"id":"1160794","alias":"cobiot","fullname":null,"avatarUrl":null,"speciality":null},"statistics":{"commentsCount":387,"favoritesCount":703,"readingCount":113873,"score":69,"votesCount":73},"hubs":[{"relatedData":null,"id":"397","alias":"analysis_design","type":"collective","title":"Анализ и проектирование систем","titleHtml":"Анализ и проектирование систем","isProfiled":true},{"relatedData":null,"id":"7504","alias":"refactoring","type":"collective","title":"Проектирование и рефакторинг","titleHtml":"Проектирование и рефакторинг","isProfiled":true}],"flows":[{"id":"1","alias":"develop","title":"Разработка"}],"relatedData":null,"textHtml":"\u003Cdiv xmlns=\"http:\u002F\u002Fwww.w3.org\u002F1999\u002Fxhtml\"\u003E\u003Cblockquote\u003E\u003Cem\u003E— Не понимаю, почему люди так восхищаются этим Карузо? Косноязычен, гугнив, поёт — ничего не разберешь!\u003C\u002Fem\u003E\u003Cbr\u002F\u003E\r\n\u003Cem\u003E— А вы слышали, как поёт Карузо?\u003C\u002Fem\u003E\u003Cbr\u002F\u003E\r\n\u003Cem\u003E— Да, мне тут кое-что из его репертуара Рабинович напел по телефону.\u003C\u002Fem\u003E\u003C\u002Fblockquote\u003E\u003Cbr\u002F\u003E\r\n\u003Ch2 id=\"detektiv-po-materialam-it-chast-pervaya\"\u003EДетектив по материалам IT. Часть первая\u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EЯ осознаю, что писать очередную статью на тему Модель-Вид-Контроллер это глупо и вредно для «кармы». Однако с этим «паттерном» у меня слишком личные отношения – проваленный проект, полгода жизни и тяжелой работы «в корзину». \u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EПроект мы переписали, уже без MVC, просто руководствуясь принципами – код перестал быть похож на клубок спагетти и сократился наполовину (об этом позже, в обещанной статье про то, как мы применяли «принципы» в своем проекте). Но хотелось понять, что же мы сделали не так, в чем была ошибка? И в течении долгого времени изучалось все, что содержало аббревиатуру MVC. До тех пор пока не встретились исходные работы от создателя – Трюгве Реенскауга… \u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EИ тогда все встало на свои места. Оказалось что фактически на основе принципов мы пере-изобретали «original MVC». А то, что зачастую преподносится как MVC, не имеет к нему никакого отношения… впрочем также как и к хорошей архитектуре. И судя по тому сколько людей пишет о несостоятельности «классического MVC», спорит о нем и изобретает его всевозможные модификации, не одни мы столкнулись с этой проблемой.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EБолее 30 лет собранные в MVC идеи и решения остаются наиболее значимыми для разработки пользовательских интерфейсов. Но как ни странно, несмотря на существующую путаницу и обилие противоречивых трактовок, разработчики продолжают довольствоваться информацией «из вторых рук», черпая знания о MVC из википедии, небольших статей в интернете и фреймворков для разработки веб-приложений. Самые «продвинутые» читают Мартина Фаулера. И почему-то почти никто не обращается к первоисточникам. Вот этот пробел и хотелось бы заполнить. И заодно развеять некоторые мифы.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Ca name=\"habracut\"\u003E\u003C\u002Fa\u003E\u003Cbr\u002F\u003E\r\n\u003Cblockquote\u003E\u003Cstrong\u003EМифы: MVC создавался для языка SmallTalk\u003C\u002Fstrong\u003E\u003C\u002Fblockquote\u003E\u003Cp\u003EКонцепция MVC была сформулирована Трюгве Реенскаугом (Trygve Reenskaug) в результате его работы в Xerox PARC в 1978\u002F79 годах. Как правило создание MVC связывают с языком SmallTalk, но это не совсем так. На самом деле Реенскауг работал в группе, занимавшейся разработкой портативного компьютера \"для детей всех возрастов\" \u003Ca href=\"https:\u002F\u002Fru.wikipedia.org\u002Fwiki\u002FDynabook\"\u003EDynabook\u003C\u002Fa\u003E под руководством Алана Кэя (Alan Kay). \u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EЧтобы оценить масштаб и революционность того проекта, нужно иметь ввиду что это были годы, когда для работы с ЭВМ требовалось штудировать многостраничные мануалы и иметь ученую степень. Задача, которую пытался решить Алан Кэй, состояла в том, чтобы сблизить компьютер и рядового пользователя, «сломать» разделяющую их стену. Он хотел обеспечить пользователя средствами, которые были бы предельно простыми и удобными, но при этом давали бы возможность управлять компьютером и сложными приложениями.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EИменно тогда\u002Fтам закладывались основы графического интерфейса, формировалось понятие \"дружелюбного интерфейса\". А также разрабатывался язык SmallTalk, вместе с концепциями объектно-ориентированного программирования, чтобы неподготовленный пользователь “мог понимать и писать программы”. Вот как описывает увиденное в Xerox PARC в 1979 году Стив Джобс – \u003Ca href=\"https:\u002F\u002Fwww.youtube.com\u002Fwatch?v=J33pVRdxWbw\"\u003EHow Steve Jobs got the ideas of GUI from XEROX\u003C\u002Fa\u003E (from 6.30)\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EПроект велся около 10 лет, группой очень сильных разработчиков. Найденные в результате решения, подходы, принципы и в области пользовательских интерфейсов, и в области объектно ориентированного программирования и вообще в разработке больших и сложных компьютерных систем были в какой-то степени проссумированы Реенскаугом и составили основу MVC. Так что MVC это действительно прежде всего совокупность направляющих архитектурных идей. В SmallTalk-80 эти идеи всего лишь получили свою первую значимую реализацию. Причем сделано это было уже после ухода Реенскауга из Xerox PARC и без его участия. \u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EК сожалению в течении долго времени о «реальном MVC» не было практически никакой доступной информации. Первая серьезная публикация от создателей появилась лишь 10 лет спустя – \"\u003Ca href=\"https:\u002F\u002Fwww.lri.fr\u002F~mbl\u002FENS\u002FFONDIHM\u002F2013\u002Fpapers\u002FKrasner-JOOP88.pdf\"\u003EA Cookbook for Using the Model-View-Controller User Interface Paradigm in Smalltalk-80\u003C\u002Fa\u003E\". Даже Фаулер упоминает, что он изучал MVC по работающей версии SmallTalk – \u003Cem\u003E\"у меня был доступ к работающей версии Smalltalk-80, чтобы я мог изучить MVC. Я не могу сказать, что это исследование было тщательным, но оно позволило мне понять некоторые аспекты решения, которые другие описания объяснить не смогли\"\u003C\u002Fem\u003E. \u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EТак что не удивительно появление «мифов» и разнообразных трактовок. Проблема заключается в том, что многие «вторичные» источники описывают MVC не только в искаженном, но еще и в обманчиво-упрощенном виде, как правило в виде некой формальной схемы. \u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EВ результате многие действительно считают MVC схемой или паттерном (из-за чего постоянно возникает вопрос – какая же из множества существующих схем «правильная» и почему их так много?). В более продвинутом варианте MVC называют \u003Cstrong\u003Eсоставным\u003C\u002Fstrong\u003E паттерном, то есть комбинацией нескольких паттернов, работающих совместно для реализации сложных приложений (тут обычно упоминаются Observer, Strategy и Composite). И лишь немногие понимают, что MVC это прежде всего набор архитектурных идей\u002Fпринципов\u002Fподходов, которые могут быть реализованы различными способами с использованием различных шаблонов...\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EК последним относится в частности Мартин Фаулер. Вот что он пишет: \u003Cem\u003E“MVC часто называют паттерном, но я не вижу особой пользы воспринимать его как паттерн, поскольку он включает в себя множество различных идей. Разные люди читают про MVC в различных источниках и извлекают от туда разные идеи, но называют их одинаково — «MVC». Это приводит к большой путанице и кроме того служит источником недоразумений и непониманию MVC, как будто бы люди узнавали про него через «испорченный телефон»…. Я уже потерял счет сколько раз я видел что-то, описываемое как MVC, которое им не оказывалось.”\u003C\u002Fem\u003E[ GUI Architectures] \u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EРискну предположить, что одна из причин «испорченного телефона» заключается в том, что большинство вторичных источников «за кадром» оставляют самое главное – собственно сами архитектурные идеи, заложенные в MVC его создателями, и те задачи, которые они пытались решить. Как раз все то, что позволяет понять суть MVC и избежать огромного количества подводных камней и ошибок. Поэтому в данной статье я хочу рассказать о том, что обычно остается «за кадром» – MVC с точки зрения заложенных в него архитектурных принципов и идей. Хотя схемы тоже будут. Вернее с них и начнем.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EНо сначала ссылки. Исходный доклад Реенскауга – \"\u003Ca href=\"http:\u002F\u002Ffolk.uio.no\u002Ftrygver\u002F2007\u002FMVC_Originals.pdf\"\u003EThe original MVC reports\u003C\u002Fa\u003E\". Позже Реенскауг все это более четко сформулировал и оформил в своей последующей работе “\u003Ca href=\"http:\u002F\u002Fheim.ifi.uio.no\u002F~trygver\u002F2003\u002Fjavazone-jaoo\u002FMVC_pattern.pdf\"\u003EThe Model-View-Controller (MVC ). \u003C\u002Fa\u003E\u003Ca href=\"http:\u002F\u002Fheim.ifi.uio.no\u002F~trygver\u002F2003\u002Fjavazone-jaoo\u002FMVC_pattern.pdf\"\u003EIts Past and Present\u003C\u002Fa\u003E”. Возможно кому-то будет интересна страница, где собраны записи Ренскауга, относящиеся к тому периоду, с его комментариями -\u003Ca href=\"http:\u002F\u002Fheim.ifi.uio.no\u002F~trygver\u002Fthemes\u002Fmvc\u002Fmvc-index.html\"\u003E MVC \u003C\u002Fa\u003E\u003Ca href=\"http:\u002F\u002Fheim.ifi.uio.no\u002F~trygver\u002Fthemes\u002Fmvc\u002Fmvc-index.html\"\u003EXEROX PARC 1978-79\u003C\u002Fa\u003E. \u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EУже упоминавшаяся первая публикация о MVC в языке SmallTalk-80 от разработчиков только в улучшенном качестве \"\u003Ca href=\"http:\u002F\u002Fwww.create.ucsb.edu\u002F~stp\u002FPostScript\u002Fmvc.pdf\"\u003EA Description of the Model-View-Controller User Interface Paradigm in the Smalltalk-80 System\u003C\u002Fa\u003E\" (Glenn Krasner и Stephen Pope). Хорошим дополнением служит также статья “\u003Ca href=\"http:\u002F\u002Fwww.math.sfedu.ru\u002Fsmalltalk\u002Fgui\u002Fmvc.pdf\"\u003EApplications Programming in Smalltalk-80.\u003C\u002Fa\u003E\u003Ca href=\"http:\u002F\u002Fwww.math.sfedu.ru\u002Fsmalltalk\u002Fgui\u002Fmvc.pdf\"\u003EHow to use Model-View-Controller\u003C\u002Fa\u003E” (автор SteveBurbeck учавствовал в разработке компилятора SmallTalk для IBM на основе Smalltalk-80, а также в разработке MacApp). Ну и если кто-то хочет полного погружения – “\u003Ca href=\"http:\u002F\u002Fstephane.ducasse.free.fr\u002FFreeBooks\u002FTheInteractiveProgrammingEnv\u002FTheInteractiveProgrammingEnv.pdf\"\u003ESmalltalk-80. \u003C\u002Fa\u003E\u003Ca href=\"http:\u002F\u002Fstephane.ducasse.free.fr\u002FFreeBooks\u002FTheInteractiveProgrammingEnv\u002FTheInteractiveProgrammingEnv.pdf\"\u003EThe Interactive Programming Environment\u003C\u002Fa\u003E” от знаменитой Адель Голдберг в дискуссиях с которой Реенскаугом и создавались термины Model, View, Controller.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Ch2\u003EСхемы MVC\u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EДля того, чтобы стало понятно, о чем идет речь и в чем заключается проблема, давайте вначале все же разберем наиболее типичные «схемы» MVC. Это важно, поскольку часто к схемам не дается никаких пояснений и к тому-же бывает, что определения заимствуются из одного места, а схемы из другого. В результате можно встретить одинаковые описания MVC с совершенно разными диаграммами, что очень запутывает. \u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EИтак, несмотря на то, что MVC трактуется и изображается очень по разному, во всем этом многообразии все же можно выделить общее «ядро». Общим является то, что везде говорится о неких трех частях — Модели, Виде и Контроллере, которые связаны между собой определенным образом, а именно:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Col\u003E\r\n\u003Cli\u003E\u003Cp\u003EМодель ничего не знает ни о Виде, ни о Контроллере, что делает возможным ее разработку и тестирование как независимого компонента. И это является главным моментом MVC. \u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Cp\u003EВид отображает Модель. И значит, он каким-то образом должен получать из нее нужные для отображения данные. Наиболее распространены следующие два варианта: 1) \u003Cstrong\u003EАктивный Вид\u003C\u002Fstrong\u003E, который знает о Модели и сам берет из нее нужные данные. 2) \u003Ca href=\"http:\u002F\u002Fmartinfowler.com\u002FeaaDev\u002FPassiveScreen.html\"\u003EПассивный Вид\u003C\u002Fa\u003E, которому данные поставляет Контроллер. В этом случае Вид с Моделью никак не связан. \u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EВидов может быть несколько — они могут по разному отображать одни и те же данные, например в виде таблицы или графика, или же отвечать за отображение разных частей данных из Модели. \u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003C\u002Fli\u003E\r\n\u003Cli\u003EКонтроллер является пожалуй самым неоднозначным компонентом. Тем не менее общим является то, что Контроллер всегда знает о Модели и может ее изменять (как правило в результате действий пользователя). \u003C\u002Fli\u003E\r\n\u003C\u002Fol\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EА также он может осуществлять управление Видом\u002FВидами (особенно если их несколько) и соответственно знать о Видах, но это не обязательно. \u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EОтсюда мы получаем базовые (максимально упрощенные) схемы двух наиболее часто встречающихся разновидностей MVC. Перечеркнутой линией обозначена необязательная связь Контроллера с Видом. \u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw1560\u002Ffiles\u002F0ad\u002F9c6\u002Fcfe\u002F0ad9c6cfeef04168a2fc0a73b8c32939.png\" alt=\"Model View Controller\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Ffiles\u002F0ad\u002F9c6\u002Fcfe\u002F0ad9c6cfeef04168a2fc0a73b8c32939.png\"\u002F\u003E\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003E\u003Cem\u003EВот так базовая схема выглядит у Фаулера: \"Основные связи между Моделью, Видом и Контроллером. (Я называю их основными, потому что на самом деле Вид и Контроллер могут быть связанными друг с другом непосредственно. Однако, разработчики в основном не используют эту связь.)\":\u003C\u002Fem\u003E\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw1560\u002Ffiles\u002F96c\u002F25b\u002Ffc9\u002F96c25bfc96cb495798a82efaced23a04.gif\" alt=\"Model View Controller\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Ffiles\u002F96c\u002F25b\u002Ffc9\u002F96c25bfc96cb495798a82efaced23a04.gif\"\u002F\u003E\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EДалее. Модель, как и Вид, тоже может быть Пассивной либо Активной. \u003Cstrong\u003EПассивная Модель\u003C\u002Fstrong\u003E никак не воздействует ни на Вид ни на Контроллер. В этом случае все изменения Модели отслеживаются Контроллером и он же отвечает за перерисовку Вида, когда это необходимо. \u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EНо обычно, под MVC все таки подразумевают вариант с \u003Cstrong\u003EАктивной Моделью\u003C\u002Fstrong\u003E. \u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003E«Активная Модель» \u003Cstrong\u003Eоповещает\u003C\u002Fstrong\u003E о том, что в ней произошли изменения. И делает она это посредством шаблона \u003Cem\u003EНаблюдатель\u003C\u002Fem\u003E, рассылая уведомления о изменениях всем своим «подписчикам». «Активный Вид» подписывается на эти сообщения сам и таким образом знает когда нужно заново считать из модели нужные ему данные и обновиться. В случае «Пассивного Вида», подписчиком является Контроллер, который затем уже обновляет Вид. \u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EШаблон \u003Cem\u003EНаблюдатель\u003C\u002Fem\u003E позволяет Модели с одной стороны информировать Вид или Контроллер о том что в ней произошли изменения, а с другой фактически ничего о них «не знать» (кроме того что они реализуют некий заданный интерфейс «подписчика») и тем самым оставаться независимой. Это называется \u003Cstrong\u003Eслабым связыванием\u003C\u002Fstrong\u003E и считается вторым ключевым моментом MVC. \u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EИменно поэтому, когда говорится, что MVC это составной шаблон, то в первую очередь в качестве одного из его компонентов упоминается паттерн \u003Cem\u003EНаблюдатель\u003C\u002Fem\u003E. На диаграммах слабое связывание принято рисовать пунктирной стрелкой, но многие это правило игнорируют.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EТаким образом, более продвинутые «схемы MVC» будут выглядеть так:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw1560\u002Ffiles\u002F91c\u002F952\u002F6c6\u002F91c9526c60fc467598d74317197e3ad1.png\" alt=\"Model View Controller\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Ffiles\u002F91c\u002F952\u002F6c6\u002F91c9526c60fc467598d74317197e3ad1.png\"\u002F\u003E\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003E\u003Cstrong\u003E\u003Cem\u003EЗамечание:\u003C\u002Fem\u003E\u003C\u002Fstrong\u003E \u003Cem\u003Eвстречаются авторы, которые в термины Пассивная и Активная модель вкладывают совсем иной смысл. А именно то, что обычно принято называть Тонкой моделью (модель содержащая исключительно данные) и Толстой моделью (полноценная модель содержащая всю бизнес логику приложения).\u003C\u002Fem\u003E\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EНу и последнее. Вообще говоря MVC, в любой своей разновидности, это прежде всего шаблон для разработки приложений с пользовательским интерфейсом и его главное назначение – обеспечить взаимодействие приложения с пользователем. Поэтому в полноценной MVC схеме (явно или неявно) должен присутствовать \u003Cstrong\u003Eпользователь\u003C\u002Fstrong\u003E. И тут в основном встречаются две трактовки:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Col\u003E\r\n\u003Cli\u003E\u003Cp\u003EПользователь управляет приложением через Контроллер, а Вид служит исключительно для отображения информации о Модели, и пользователь его лишь видит\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw1560\u002Ffiles\u002F0be\u002Fae1\u002Ffe0\u002F0beae1fe0b98446cad4d399bce29908f.png\" alt=\"Model View Controller\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Ffiles\u002F0be\u002Fae1\u002Ffe0\u002F0beae1fe0b98446cad4d399bce29908f.png\"\u002F\u003E\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003E\u003Cem\u003EЧасто указывают\u002Fрисуют лишь то, что пользователь действует на Контроллер, а то что он видит Вид опускается\u003C\u002Fem\u003E.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Cp\u003EПользователь взаимодействует только с Видом. То есть Вид не только отражает Модель, но также принимает команды пользователя и передает их Контроллеру. В этом случае между Видом и Контроллером образуется еще одна связь: прямая (Вид знает о Контроллере и напрямую передает информацию) или, чаще всего, ослабленная (Вид просто рассылает информацию о действиях пользователя всем заинтересованным подписчикам а Контроллер на эту рассылку подписывается) \u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw1560\u002Ffiles\u002F09e\u002F595\u002F6a8\u002F09e5956a8a6a4c9697150a31cb1ac6ab.png\" alt=\"Model View Controller\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Ffiles\u002F09e\u002F595\u002F6a8\u002F09e5956a8a6a4c9697150a31cb1ac6ab.png\"\u002F\u003E\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003C\u002Fli\u003E\r\n\u003C\u002Fol\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003E\u003Cem\u003E\u003Cstrong\u003EЗамечание:\u003C\u002Fstrong\u003E нужно иметь ввиду, что вариант с \u003Cstrong\u003EПассивным Видом\u003C\u002Fstrong\u003E, когда Вид никак не связан с Моделью и данные для отображения ему поставляет Контроллер, иногда называют MVC, а иногда выделяют в отдельную разновидность — MVP и тогда Контроллер переименовывают в \u003Cstrong\u003EПрезентер\u003C\u002Fstrong\u003E.\u003C\u002Fem\u003E\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EДля иллюстрации всего вышесказанного несколько диаграмм «из интернета» (надеюсь стало понятнее почему они такие разные): \u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw1560\u002Ffiles\u002Fb5c\u002F6bf\u002F3b9\u002Fb5c6bf3b990c48b3b0ba0fa7ddbfd119.png\" alt=\"Model View Controller\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Ffiles\u002Fb5c\u002F6bf\u002F3b9\u002Fb5c6bf3b990c48b3b0ba0fa7ddbfd119.png\"\u002F\u003E\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EА теперь самое главное — как применяются, что обозначают и чему соответствует Модель Вид и Контроллер при написании приложений?\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EТут можно выделить два кардинально отличающихся подхода, в каждом из которых Модель, Вид и Контроллер трактуются весьма различным образом. \u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Ch2\u003E«Трехуровневый MVC» от веб\u003C\u002Fh2\u003E \u003Cbr\u002F\u003E\r\n\u003Cp\u003EПервый подход идет из веб-программирования, где MVC получил самое широкое распространение, и поэтому в нем максимально отразились свойственные веб-программированию черты. А именно, привязка к трехуровневой архитектуре «клиент–сервер–база данных» и преобладание скриптовых языков. В результате компоненты MVC формально привязываются к трем слоям архитектуры и получается что:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Col\u003E\r\n\u003Cli\u003E\u003Cp\u003E\u003Cstrong\u003EМодель = База Данных\u003C\u002Fstrong\u003E\u003Cbr\u002F\u003E\r\nМодель — это просто данные, которыми оперирует приложение \u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Cp\u003E\u003Cstrong\u003EКонтроллер = Сервер\u003C\u002Fstrong\u003E\u003Cbr\u002F\u003E\r\nКонтроллер — это бизнес-логика приложения. Иногда еще говорят что контроллер это центр обработки всех запросов и принятия решений, а также промежуточный слой обеспечивающий связь модели и представления.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Cstrong\u003EВид = Клиент\u003C\u002Fstrong\u003E (как правило тонкий)\u003Cbr\u002F\u003E\r\nВид — это пользовательский интерфейс. Причем интерфейс в этом случае, как правило, понимается в основном исключительно как «дизайн», просто набор графических элементов. Логика же работы этого интерфейса, как и логика работы с данными, выносится в Контроллер\u003C\u002Fli\u003E\r\n\u003C\u002Fol\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw1560\u002Ffiles\u002F1ed\u002Ff60\u002F74f\u002F1edf6074f07940db9b303403c601a610.png\" alt=\"image alt text\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Ffiles\u002F1ed\u002Ff60\u002F74f\u002F1edf6074f07940db9b303403c601a610.png\"\u002F\u003E \u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EПро неадекватность этого подхода написано уже так много, что это вошло даже в википедию (\u003Ca href=\"https:\u002F\u002Fru.wikipedia.org\u002Fwiki\u002FModel-View-Controller#.D0.9D.D0.B0.D0.B8.D0.B1.D0.BE.D0.BB.D0.B5.D0.B5_.D1.87.D0.B0.D1.81.D1.82.D1.8B.D0.B5_.D0.BE.D1.88.D0.B8.D0.B1.D0.BA.D0.B8\"\u003EMVC. Наиболее частые ошибки\u003C\u002Fa\u003E). Хорошо и подробно возникающие при этом проблемы рассматриваются в статье, ставшей своего рода классикой \"\u003Ca href=\"http:\u002F\u002Fhabrahabr.ru\u002Fpost\u002F175465\u002F\"\u003EM в MVC: почему модели непоняты и недооценены\u003C\u002Fa\u003E\". Поэтому постараюсь просто кратко просуммировать:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Col\u003E\r\n\u003Cli\u003E\u003Cp\u003EНезависимость Модели является главным в MVC. Если Модель тонкая, то есть содержит лишь данные, то возможность ее независимой разработки имеет мало смысла. Соответственно при таком подходе теряет смысл и сам MVC \u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Cp\u003EВся бизнес логика приложения, то есть большая часть кода, сосредотачивается в Контроллере и это при том что как раз Контроллер является самой зависимой частью в MVC – в общем случае он зависит и от Модели и от Вида. Вообще говоря в хорошо спроектированных приложениях стараются делать с точностью до наоборот – наиболее зависимые части должны быть минимальными, а не максимальными \u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Cp\u003EНа практике Контроллеру в веб-приложении обычно соответствует один скрипт и вынесение всей бизнес-логики в Контроллер фактически означает еще и то, что большая часть приложения оказывается в одном скрипте. Отсюда и появился термин ТТУК — толстый тупой уродливый контроллер \u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003C\u002Fli\u003E\r\n\u003Cli\u003EПоскольку, как правило, тонкой является не только Модель но также и Вид (тупой Вид или тупой интерфейс — Dumb GUI, Dumb View), то, как следствие, в Контроллер помимо всей бизнес-логики приложения помещается также еще и логика управления пользовательским интерфейсом. То есть, вместо разделения бизнес логики и логики представления при таком подходе получается их смешение. \u003C\u002Fli\u003E\r\n\u003C\u002Fol\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw1560\u002Ffiles\u002Fb94\u002F39e\u002F467\u002Fb9439e467c0a4f53969685ca8f35a824.png\" alt=\"web MVC\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Ffiles\u002Fb94\u002F39e\u002F467\u002Fb9439e467c0a4f53969685ca8f35a824.png\"\u002F\u003E\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EПрограмма, конечно, разбивается на множество MVC, соответствующих страницам веб-приложения, и это спасает ситуацию но, увы, не меняет сути. Проблема эта известна, вот неплохая статья — \"\u003Ca href=\"http:\u002F\u002Ftutorials.jenkov.com\u002Fsoftware-architecture\u002Fria-architecture.html\"\u003ERIA Architecture\u003C\u002Fa\u003E\". \u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cblockquote\u003E\u003Cstrong\u003EТипичные ошибки: смешение в Контроллере бизнесс-логики и GUI-логики\u003C\u002Fstrong\u003E\u003C\u002Fblockquote\u003E\u003Cp\u003EХорошая новость заключается в том, что «веб-вариант MVC», всего несколько лет назад бывший самым распространенным, сейчас активно сдает позиции. Плохо то, что он по прежнему распространен, только теперь не в явном, а в замаскированном виде. Поскольку за фразы (цитирую): \"\u003Cem\u003EМодель это обмен данными с БД\u003C\u002Fem\u003E и т.п. \u003Cem\u003EКонтроллер логика обработки этих данных и подготовка к View\u003C\u002Fem\u003E\" сейчас активно «минусуют», то стали писать:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cul\u003E\r\n\u003Cli\u003EМодель — это данные и методы работы с ними \u003C\u002Fli\u003E\r\n\u003Cli\u003EКонтроллер — обработка действий пользователя и вводимой им информации \u003C\u002Fli\u003E\r\n\u003C\u002Ful\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EДело в том, что в объектно-ориентированном приложении нет данных, а есть множество объектов и каждый из них содержит какие-то данные и методы работы с ними. В том числе и объекы доступа к базе данных (если они имеются). Поэтому когда определение Модели начинается со слова «данные», то оно в сущности имеет мало смысла и нередко в завуалированной форме подразумевает все тот же самый доступ к базе данных. В \u003Cstrong\u003Eобработку\u003C\u002Fstrong\u003E же \u003Cstrong\u003Eдействий пользователя\u003C\u002Fstrong\u003E нередко помещается львиная доля бизнес логики и в результате по прежнему вся, или почти вся, логика приложения часто оказывается в Контроллере.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Ch2\u003E«Архитектурный MVC»\u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EВторой подход гораздо ближе к первоисточникам. Поэтому разберем его подробнее.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EМартин Фаулер абсолютно прав, когда говорит что MVC это не паттерн, а набор архитектурных принципов и идей, используемых при построении пользовательских информационных систем (как правило сложных).\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EАрхитектурные принципы мы постарались собрать и описать в статье \"\u003Ca href=\"https:\u002F\u002Fhabrahabr.ru\u002Fpost\u002F276593\u002F\"\u003EСоздание архитектуры программы или как проектировать табуретку\u003C\u002Fa\u003E\". Если же говорить предельно кратко, то суть состоит в следующем: сложную систему нужно разбивать на модули. Причем декомпозицию желательно делать \u003Cstrong\u003Eиерархически\u003C\u002Fstrong\u003E, а модули, на которые разбивается система, должны быть, по возможности, независимы или \u003Cstrong\u003Eслабо связаны\u003C\u002Fstrong\u003E (\u003Cstrong\u003ELow coupling\u003C\u002Fstrong\u003E). Чем слабее связанность, тем легче писать\u002Fпонимать\u002Fрасширять\u002Fчинить программу. Поэтому одной из основных задач при декомпозиции является минимизация и ослабление связей между компонентами.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EДавайте посмотрим, как эти принципы применяются в MVC для создания первичной архитектуры (декомпозиции) пользовательских приложений. По сути в основе MVC лежат три довольно простые идеи:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003E\u003Cstrong\u003E«1» Отделение модели предметной области (бизнес логики) приложения от пользовательского интерфейса\u003C\u002Fstrong\u003E \u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EПервая и основная идея MVC заключается в том, что любое пользовательское приложение в первом приближении можно разделить на два модуля — один из которых обеспечивает основной функционал приложения, его бизнес логику, а второй отвечает за взаимодействие с пользователем: \u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw1560\u002Ffiles\u002F0bd\u002F003\u002F42d\u002F0bd00342d45c4515bd7d09e200a3cf02.png\" alt=\"MVC\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Ffiles\u002F0bd\u002F003\u002F42d\u002F0bd00342d45c4515bd7d09e200a3cf02.png\"\u002F\u003E\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EТем самым мы получаем возможность разрабатывать \u003Cstrong\u003Eмодель предметной области\u003C\u002Fstrong\u003E, содержащую бизнес-логику системы и составляющую функциональное ядро приложения, не думая о том как именно она будет взаимодействовать с пользователем. \u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EЗадача же взаимодействия с пользователем выносится в отдельный модуль – \u003Cstrong\u003Eпользовательский интерфейс\u003C\u002Fstrong\u003E и тоже может решаться относительно независимо. \u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EИменно модель предметной области (\u003Ca href=\"http:\u002F\u002Fwww.informit.com\u002Farticles\u002Farticle.aspx?p=1398617&amp;seqNum=2\"\u003EДоменная Модель\u003C\u002Fa\u003E от английского \u003Cstrong\u003Edomain model\u003C\u002Fstrong\u003E) считается \u003Cstrong\u003EМоделью\u003C\u002Fstrong\u003E в «архитектурном MVC» (отсюда и термин). Поэтому так важно чтобы она была независимой и могла независимо разрабатываться и тестироваться.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003E\u003Cem\u003E\"Сердцевиной идеей MVC, как и основной идеей для всех последующих каркасов, является то, что я называю «отделенное представление» (\u003Ca href=\"http:\u002F\u002Fwww.martinfowler.com\u002FeaaDev\u002FSeparatedPresentation.html\"\u003ESeparated Presentation\u003C\u002Fa\u003E). Смысл отделенного представления в том, чтобы провести четкую границу между доменными объектами, которые отражают наш реальный мир, и объектами представления, которыми являются GUI-элементы на экране. Доменные объекты должны быть полностью независимы и работать без ссылок на представление, они должны обладать возможностью поддерживать (support) множественные представления, возможно даже одновременно. Этот подход, кстати, так же был одним из важных аспектов Unix-культуры, позволяющий даже сегодня работать во множестве приложений как через командную строку, так и через графический интерфейс (одновременно).\"\u003C\u002Fem\u003E — Фаулер\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003E\u003Cstrong\u003E«2» Независимость Модели и синхронизация пользовательских интерфейсов за счет шаблона \u003Cem\u003EНаблюдатель\u003C\u002Fem\u003E\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EВторая ключевая идея заключается в том, что для того, чтобы иметь возможность разрабатывать Модель \u003Cstrong\u003Eнезависимо\u003C\u002Fstrong\u003E, необходимо ослабить ее зависимость от пользовательского интерфейса. И делается это, как уже упоминалось выше, за счет шаблона \u003Cstrong\u003E\u003Cem\u003EНаблюдатель\u003C\u002Fem\u003E\u003C\u002Fstrong\u003E. \u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EМодель \u003Cstrong\u003Eрассылает извещения об изменениях\u003C\u002Fstrong\u003E. Интерфейс подписывается на эти оповещения и таким образом знает, когда нужно заново считать данные из модели и обновиться. Благодаря этому мы получаем практически \u003Cstrong\u003Eнезависимую Модель\u003C\u002Fstrong\u003E, которая ничего не знает о связанных с ней пользовательских интерфейсах, кроме того что они реализуют интерфейс «наблюдателя».\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003E\u003Cstrong\u003E«3» Разделение Пользовательского Интерфейса на Вид и Контроллер.\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EТретья идея это просто второй шаг иерархической декомпозиции. После первичного разделения приложения на бизнес модель и интерфейс, декомпозиция продолжается на следующем иерархическом уровне и уже пользовательский интерфейс, в свою очередь, делится на Вид и Контроллер.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw1560\u002Ffiles\u002F0d5\u002F00d\u002F0e5\u002F0d500d0e5b35406a9f68022716ba807a.png\" alt=\"MVC\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Ffiles\u002F0d5\u002F00d\u002F0e5\u002F0d500d0e5b35406a9f68022716ba807a.png\"\u002F\u003E\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EУ меня сложилось впечатление, что суть этого деления мало кто понимает и соответственно может объяснить. Обычно приводят лишь стандартную обтекаемую формулировку, что Контроллер как-то реагирует на действия пользователя, а Вид отображает Модель (поэтому в большинстве реализаций именно Вид подписывается на извещения об изменениях Модели. Хотя, как уже говорилось, подписчиком может быть и Контроллер, либо Вид и Контроллер вместе).\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EПоскольку деление пользовательского интерфейса на Вид и Контроллер относится ко \u003Cstrong\u003Eвторому уровню иерархии\u003C\u002Fstrong\u003E, оно гораздо менее значимо чем первичное разделения приложения на доменную модель и интерфейс. Очень часто (особенно когда дело касается простых виджетов) оно вообще не делается и используется «\u003Cstrong\u003Eупрощенный MVC\u003C\u002Fstrong\u003E», в котором имеется только Модель и единый UI-компонент, представляющий собой объединенный ВидКонтроллер. Более подробно об этом речь пойдет чуть позже. \u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003E«Архитектурный MVC» на первый взгляд выглядит вполне разумно. Но как только мы попытаемся применить его не к учебному примеру из трех классов а к реальной программе, то столкнемся с целым рядом проблем и вопросов, о которых редко пишут, но которые чрезвычайно важны. И касаются они не только пользовательского интерфейса, но и самой Модели. Так что предлагаю таки попробовать с ними разобраться и, наконец-то, \"послушать Карузо\", то есть обратиться к первоисточникам.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Ch2\u003E«Original MVC»: Реенскауг и SmallTalk-80\u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EМы привыкли к тому, что MVC почти всегда рассматривается на примере создания какого нибудь простейшего графического компонента, вся «бизнес логика» которого помещается в один класс с данными и парой методов для их изменения. Но что делать, когда речь идет о \u003Cstrong\u003Eреальных\u003C\u002Fstrong\u003E приложениях, ядро которых состоит из многих взаимосвязанных объектов работающих совместно? \u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003E\u003Cstrong\u003EВ общем случае \u003Cem\u003EМодель\u003C\u002Fem\u003E это один объект или множество объектов? И на самом ли деле \u003Cem\u003EМодель\u003C\u002Fem\u003E в «MVC-схеме» тождественна доменной модели, описывающей предметную область и бизнес-логику приложения?\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EТо, что Модель реализует шаблон \u003Cem\u003EНаблюдатель\u003C\u002Fem\u003E явно указывает на то, что Модель это именно один объект. На это же указывает и то, что Вид и Контроллер должны знать о Модели (для того чтобы брать из нее данные и вносить изменения) и следовательно они должны содержать на нее ссылку. Но тогда, если считать, что под Моделью подразумевается доменная модель, мы вновь приходим к тому что все ядро приложения оказывается в одном объекте. Только теперь вместо толстого уродливого Контроллера, у нас появляется толстая Модель. Толстая Модель конечно лучше, поскольку она независима и в ней, по крайней мере, не смешивается бизнес логика с логикой GUI, но все равно такое решение сложно отнести к хорошей архитектуре. \u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EОстается второй вариант — Модель это множество доменных объектов, совместно реализующих бизнес логику. Это предположение подтверждает и сам Реенскауг: \"\u003Cem\u003EA model could be a single object (rather uninteresting), or it could be some structure of objects.\u003C\u002Fem\u003E\" Но тогда остается открытым вопрос – кто реализует шаблон \u003Cem\u003EНаблюдатель\u003C\u002Fem\u003E, откуда берет данные Вид, куда передает команды пользователя Контроллер? \u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EИ вот здесь нередко встречается попытка обмануть самих себя путем примерно следующего рассуждения: \"пусть Модель это множество доменных объектов, но… среди этого множества есть в том числе и «объект с данными», вот он-то и будет реализовывать шаблон Наблюдатель, а также служить источником данных для Вида.\" Эту уловку можно назвать «Модель в Модели». И по сути это еще один «завуалированный» вариант того, что «Модель это данные». \u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EТут можно сказать лишь одно: архитектура, в которой один модуль (Вид или Контроллер), должен «лезть» \u003Cstrong\u003Eвнутрь\u003C\u002Fstrong\u003E другого модуля (доменной модели) и искать там для себя данные или объекты для изменения очень нехорошо «пахнет». Получается что Вид и Контроллер зависят от деталей реализации доменной модели, и если структура этой самой модели изменится, то придется переделывать весь пользовательский интерфейс.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EДля того же, чтобы понять «а как должно быть» предлагаю вновь обратится к «принципам». Когда говорилось о том, что систему надо разбивать на модули, \u003Cstrong\u003Eслабо связанные\u003C\u002Fstrong\u003E друг с другом, мы не упомянули главное правило, позволяющее добится этой самой слабой связанности. А именно – модули друг для друга должны быть «черными ящиками». Ни при каких условиях один модуль не должен обращаться к объектам другого модуля напрямую и что либо знать о его внутренней структуре. Модули должны взаимодействовать друг с другом лишь на уровне абстрактных интерфейсов (Dependency Inversion Principle). А реализует интерфейс модуля как правило специальный объект — \u003Cstrong\u003EФасад\u003C\u002Fstrong\u003E. \u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EИ если поискать какие же паттерны позволяют добится слабой связанности, то на первом месте будет находится именно паттерн \u003Cem\u003EФасад\u003C\u002Fem\u003E, и только затем \u003Cem\u003EНаблюдатель\u003C\u002Fem\u003E и тд. \u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EНу а теперь схема из доклада Трюгве Реенскауга:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw1560\u002Ffiles\u002Fb04\u002Ff6f\u002F022\u002Fb04f6f02268a41b28e317cd2bab38871.png\" alt=\"MVC Reenskaug\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Ffiles\u002Fb04\u002Ff6f\u002F022\u002Fb04f6f02268a41b28e317cd2bab38871.png\"\u002F\u003E\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003E\u003Cstrong\u003E\u003Cem\u003EПояснение:\u003C\u002Fem\u003E\u003C\u002Fstrong\u003E \u003Cem\u003EПоскольку во времена создания MVC интерфейсы компьютерных программ были в основном текстовыми, то есть, по сути представляли собой простейший вид редактора, то вместо термина «Пользовательский Интерфейс», который появился позже, Трюгве Реенскауг использует термин «Editor» (редактор).\u003C\u002Fem\u003E \u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EТаким образом, ключевая идея MVC действительно состоит в том, что пользовательское приложение делится на два модуля – один из которых моделирует предметную область и реализует бизнес логику (\u003Cem\u003Eдоменная модель\u003C\u002Fem\u003E), а второй отвечает за взаимодействие с пользователем (\u003Cem\u003Eпользовательский интерфейс\u003C\u002Fem\u003E). Но при этом \u003Cstrong\u003EМодель\u003C\u002Fstrong\u003E в «MVC схеме» вовсе \u003Cstrong\u003Eне тождественна доменной модели\u003C\u002Fstrong\u003E (которая может быть сколь угодно сложной и состоять из множества объектов), а является всего лишь ее \u003Cstrong\u003Eинтерфейсом\u003C\u002Fstrong\u003E и \u003Cstrong\u003Eфасадом\u003C\u002Fstrong\u003E. \u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EТак что ни Вид ни Контроллер разумеется не должны знать о том, как устроен модуль предметной области (доменная модель), где и в каком формате там храняться данные, и как именно осуществляется управление. Они взаимодействуют лишь с \u003Cstrong\u003Eинтерфейсом\u003C\u002Fstrong\u003E и реализующим его \u003Cstrong\u003Eобъектом-фасадом\u003C\u002Fstrong\u003E, который предоставляет все нужные данные в нужном формате и удобный набор высокоуровневых команд для управления подсистемой, а также реализует шаблон Наблюдатель, для извещения о \u003Cstrong\u003Eзначимых\u003C\u002Fstrong\u003E изменениях в подсистеме. И если мы захотим поменять базу данных, использовать облако, или вообще собирать нужные нам данные из различных источников в сети… если внесем какие угодно изменения в бизнес логику приложения, но при этом оставим неизменным интерфейс-фасад, то ни Вид, ни Контроллер это никак не затронет. Мы имеем архитектуру \u003Cstrong\u003Eустойчивую\u003C\u002Fstrong\u003E к изменениям. \u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EИ если уж рисовать схему MVC, то выглядеть она должна следующим образом:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw1560\u002Ffiles\u002F08f\u002Fa79\u002Fc2b\u002F08fa79c2b3664daead48c60eeaf7ebe3.png\" alt=\"MVC\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Ffiles\u002F08f\u002Fa79\u002Fc2b\u002F08fa79c2b3664daead48c60eeaf7ebe3.png\"\u002F\u003E\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EДавайте рассмотрим данную схему подробнее. Традиционно в клиент серверных приложениях главным считается сервер. Он предоставляет услуги\u002Fсервисы и решает в каком виде это должно быть реализовано. Соответственно интерфейс и фасад, как правило, определяются с точки зрения сервера. А клиенты под этот заданный формат подстраиваются.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EНа практике же более адекватной оказывается не сервер-ориентированная архитектура, а клиент-ориентированная. В ней фокус с сервера смещается в сторону клиента и интерфейс, вернее интерфейсы (и фасад или фасады), определяются исходя из потребностей клиентов. Вместо \u003Cstrong\u003EПредоставляемого Интерфейса\u003C\u002Fstrong\u003E (\u003Cem\u003EProvided Interface\u003C\u002Fem\u003E) используются \u003Cstrong\u003EТребуемые Интерфейсы\u003C\u002Fstrong\u003E (\u003Ca href=\"http:\u002F\u002Fmartinfowler.com\u002Fbliki\u002FRequiredInterface.html\"\u003ERequiredInterface\u003C\u002Fa\u003E). \u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw1560\u002Ffiles\u002Fe2e\u002Ff2f\u002F71f\u002Fe2ef2f71f62b4f4b842385979e46a991.png\" alt=\"RequiredInterface\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Ffiles\u002Fe2e\u002Ff2f\u002F71f\u002Fe2ef2f71f62b4f4b842385979e46a991.png\"\u002F\u003E\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EКонкретные реализации могут варьироваться, но это не суть важно\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw1560\u002Ffiles\u002F7c5\u002Fec1\u002Faa4\u002F7c5ec1aa4b654f1fbd9038a47e85c7db.png\" alt=\"RequiredInterface\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Ffiles\u002F7c5\u002Fec1\u002Faa4\u002F7c5ec1aa4b654f1fbd9038a47e85c7db.png\"\u002F\u003E \u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EКлиент ориентированный подход гораздо лучше соответствует \u003Cem\u003EПринципу разделения интерфейсов\u003C\u002Fem\u003E (\u003Cem\u003EInterface Segregation Principle\u003C\u002Fem\u003E) поскольку в нем вместо единого для всех толстого \u003Cstrong\u003EProvidedInterface\u003C\u002Fstrong\u003E используется множество тонких \u003Cstrong\u003ERequiredInterface\u003C\u002Fstrong\u003E.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EЕсли я не ошибаюсь, именно такой подход используется в архитектуре микросервисов. Там для взаимодействия с множеством сервисов введено понятие шлюза, который является ни чем иным как фасадом — “\u003Cem\u003EAn API Gateway is a server that is the single entry point into the system. It is similar to the Facade pattern from object-oriented design. The API Gateway encapsulates the internal system architecture and provides an API that is tailored to each client\u003C\u002Fem\u003E. ” \u003Ca href=\"https:\u002F\u002Fwww.nginx.com\u002Fblog\u002Fbuilding-microservices-using-an-api-gateway\u002F\"\u003EBuilding Microservices: Using an API Gateway\u003C\u002Fa\u003E. \u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EПричем шлюз этот \"\u003Cem\u003Eвместо того чтобы обеспечивать общий единый для всех API, предоставляет различные API для каждого клиента (Rather than provide a one-size-fits-all style API, the API gateway can expose a different API for each client. For example, the Netflix API gateway runs client-specific adapter code that provides each client with an API that’s best suited to it’s requirements)\u003C\u002Fem\u003E\" \u003Ca href=\"http:\u002F\u002Fmicroservices.io\u002Fpatterns\u002Fapigateway.html\"\u003EAPI Gateway\u003C\u002Fa\u003E.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EКак мы увидим дальше клиент-ориентированный подход применялся также и в SmallTalk-80. Но вначале давайте просто пере-рисуем схему MVC с учетом вышесказанного:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw1560\u002Ffiles\u002F0db\u002F5aa\u002F0b4\u002F0db5aa0b47764f9d93ceac2658253fb4.png\" alt=\"MVC\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Ffiles\u002F0db\u002F5aa\u002F0b4\u002F0db5aa0b47764f9d93ceac2658253fb4.png\"\u002F\u003E\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EСмотрим на фасад… Вот он тот самый клей (glue), объект посредник, прокси, фильтр, адаптер… связывающий между собой доменную модель и пользовательский интерфейс и поставляющий нужные данные в нужном\u002Fудобном формате. \u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EУдивительно то, что кроме Реенскауга об этом почти никто не пишет. Хотя некоторые пере-открывают эту идею самостоятельно (пример можно посмотреть \u003Ca href=\"http:\u002F\u002Fdocs.roguewave.com\u002Fstingray\u002F11.2\u002Fhtml\u002Fsflug\u002F8-9.html\"\u003Eтут\u003C\u002Fa\u003E или \u003Ca href=\"http:\u002F\u002Fweb.archive.org\u002Fweb\u002F20050314095039\u002Fhttp:\u002F\u002Fwww.roguewave.com\u002Fproducts\u002Fwhitepapers\u002Fmvcwp.pdf\"\u003Eтут\u003C\u002Fa\u003E раздел \"Interface-Based Programming Techniques\"). \u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EОсобенно хорошо тема Моделей-интерфейсов раскрыта в статье одного из JavaGuru — \u003Ca href=\"http:\u002F\u002Fjavadude.com\u002Farticles\u002Fvaddmvc2\u002Fmvc2.html\"\u003EAdvanced MVC Patterns\u003C\u002Fa\u003E. Автор подчеркивает, что Модели это не данные, а исключительно интерфейсы\u002Fобъекты-посредники\u002Fфильтры (Models as Proxies, Models as Filters), обеспечивающие удобный доступ к данным, которые могут находится где угодно – на разных машинах, в разных форматах: “\u003Cem\u003EО чем большинство программистов не думает, так это о том, что модели являются всего лишь интерфейсами. Они не должны содержать никаких данных!.. Модели-посредники расширяют охват и позволяют использовать уже \u003Cstrong\u003Eсуществующие данные\u003C\u002Fstrong\u003E где бы они не находились\u003C\u002Fem\u003E”. \u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EИз-за того что фасад, присутствующий в original MVC, был «утерян», то его роль зачастую берет на себя Контроллер. Отсюда и проистекают представления что Контроллер находится «между Моделью и Видом», служит клеем между ними и обеспечивает нужные Виду данные. \u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EНа форумах нередко встречается вопрос — \"Чем контроллер отличается от фасада?\". Не смотря на наивность этот вопрос вполне закономерен и на него сложно дать разумный ответ поскольку во многих MVC фреймворках Контроллер на самом деле фактически является фасадом — \u003Cstrong\u003E«Фронт-Контроллер»\u003C\u002Fstrong\u003E. \u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EЧем плохо такое решение? Если оно граммотно реализовано, то ничем. Но это в теории. А на практике нередко происходит путаница концепций и понятий и в результате Фронт-Контроллер с одной стороны злоупотребляет своими полномочиями и вместо \u003Cstrong\u003Eделегирования команд\u003C\u002Fstrong\u003E начинает включать в себя \u003Cstrong\u003Eреализацию\u003C\u002Fstrong\u003E бизнес логики. А с другой – продолжает одновременно выполнять функции пользовательского интерфейса и в результате в нем происходит уже упоминавшееся смешение «бизнес логики» и «GUI логики» (что собственно и делает его код похожим на огромную свалку). \u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EДумаю, что пришло время перейти к Smalltalk. Smalltalk-80 создавался очень талантливыми людьми. С документацией в нем действительно имелись проблемы (тем более что «шаблонов проектирования» тогда еще не существовало) но вот с реализацией в основном все было хорошо и пользовательские интерфейсы, конечно же, не взаимодействовали с доменной моделью напрямую. \u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EМежду интерфейсом и доменной моделью (объектами языка SmallTalk) всегда располагался некий промежуточный класс\u002Fобъект, который обеспечивал удобный интегральный доступ к доменным объектам их данным и методам. Вот эти-то промежуточные объекты (по сути выполняющие роль фасадов) и были в действительности Моделями в SmallTalk-80. \u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EНапример, для работы с кодом в Smalltalk использовались следующие GUI интерфейсы: Inspector, Browser, Workspace,… \u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw1560\u002Ffiles\u002F7ba\u002Fdc8\u002F179\u002F7badc8179d43404f937a7026e7f0ebdc.png\" alt=\"smalltalk-80 MVC\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Ffiles\u002F7ba\u002Fdc8\u002F179\u002F7badc8179d43404f937a7026e7f0ebdc.png\"\u002F\u003E\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EВот что пишет об их устройстве Glenn Krasner:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003E\u003Cem\u003E\"Inspector в системе состоит из двух видов. ListView отображает список переменных (слева), а TextView показывает значение выбранной переменной (справа)… Моделью для этих видов служит экземпляр класса «\u003Cstrong\u003EInspector\u003C\u002Fstrong\u003E»… Отдельный класс «\u003Cstrong\u003EInspector\u003C\u002Fstrong\u003E» является \u003Cstrong\u003Eпосредником\u003C\u002Fstrong\u003E или \u003Cstrong\u003Eфильтром\u003C\u002Fstrong\u003E для того чтобы обеспечивать доступ к любому свойству любого объекта. Использование промежуточных объектов между View и \"\u003Cstrong\u003Eactual\u003C\u002Fstrong\u003E\" models является типичным способом изолировать поведение отображения от модели приложения...\u003C\u002Fem\u003E\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003E\u003Cem\u003EКак и в случае Inspector, промежуточные объекты использовались также в качестве моделей для системных браузеров. Экземпляр класса «\u003Cstrong\u003EBrowser\u003C\u002Fstrong\u003E» является моделью-посредником для каждого системного браузера...\u003C\u002Fem\u003E\"\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003E\u003Cstrong\u003EЗамечание\u003C\u002Fstrong\u003E: название класса-посредника, описывающего промежуточный объект-фасад, обычно совпадало с названием отображающего его виджета. У Inspector промежуточная модель так и называлась «\u003Cem\u003EInspector\u003C\u002Fem\u003E», а у Browser соответственно – «\u003Cem\u003EBrowser\u003C\u002Fem\u003E».\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EВ случае Workspace, который был одним из простейших интерфейсов \"\u003Cem\u003Eмоделью служил экземпляр StringHolder, который просто предоставлял текст, то есть строку с информацией о форматировании\".\u003C\u002Fem\u003E \u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw1560\u002Ffiles\u002F17a\u002Fea1\u002F079\u002F17aea10795a944368b483e9803ad5ef8.png\" alt=\"smalltalk-80 MVC\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Ffiles\u002F17a\u002Fea1\u002F079\u002F17aea10795a944368b483e9803ad5ef8.png\"\u002F\u003E\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EВ конце своей статьи Krasner приводит список использовавшихся в SmallTalk Моделей (наследников базового класса Model): \u003Cstrong\u003EStringHolder\u003C\u002Fstrong\u003E, \u003Cstrong\u003EBrowser\u003C\u002Fstrong\u003E, \u003Cstrong\u003EInspector\u003C\u002Fstrong\u003E, \u003Cstrong\u003EFileModel\u003C\u002Fstrong\u003E, \u003Cstrong\u003EIcon\u003C\u002Fstrong\u003E… А также отмечает что \"\u003Cem\u003Ethe models were almost always some sort of filter class\u003C\u002Fem\u003E\".\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EПозже в VisualWorks Smalltalk идея промежуточных Holder-ов была развита и реализована в полной мере. Там для доступа к каждой переменной, принадлежащей доменным объектам, используется свой интерфейс и фасад – \u003Ca href=\"http:\u002F\u002Fc2.com\u002Fcgi\u002Fwiki?ValueModel\"\u003EValueModel\u003C\u002Fa\u003E и ValueHolder. И, как не трудно догадаться, именно ValueModel реализует шаблон \u003Cem\u003EНаблюдатель\u003C\u002Fem\u003E, извещая GUI о происходящих «в домене» изменениях. \u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw1560\u002Ffiles\u002F3aa\u002F904\u002Fba5\u002F3aa904ba565c404f8fc71060e28501b9.png\" alt=\"smalltalk Value-Model MVC\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Ffiles\u002F3aa\u002F904\u002Fba5\u002F3aa904ba565c404f8fc71060e28501b9.png\"\u002F\u003E\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cblockquote\u003E\u003Cstrong\u003EТипичные ошибки: обращение к доменным объектам напрямую\u003C\u002Fstrong\u003E\u003C\u002Fblockquote\u003E\u003Cp\u003EПоскольку на практике в любом сколько нибудь серьезном приложении сложно обойтись без фасадов, то не удивительно что во многих фреймворках и \"модификациях MVC\" аналоги фасада или объекта-посредника между GUI и доменной моделью пере-изобретаются под самыми разными именами. Помимо Front-Controller здесь можно упомянуть также ApplicationModel, \u003Ca href=\"https:\u002F\u002Fru.wikipedia.org\u002Fwiki\u002FModel-View-ViewModel\"\u003EViewModel\u003C\u002Fa\u003E (подробнее см. дискуссию \u003Ca href=\"http:\u002F\u002Fc2.com\u002Fcgi\u002Fwiki?ModelModelViewController\"\u003EModel-ModelView-Controller\u003C\u002Fa\u003E) и \u003Ca href=\"https:\u002F\u002Fdoc.qt.io\u002Farchives\u002F4.6\u002Fmodel-view-proxy-models.html\"\u003EProxy-model\u003C\u002Fa\u003E. \u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EИз-за того, что разработчики не всегда хорошо понимают что стоит за всеми этими «моделями», а сами модели привыкли воспринимать как данные а не интерфейс, то это становится источником еще одной весьма распространенной и ресурсоемкой ошибки. Вместо того чтобы нужным образом всего лишь \u003Cstrong\u003Eинтерпретировать\u003C\u002Fstrong\u003E и адаптировать имеющиеся доменные данные с помощью моделей-посредников их начинают \u003Cstrong\u003Eкопировать\u003C\u002Fstrong\u003E в эти модели-посредники. \u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EНапример, ValueHolder это, как правило, всего лишь обертка вокруг уже существующей доменной переменной, он не должен содержать данные, он содержит ссылку на данные. Вот что пишут: \"\u003Cem\u003EValueModel does not need to actually store the value because it is already being stored by another model\u003C\u002Fem\u003E\" (\u003Ca href=\"http:\u002F\u002Fc2.com\u002Fppr\u002Fvmodels.html\"\u003EUnderstanding and Using ValueModels\u003C\u002Fa\u003E). \u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EА вот цитата из статьи \u003Ca href=\"http:\u002F\u002Fjavadude.com\u002Farticles\u002Fvaddmvc2\u002Fmvc2.html\"\u003EAdvanced MVC Patterns\u003C\u002Fa\u003E: \"\u003Cem\u003EОдна из самых распространенных ошибок, которую совершают люди когда используют Swing компоненты, заключается в копировании данных в модели этих Swing компонент. Правильный же способ состоит в том чтобы использовать уже существующие данные, адаптируя их при помощи фильтра… Запомните: никогда не копируйте данные которые можно просто интерпретировать!\u003C\u002Fem\u003E\". \u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EРассмотрим следующий простой пример. Если последовать интернет советам и для \"добавления элементов в список\" использовать код подобный этому (взято со StackOverflow и \u003Ca href=\"http:\u002F\u002Fwww.java2s.com\u002FTutorial\u002FJava\u002F0240__Swing\u002FAddingandRemovinganIteminaJListComponent.htm\"\u003EAdding and Removing an Item in a JList\u003C\u002Fa\u003E), то будет происходить как раз то самое \u003Cstrong\u003Eкопирование\u003C\u002Fstrong\u003E данных в модель списка:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"java\"\u003EObject[] items; \u002F\u002F Доменный объект\n\nDefaultListModel model = new DefaultListModel();\nJList list = new JList(model);\nfor (int i = 0; i &lt; items.length; i++){\n     \u002F\u002F КОПИРОВАНИЕ доменных данных в модель списка!\n     model.addElement(items[i]);  \n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EПравильнее, конечно же, использовать данные массива просто обернув их в интерфейс ListModel (тем более что для этих целей создана уже почти готовая AbstractListModel):\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"java\"\u003E\u002F\u002F создаем фасад-адаптер к доменным данным,\n\u002F\u002F который просто интерпретирует их нужным образом\nListModel model = new AbstractListModel() {\n    public int getSize() {return items.length;}\n    public Object getElementAt(int index) {return  items[index];}\n};\n\u002F\u002F передаем созданный фасад списку в качестве модели\nJList list = new JList(model);\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EИ если надо объединить данные, отфильтровать или преобразовать каким-нибудь образом, то совершенно не нужны промежуточные массивы. Все делается непосредственно в модели-фасаде\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"java\"\u003EObject[] items1;  Object[] items2; \u002F\u002F Доменные объекты\n\n\u002F\u002F модель-фасад которая объединяет массивы\nListModel model = new AbstractListModel() {\n    public int getSize() { return items1.length + items2.length;}\n    public Object getElementAt(int index) {\n        return index&lt;items1.length ? items1[index] : items2[index-items1.length];\n    }\n};\nJList list = new JList(model);\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EВ случае небольших статических массивов преимущества не очевидны. Но в общем случае такой подход позволяет не только избегать копирования, но прежде всего защищает от проблем связанных с рассинхронизацией данных (если не полениться прописать методы извещающие слушателей об изменениях).\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EНу а если хочется краткости, то тогда уж лучше так:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"java\"\u003EJList list = new JList(items);\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EВ этом случае Джава сама сделает обертку-адаптер вместо копирования. \u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cblockquote\u003E\u003Cstrong\u003EТипичные ошибки: копирование доменных данных в модели GUI-компонент\u003C\u002Fstrong\u003E\u003C\u002Fblockquote\u003E\u003Cp\u003E \u003Cbr\u002F\u003E\r\nНу и наконец мы может развеять главный миф, являющийся источником наибольшего количества проблем и ошибок.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cblockquote\u003E\u003Cstrong\u003EМифы: Модель в «MVC схеме» тождественна доменной модели и данным\u003C\u002Fstrong\u003E\u003C\u002Fblockquote\u003E\u003Cp\u003EПутаница возникает из-за того что одно и то же слово «Модель» используется в разных контекстах. Когда речь идет о декомпозиции и отделении \u003Cem\u003Eбизнес-логики\u003C\u002Fem\u003E от \u003Cem\u003Eпользовательского интерфейса\u003C\u002Fem\u003E, то под Моделью действительно понимается именно \u003Cstrong\u003Eдоменная модель\u003C\u002Fstrong\u003E, содержащая данные и логику работы с ними и обеспечивающая основной функционал приложения. \u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EНо в контексте шаблонов и схем Модель это прежде всего \u003Cstrong\u003Eинтерфейс\u003C\u002Fstrong\u003E и реализующий его \u003Cstrong\u003Eобъект-посредник\u003C\u002Fstrong\u003E (фасад, адаптер, прокси) обеспечивающие удобный и безопасный доступ к доменным данным, которые могут находится где угодно. Реенскауг так и писал: \"\u003Cem\u003Emodel object with a façade that reflects the user’s mental model\u003C\u002Fem\u003E\". \u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EКогда MVC преподносится исключительно как «схема», то наличие «промежуточных моделей» кажется сложным и запутанным. Появляются вопросы (\"Чем эти модели отличаются друг от друга?\", “Как их правильно использовать?”), неоднозначные трактовки и множество возможностей сделать ошибку. \u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EНо если понимать заложенные в MVC архитектурные идеи, то все становится предельно ясным: пользовательский интерфейс не имеет права обращаться к объектам доменной модели напрямую. А значит между доменной моделью и пользовательским интерфейсом должнен находиться фасад\u002Fпосредник\u002Fадаптер..., и взаимодействовать пользовательский интерфейс (Вид и Контроллер) может только с ним. Возможностей сделать ошибку – ноль. \u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EИ по большому счету становится все равно каким термином этот объект-посредник называется и какая именно Model-View-Whatever разновидность MVC используется… Начинаешь видеть: какая задача решается, с помощью каких шаблонов и то, насколько хорошо или плохо это делается\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EВ принципе на этом статью можно и закончить. Как уже упоминалось деление пользовательского интерфейса на Вид и Контроллер является наименее значимым, даже вспомогательным моментом. Но с другой стороны пользовательский интерфейс присутствует в каждом пользовательском приложении и иметь представление о подходах и идеях наработанных в этой области часто бывает полезно. К тому же именно вокруг Контроллера ведутся основные споры. Поэтому – \u003Ca href=\"https:\u002F\u002Fhabrahabr.ru\u002Fpost\u002F322700\u002F\"\u003Eвторая часть\u003C\u002Fa\u003E, полностью посвященная именно этой теме.\u003C\u002Fp\u003E\u003C\u002Fdiv\u003E","tags":[{"titleHtml":"MVC"},{"titleHtml":"архитектура приложений"}],"metadata":{"stylesUrls":[],"scriptUrls":[],"shareImageUrl":"https:\u002F\u002Fhabr.com\u002Fshare\u002Fpublication\u002F321050\u002F8b69758434caccd606a0344f27aff6fd\u002F","shareImageWidth":1200,"shareImageHeight":630,"vkShareImageUrl":"https:\u002F\u002Fhabr.com\u002Fshare\u002Fpublication\u002F321050\u002F8b69758434caccd606a0344f27aff6fd\u002F?format=vk","schemaJsonLd":"{\"@context\":\"http:\\\u002F\\\u002Fschema.org\",\"@type\":\"Article\",\"mainEntityOfPage\":{\"@type\":\"WebPage\",\"@id\":\"https:\\\u002F\\\u002Fhabr.com\\\u002Fru\\\u002Fpost\\\u002F321050\\\u002F\"},\"headline\":\"Охота на мифический MVC. Обзор, возвращение к первоисточникам и про то, как анализировать и выводить шаблоны самому\",\"datePublished\":\"2017-02-07T04:48:41+03:00\",\"dateModified\":\"2017-02-27T15:42:14+03:00\",\"author\":{\"@type\":\"Person\",\"name\":\"cobiot\"},\"publisher\":{\"@type\":\"Organization\",\"name\":\"Habr\",\"logo\":{\"@type\":\"ImageObject\",\"url\":\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fwebt\\\u002Fa_\\\u002Flk\\\u002F9m\\\u002Fa_lk9mjkccjox-zccjrpfolmkmq.png\"}},\"description\":\"&mdash; Не понимаю, почему люди так восхищаются этим Карузо? Косноязычен, гугнив, поёт &mdash; ничего не разберешь! &mdash; А вы слышали, как поёт Карузо? &mdash; Да, мне тут кое-что из...\",\"url\":\"https:\\\u002F\\\u002Fhabr.com\\\u002Fru\\\u002Fpost\\\u002F321050\\\u002F#post-content-body\",\"about\":[\"h_analysis_design\",\"h_refactoring\",\"f_develop\"],\"image\":[\"https:\\\u002F\\\u002Fhabr.com\\\u002Fshare\\\u002Fpublication\\\u002F321050\\\u002F8b69758434caccd606a0344f27aff6fd\\\u002F\"]}","metaDescription":"— Не понимаю, почему люди так восхищаются этим Карузо? Косноязычен, гугнив, поёт — ничего не разберешь!\r\n— А вы слышали, как поёт Карузо?\r\n— Да, мне тут кое-что из его репертуара Рабинович напел по...","mainImageUrl":null,"amp":false,"customTrackerLinks":[]},"polls":[],"commentsEnabled":true,"rulesRemindEnabled":false,"votesEnabled":true,"status":"published","plannedPublishTime":null,"checked":null,"isEditorial":false}},"articlesIds":{},"isLoading":false,"pagesCount":{},"route":{},"reasonsList":null,"view":"cards","lastVisitedRoute":{},"ssrCommentsArticleIds":[""],"karma":{}},"authorContribution":{"authors":{}},"betaTest":{"currentAnnouncement":null,"announcements":{},"announcementCards":null,"announcementComments":{},"announcementCommentThreads":{},"announcementCommentingStatuses":{},"archivedList":[]},"authorStatistics":{"articleRefs":{},"articleIds":{},"pagesCount":{},"route":{},"viewsCount":[],"maxStatsCount":{}},"career":{"seoLandings":[{"title":"Cистемный аналитик","vacanciesCount":415,"itemUrl":"https:\u002F\u002Fcareer.habr.com\u002Fvacancies\u002Fsistemnij_analitik","itemHubs":["uml","prototyping","analysis_design","productpm"]}],"hubs":"analysis_design,refactoring"},"comments":{"articleComments":{},"searchCommentsResults":null,"previewComment":null,"pagesCount":null,"commentAccess":{},"scrollParents":{},"pageArticleComments":{"lastViewedComment":0,"postId":null,"lastCommentTimestamp":"","moderated":[],"moderatedIds":[],"commentRoute":""}},"companies":{"companyRefs":{},"companyIds":{},"companyTopIds":{},"pagesCount":{},"companyProfiles":{},"companiesCategories":[],"companiesCategoriesTotalCount":0,"companiesWidgets":{},"companiesWorkers":{},"companiesFans":{},"route":{},"isLoading":false,"companyWorkersLoading":false,"companyFansLoading":false,"vacancies":{},"workplaceInfo":null},"companyAdmin":{"companyInfo":null,"companyInfoLoading":false,"faqArticles":null,"brandingPreviewImageUrl":null},"companiesContribution":{"hubs":{},"flows":{},"companyRefs":{}},"companyHubsContribution":{"contributionRefs":{"hubRefs":{},"hubIds":{}}},"conversation":{"messages":[],"respondent":null,"isLoadMore":false},"conversations":{"conversations":[],"unreadCount":0,"pagesCount":0,"isLoadMore":false},"desktopState":{"desktopFl":null,"desktopHl":null,"isChecked":false,"isLoginDemanded":false},"docs":{"menu":{},"articles":{},"mainMenu":[],"loading":{"main":false,"dropdown":false,"article":false}},"feature":{"isProbablyVisible":"true"},"flows":{"flows":[{"alias":"develop","id":1,"route":{"name":"FLOW_PAGE","params":{"flowName":"develop"}}},{"alias":"admin","id":6,"route":{"name":"FLOW_PAGE","params":{"flowName":"admin"}}},{"alias":"design","id":2,"route":{"name":"FLOW_PAGE","params":{"flowName":"design"}}},{"alias":"management","id":3,"route":{"name":"FLOW_PAGE","params":{"flowName":"management"}}},{"alias":"marketing","id":4,"route":{"name":"FLOW_PAGE","params":{"flowName":"marketing"}}},{"alias":"popsci","id":7,"route":{"name":"FLOW_PAGE","params":{"flowName":"popsci"}}}]},"global":{"isPwa":false,"device":"desktop","isHabrCom":true},"hubs":{"hubRefs":{},"hubIds":{},"pagesCount":{},"isLoading":false,"route":{}},"hubsBlock":{"hubRefs":{},"hubIds":{}},"i18n":{"fl":"ru","hl":"ru"},"info":{"infoPage":{},"isLoading":true},"location":{"urlStruct":{"protocol":null,"slashes":null,"auth":null,"host":null,"port":null,"hostname":null,"hash":null,"search":null,"query":{},"pathname":null,"path":null,"href":""},"searchQuery":null},"me":{"user":null,"ppgDemanded":false,"karmaResetInfo":{"canReincarnate":null,"wasReincarnated":null,"currentScore":null},"notes":null},"mostReadingList":{"mostReadingListIds":[],"mostReadingListRefs":null,"promoPost":null},"pinnedPost":{"pinnedPost":null},"ppa":{"articles":{},"card":null,"transactions":null,"totalTransactions":null,"isAccessible":null},"projectsBlocks":{"activeBlocks":{}},"promoData":{"isLoading":false,"hasLoaded":false,"featurer":null,"megaposts":null,"promoLinks":null,"promoPosts":null},"pullRefresh":{"shouldRefresh":false},"sandbox":{"articleIds":[],"articleRefs":{},"pagesCount":null,"route":{},"lastVisitedRoute":{},"isLoading":false},"search":{"searchQueryError":null},"settingsOther":{"inputs":{"uiLang":{"errors":[],"ref":null,"value":""},"articlesLangEnglish":{"errors":[],"ref":null,"value":false},"articlesLangRussian":{"errors":[],"ref":null,"value":false},"agreement":{"errors":[],"ref":null,"value":false},"email":{"errors":[],"ref":null,"value":true},"digest":{"errors":[],"ref":null,"value":true}}},"similarList":{"similarListIds":[],"similarListRefs":null},"ssr":{"error":null,"isDataLoaded":false,"isDataLoading":false,"isHydrationFailed":false,"isServer":false},"technotext":{"nominationsList":[]},"userHubsContribution":{"contributionRefs":{"hubRefs":{},"hubIds":{}}},"userInvites":{"availableInvites":0,"usedInvitesIds":[],"usedInvitesRefs":{},"usedInvitesPagesCount":0,"unusedInvitesIds":[],"unusedInvitesRefs":{},"unusedInvitesPagesCount":0},"users":{"authorRefs":{},"authorIds":{},"pagesCount":{},"authorProfiles":{},"userHubs":{},"userInvitations":{},"authorFollowers":{},"authorFollowed":{},"userSpecialization":{},"karmaStats":[],"statistics":null,"isLoading":false,"authorFollowersLoading":false,"authorFollowedLoading":false,"userHubsLoading":false,"userInvitationsLoading":false,"route":{}},"viewport":{"prevScrollY":{},"scrollY":0,"width":0},"tracker":{"items":{},"pagesCache":{},"markedViewedSilently":{},"markedRead":{},"unreadCounters":{"applications":null,"system":null,"mentions":null,"subscribers":null,"posts_and_comments":null},"unviewedCounters":{"applications":null,"system":null,"mentions":null,"subscribers":null,"posts_and_comments":null}}};(function(){var s;(s=document.currentScript||document.scripts[document.scripts.length-1]).parentNode.removeChild(s);}());</script>
<script src="https://assets.habr.com/habr-web/js/chunk-vendors.da6c6b36.js" defer></script><script src="https://assets.habr.com/habr-web/js/app.92df6f6d.js" defer></script>



    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    </script>
  
  <script type="text/javascript" >
    (function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
    m[i].l=1*new Date();k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})
    (window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");

    ym(24049213, "init", {
      defer:true,
      trackLinks:true,
      accurateTrackBounce:true,
      webvisor:false,
    });
  </script>
  <noscript>
    <div>
      <img src="https://mc.yandex.ru/watch/24049213" style="position:absolute; left:-9999px;" alt="" />
    </div>
  </noscript>
  
    <script type="text/javascript">
      window.addEventListener('load', function () {
        setTimeout(() => {
          const img = new Image();
          img.src = 'https://vk.com/rtrg?p=VK-RTRG-421343-57vKE';
        }, 0);
      });
    </script>
  
<script src="https://habr.com/js/ads.js" onload="window['zhY4i4nJ9K'] = true"></script>
</body>
</html>
