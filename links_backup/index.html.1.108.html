<!DOCTYPE html>
<html lang="ru" data-vue-meta="%7B%22lang%22:%7B%22ssr%22:%22ru%22%7D%7D">
<head >
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1.0,viewport-fit=cover">
  <meta name="referrer" content="unsafe-url">
  <title>Логическая репликация в PostgreSQL. Репликационные идентификаторы и популярные ошибки / Хабр</title>
  <style>
    /* cyrillic-ext */
    @font-face {
      font-family: 'Fira Sans';
      font-style: normal;
      font-weight: 500;
      font-display: swap;
      src: url(https://fonts.gstatic.com/s/firasans/v11/va9B4kDNxMZdWfMOD5VnZKveSxf6TF0.woff2) format('woff2');
      unicode-range: U+0460-052F, U+1C80-1C88, U+20B4, U+2DE0-2DFF, U+A640-A69F, U+FE2E-FE2F;
    }

    /* cyrillic */
    @font-face {
      font-family: 'Fira Sans';
      font-style: normal;
      font-weight: 500;
      font-display: swap;
      src: url(https://fonts.gstatic.com/s/firasans/v11/va9B4kDNxMZdWfMOD5VnZKveQhf6TF0.woff2) format('woff2');
      unicode-range: U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116;
    }

    /* latin-ext */
    @font-face {
      font-family: 'Fira Sans';
      font-style: normal;
      font-weight: 500;
      font-display: swap;
      src: url(https://fonts.gstatic.com/s/firasans/v11/va9B4kDNxMZdWfMOD5VnZKveSBf6TF0.woff2) format('woff2');
      unicode-range: U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;
    }

    /* latin */
    @font-face {
      font-family: 'Fira Sans';
      font-style: normal;
      font-weight: 500;
      font-display: swap;
      src: url(https://fonts.gstatic.com/s/firasans/v11/va9B4kDNxMZdWfMOD5VnZKveRhf6.woff2) format('woff2');
      unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
    }

    /* non-breaking hyphen */
    @font-face {
      font-family: 'Fira Sans';
      font-style: normal;
      font-weight: 500;
      font-display: swap;
      src: url(https://fonts.gstatic.com/l/font?kit=KFOlCnqEu92Fr1MmEU9vBh0_IsHAlmrO6g&skey=ee881451c540fdec&v=v29) format('woff2');
      unicode-range: U+02011;
    }
  </style>
  <link rel="preload" href="https://assets.habr.com/habr-web/css/chunk-vendors.e7843cc0.css" as="style"><link rel="preload" href="https://assets.habr.com/habr-web/js/chunk-vendors.da6c6b36.js" as="script"><link rel="preload" href="https://assets.habr.com/habr-web/css/app.4de4e95a.css" as="style"><link rel="preload" href="https://assets.habr.com/habr-web/js/app.92df6f6d.js" as="script">
  <link rel="stylesheet" href="https://assets.habr.com/habr-web/css/chunk-vendors.e7843cc0.css"><link rel="stylesheet" href="https://assets.habr.com/habr-web/css/app.4de4e95a.css">
  <script>window.i18nFetch = new Promise((res, rej) => {
          const xhr = new XMLHttpRequest();
          xhr.open('GET', '/js/i18n/ru-compiled.2822d469ec31a56409ac330bbcf7fcbf.json');
          xhr.responseType = 'json';
          xhr.onload = function(e) {
            if (this.status === 200) {
              res({ru: xhr.response});
            } else {
              rej(e);
            }
          };
          xhr.send();
        });</script>
  
  <script data-vue-meta="ssr" type="application/ld+json" data-vmid="ldjson-schema">{"@context":"http:\/\/schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/habr.com\/ru\/company\/postgrespro\/blog\/489308\/"},"headline":"Логическая репликация в PostgreSQL. Репликационные идентификаторы и популярные ошибки","datePublished":"2021-02-28T22:38:29+03:00","dateModified":"2021-03-01T19:30:29+03:00","author":{"@type":"Person","name":"Коротких Василий"},"publisher":{"@type":"Organization","name":"Habr","logo":{"@type":"ImageObject","url":"https:\/\/habrastorage.org\/webt\/a_\/lk\/9m\/a_lk9mjkccjox-zccjrpfolmkmq.png"}},"description":"Начиная с 10 версии, перенести данные с одной базы PostgreSQL на другую несложно, с обновлением, без обновления &mdash; неважно. Об этом немало сказано и сказанное св...","url":"https:\/\/habr.com\/ru\/company\/postgrespro\/blog\/489308\/#post-content-body","about":["c_postgrespro","h_postgresql","h_db_admins","h_data_engineering","f_develop","f_admin"],"image":["https:\/\/habrastorage.org\/webt\/rc\/4w\/c4\/rc4wc4pblkhrdji9tkuwdwvt2ro.jpeg"]}</script>
  <script src="https://www.googletagservices.com/tag/js/gpt.js" async></script>
  <style>.grecaptcha-badge{visibility: hidden;}</style>
  <meta name="habr-version" content="2.64.0">
  
  <meta data-vue-meta="ssr" property="fb:app_id" content="444736788986613"><meta data-vue-meta="ssr" property="fb:pages" content="472597926099084"><meta data-vue-meta="ssr" name="twitter:card" content="summary_large_image"><meta data-vue-meta="ssr" name="twitter:site" content="@habr_com"><meta data-vue-meta="ssr" property="og:site_name" content="Хабр" data-vmid="og:site_name"><meta data-vue-meta="ssr" property="og:title" content="Логическая репликация в PostgreSQL. Репликационные идентификаторы и популярные ошибки" data-vmid="og:title"><meta data-vue-meta="ssr" name="twitter:title" content="Логическая репликация в PostgreSQL. Репликационные идентификаторы и популярные ошибки" data-vmid="twitter:title"><meta data-vue-meta="ssr" name="aiturec:title" content="Логическая репликация в PostgreSQL. Репликационные идентификаторы и популярные ошибки" data-vmid="aiturec:title"><meta data-vue-meta="ssr" name="description" content="Начиная с 10 версии, перенести данные с одной базы PostgreSQL на другую несложно, с обновлением, без обновления — неважно. Об этом немало сказано и сказанное сводится к следующему: на мастере, 10..." data-vmid="description"><meta data-vue-meta="ssr" itemprop="description" content="Начиная с 10 версии, перенести данные с одной базы PostgreSQL на другую несложно, с обновлением, без обновления — неважно. Об этом немало сказано и сказанное сводится к следующему: на мастере, 10..." data-vmid="description:itemprop"><meta data-vue-meta="ssr" property="og:description" content="Начиная с 10 версии, перенести данные с одной базы PostgreSQL на другую несложно, с обновлением, без обновления — неважно. Об этом немало сказано и сказанное сводится к следующему: на мастере, 10..." data-vmid="og:description"><meta data-vue-meta="ssr" name="twitter:description" content="Начиная с 10 версии, перенести данные с одной базы PostgreSQL на другую несложно, с обновлением, без обновления — неважно. Об этом немало сказано и сказанное сводится к следующему: на мастере, 10..." data-vmid="twitter:description"><meta data-vue-meta="ssr" property="aiturec:description" content="Начиная с 10 версии, перенести данные с одной базы PostgreSQL на другую несложно, с обновлением, без обновления — неважно. Об этом немало сказано и сказанное сводится к следующему: на мастере, 10..." data-vmid="aiturec:description"><meta data-vue-meta="ssr" itemprop="image" content="https://habr.com/share/publication/489308/9a7062c6b3f4eeb532c9d000cc28b24c/" data-vmid="image:itemprop"><meta data-vue-meta="ssr" property="og:image" content="https://habr.com/share/publication/489308/9a7062c6b3f4eeb532c9d000cc28b24c/" data-vmid="og:image"><meta data-vue-meta="ssr" property="og:image:width" content="1200" data-vmid="og:image:width"><meta data-vue-meta="ssr" property="og:image:height" content="630" data-vmid="og:image:height"><meta data-vue-meta="ssr" property="aiturec:image" content="https://habr.com/share/publication/489308/9a7062c6b3f4eeb532c9d000cc28b24c/" data-vmid="aiturec:image"><meta data-vue-meta="ssr" name="twitter:image" content="https://habr.com/share/publication/489308/9a7062c6b3f4eeb532c9d000cc28b24c/" data-vmid="twitter:image"><meta data-vue-meta="ssr" property="vk:image" content="https://habr.com/share/publication/489308/9a7062c6b3f4eeb532c9d000cc28b24c/?format=vk" data-vmid="vk:image"><meta data-vue-meta="ssr" property="aiturec:item_id" content="489308" data-vmid="aiturec:item_id"><meta data-vue-meta="ssr" property="aiturec:datetime" content="2021-02-28T19:38:29.000Z" data-vmid="aiturec:datetime"><meta data-vue-meta="ssr" content="https://habr.com/ru/company/postgrespro/blog/489308/" property="og:url" data-vmid="og:url"><meta data-vue-meta="ssr" property="og:type" content="article" data-vmid="og:type"><meta data-vue-meta="ssr" property="og:locale" content="ru_RU" data-vmid="og:locale"><meta data-vue-meta="ssr" name="keywords" content="postgersql, postgres pro, логическая репликация">
  <link data-vue-meta="ssr" href="https://habr.com/ru/rss/post/489308/?fl=ru" type="application/rss+xml" title="" rel="alternate" name="rss"><link data-vue-meta="ssr" href="index.html.1.108.html" rel="canonical" data-vmid="canonical"><link data-vue-meta="ssr" data-vmid="hreflang"><link data-vue-meta="ssr" image_src="image" href="https://habr.com/share/publication/489308/9a7062c6b3f4eeb532c9d000cc28b24c/" data-vmid="image:href">
  <meta name="apple-mobile-web-app-status-bar-style" content="#303b44">
  <meta name="msapplication-TileColor" content="#629FBC">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="mobile-web-app-capable" content="yes">
  <link
    rel="shortcut icon"
    type="image/png"
    sizes="16x16"
    href="https://assets.habr.com/habr-web/img/favicons/favicon-16.png"
  >
  <link
    rel="shortcut icon"
    type="image/png"
    sizes="32x32"
    href="https://assets.habr.com/habr-web/img/favicons/favicon-32.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="76x76"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-76.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="120x120"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-120.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="152x152"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-152.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="180x180"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-180.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="256x256"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-256.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1136x640.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2436x1125.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1792x828.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_828x1792.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1334x750.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1242x2668.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 736px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2208x1242.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1125x2436.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 736px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1242x2208.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2732x2048.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2688x1242.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 834px) and (device-height: 1112px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2224x1668.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_750x1334.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2048x2732.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2388x1668.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 834px) and (device-height: 1112px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1668x2224.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_640x1136.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1668x2388.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2048x1536.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1536x2048.png"
  >
  <link
    rel="mask-icon"
    color="#77a2b6"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-120.svg"
  >
  <link
    crossorigin="use-credentials"
    href="https://habr.com/manifest.webmanifest"
    rel="manifest"
  >
</head>
<body>


<div id="app" data-server-rendered="true" data-async-called="true"><div class="tm-layout__wrapper"><!----> <div></div> <!----> <header class="tm-header"><div class="tm-page-width"><div class="tm-header__container"><!----> <span class="tm-header__logo-wrap"><a href="https://habr.com/ru/" class="tm-header__logo tm-header__logo_ru"><svg height="16" width="16" class="tm-svg-img tm-header__icon"><title>Хабр</title> <use xlink:href="/img/habr-logo-ru.svg#logo"></use></svg></a> <span class="tm-header__beta-sign" style="display:none;">β</span></span> <div class="tm-dropdown tm-header__projects"><div class="tm-dropdown__head"><button class="tm-header__dropdown-toggle"><svg height="16" width="16" class="tm-svg-img tm-header__icon tm-header__icon_dropdown"><title>Открыть список</title> <use xlink:href="/img/megazord-v25.4b679db1.svg#arrow-down"></use></svg></button></div> <!----></div> <a href="https://habr.com/ru/sandbox/start/" class="tm-header__become-author-btn">
            Как стать автором
          </a> <div class="tm-feature tm-header__feature tm-feature_variant-inline"><!----></div> <!----> <!----></div></div></header> <div class="tm-layout"><div class="tm-page-progress-bar"></div> <div data-menu-sticky="true" class="tm-base-layout__header tm-base-layout__header_is-sticky"><div class="tm-page-width"><div class="tm-base-layout__header-wrapper"><div class="tm-main-menu"><div class="tm-main-menu__section"><nav class="tm-main-menu__section-content"><!----> <a href="https://habr.com/ru/flows/all" class="tm-main-menu__item">
        Все потоки
      </a> <a href="https://habr.com/ru/flows/develop/" class="tm-main-menu__item">
          Разработка
        </a><a href="https://habr.com/ru/flows/admin/" class="tm-main-menu__item">
          Администрирование
        </a><a href="https://habr.com/ru/flows/design/" class="tm-main-menu__item">
          Дизайн
        </a><a href="https://habr.com/ru/flows/management/" class="tm-main-menu__item">
          Менеджмент
        </a><a href="https://habr.com/ru/flows/marketing/" class="tm-main-menu__item">
          Маркетинг
        </a><a href="https://habr.com/ru/flows/popsci/" class="tm-main-menu__item">
          Научпоп
        </a></nav></div></div> <div class="tm-header-user-menu tm-base-layout__user-menu"><a href="https://habr.com/ru/search/" class="tm-header-user-menu__item tm-header-user-menu__search"><svg height="24" width="24" class="tm-svg-img tm-header-user-menu__icon tm-header-user-menu__icon_search tm-header-user-menu__icon_dark"><title>Поиск</title> <use xlink:href="/img/megazord-v25.4b679db1.svg#search"></use></svg></a> <!----> <!----> <!----> <div class="tm-header-user-menu__item tm-header-user-menu__user_desktop"><div class="tm-dropdown"><div class="tm-dropdown__head"><svg height="24" width="24" data-test-id="menu-toggle-guest" class="tm-svg-img tm-header-user-menu__icon"><title>Профиль</title> <use xlink:href="/img/megazord-v25.4b679db1.svg#header-user"></use></svg> <!----></div> <!----></div> <!----></div> <!----></div></div></div></div> <!----> <div class="tm-page-width"></div> <main class="tm-layout__container"><div hl="ru" companyName="postgrespro" data-async-called="true" class="tm-page"><div class="tm-page-width"><div class="tm-page__header"><!----></div> <div class="tm-page__wrapper"><div class="tm-page__main tm-page__main_has-sidebar"><div class="pull-down"><div class="pull-down__header" style="height:0px;"><div class="pull-down__content" style="bottom:10px;"><svg height="24" width="24" class="tm-svg-img pull-down__arrow"><title>Обновить</title> <use xlink:href="/img/megazord-v25.4b679db1.svg#pull-arrow"></use></svg></div></div> <div class="tm-article-presenter"><div class="tm-company-profile-card tm-company-article__profile-card"><div class="tm-company-card tm-company-profile-card__info"><div class="tm-company-card__header"><a href="https://habr.com/ru/company/postgrespro/profile/" class="tm-company-card__avatar"><div class="tm-entity-image"><img alt="" height="48" src="https://habrastorage.org/getpro/habr/company/4e0/339/621/4e0339621abc865fefb88f9e9f44748f.jpg" width="48" class="tm-entity-image__pic"></div></a> <!----> <div class="tm-rating tm-company-card__rating"><div class="tm-rating__header"> <div class="tm-rating__counter">140.03</div></div> <div class="tm-rating__text">
    Рейтинг
  </div></div> <!----></div> <div class="tm-company-card__info"><a href="https://habr.com/ru/company/postgrespro/profile/" class="tm-company-card__name">
      Postgres Professional
    </a> <div class="tm-company-card__description">Разработчик СУБД Postgres Pro</div></div></div> <!----></div> <div class="tm-article-presenter__body"><div class="tm-misprint-area"><div class="tm-misprint-area__wrapper"><article class="tm-article-presenter__content tm-article-presenter__content_narrow"><div class="tm-article-presenter__header"> <div class="tm-article-snippet tm-article-presenter__snippet"><div class="tm-article-snippet__meta-container"><div class="tm-article-snippet__meta"><span class="tm-user-info tm-article-snippet__author"><a href="https://habr.com/ru/users/korva/" title="korva" class="tm-user-info__userpic"><div class="tm-entity-image"><img alt="" height="24" src="https://habrastorage.org/r/w32/getpro/habr/avatars/11b/0d4/905/11b0d4905c5dbe422c3998cfc9aa59cc.jpg" width="24" class="tm-entity-image__pic"></div></a> <span class="tm-user-info__user"><a href="https://habr.com/ru/users/korva/" class="tm-user-info__username">
      korva
    </a> </span></span> <span class="tm-article-snippet__datetime-published"><time datetime="2021-02-28T19:38:29.000Z" title="2021-02-28, 22:38">28  февраля  2021 в 22:38</time></span></div> <!----></div> <h1 lang="ru" class="tm-article-snippet__title tm-article-snippet__title_h1"><span>Логическая репликация в PostgreSQL. Репликационные идентификаторы и популярные ошибки</span></h1> <div class="tm-article-snippet__hubs"><span class="tm-article-snippet__hubs-item"><a href="https://habr.com/ru/company/postgrespro/blog/" class="tm-article-snippet__hubs-item-link router-link-active"><span>Блог компании Postgres Professional</span> <!----></a></span><span class="tm-article-snippet__hubs-item"><a href="https://habr.com/ru/hub/postgresql/" class="tm-article-snippet__hubs-item-link"><span>PostgreSQL</span> <span title="Профильный хаб" class="tm-article-snippet__profiled-hub">*</span></a></span><span class="tm-article-snippet__hubs-item"><a href="https://habr.com/ru/hub/db_admins/" class="tm-article-snippet__hubs-item-link"><span>Администрирование баз данных</span> <span title="Профильный хаб" class="tm-article-snippet__profiled-hub">*</span></a></span><span class="tm-article-snippet__hubs-item"><a href="https://habr.com/ru/hub/data_engineering/" class="tm-article-snippet__hubs-item-link"><span>Data Engineering</span> <span title="Профильный хаб" class="tm-article-snippet__profiled-hub">*</span></a></span></div> <div class="tm-article-snippet__labels"><div class="tm-article-snippet__label tm-article-snippet__label_variant-technotext2021"><a href="https://habr.com/ru/technotext/">
        ✏️ Технотекст 2021
      </a></div><div class="tm-article-snippet__label tm-article-snippet__label_variant-tutorial"><span>
        Tutorial
      </span></div></div> <!----> <!----></div></div> <!----> <div data-gallery-root="" lang="ru" class="tm-article-body"><div></div> <div id="post-content-body"><div><div class="article-formatted-body article-formatted-body_version-1"><div xmlns="http://www.w3.org/1999/xhtml"><div style="text-align:center;"><img src="https://habrastorage.org/r/w780q1/webt/rc/4w/c4/rc4wc4pblkhrdji9tkuwdwvt2ro.jpeg" alt="image" data-src="https://habrastorage.org/webt/rc/4w/c4/rc4wc4pblkhrdji9tkuwdwvt2ro.jpeg" data-blurred="true"/></div><br/>
Начиная с 10 версии, перенести данные с одной базы PostgreSQL на другую несложно, с обновлением, без обновления — неважно. Об этом немало сказано и сказанное сводится к следующему: на мастере, 10 версии и выше, устанавливаем параметр конфигурации <code>wal_level="logical"</code>. В pg_hba.conf добавляем такую строку:<br/>
<br/>
<pre><code class="plaintext">host    db_name    postgres    192.168.1.3/32     trust</code></pre><br/>
Затем рестартуем на мастере postgres и выполняем на реплике из-под пользователя postgres:<br/>
<br/>
<pre><code class="bash">pg_dumpall --database=postgres --host=192.168.1.2 --no-password --globals-only --no-privileges | psql
pg_dump --dbname db_name --host=192.168.1.2 --no-password --create --schema-only | psql</code></pre><br/>
Теперь подключаемся на мастере пользователем <code>postgres</code> к базе <code>db_name</code> и создаём публикацию:<br/>
<br/>
<pre><code class="pgsql">CREATE PUBLICATION db_pub FOR ALL TABLES;</code></pre><br/>
а на реплике создаём подписку:<br/>
<br/>
<pre><code class="pgsql">CREATE SUBSCRIPTION db_sub CONNECTION 'host=192.168.1.2 dbname=db_name' PUBLICATION db_pub;</code></pre><br/>
По завершении репликации переключаем приложение или балансировщик на новую базу.<br/>
<br/>
Теперь вы знаете постгрес (и с какой стороны доить слонеску) и можете идти устраиваться ДБА.<br/>
<sup>Для любознательных есть пара небольших деталей под катом.</sup><br/>
<a name="habracut"></a><br/>
<h2>Задачи, решаемые логической репликацией</h2><br/>
Для чего может быть полезна логическая репликация, написано в <a href="https://postgrespro.ru/docs/postgresql/12/logical-replication">документации</a>:<br/>
<ul>
<li>Передача подписчикам инкрементальных изменений в одной базе данных или подмножестве базы данных, когда они происходят.</li>
<li>Срабатывание триггеров для отдельных изменений, когда их получает подписчик.</li>
<li>Объединение нескольких баз данных в одну (например, для целей анализа).</li>
<li>Репликация между разными основными версиями PostgreSQL.</li>
<li>Репликация между экземплярами PostgreSQL на разных платформах (например, с Linux на Windows).</li>
<li>Предоставление доступа к реплицированным данным другим группам пользователей.</li>
<li>Разделение подмножества базы данных между несколькими базами данных.</li>
</ul><br/>
Логическая репликация удобна тем, что вначале переносится схема данных. На ней можно тестировать возможность репликации заливкой данных с предварительно восстановленных резервных копий; проверять гипотезы по устранению возникающих при репликации проблем и имеющихся в базе ошибок проектирования. Также в этом случае появляется возможность внести и проверить такие изменения в схеме, которые на рабочей системе делать опасно. <br/>
<br/>
Это тот момент, когда можно сказать — «А помните, мы хотели уменьшить объём базы за счёт выравнивания? Давайте сейчас столбцы и перераспределим!». Также на стороне реплики возможно, например, провести перераспределение данных из одного столбца типа JSON в несколько других столбцов, или даже таблиц, либо наоборот, после чего заполнять уже доработанную и протестированную базу, при необходимости обрабатывая данные <s>напильником</s> триггерами. Можно какие-то поля отправить в TOAST, а какие-то наоборот — достать. В некоторых пределах можно поменять типы значений в столбцах. Также причиной выбора является возможность провести практически бесшовное обновление, одновременно с котором допустимо некоторое изменение схемы данных, а при некотором усердии — кардинальное перекраивание схемы данных. В общем, к списку добавляется один пункт:<br/>
<br/>
<ul>
<li>Трансформация схемы данных, в определённых пределах, практически без перерыва в обслуживании.</li>
</ul><br/>
Но, как и любой другой инструмент, логическая репликация имеет, помимо преимуществ, ещё и <a href="https://postgrespro.ru/docs/postgresql/12/logical-replication-restrictions">ограничения</a> и недостатки. Знать их не помешает, ведь приведённый над катом пример будет работать без проблем только в сферической учебной БД. <br/>
<br/>
<h2>Документация и примечания к выпускам</h2><br/>
Надо помнить, что поведение СУБД в различных мажорных версиях может заметно разниться. Поэтому перед обновлением, да и вообще, важно ознакомиться с <a href="https://postgrespro.ru/docs/postgresql/12/logical-replication">документацией</a> и списком изменений (<a href="https://postgrespro.ru/docs/postgresql/10/release">10</a>, <a href="https://postgrespro.ru/docs/postgresql/11/release">11</a>, <a href="https://postgrespro.ru/docs/postgresql/12/release">12</a>, <a href="https://postgrespro.ru/docs/postgresql/13/release">13</a>) и определить, какие из них могут изменить поведение вашей БД. <br/>
<br/>
Здесь не будет рассказываться о создании <a href="https://postgrespro.ru/docs/postgresql/13/sql-createpublication">публикаций</a> и <a href="https://postgrespro.ru/docs/postgresql/13/sql-createsubscription">подписок</a>, всё это есть в документации. Статья носит обзорный характер и не служит заменой документации. <br/>
<br/>
<h3>Примечание</h3><br/>
В статье приводится много примеров для воспроизведения которых лучше использовать <code>psql</code>, так как <code>pgcli</code> работает немного по-другому и перетащенный туда скрипт работает с ущербом для наглядности. Также создайте базу <code>test</code>, а в ней схему <code>ts</code>:<br/>
<br/>
<pre><code class="sql">CREATE DATABASE test;
\c test
CREATE SCHEMA ts; 
REVOKE ALL PRIVILEGES 
  ON DATABASE test
  FROM public; -- ведь у вас на проде всё точно так же?
---</code></pre><br/>
Не все скрипты можно перетаскивать как есть, в некоторых придётся поменять IP-адреса.<br/>
<b><i>Приведённые примеры кода ни в коем случае не выполняйте на экземплярах СУБД, которые кем-либо используются. Некоторые примеры приведены для демонстрации падения СУБД и могут принести немало неприятностей. Лучше всего создать пару ВМ и экспериментировать на них.</i></b><br/>
<br/>
<h2>Обновление до последней корректирующей (минорной) версии</h2><br/>
Первое, что нужно запланировать и сделать при подготовке к использованию логической репликации — обновиться на последнюю минорную версию, особенно если в создаваемых публикациях планируется использовать предложение <code>FOR ALL TABLES</code>.<br/>
<br/>
Почему стоит обновиться? Например, поэтому:<br/>
<br/>
<ol>
<li>В версиях 10.8 и 11.3 был исправлен <a href="https://www.postgresql.org/message-id/flat/f3f151f7-c4dd-1646-b998-f60bd6217dd3@2ndquadrant.com">баг</a> с обработкой изменений, вносящихся во временные и нежурналируемые таблицы. Данные в таких таблицах в логической репликации не участвуют, поэтому им не требуется настройка репликационных идентификаторов, но, при попытке обновить в таких таблицах данные, сервер выдавал сообщение об ошибке: <code>ERROR: cannot update table "logical_replication_test" because it does not have a replica identity and publishes updates</code> и отменял транзакцию. Хорошего в этом мало, поэтому, если ваше приложение использует временные или нежурналируемые таблицы, то обновление обязательно;</li>
<li>В версиях 10.11 и 11.6 был устранён <a href="https://www.postgresql.org/message-id/flat/a9139c29-7ddd-973b-aa7f-71fed9c38d75%40minerva.info">вывод ошибки</a> в случае, когда состав столбцов идентификации на мастере и на реплике различался. Правда и репликация изменения или удаления строк в таком случае <a href="index.html.1.108.html#uncosistecy">прекращается</a>;</li>
<li>В версиях 10.12, 11.7, 12.2 был устранено несколько багов, которые приводили к невозможности значительно изменять схему таблиц на реплике по сравнению со схемой таблиц на мастере. Например, на реплике нельзя было создавать дополнительные столбцы с функцией в качестве значения по умолчанию ("… clmname numeric DEFAULT random() ...").</li>
<li>В версиях 10.16, 11.11, 12.6 13.2 устранили утечки памяти в процессах walsender при передаче новых снимков для логического декодирования</li>
</ol><br/>
Как видите, для снижения километража истрёпанных нервов, предпочтительнее обновиться, пусть это и займёт некоторое время.<br/>
<br/>
<h2>Создание ролей и строк аутентификации в pg_hba.conf</h2><br/>
После минорного обновления следует создать те роли, которые планируется использовать для создания публикации и подписки. При этом требования к ролям на мастере и реплике немного <a href="https://postgrespro.ru/docs/postgresql/12/logical-replication-security">различаются</a>. <br/>
<br/>
В целом на реплике можно вообще не создавать отдельную роль, так как создание подписки разрешается только суперпользователям и применение полученных изменений происходит с правами суперпользователя. Поэтому на реплике можно пользоваться ролью <code>postgres</code>. <br/>
<br/>
На мастере быть суперпользователем не обязательно, но если планируется обновление, то этот вариант удобнее. Конечно, можно обойтись и без выделенной роли, но на мастере роль предпочтительно создать для того, чтоб ограничить возможность подключения только тем сервером, на который происходит репликация.<br/>
<br/>
Создать роль можно такой командой:<br/>
<br/>
<pre><code class="sql">SET password_encryption = 'scram-sha-256';
CREATE ROLE log_rep_rolename 
  WITH SUPERUSER 
       LOGIN
       PASSWORD 'sadp!'; -- sadp! = StrongAndDifficultPassword! 
-- По возможности избегайте кавычек (', ") в пароле,
-- его предстоит в строке подключения указывать.
</code></pre><br/>
В pg_hba.conf на мастере нужно добавить две записи: одну для локального подключения, другую для подключения с реплики. Предпочтительно указывать точные адреса реплик — лучше сто записей в pg_hba, чем одна дыра в безопасности.<br/>
<br/>
<pre><code class="plaintext">host  test  log_rep_rolename  127.0.0.1/32                     scram-sha-256
host  test  log_rep_rolename  192.168.122.95  255.255.255.255  scram-sha-256</code></pre><br/>
Обратите внимание что, несмотря на то что логическая репликация основана в значительной мере на потоковой, указывается не специальная запись <code>replication</code>, а имя базы или <code>all</code> — указание на все базы. Если указать <code>replication</code>, то создать подписку на реплике не получится из-за ошибки аутентификации.<br/>
<br/>
После этого перезагружаем настройки из-под суперпользователя:<br/>
<br/>
<pre><code class="sql">SELECT pg_reload_conf();
---</code></pre><br/>
<h2>Репликационные идентификаторы</h2><br/>
Весь процесс логической репликации в принципе строится на идее <i>репликационных идентификаторов</i>. Поэтому дальнейшая подготовка состоит в проверке наличия во всех реплицируемых таблицах либо первичного ключа, либо индекса, соответствующего некоторым минимальным требованиям и задействованного в <code>REPLICA IDENTITY USING INDEX</code>, либо назначении <code>REPLICA IDENTITY FULL</code>. То есть проверка наличия в таблицах <i>репликационных идентификаторов</i>. Они нужны для однозначной идентификации изменяемых или удаляемых строк при репликации команд <code>UPDATE</code> и <code>DELETE</code> и передаются на реплику в специальном поле для каждой записи.<br/>
<br/>
Репликационные идентификаторы можно не настраивать, или даже отключить, если планируется реплицировать только команды <code>INSERT</code>. Главное не забыть правильно создать публикацию — исключить из неё команды <code>UPDATE</code> и <code>DELETE</code>. Но если вам на реплике нужны актуальные данные из активно изменяющихся таблиц, а первичные ключи или уникальные <code>NOT NULL</code> индексы в таблицах отсутствуют, то репликационные идентификаторы придётся настраивать с нуля. Не выполнив это условие, можно добиться того, что <code>UPDATE</code> и <code>DELETE</code> будут приводить к <a href="index.html.1.108.html#update_delete_fail">отмене транзакций</a> на мастере, малоприятный факт на рабочей базе.<br/>
<br/>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title">Поиск таблиц, не имеющих репликационных идентификаторов</b>
                        <div class="spoiler_text"><pre><code class="sql">SELECT pgn.nspname || '.' || pgc.relname AS "Таблицы без репликационных идентификаторов"
  FROM pg_class AS pgc,
       pg_namespace AS pgn
  WHERE pgn.nspname !~ '^(?:pg_.*|information_schema)$'
    AND pgc.relreplident IN ('n', 'd')
    AND pgc.relkind IN ('r', 'p') 
    AND pgc.oid NOT IN (SELECT pgi.indrelid FROM pg_index AS pgi WHERE pgi.indisprimary)
    AND pgc.relnamespace = pgn.oid
    ORDER BY 1;
---</code></pre></div>
                    </div><br/>
<h3>Что может выступать в качестве репликационного идентификатора</h3><br/>
Как понятно из названия репликационных идентификаторов — они должны идентифицировать строки таблиц. Если в вашей таблице есть поле или комбинация полей, которая никогда не повторяется и поэтому позволяет идентифицировать строку, её следует либо объявить первичным ключом, либо создать по ней уникальный индекс. <br/>
<br/>
Если столбцов пригодных к роли репликационных идентификаторов нет, что очень странно, то придётся их создавать. Каждое значение в таком столбце должно быть уникальным. В качестве источника уникальности могут выступать как естественные, так и искусственные ключи и их комбинации — зависит от архитектуры базы данных. При этом неважно что именно использовать в качестве естественных ключей, главное, чтоб они выполняли роль однозначного идентификатора. В качестве искусственных ключей используются, как правило, различные последовательности и типы UUID. <br/>
<br/>
<h3>Последовательности</h3><br/>
Использовать последовательности при создании репликационных идентификаторов можно двумя с половиной способами: ручное указание вызова функции получения следующего значения последовательности, например <code><a href="https://postgrespro.ru/docs/postgresql/12/functions-sequence">nextval</a></code>; назначение столбцу последовательного псевдотипа <code><a href="https://postgrespro.ru/docs/postgresql/12/datatype-numeric#DATATYPE-SERIAL">serial</a></code>; использование <i>столбцов идентификации</i> в соответствии со стандартом SQL. Вполне рабочим вариантом может быть отсутствие значения по умолчанию, ведь можно возложить эту обязанность на приложение, но столбец должен быть <code>NOT NULL</code>.<br/>
<br/>
<b>SEQUENCE и serial</b><br/>
<br/>
Наиболее гибким и мощным является использование различных <a href="https://postgrespro.ru/docs/postgresql/12/sql-createsequence"><code>SEQUENCE</code></a>. В таком случае, после создания последовательности, значения по умолчанию для столбцов необходимо прописывать самостоятельно. При необходимости назначить таблицу-владельца последовательности также придётся поработать руками.<br/>
<br/>
Тип <code><a href="https://postgrespro.ru/docs/postgresql/12/datatype-numeric#DATATYPE-SERIAL">serial</a></code> это синтаксический сахар для обычного способа создания последовательностей, этакий шаблон. Всё что нужно сделать, это назначить столбцу тип smallserial/serial/bigserial.<br/>
<br/>
Использование типа <code>serial</code> менее гибко, но его использование позволяет избавиться от необходимости создавать последовательности вручную. Также такой последовательности автоматически назначается свойство <code>OWNED BY</code>. Это указание на столбец таблицы, при создании которого была создана последовательность. <br/>
<br/>
Такую последовательность в дальнейшем нельзя удалить, не удалив это указание. И здесь кроется опасность — удалив такую последовательность с указанием ключевого слова <code>CASCADE</code> можно устроить локальный армагеддон. В привязанном к удалённой последовательности столбце останется включенным свойство <code>NOT NULL</code>, а вот свойство <code>DEFAULT</code> обнулится.<br/>
<br/>
У полей <code>serial</code> есть ещё одна неприятная <a href="https://www.2ndquadrant.com/en/blog/postgresql-10-identity-columns">особенность</a> — пользователь без права на использование автоматически созданной последовательности, и с правами на <code>INSERT</code> в таблицу, практически вставку выполнять не сможет, если только не укажет значение поля <code>serial</code> вручную. Если не укажет, то получит ошибку доступа к соответствующей последовательности. В принципе это не проблема, нужно не забывать давать права на использование последовательности вместе с правами на вставку в таблицу.<br/>
<br/>
<b>Несколько таблиц на одной последовательности</b><br/>
Если нужно подключить к одной последовательности несколько таблиц, — делать это нужно самостоятельно. Для этого задаётся получение <code>nextval(нужная_последовательность)</code> в свойстве <code>DEFAULT</code> интересующего вас столбца. Воспользоваться можно и той последовательностью, что была создана с использованием <code>serial</code> — никто не мешает вручную прописать её для других таблиц, разве что потом будут некоторые проблемы с удалением самой первой таблицы: нужно будет поменять или удалить ссылку на таблицу-владельца такой последовательности: <code>ALTER SEQUENCE name_of_your_seq OWNED BY NONE</code>.<br/>
<br/>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title">Воспроизведение</b>
                        <div class="spoiler_text"><pre><code class="sql">CREATE TABLE t1 (i serial, t text);
CREATE TABLE t2 (i int NOT NULL DEFAULT nextval('t1_i_seq'), t text);
INSERT INTO t2 (t) VALUES('The first value in table t2');
INSERT INTO t1 (t) VALUES('The first value in table t1');
SELECT * FROM t1;
SELECT * FROM t2;
\d t2
DROP TABLE t1;
DROP SEQUENCE t1_i_seq;
DROP TABLE t1 CASCADE;
INSERT INTO t2 (t) VALUES('Maybe the second value in table t2');
\d t2
DROP TABLE t2;
---</code></pre></div>
                    </div><br/>
<b>Столбцы идентификации</b><br/>
<br/>
Пришедшие из стандарта SQL cтолбцы идентификации задаются либо при создании таблицы, либо ими могут стать имеющиеся столбцы, либо можно добавить такие столбцы отдельно. <br/>
<br/>
Последовательность, созданную для столбца идентификации, в отличие от первых полутора вариантов, не стоит использовать в других таблицах. В дальнейшем это помешает удалить исходную таблицу, а если удалить её с предложением <code>CASCADE</code>, то свойство <code>DEFAULT</code> у таблиц использовавших эту последовательность обнулится. При этом свойство <code>NOT NULL</code> никуда не денется.<br/>
<br/>
В результате появится шанс наблюдать на мастере орды <code>null value in column "i" violates not-null constraint</code>. С последовательностями, созданными с помощью <code>serial</code> тоже такое бывает, но для них это исправимо — поменяйте принадлежность последовательности либо на нужный столбец нужной таблицы, либо сделайте её «бесхозяйной». С последовательностями столбцов идентификации это не работает.<br/>
<br/>
Первичными ключами столбцы идентификации автоматически не становятся, это просто синтаксис назначения столбцу особых свойств, несколько отличающихся от обычных последовательностей. В частности, при типе <code>serial</code> вы можете спокойно проводить вставку любых произвольных значений в ключевые поля, за исключением имеющихся конечно (если на столбце включен <code>PRIMARY KEY</code>). <br/>
<br/>
Понятно, что это приведёт к тому, что однажды последовательность выдаст вставленные ранее произвольные значения и получившая их транзакция прервётся с ошибкой <a href="index.html.1.108.html#duplicate_key"><code>duplicate key</code></a>. Использование столбцов идентификации позволит не беспокоиться о таком развитии событий — в столбцы идентификации, созданные с ключом <code>ALWAYS</code>, вставить произвольное число не так просто, нужно использовать специальную форму команды <code>INSERT</code>. При создании таких столбцов поддерживаются те же параметры, что и при создании обычной последовательности.<br/>
<br/>
<b>Universally Unique IDentifiers</b><br/>
<br/>
Если назначить столбцу тип <a href="https://postgrespro.ru/docs/postgresql/12/datatype-uuid">UUID</a>, то значение для такого столбца не будет генерироваться автоматически. Для получения нового значения UUID необходимо пользоваться одним из двух дополнительных модулей: <a href="https://postgrespro.ru/docs/postgresql/12/uuid-ossp">uuid-ossp</a> или <a href="https://postgrespro.ru/docs/postgresql/12/uuid-ossp">pgcrypto</a><br/>
<br/>
В отличие от последовательностей UUID имеет длину не 16/32/64 бита, а 128 бит, — что нужно учитывать при расчётах нагрузки на сетевую подсистему. Зато у него есть то преимущество, что UUID генерирует такие строки, содержимое которых не повторяется в распределённых системах. <br/>
<br/>
К слову, при использовании последовательностей можно использовать независимые последовательности с добавлением префикса, уникального для каждого участвующего во взаимообмене данными сервера. Столбец в таком случае придётся сделать текстовым, но даже так получится экономичнее.<br/>
<br/>
В простейшем случае получать значения UUID можно через расширение <code>pg_crypto</code>. В нём есть только одна функция получения UUID:<br/>
<br/>
<pre><code class="sql">CREATE EXTENSION pgcrypto;
SELECT gen_random_uuid();</code></pre><br/>
Модуль <code>uuid-ossp</code>, в отличие от <code>pg_crypto</code> предоставляет больше возможностей по части выбора типа UUID. Если PostgreSQL установлен из пакетов, то можно сразу устанавливать расширение, только его имя обязательно нужно заключить в двойные кавычки, так как оно содержит дефис. Если собираете PostgreSQL из исходников, то нужно воспользоваться ключом --with-uuid=ossp (работает в Debian, как в RHEL — не знаю). Для этого, в дополнение к уже установленному постгресу, понадобится поставить несколько пакетов:<br/>
<br/>
<pre><code class="bash"># Debian Buster
#    пакет postgresql-10 можно установить до 
#    или после компиляции и установки расширения.
sudo apt-get install gcc libossp-uuid-dev libreadline-dev make zlib1g-dev
wget https://ftp.postgresql.org/pub/source/v10.16/postgresql-10.16.tar.gz
gunzip postgresql-10.16.tar.gz
tar xf postgresql-10.16.tar
cd postgresql-10.16
./configure --with-uuid=ossp
make
make install</code></pre><br/>
<pre><code class="sql">CREATE EXTENSION "uuid-ossp";
SELECT uuid_generate_v1();
SELECT uuid_generate_v1mc();
SELECT uuid_generate_v3(uuid_ns_url(), 'https://postgrespro.ru/');
SELECT uuid_generate_v4();
SELECT uuid_generate_v5(uuid_ns_dns(), 'postgrespro.ru');</code></pre><br/>
<h2>Первичные ключи и уникальные индексы</h2><br/>
Определившись с источниками уникальности нужно указать какой столбец, или какие столбцы, надлежит использовать как репликационные идентификаторы. По умолчанию ими являются первичные ключи. Они, как и уникальные индексы, позволяют добавлять на стороне реплики произвольное число столбцов, не опасаясь приостановки репликации при операциях <code>UPDATE</code> и <code>DELETE</code>.<br/>
<br/>
Главное, чтобы у добавленных столбцов не было назначено свойство <code>NOT NULL</code> с отсутствующим значением по умолчанию — при начальной репликации и репликации команды <code>INSERT</code> возникнет ошибка на стороне реплики, устранять которую возможно только на стороне реплики. На стороне мастера тут уже ничего не поделаешь, разве что удалить слот репликации — чтоб журнал предзаписи не переполнялся, и мастер не создавал каждые пять секунд процесс декодирования. Также можно запретить доступ через pg_hba.conf или на балансировщике, затем исправить неполадки на реплике и снова разрешить доступ.<br/>
<br/>
Перед началом репликации таблицы первичные ключи должны быть настроены с обоих сторон, а имеющиеся в реплицируемой таблице столбцы, даже не являющиеся репликационными идентификаторами, должны присутствовать и в реплицированной таблице. То есть на мастере нельзя удалять столбцы, если они есть на реплике.<br/>
<br/>
При непосредственном создании первичных ключей таблица блокируется на запись блокировкой <code>SHARE ROW EXCLUSIVE</code>. Поэтому предпочтительно использовать предварительное создание уникального индекса в режиме <code>CONCURRENTLY</code> и затем уже привязку его в качестве первичного ключа. Да — это ресурсоёмкая операция, зато доступность БД на запись не страдает.<br/>
<br/>
Обратите внимание на то, что если вы создаёте первичный ключ на столбце, не имеющем свойства <code>NOT NULL</code>, то такое свойство будет создано автоматически, но после после удаления ограничения автоматически не удалится. <br/>
<br/>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title">Демонстрация появления ограничения NOT NULL</b>
                        <div class="spoiler_text"><pre><code class="sql">CREATE TABLE ts.testt (i serial, clmn_1 text, clmn_2 int);
\d ts.testt
/*                          Table "ts.testt"
 Column |  Type   | Nullable |             Default             
--------+---------+----------+---------------------------------
 i      | integer | not null | nextval('testt_i_seq'::regclass)
 clmn_1 | text    |          | 
 clmn_2 | integer |          |                                   */
ALTER TABLE ts.testt ADD PRIMARY KEY (i, clmn_1);
\d ts.testt
/*                          Table "ts.testt"
 Column |  Type   | Nullable |             Default             
--------+---------+----------+---------------------------------
 i      | integer | not null | nextval('testt_i_seq'::regclass)
 clmn_1 | text    | not null | 
 clmn_2 | integer |          | 
Indexes:
    "testt_pkey" PRIMARY KEY, btree (i, clmn_1)                  */
ALTER TABLE ts.testt DROP CONSTRAINT testt_pkey;
\d ts.testt
/*                          Table "ts.testt"
 Column |  Type   | Nullable |             Default             
--------+---------+----------+---------------------------------
 i      | integer | not null | nextval('testt_i_seq'::regclass)
 clmn_1 | text    | not null | 
 clmn_2 | integer |          |                                   */
ALTER TABLE ts.testt ADD PRIMARY KEY (i);
\d ts.testt
/*                          Table "ts.testt"
 Column |  Type   | Nullable |             Default             
--------+---------+----------+---------------------------------
 i      | integer | not null | nextval('testt_i_seq'::regclass)
 clmn_1 | text    | not null | 
 clmn_2 | integer |          | 
Indexes:
    "testt_pkey" PRIMARY KEY, btree (i)                          */
ALTER TABLE ts.testt ALTER COLUMN clmn_1 DROP NOT NULL;
\d ts.testt
/*                          Table "ts.testt"
 Column |  Type   | Nullable |             Default             
--------+---------+----------+---------------------------------
 i      | integer | not null | nextval('testt_i_seq'::regclass)
 clmn_1 | text    |          | 
 clmn_2 | integer |          | 
Indexes:
    "testt_pkey" PRIMARY KEY, btree (i)                          */
DROP TABLE ts.testt;
---</code></pre></div>
                    </div><br/>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title">Пример работы с первичными ключами и последовательностями</b>
                        <div class="spoiler_text"><pre><code class="sql">-- ПОСЛЕДОВАТЕЛЬНОСТИ
-- Сначала создаём последовательность
CREATE SEQUENCE ts.testt_sequence AS bigint 
  INCREMENT BY 1 
  MINVALUE 1 
  NO MAXVALUE 
  START WITH 1 
  OWNED BY NONE;
\ds+ ts.testt_sequence
-- Затем создаём таблицу
-- Либо сразу с последовательностью
CREATE TABLE ts.testt (
  i bigint 
    PRIMARY KEY 
    NOT NULL 
    DEFAULT nextval('ts.testt_sequence'::regclass), 
  ac text);
\d+ ts.testt
DROP TABLE ts.testt;
-- Либо, если таблица и колонка уже существовали, добавляем недостающее
CREATE TABLE ts.testt (i bigint, ac text);
INSERT INTO ts.testt (i, ac) VALUES (1, '1'), (1, '2'), (2, '3'), (3, '4');
SELECT * FROM ts.testt;
ALTER TABLE ts.testt ALTER COLUMN i SET DEFAULT nextval('ts.testt_sequence');
INSERT INTO ts.testt (ac) VALUES ('5'), ('6'), ('7'), ('8');
SELECT * FROM ts.testt;
UPDATE ts.testt SET i = nextval('ts.testt_sequence'::regclass);
SELECT * FROM ts.testt;
ALTER TABLE ts.testt ALTER COLUMN i SET NOT NULL;
ALTER TABLE ts.testt ADD PRIMARY KEY (i);
\d+ ts.testt
DROP TABLE ts.testt;
DROP SEQUENCE ts.testt_sequence;
--
-- C использованием типа serial можно не создавать последовательность,
-- она будет создана автоматически
CREATE TABLE ts.testt (
  i bigserial PRIMARY KEY, 
  ac text);
\d+ ts.testt
-- В качестве первичного ключа можно задать несколько колонок
-- Сначала удалим старый первичный ключ
ALTER TABLE ts.testt DROP CONSTRAINT testt_pkey;
\d+ ts.testt
-- Затем создадим новый, двухколоночный.
ALTER TABLE ts.testt ADD PRIMARY KEY (i, ac);
\d+ ts.testt
DROP TABLE ts.testt;
--
-- СТОЛБЦЫ ИДЕНТИФИКАЦИИ
-- Можно сразу создать таблицу с соответствующими столбцами
CREATE TABLE ts.testt (
  i bigint
    GENERATED ALWAYS AS IDENTITY (
      INCREMENT BY 1 
      MINVALUE 1 
      START WITH 1) 
    PRIMARY KEY,
  ac text);
\d+ ts.testt
\d ts.testt_i_seq
-- Меняем ALWAYS на BY DEFAULT
ALTER TABLE ts.testt ALTER COLUMN i SET GENERATED BY DEFAULT;
\d+ ts.testt
\d ts.testt_i_seq
-- Удаляем IDENTITY со столбца
ALTER TABLE ts.testt ALTER COLUMN i DROP IDENTITY;
\d+ ts.testt
\d ts.testt_i_seq
-- Можно добавить IDENTITY имеющемуся столбцу 
ALTER TABLE ts.testt 
  ALTER COLUMN i ADD GENERATED ALWAYS AS IDENTITY (START WITH 1001);
\d+ ts.testt
\d ts.testt_i_seq
SELECT * FROM ts.testt_i_seq;
-- Можно добавить новый столбец с IDENTITY
ALTER TABLE ts.testt 
  ADD COLUMN impk bigint GENERATED ALWAYS AS IDENTITY;
\d+ ts.testt
\d ts.testt_impk_seq
-- В этот раз создадим первичный ключ через
-- предварительное создание уникального индекса
-- который создадим неблокирующим способом:
CREATE UNIQUE INDEX CONCURRENTLY testt_hm_idx ON ts.testt (i, impk);
ALTER TABLE ts.testt DROP CONSTRAINT testt_pkey,
    ADD CONSTRAINT hm_pkey PRIMARY KEY USING INDEX testt_hm_idx;
\d+ ts.testt
DROP TABLE ts.testt;
---</code></pre></div>
                    </div><br/>
<b>Уникальные индексы</b><br/>
<br/>
Наравне с первичными ключами можно использовать уникальные индексы, но их использование в качестве идентификатора репликации необходимо указывать явно с помощью предложения <code>... REPLICA IDENTITY USING INDEX name_of_index ...</code> и с ними нужно быть <a href="index.html.1.108.html#pk_and_idx_is_ud_fail">поосторожнее</a>. В отличие от первичных ключей столбцы, на которых строится индекс, нужно самостоятельно снабдить ограничением <code>NOT NULL</code>. <br/>
<br/>
Требования к индексам перечислены в документации: <i>индекс должен быть уникальным, не частичным, не отложенным и включать только столбцы, помеченные NOT NULL</i>. Состав столбцов, по которым построен индекс на мастере, должен совпадать с их составом на реплике. Если в нужных таблицах в реплицируемой схеме нет первичных ключей — можно на мастере создать уникальный индекс, назначить его репликационным идентификатором, а после переноса схемы на реплику — создать там идентичный по составу и порядку столбцов первичный ключ. Можно и наоборот.<br/>
<br/>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title">Пример репликации, где на мастере индекс, а на реплике ПК</b>
                        <div class="spoiler_text"><pre><code class="sql">-- Подготавливаем мастер
CREATE TABLE ts.testt (i serial, t text NOT NULL DEFAULT random(), d text DEFAULT random());
CREATE UNIQUE INDEX CONCURRENTLY testt_idx ON ts.testt USING btree (i, t);
ALTER TABLE ts.testt REPLICA IDENTITY USING INDEX testt_idx;
INSERT INTO ts.testt (t, d) VALUES ('001', 'first'), ('002', 'second'), ('003', 'third');
CREATE PUBLICATION testt_pub for TABLE ts.testt;
SELECT * FROM ts.testt;
-- Подготавливаем реплику
CREATE TABLE ts.testt (i serial, t text NOT NULL DEFAULT random(), d text DEFAULT random());
ALTER TABLE ts.testt ADD PRIMARY KEY (t, i);
CREATE SUBSCRIPTION testt_sub 
  CONNECTION 'host=192.168.122.182 
              dbname=test 
              user=log_rep_rolename 
              password=sadp!'
  PUBLICATION testt_pub;
SELECT pg_sleep(5.5);
SELECT * FROM ts.testt;
-- Выполняем на мастере вставку строки
INSERT INTO ts.testt (t, d) VALUES ('004', 'fourth');
SELECT * FROM ts.testt;
-- Проверяем на реплике - произошла репликация или нет
SELECT * FROM ts.testt;
-- Выполняем на мастере UPDATE
UPDATE ts.testt SET t = t || ' upd' WHERE random() >= 0.5;
INSERT INTO ts.testt (t, d) VALUES ('005', 'AFTER UPDATE');
SELECT * FROM ts.testt;
-- Проверяем на реплике - произошла репликация или нет
SELECT * FROM ts.testt; 
-- Выполняем на мастере DELETE
DELETE FROM ts.testt WHERE random() >= 0.5;
INSERT INTO ts.testt (t, d) VALUES ('006', 'AFTER DELETE');
SELECT * FROM ts.testt;
-- Проверяем на реплике - произошла репликация или нет
SELECT * FROM ts.testt;
-- Чистим реплику
DROP SUBSCRIPTION IF EXISTS testt_sub;
DROP TABLE IF EXISTS ts.testt;
-- Чистим мастер
DROP PUBLICATION IF EXISTS testt_pub;
DROP TABLE IF EXISTS ts.testt;
---</code></pre></div>
                    </div><br/>
<b>REPLICA IDENTITY FULL</b><br/>
<br/>
В отличие от первичных ключей и индексов при <code>REPLICA IDENTITY FULL</code> идентификатором служит вся строка. В этом случае в журнал предзаписи попадает вся старая строка и по протоколу репликации также передаётся вся старая строка. Не передаются только значения полей <code>TOAST</code> — если изменения их не коснулись. Исходя из этого можно представить, насколько разрастается объём хранимых и передаваемых данных. <br/>
<br/>
Поэтому от применения <code>REPLICA IDENTITY FULL</code> нужно максимально воздерживаться. Мало того — ошибки в его использовании могут привести к необходимости рестарта репликации. Когда используется <code>REPLICA IDENTITY FULL</code>, то состав столбцов в таблице на мастере и реплике преимущественно должен совпадать (порядок столбцов значения не имеет), иначе изменение и удаление данных реплицироваться не будет и последствия будут различаться в зависимости от того, где есть лишние столбцы — на мастере или на реплике.<br/>
<br/>
Если лишние столбцы будут на мастере и публикация будет создана для команд <code>UPDATE</code> и <code>DELETE</code> — репликация приостановится до тех пор, пока на реплике будут отсутствовать нужные столбцы. <br/>
<br/>
Вставка данных и начальная синхронизация не так строго ограничены по части состава столбцов — на реплике могут быть дополнительные столбцы, и они даже могут содержать какие-то данные. Но репликация будет идти благополучно для всех команд только если добавленные на реплике столбцы не содержат данных. Это связано с тем, что поля со значением <code>NULL</code> в идентификации строк не участвуют. <br/>
<br/>
Однако пользы от такого способа добавления столбцов немного — при обычном добавлении столбцов, без данных, перезаписи таблицы не происходит, поэтому добавлять пустые столбцы можно и на рабочей базе. <br/>
<br/>
Если же нужно менять данные на реплике, но на мастере нет возможности создать первичный ключ — его можно создать на реплике, тогда репликация всех команд будет происходить благополучно, хоть в дополнительных столбцах реплики и будут данные. Это работает, потому что в сообщениях протокола логической репликации, при <code>REPLICA IDENTITY FULL</code> на мастере, в качестве идентификатора отправляется вся строка старых данных и процесс применения сообщений выбирает из него значение того поля, которое на реплике является полем первичного ключа.<br/>
<br/>
<code>REPLICA IDENTITY FULL</code> удобно использовать для трансляции небольших, редко изменяемых таблиц или для таблиц с небольшим размером строк — им не нужны индексы на мастере и данные очень быстро пишутся и отправляются. На реплике же можно и индексы строить, и первичные ключи создавать — вполне удобно. Но для обновляемых данных в масштабных таблицах применять его очень опрометчиво.<br/>
<br/>
Включить для таблицы этот идентификатор крайне просто:<br/>
<br/>
<pre><code class="sql">ALTER TABLE ts.testt REPLICA IDENTITY FULL;</code></pre><br/>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title">Работа с REPLICA IDENTITY FULL</b>
                        <div class="spoiler_text"><pre><code class="sql">-- Подготавливаем мастер
CREATE TABLE ts.testt (i serial, t text, d text DEFAULT now());
ALTER TABLE ts.testt REPLICA IDENTITY FULL;
INSERT INTO ts.testt (t) VALUES ('first'), ('second'), ('third');
CREATE PUBLICATION testt_pub for TABLE ts.testt;
SELECT * FROM ts.testt;
-- Подготавливаем реплику
CREATE TABLE ts.testt (i serial, t text, d text);
ALTER TABLE ts.testt REPLICA IDENTITY FULL;
CREATE SUBSCRIPTION testt_sub 
  CONNECTION 'host=192.168.122.182 
              dbname=test 
              user=log_rep_rolename 
              password=sadp!'
  PUBLICATION testt_pub;
SELECT pg_sleep(5.5);
SELECT * FROM ts.testt;
-- Выполняем на мастере вставку строки
INSERT INTO ts.testt (t) VALUES ('INSERTED');
SELECT * FROM ts.testt;
-- Проверяем на реплике - произошла репликация или нет
SELECT * FROM ts.testt;
-- Выполняем на мастере UPDATE
UPDATE ts.testt SET t = t || ' upd' WHERE i = 1;
INSERT INTO ts.testt (t) VALUES ('AFTER UPDATE');
SELECT * FROM ts.testt;
-- Проверяем на реплике - произошла репликация или нет
SELECT * FROM ts.testt; 
-- Выполняем на мастере DELETE
DELETE FROM ts.testt WHERE i = 1;
INSERT INTO ts.testt (t) VALUES ('AFTER DELETE');
SELECT * FROM ts.testt;
-- Проверяем на реплике - произошла репликация или нет
SELECT * FROM ts.testt;
-- Чистим реплику
DROP SUBSCRIPTION IF EXISTS testt_sub;
DROP TABLE IF EXISTS ts.testt;
-- Чистим мастер
DROP PUBLICATION IF EXISTS testt_pub;
DROP TABLE IF EXISTS ts.testt;
---</code></pre></div>
                    </div><br/>
Если на мастере <code>REPLICA IDENTITY FULL</code> задана, то на реплике её наличие роли не играет — но только при условии, что состав столбцов таблицы на реплике идентичен таковому на мастере. Иначе на реплике будут применяться только команды <code>INSERT</code>, а если у вас 11 версия мастера — то и <code>TRUNCATE</code>. Команды <code>UPDATE</code> и <code>DELETE</code> будут применяться только если дополнительные столбцы в изменяемой/удаляемой строке будут равны NULL.<br/>
<br/>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title">Пример реплики с REPLICA IDENTITY NOTHING</b>
                        <div class="spoiler_text"><pre><code class="sql">-- Подготавливаем мастер
CREATE TABLE ts.testt (i serial, 
                       t text, 
                       d text);
ALTER TABLE ts.testt REPLICA IDENTITY FULL;
INSERT INTO ts.testt (t, d) VALUES ('001', 'first'), ('002', 'second'), ('003', 'third');
CREATE PUBLICATION testt_pub for TABLE ts.testt;
SELECT * FROM ts.testt;
-- Подготавливаем реплику
SELECT pg_reload_conf();
CREATE TABLE ts.testt (d text, 
                       t text,
                       i serial);
ALTER TABLE ts.testt REPLICA IDENTITY NOTHING;
CREATE SUBSCRIPTION testt_sub 
  CONNECTION 'host=192.168.122.182 
              dbname=test 
              user=log_rep_rolename
              password=sadp!'
  PUBLICATION testt_pub;
SELECT pg_sleep(5.5);
SELECT * FROM ts.testt;
-- Выполняем на мастере INSERT, UPDATE, DELETE
INSERT INTO ts.testt (t, d) VALUES ('004', 'fourth');
UPDATE ts.testt SET t = t || ' upd' WHERE i = 4;
DELETE FROM ts.testt WHERE i = 1;
SELECT * FROM ts.testt;
-- Проверяем на реплике - произошла репликация или нет
SELECT * FROM ts.testt;
-- Чистим реплику
DROP SUBSCRIPTION IF EXISTS testt_sub;
DROP TABLE IF EXISTS ts.testt;
-- Чистим мастер
DROP PUBLICATION IF EXISTS testt_pub;
DROP TABLE IF EXISTS ts.testt;
---</code></pre></div>
                    </div><br/>
Если нужно реплицировать исторические данные или провести только начальную синхронизацию — можно вообще убрать идентификаторы репликации: <br/>
<br/>
<pre><code class="sql">ALTER TABLE ts.testt REPLICA IDENTITY NOTHING;</code></pre><br/>
это снизит нагрузку на журнал предзаписи, декодирование и сеть. Но нужно обязательно создавать публикацию только для команд <code>INSERT</code>, иначе обновление и удаление в этой таблице работать перестанут, независимо от того — есть подписка или нет.<br/>
<br/>
<h3>Состав и порядок столбцов</h3><br/>
Вне зависимости от выбранных репликационных идентификаторов — порядок столбцов, даже ключевых — значения практически не имеет. Начальная синхронизация и репликация команд <code>INSERT</code> проходят без проблем, независимо от настройки репликационных идентификаторов — идентификаторы строк в этом случае не передаются.<br/>
<br/>
Если же бездумно добавлять столбцы к таблице с той или другой стороны, то, например, при <code>REPLICA IDENTITY FULL</code>, придётся перезапускать репликацию для такой таблицы. Причём, в зависимости от способа прицеливания в ногу, можно либо добиться <a href="index.html.1.108.html#uncosistecy">неконсистентности</a> на реплике, либо ещё и <a href="index.html.1.108.html#overgrowth_wal">раздуть</a> на мастере журнал предзаписи до невероятных размеров. Что, в одном случае, не даст возможности восстановить согласованность данных в проблемной таблице на реплике и приведёт к необходимости перезаливки данных. Во втором случае такая возможность останется (условно) и реализуется автоматически — после выявления и устранения причины такой ситуации, однако целостность данных после этого всё равно останется под сомнением.<br/>
<br/>
С первичными ключами и индексами ситуация значительно лучше. Хоть на реплике и нельзя удалять столбцы если такие есть на мастере, зато появляется возможность добавлять новые. И не просто добавлять, а различными способами заполнять их данными, без опаски получить остановку репликации или неконсистентность.<br/>
<br/>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title">Пример репликации с различным порядком столбцов</b>
                        <div class="spoiler_text"><pre><code class="sql">-- Подготавливаем мастер
CREATE TABLE ts.testt (i serial, 
                       t varchar NOT NULL DEFAULT random(), 
                       d varchar DEFAULT random());
CREATE UNIQUE INDEX CONCURRENTLY testt_idx ON ts.testt USING btree (i, t);
ALTER TABLE ts.testt REPLICA IDENTITY USING INDEX testt_idx;
INSERT INTO ts.testt (t, d) VALUES ('001', 'first'), ('002', 'second'), ('003', 'third');
CREATE PUBLICATION testt_pub for TABLE ts.testt;
SELECT * FROM ts.testt;
-- Подготавливаем реплику (Обратите внимание на типы)
CREATE TABLE ts.testt (d text DEFAULT random(), 
                       s text DEFAULT now(),
                       t text NOT NULL DEFAULT random(), 
                       i bigserial);
CREATE UNIQUE INDEX CONCURRENTLY testt_idx ON ts.testt USING btree (t, i);
ALTER TABLE ts.testt REPLICA IDENTITY USING INDEX testt_idx;
CREATE SUBSCRIPTION testt_sub 
  CONNECTION 'host=192.168.122.182 
              dbname=test 
              user=log_rep_rolename 
              password=sadp!'
  PUBLICATION testt_pub;
SELECT pg_sleep(5.5);
SELECT * FROM ts.testt;
-- Выполняем на мастере вставку строки
INSERT INTO ts.testt (t, d) VALUES ('004', 'fourth');
SELECT * FROM ts.testt;
-- Проверяем на реплике - произошла репликация или нет
SELECT * FROM ts.testt;
-- Выполняем на мастере UPDATE
UPDATE ts.testt SET t = t || ' upd' WHERE random() >= 0.5;
INSERT INTO ts.testt (t, d) VALUES ('005', 'AFTER UPDATE');
SELECT * FROM ts.testt;
-- Проверяем на реплике - произошла репликация или нет
SELECT * FROM ts.testt; 
-- Выполняем на мастере DELETE
DELETE FROM ts.testt WHERE random() >= 0.5;
INSERT INTO ts.testt (t, d) VALUES ('006', 'AFTER DELETE');
SELECT * FROM ts.testt;
-- Проверяем на реплике - произошла репликация или нет
SELECT * FROM ts.testt;
-- Чистим реплику
DROP SUBSCRIPTION IF EXISTS testt_sub;
DROP TABLE IF EXISTS ts.testt;
-- Чистим мастер
DROP PUBLICATION IF EXISTS testt_pub;
DROP TABLE IF EXISTS ts.testt;
---</code></pre></div>
                    </div><br/>
<h2>Склад грабель горизонтального хранения</h2><br/>
Предупреждён — значит вооружен. Ниже приведены несколько самых распространённых сообщений об ошибках и просто общих рассуждений. Лучше прочитать эти сообщения здесь, чем на рабочих серверах — читаем и вооружаемся. Если у вас есть что-нибудь интересное на эту тему — расскажите в комментариях.<br/>
<br/>
<h2><a name="update_delete_fail"></a>Если на мастере репликационные идентификаторы не заложены в бюджет</h2>По умолчанию публикация создаётся для команд <code>INSERT</code>, <code>UPDATE</code> и <code>DELETE</code> (и <code>TRUNCATE</code>, начиная с 11 версии). При этом проверки идентификаторов репликации в целевых таблицах не происходит, от этого может получиться так, что они будут не у всех таблиц. Мало того — после создания публикации допускается сброс или удаление репликационного идентификатора:<br/>
<br/>
<pre><code class="pgsql">ALTER TABLE tablename REPLICA IDENTITY DEFAULT;
ALTER TABLE tablename REPLICA IDENTITY NOTHING;</code></pre><br/>
Первое — сброс на значение по умолчанию, то есть на использование первичного ключа таблицы и если он есть — жить можно. Второе — отключение идентификаторов на таблице. Но если нет первичного ключа или идентификаторов вообще, то, при попытке выполнить на мастере обновление или удаление строк, будут получены соответствующие ошибки:<br/>
<br/>
<pre><code class="plaintext">ERROR:  cannot update table "tablename" because it does not have a replica identity and publishes updates
HINT:  To enable updating the table, set REPLICA IDENTITY using ALTER TABLE.

ERROR:  cannot delete from table "tablename" because it does not have a replica identity and publishes deletes
HINT:  To enable deleting from the table, set REPLICA IDENTITY using ALTER TABLE.</code></pre><br/>
Так будет в случае, когда публикация не создана исключительно для команд <code>INSERT</code> и, для одиннадцатой версии — <code>TRUNCATE</code>. Вариантов исправления такой ситуации два — изменить подписку на <code>publish='insert'</code> или добавить репликационные идентификаторы.<br/>
<br/>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title">Воспроизведение</b>
                        <div class="spoiler_text"><pre><code class="sql">-- Подготавливаем мастер
CREATE TABLE ts.testt (i serial, 
                       t varchar, 
                       d varchar);
ALTER TABLE ts.testt REPLICA IDENTITY NOTHING;
INSERT INTO ts.testt (t, d) VALUES ('001', 'first'), ('002', 'second'), ('003', 'third');
CREATE PUBLICATION testt_pub for TABLE ts.testt;
SELECT * FROM ts.testt;
-- Проверяем INSERT
INSERT INTO ts.testt (t, d) VALUES ('004', 'fourth');
-- Проверяем UPDATE
UPDATE ts.testt SET t = t || ' upd' WHERE i = 3;
-- Проверяем DELETE
DELETE FROM ts.testt WHERE i = 4;
SELECT * FROM ts.testt;
-- Исправляем публикацию
ALTER PUBLICATION testt_pub SET (publish = 'insert'); -- v.10
--ALTER PUBLICATION testt_pub SET (publish = 'insert, truncate'); -- v. >=11
-- Проверяем UPDATE
UPDATE ts.testt SET t = t || ' upd' WHERE i = 3;
-- Проверяем DELETE
DELETE FROM ts.testt WHERE i = 4;
SELECT * FROM ts.testt;
-- Чистим мастер
DROP PUBLICATION IF EXISTS testt_pub;
DROP TABLE IF EXISTS ts.testt;
---</code></pre></div>
                    </div><br/>
<h2><a name="uncosistecy"></a>... not find row.. .</h2><br/>
<pre><code class="plaintext">DEBUG:  logical replication did not find row for update in replication target relation "your_table_name"
DEBUG:  logical replication could not find row for delete in replication target relation "your_table_name"</code></pre> <br/>
Пример сообщений которые можно увидеть когда:<br/>
<br/>
<ul>
<li> на реплике добавили столбец и его значение не <code>NULL</code>;</li>
<li> на реплике по какой-либо причине строки отсутствуют, а на мастере они есть;</li>
<li> на реплике были изменены строки;</li>
<li> на реплике нет строки с переданным значением репликационного идентификатора</li>
</ul><br/>
Если на реплике сложилась одна из приведённых ситуаций, то, при обычном значении параметра <code>log_min_messages=warning</code>, этих сообщений в логах реплики не появится. От того и о пропавших данных можно узнать, когда будет уже очень поздно. А можно и не узнать. С точки зрения СУБД в таком поведении нет ничего предосудительного, возможно таков был план. Но если это не был план, то для приложения это катастрофа, так что тут нужно быть предусмотрительным и внимательным.<br/>
<br/>
Наблюдать эти сообщения в логах возможно при <code>log_min_messages=debug1</code>. Однако так увеличится объём логов, но консистентности данных не прибавится — реплика, получив сообщение об изменениях, не смогла найти изменяемую/удаляемую строку и благополучно выкинула сообщение на свалку истории, а второго шанса ей не предоставится. Мастер не будет уведомлен об этом и в свои логи писать ничего не станет. Следует учесть, что в этом режиме в лог будет записываться строка подключения, вместе с именем пользователя и его паролем — сомнительное преимущество использования такого уровня сообщений журнала. <br/>
<br/>
В данном случае можно радоваться хотя бы тому, что на мастере такое поведение почти никак не скажется. В этом случае реплика получает сообщения репликации, затем, не применив их, отчитывается мастеру, что всё хорошо и журнал предзаписи не разрастается. Конечно, после такого инцидента придётся выправлять сложившееся положение дел: <br/>
<br/>
<ol>
<li>На мастере исключать таблицу из публикации; </li>
<li>На реплике обновлять подписку и вычищать таблицу;</li>
<li>Привести состав столбцов к единому виду;</li>
<li>Включать на мастере таблицу в публикацию; </li>
<li>Обновлять подписку на реплике и ждать перезаливки данных.</li>
</ol><br/>
А всего нужно было — не добавлять столбцы в таблицу на стороне реплики если используется <code>REPLICA IDENTITY FULL</code> или не изменять, бездумно, данные на реплике.<br/>
<br/>
В отличие от <code>UPDATE</code> и <code>DELETE</code>, операция <code>INSERT</code> и начальная синхронизация будут нормально обрабатываться, даже если на реплике есть столбцы отсутствующие на мастере.<br/>
<br/>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title">Воспроизведение</b>
                        <div class="spoiler_text"><pre><code class="sql">-- Подготавливаем мастер
CREATE TABLE ts.testt (i serial, 
                       t varchar, 
                       d varchar);
ALTER TABLE ts.testt REPLICA IDENTITY FULL;
INSERT INTO ts.testt (t, d) 
  VALUES ('001', 'first'), ('002', 'second'), ('003', 'third');
CREATE PUBLICATION testt_pub for TABLE ts.testt;
SELECT * FROM ts.testt;
-- Подготавливаем реплику
SELECT setting AS lmm FROM pg_settings WHERE name = 'log_min_messages' \gset
ALTER SYSTEM SET log_min_messages=debug1;
SELECT pg_reload_conf();
CREATE TABLE ts.testt (i serial, 
                       t varchar, 
                       d varchar,
                       x numeric);
CREATE SUBSCRIPTION testt_sub 
  CONNECTION 'host=192.168.122.182 
              dbname=test 
              user=log_rep_rolename 
              password=sadp!'
  PUBLICATION testt_pub;
SELECT pg_sleep(5.5);
SELECT * FROM ts.testt;
-- Выполняем на мастере UPDATE и DELETE
UPDATE ts.testt SET t = t || ' upd' WHERE i = 2;
DELETE FROM ts.testt WHERE i = 3;
SELECT * FROM ts.testt;
-- Проверяем на реплике - произошла репликация или нет
-- Заодно меняем одну строчку и удаляем другую
SELECT * FROM ts.testt;
UPDATE ts.testt SET t = 'updated on the replica' WHERE i = 1;
DELETE FROM ts.testt WHERE i = 2;
SELECT * FROM ts.testt;
-- На мастере обновляем строку которой уже нет на реплике
-- а удаляем ту, которая есть, но уже отличается
-- от версии на мастере. Для того чтоб убедиться в 
-- том, что репликация прошла - после изменений вставим строки
-- если репликация приостановится, то вставленные строки
-- не появятся на реплике.
UPDATE ts.testt SET t = 'updated on the master' WHERE i = 2;
DELETE FROM ts.testt WHERE i = 1;
INSERT INTO ts.testt (t, d) 
  VALUES ('004', 'fourth'), ('005', 'fifth element'), ('006', 'sixth');
SELECT * FROM ts.testt; 
-- Проверяем на реплике - произошла репликация или нет
SELECT * FROM ts.testt; -- полимеры утрачены, смотрим логи
-- Добавляем первичные ключи через предварительное создание
-- уникального индекса.
-- Cначала на реплике, иначе ошибки приостановят репликацию
CREATE UNIQUE INDEX CONCURRENTLY testt_hm_idx ON ts.testt (i);
ALTER TABLE ts.testt
  ADD CONSTRAINT hm_pkey PRIMARY KEY USING INDEX testt_hm_idx;
-- Затем на мастере
CREATE UNIQUE INDEX CONCURRENTLY testt_hm_idx ON ts.testt (i);
ALTER TABLE ts.testt
  ADD CONSTRAINT hm_pkey PRIMARY KEY USING INDEX testt_hm_idx;
-- Изменим значения полей на реплике
UPDATE ts.testt SET t = 'updated on the replica again' WHERE i &lt;> 1;
SELECT * FROM ts.testt; 
-- Обновляем и удаляем пару строк на мастере.
-- Для того чтоб убедиться в том, что репликация
-- прошла - после изменений вставим строку.
-- Если репликация приостановится, то вставленная строка
-- не появится на реплике.
UPDATE ts.testt SET t = 'recently updated on the master' WHERE i = 6;
DELETE FROM ts.testt WHERE i = 4;
INSERT INTO ts.testt (t, d) 
  VALUES ('007', 'seventh');
SELECT * FROM ts.testt; 
-- Проверяем на реплике - произошла репликация или нет
-- i=4 удалён, i=6 обновлён, новая строка появилась
-- вот что PK животворящий делает!
SELECT * FROM ts.testt; 
-- Чистим реплику
DROP SUBSCRIPTION IF EXISTS testt_sub;
DROP TABLE IF EXISTS ts.testt;
ALTER SYSTEM SET log_min_messages = :lmm;
SELECT pg_reload_conf();
-- Чистим мастер
DROP PUBLICATION IF EXISTS testt_pub;
DROP TABLE IF EXISTS ts.testt;
---</code></pre></div>
                    </div><br/>
<h2><a name="overgrowth_wal"></a>Лишний столбец на мастере</h2><br/>
Если же случилось так, что кто-то удосужился создать лишний столбец на мастере, то на реплике начнёт появляться множество таких сообщений: <br/>
<br/>
<pre><code class="plaintext">DEBUG:  starting logical replication worker for subscription "your_subscription_name"
DEBUG:  registering background worker "logical replication worker for subscription 16766"
DEBUG:  starting background worker process "logical replication worker for subscription 16766"
LOG:  logical replication apply worker for subscription "your_subscription_name" has started
DEBUG:  connecting to publisher using connection string "host=192.168.122.182 dbname=your_db_name"
ERROR:  logical replication target relation "public.your_table_name" is missing some replicated columns
DEBUG:  unregistering background worker "logical replication worker for subscription 16766"
LOG:  background worker "logical replication worker" (PID 10708) exited with exit code 1</code></pre><br/>
А на мастере множество таких:<br/>
<br/>
<pre><code class="plaintext">DEBUG:  received replication command: IDENTIFY_SYSTEM
DEBUG:  received replication command: START_REPLICATION SLOT "your_subscription_name" LOGICAL 0/0 (proto_version '1', publication_names '"your_publication_name"')
LOG:  starting logical decoding for slot "your_subscription_name"
DETAIL:  streaming transactions committing after 0/1AC5FAD0, reading WAL from 0/1AC5FA98
LOG:  logical decoding found consistent point at 0/1AC5FA98
DETAIL:  There are no running transactions.
DEBUG:  got new restart lsn 0/1AC5FC40 at 0/1AC5FC40
DEBUG:  "your_subscription_name" has now caught up with upstream server</code></pre><br/>
То есть вставка, изменение и удаление строк не принимается репликой, ведь на стороне реплики нет столбцов для поступивших данных. О сложившейся ситуации мастер «информируется». В этом случае на реплике постоянно создаётся и уничтожается новый процесс репликации для сбойной подписки.<br/>
<br/>
В результате на мастере начнёт раздувать журнал предзаписи независимо от типа операции. Так можно довести и до останова сервера, не заметив вовремя разбухание журнала. Удаление столбца на стороне мастера не спасёт — логическое декодирование будет использовать записи из журнала предзаписи, а там добавленный столбец есть и никуда не денется. Также не спасёт и удаление таблицы из публикации — это связано с тем, что публикацией может пользоваться несколько подписок и такое лекарство окажется опаснее болезни, потому и возможность такую не реализовали. <br/>
<br/>
Лично я считаю, что для публикаций с одним подписчиком не помешает добавить такую возможность — но пока что разработчики так не думают. В общем имеется три варианта: <br/>
<br/>
<ul>
<li>Добавить на реплику недостающий столбец и надеяться, что на обоих серверах их содержимое совпадает (\x6c6f6c), иначе все операции <code>UPDATE</code> и <code>DELETE</code> по несовпадающим строкам пропадут и оставят после себя уже знакомые записи в логе "<code>... not find row for ...</code>" — это относится к <code>REPLICA IDENTITY FULL</code>. <br/>
<br/>
Отсутствие в добавленном столбце данных, имеющихся на мастере, приведет к тому, что пробка, конечно, рассосётся — только вот накопившиеся операции <code>INSERT</code> данных попадут в таблицу на реплике, а <code>UPDATE</code> и <code>DELETE</code> — нет. Потому что идентификатором строки будет вся строка, а в одном из столбцов данные не совпадают. <br/>
<br/>
Выбор так себе, но так можно относительно безопасно разгрести журнал предзаписи на мастере и не доводить до второго способа. Ну а далее — чистим публикацию от проблемной таблицы, обновляем подписку, добавляем таблицу обратно в публикацию, добавляем в таблицу недостающие столбцы, обновляем подписку, ждём. Если же на обоих серверах нормальные репликационные идентификаторы — первичный ключ или уникальный индекс — репликация восстановится без потерь данных.</li>
<li>Удалить подписку целиком и создать вновь, не забыв очистить таблицу перед пересозданием, ну и столбцы в неё добавить. Сработает потому, что удалится слот на стороне мастера.</li>
<li>Можно, на основе общего с мастером столбца, создать на реплике первичный ключ, или уникальный индекс в качестве <code>REPLICA IDENTITY</code>. После этого добавить недостающий столбец. Однако, при этом нужно быть уверенным, что значения в выбранном для репликационного идентификатора столбце — уникальны для всех строк таблицы. Тут возникает вопрос — почему первичный ключ не был создан сразу?</li>
</ul><br/>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title">Воспроизведение</b>
                        <div class="spoiler_text"><pre><code class="sql">-- Подготавливаем мастер
CREATE TABLE ts.testt (i serial, 
                       t varchar, 
                       d varchar);
ALTER TABLE ts.testt REPLICA IDENTITY FULL;
INSERT INTO ts.testt (t, d) 
  VALUES ('001', 'first'), ('002', 'second'), ('003', 'third');
CREATE PUBLICATION testt_pub for TABLE ts.testt;
SELECT * FROM ts.testt;
-- Подготавливаем реплику
CREATE TABLE ts.testt (i serial, 
                       t text);
CREATE SUBSCRIPTION testt_sub 
  CONNECTION 'host=192.168.122.182 
              dbname=test 
              user=log_rep_rolename 
              password=sadp!'
  PUBLICATION testt_pub;
SELECT pg_sleep(5.5);
SELECT * FROM ts.testt;
-- Смотрим логи, потом добавляем на реплике недостающий столбец
ALTER TABLE ts.testt ADD COLUMN d text;
SELECT pg_sleep(5.5);
SELECT * FROM ts.testt;
-- Чистим реплику
DROP SUBSCRIPTION IF EXISTS testt_sub;
DROP TABLE IF EXISTS ts.testt;
-- Чистим мастер
DROP PUBLICATION IF EXISTS testt_pub;
DROP TABLE IF EXISTS ts.testt;
---</code></pre></div>
                    </div><br/>
<h2><a name="duplicate_key"></a>Дубликаты значений в столбцах репликационных идентификаторов или «Раньше думать надо было!»</h2><br/>
<pre><code class="plaintext">При начальной синхронизации
ERROR:  duplicate key value violates unique constraint "testt_pkey"
DETAIL:  Key (i)=(3) already exists.
CONTEXT:  COPY testt, line 3  -- Заодно узнали какой командой переносятся данные при ничальной синхронизации

После перехода в режим репликации
ERROR:  duplicate key value violates unique constraint "testt_pkey"
DETAIL:  Key (i)=(4) already exists.</code></pre><br/>
Возникают такие ошибки потому, что с мастера на реплику приходит новая строка с имеющимся на реплике значением репликационного идентификатора на основе первичного ключа или уникального индекса. При обновлении логической репликацией или простом переносе данных такие ошибки не появляются. Они появляются если база находится в доступе на запись для пользователей или приложений и те этим пользуются. По сути, это не ошибка PostgreSQL, это ошибка проектирования и вопросы нужно задавать себе.<br/>
<br/>
Исправлять такие инциденты не так уж и просто — сначала необходимо определить какая из двух конфликтующих строк неправильная, и насколько. Если неправильным является содержимое строки на реплике, то репликация продолжится после удаления с реплики такой строки. <br/>
<br/>
Совсем другое дело, когда неправильной является строка, пришедшая с мастера. В этом случае всё равно придётся либо удалять строку на реплике, либо назначать ей заведомо большой идентификатор; ждать завершения загрузки с мастера отставших транзакций; заменять пришедшую с мастера строку старой строкой с реплики.<br/>
<br/>
Ситуация в обоих случаях усугубляется тем, что лишних строк может быть очень много. Настолько, что новые транзакции будут выполняться быстрее, чем будут разбираться конфликтные ситуации. И всё время, пока расследуется инцидент, размер журнала предзаписи будет разрастаться, а пользователи реплики не будут иметь возможности получать актуальные данные. <br/>
<br/>
Если предполагается использовать логическую репликацию не для обновления, а для обмена данными между различными базами — следует очень внимательно проработать вопрос об идентификации строк. Так как для идентификации, обычно, используются последовательности, то можно посоветовать пробежаться по слайдам доклада CTO Stickeroid Ai, Камиля Исламова <a href="https://pgconf.ru/media/2020/02/04/%D0%9A%D0%B0%D0%BC%D0%B8%D0%BB%D1%8C%20%D0%98%D1%81%D0%BB%D0%B0%D0%BC%D0%BE%D0%B2%20-%20%D0%9C%D0%B5%D1%82%D0%BE%D0%B4%D1%8B%20%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F%20Sequences%20%D0%B2%20%D0%B1%D0%B8%D0%B7%D0%BD%D0%B5%D1%81-%D0%BB%D0%BE%D0%B3%D0%B8%D0%BA%D0%B5.pdf">о способах применения последовательностей в PostgreSQL</a> и документацию по последовательностям, затем перепроектировать их в сбойной системе баз данных.<br/>
<br/>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title">Воспроизведение</b>
                        <div class="spoiler_text"><pre><code class="sql">-- Подготавливаем мастер
CREATE TABLE ts.testt (i serial PRIMARY KEY, 
                       t varchar);
ALTER TABLE ts.testt REPLICA IDENTITY FULL;
INSERT INTO ts.testt (t) 
  VALUES ('001'), ('002'), ('003');
CREATE PUBLICATION testt_pub for TABLE ts.testt;
SELECT * FROM ts.testt;
-- Подготавливаем реплику
CREATE TABLE ts.testt (i bigserial PRIMARY KEY, 
                       t text);
INSERT INTO ts.testt (i, t) 
  VALUES (3, '003 only replica value'),
         (4, '004 only replica value');
CREATE SUBSCRIPTION testt_sub 
  CONNECTION 'host=192.168.122.182 
              dbname=test 
              user=log_rep_rolename 
              password=sadp!'
  PUBLICATION testt_pub;
SELECT pg_sleep(5.5);
SELECT * FROM ts.testt;
-- Смотрим логи, потом удаляем лишнюю строчку на реплике
-- на мастере удалять не поможет - порядок применения
-- сообщений репликации - транзакционный. Удаленная на мастере
-- строка удалится на реплике только после разрешения инцидента.
DELETE FROM ts.testt WHERE i = 3;
SELECT pg_sleep(5.5);
SELECT * FROM ts.testt;
-- Чистим реплику
DROP SUBSCRIPTION IF EXISTS testt_sub;
DROP TABLE IF EXISTS ts.testt;
-- Чистим мастер
DROP PUBLICATION IF EXISTS testt_pub;
DROP TABLE IF EXISTS ts.testt;
---</code></pre></div>
                    </div><br/>
<h2><a name="nnwd"></a>Столбец NOT NULL без DEFAULT на реплике</h2><br/>
<pre><code class="plaintext">ERROR:  null value in column "column_name" violates not-null constraint</code></pre><br/>
Для любых столбцов на реплике не должно быть установлено свойство <code>NOT NULL</code> без указания значения по умолчанию. Особенно это касается тех столбцов, которые есть на мастере, потому что на реплике для них значение <code>DEFAULT</code> подставляться не будет — как пришел <code>NULL</code>, так и будет записываться. <br/>
<br/>
Если в дополнительные <code>NOT NULL</code> столбцы значение по умолчанию не поставить, то репликация приостановится с приведённой выше ошибкой. Как только удалите такой столбец, зададите ему значение по умолчанию или удалите ограничение <code>NOT NULL</code> — репликация возобновится без потери данных.<br/>
<br/>
Если в реплицируемой таблице на стороне мастера изначально есть значения <code>NULL</code> — сначала необходимо заполнить такие поля, либо удалить ограничение <code>NOT NULL</code> на реплике.<br/>
<br/>
При появлении такой ошибки в начале репликации можно узнать из логов название проблемной таблицы, но не схему в которой она расположена:<br/>
<br/>
<pre><code class="plaintext">ERROR:  null value in column "d" violates not-null constraint
DETAIL:  Failing row contains (3, 003, null).
CONTEXT:  COPY testt, line 3: "3    003     \N"</code></pre><br/>
Если же начальная синхронизация давно закончилась и репликация идёт полным ходом, то в логах записи о таблице не будет — придётся искать вручную.<br/>
<br/>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title">Воспроизведение</b>
                        <div class="spoiler_text"><pre><code class="sql">-- Подготавливаем мастер
CREATE TABLE ts.testt (i serial PRIMARY KEY, t text, d text);
INSERT INTO ts.testt (t, d) VALUES ('001', 'first'), ('002', 'second'), ('003', NULL);
CREATE PUBLICATION testt_pub for TABLE ts.testt;
SELECT * FROM ts.testt;
-- Подготавливаем реплику
CREATE TABLE ts.testt (i serial PRIMARY KEY, t text, d text NOT NULL DEFAULT 'null from master');
CREATE SUBSCRIPTION testt_sub 
  CONNECTION 'host=192.168.122.182 
              dbname=test 
              user=log_rep_rolename 
              password=sadp!'
  PUBLICATION testt_pub;
SELECT pg_sleep(5.5);
SELECT * FROM ts.testt;
-- Начальная синхронизация не сработала - смотрите логи
-- Исправляем проблему со столбцом d
-- Добавляем новый столбец, которого нет на мастере
ALTER TABLE ts.testt ALTER COLUMN d DROP NOT NULL,
                     ALTER COLUMN d DROP DEFAULT;
SELECT pg_sleep(5.5);
SELECT * FROM ts.testt;
ALTER TABLE ts.testt ADD COLUMN x text NOT NULL DEFAULT 'start default';
ALTER TABLE ts.testt ALTER COLUMN x DROP DEFAULT;
SELECT * FROM ts.testt;
-- Выполняем на мастере вставку
INSERT INTO ts.testt (t) VALUES ('004');
SELECT * FROM ts.testt;
-- Проверяем логи реплике - там уже куча ошибок
-- Затем исправляем на реплике проблему
-- Либо убираем NOT NULL
--   ALTER TABLE ts.testt ALTER COLUMN x DROP NOT NULL;
-- Либо добавляем DEFAULT
--   ALTER TABLE ts.testt ALTER COLUMN x SET DEFAULT 'second default';
-- Либо удаляем столбец
--   ALTER TABLE ts.testt DROP COLUMN x;
-- Проверяем на реплике - произошла репликация или нет
SELECT pg_sleep(5.5);
SELECT * FROM ts.testt;
-- Чистим реплику
DROP SUBSCRIPTION IF EXISTS testt_sub;
DROP TABLE IF EXISTS ts.testt;
-- Чистим мастер
DROP PUBLICATION IF EXISTS testt_pub;
DROP TABLE IF EXISTS ts.testt;
---</code></pre></div>
                    </div><br/>
<h2><a name="mhpk_rhnpk_ud"></a>На мастере есть первичный ключ, на реплике он отсутствует</h2><br/>
<pre><code class="plaintext">ERROR:  logical replication target relation "ts.testt" has neither REPLICA IDENTITY index nor PRIMARY KEY and published relation does not have REPLICA IDENTITY FULL</code></pre><br/>
Ошибка наблюдается при репликации команд <code>UPDATE</code> и <code>DELETE</code>, если в таблице на реплике отсутствует первичный ключ, который есть на мастере. Повторяется до тех пор, пока на реплике не будет создан соответствующий первичный ключ. Репликация при этом приостанавливается и продолжается после устранения причины ошибки. Состав столбцов на обоих серверах либо идентичен, либо на реплике могут быть дополнительные столбцы; порядок столбцов может различаться.<br/>
<br/>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title">Воспроизведение</b>
                        <div class="spoiler_text"><pre><code class="sql">-- Подготавливаем мастер
CREATE TABLE ts.testt (i serial PRIMARY KEY, t text, d text);
INSERT INTO ts.testt (t, d) VALUES ('001', 'first'), ('002', 'second'), ('003', 'third');
CREATE PUBLICATION testt_pub for TABLE ts.testt;
SELECT * FROM ts.testt;
-- Подготавливаем реплику
CREATE TABLE ts.testt (i serial, t text, d text); 
CREATE SUBSCRIPTION testt_sub 
  CONNECTION 'host=192.168.122.182 
              dbname=test 
              user=log_rep_rolename 
              password=sadp!'
  PUBLICATION testt_pub;
SELECT pg_sleep(5.5);
SELECT * FROM ts.testt;
-- Выполняем на мастере обновление
UPDATE ts.testt SET t = t || ' updated' WHERE i = 1;
INSERT INTO ts.testt (t, d) VALUES ('004', 'AFTER UPDATE');
SELECT * FROM ts.testt;
-- Проверяем на реплике - произошла репликация или нет
SELECT pg_sleep(5.5);
SELECT * FROM ts.testt; -- репликация не произошла
-- Исправляем на реплике отсутствие первичного ключа, ждём, проверяем репликацию, удаляем первичный ключ для воспроизведения ошибки при удалении строки.
ALTER TABLE ts.testt ADD PRIMARY KEY (i);
SELECT pg_sleep(5.5);
SELECT * FROM ts.testt; -- репликация возобновилась
ALTER TABLE ts.testt DROP CONSTRAINT testt_pkey;
-- Выполняем на мастере удаление
DELETE FROM ts.testt WHERE i = 1;
INSERT INTO ts.testt (t, d) VALUES ('005', 'AFTER DELETE');
SELECT * FROM ts.testt;
-- Проверяем на реплике - произошла репликация или нет
SELECT pg_sleep(5.5);
SELECT * FROM ts.testt; -- репликация не произошла
-- Исправляем на реплике отсутствие первичного ключа, ждём, проверяем репликацию
ALTER TABLE ts.testt ADD PRIMARY KEY (i);
SELECT pg_sleep(5.5);
SELECT * FROM ts.testt; -- репликация возобновилась
-- Чистим реплику
DROP SUBSCRIPTION IF EXISTS testt_sub;
DROP TABLE IF EXISTS ts.testt;
-- Чистим мастер
DROP PUBLICATION IF EXISTS testt_pub;
DROP TABLE IF EXISTS ts.testt;
---</code></pre></div>
                    </div><br/>
<br/>
<h2><a name="dpk"></a>На мастере и реплике первичные ключи или индексы построены на разных столбцах</h2><br/>
<pre><code class="plaintext">ERROR:  publisher did not send replica identity column expected by the logical replication target relation "ts.testt"</code></pre><br/>
Ошибка появляется при репликации команд <code>UPDATE</code> и <code>DELETE</code>, если в таблице на реплике первичный ключ (индекс) построен не на том столбце, на котором построен первичный ключ (индекс) на мастере. Повторяется до тех пор, пока на реплике не будет удалён неправильный и не будет создан правильный первичный ключ (индекс). <br/>
<br/>
Репликация при этом приостанавливается и продолжается после устранения причины ошибки. На реплике могут быть дополнительные столбцы, порядок столбцов может различаться.<br/>
<br/>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title">Воспроизведение</b>
                        <div class="spoiler_text"><pre><code class="sql">-- Подготавливаем мастер
CREATE TABLE ts.testt (i serial PRIMARY KEY, t text, d text);
INSERT INTO ts.testt (t, d) VALUES ('001', 'first'), ('002', 'second'), ('003', 'third');
CREATE PUBLICATION testt_pub for TABLE ts.testt;
SELECT * FROM ts.testt;
-- Подготавливаем реплику
CREATE TABLE ts.testt (i serial, t text PRIMARY KEY, d text); 
CREATE SUBSCRIPTION testt_sub 
  CONNECTION 'host=192.168.122.182 
              dbname=test 
              user=log_rep_rolename 
              password=sadp!'
  PUBLICATION testt_pub;
SELECT pg_sleep(5.5);
SELECT * FROM ts.testt;
-- Выполняем на мастере обновление
UPDATE ts.testt SET t = t || ' upd' WHERE i = 1;
INSERT INTO ts.testt (t, d) VALUES ('004', 'AFTER UPDATE');
SELECT * FROM ts.testt;
-- Проверяем на реплике - произошла репликация или нет
SELECT pg_sleep(5.5);
SELECT * FROM ts.testt; -- посмотреть ошибки
-- Исправляем на реплике неправильный первичный ключ, ждём, проверяем репликацию, возвращаем неправильный первичный ключ для воспроизведения ошибки при удалении строки.
ALTER TABLE ts.testt DROP CONSTRAINT testt_pkey;
ALTER TABLE ts.testt ADD PRIMARY KEY (i);
SELECT pg_sleep(5.5);
SELECT * FROM ts.testt; -- репликация возобновилась
ALTER TABLE ts.testt DROP CONSTRAINT testt_pkey;
ALTER TABLE ts.testt ADD PRIMARY KEY (t);
-- Выполняем на мастере удаление
DELETE FROM ts.testt WHERE i = 1;
INSERT INTO ts.testt (t, d) VALUES ('005', 'AFTER DELETE');
SELECT * FROM ts.testt;
-- Проверяем на реплике - произошла репликация или нет
SELECT pg_sleep(5.5);
SELECT * FROM ts.testt; -- репликация не произошла
-- Исправляем на реплике неправильный первичный ключ, ждём, проверяем репликацию.
ALTER TABLE ts.testt DROP CONSTRAINT testt_pkey;
ALTER TABLE ts.testt ADD PRIMARY KEY (i);
SELECT pg_sleep(5.5);
SELECT * FROM ts.testt; -- репликация возобновилась
-- Чистим реплику
DROP SUBSCRIPTION IF EXISTS testt_sub;
DROP TABLE IF EXISTS ts.testt;
-- Чистим мастер
DROP PUBLICATION IF EXISTS testt_pub;
DROP TABLE ts.testt;
---</code></pre></div>
                    </div><br/>
<h2><a name="pk_and_idx_is_ud_fail"></a>Фантомного индекса боль</h2><br/>
<pre><code class="plaintext">ERROR:  cannot delete from table "test" because it does not have a replica identity and publishes deletes
HINT:  To enable deleting from the table, set REPLICA IDENTITY using ALTER TABLE.</code></pre><br/>
Ошибка очень интересная и наблюдается на мастере при выполнении команд <code>UPDATE</code> и <code>DELETE</code>, если в таблице на мастере в качестве репликационного идентификатора использовался уникальный индекс, который потом удалили, например потому, что создали взамен первичный ключ, или просто так удалили (всяко быват, уж мы их ругам-ругам, ничо не помогат). <br/>
<br/>
Ошибку эту можно получить только на мастере и только на таблицах, включенных в публикации, поддерживающие <code>UPDATE</code> и <code>DELETE</code>. Вообще эта ошибка означает именно отсутствие любого репликационного идентификатора, но в данном случае всё немного интереснее — идентификатором остаётся индекс, который удалили.<br/>
<br/>
Чтоб исправить ошибку нужно вернуть <code>REPLICA IDENTITY DEFAULT</code>, перенацелив тем самым поиcк идентификатора туда, где он есть — на первичный ключ. Также можно воссоздать индекс и снова перенацелиться на него, так как oid у него будет уже другой, и система не будет его видеть. <br/>
<br/>
Если же нет времени строить индексы и первичные ключи — включаем <code>REPLICA IDENTITY FULL</code>, а уж затем восстанавливаем индексы и так далее. В рабочих системах начинать изменения нужно с реплики, иначе вылезут другие ошибки.<br/>
<br/>
Идентифицировать именно такой вариант развития событий не так уж и просто, хотя бы потому, что никому такое в голову не придёт. И, не приведи вселенная, если ещё до вас кто-то удалил и снова создал индекс — выявить причину происходящего будет практически невозможно.<br/>
<br/>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title">Воспроизведение</b>
                        <div class="spoiler_text"><pre><code class="sql">-- Воспроизводить на мастере
-- Создаём таблицу
CREATE TABLE ts.testt (i serial, t text, d text);
-- Создаём индекс
CREATE UNIQUE INDEX CONCURRENTLY testt_idx ON ts.testt USING btree (i);
-- Назначаем индекс в качестве репликационного идентификатора
ALTER TABLE ts.testt REPLICA IDENTITY USING INDEX testt_idx;
-- Информация о таблице отображает индекс как REPLICA IDENTITY
\d ts.testt
-- Смотрим что назначено репликационным идентификатором
-- relreplident = i, т.е. индекс
SELECT relname, relreplident -- i-index, d-default
  FROM pg_class 
  WHERE oid = 'ts.testt'::regclass;
-- Без следующей строки ошибка воспроизводится, но не так наглядно.
ALTER TABLE ts.testt ADD CONSTRAINT pkey PRIMARY KEY (i); 
-- Добавился первичный ключ в информации по таблице
\d ts.testt
-- Смотрим что назначено репликационным идентификатором
-- всё ещё relreplident = i, т.е. индекс
-- так и должно быть, ведь ПК как РИ не назначали
SELECT relname, relreplident -- i-index, d-default
  FROM pg_class 
  WHERE oid = 'ts.testt'::regclass;
CREATE PUBLICATION testt_pub for TABLE ts.testt;
INSERT INTO ts.testt (t, d) VALUES ('001', 'first'), ('002', 'second'), ('003', 'third');
DROP INDEX ts.testt_idx;
-- После удаления индекса - информации про него нет
\d ts.testt
-- Смотрим что назначено репликационным идентификатором
-- всё ещё relreplident = i, т.е. индекс
-- несмотря на то, что индекса уже нет, он всё ещё РИ
SELECT relname, relreplident -- i-index, d-default
  FROM pg_class 
  WHERE oid = 'ts.testt'::regclass;
-- Сейчас будут ошибки, а посмотришь на \d testt выполненный выше
-- то непонятно, как же так - первичный ключ ведь есть.
-- есть-то он есть, да вот только запрос к pg_class
-- показывает что идентификатором служит индекс - i, а не d - default
-- а индекс-то этот уже удалён
UPDATE ts.testt SET t = t || ' upd' WHERE i = 1;
DELETE FROM ts.testt WHERE i = 3;
-- Cоздаём одноимённый индекс обратно и попробуйте
-- найти в чем причина ошибки - индекс-то существует, идентификатором
-- он вроде как назначен...
CREATE UNIQUE INDEX CONCURRENTLY testt_idx ON ts.testt USING btree (i);
ALTER TABLE ts.testt REPLICA IDENTITY USING INDEX testt_idx;
-- Смотрим есть ли индексы на таблице со столбцом indisreplident=t 
-- и такой индекс есть, это воссозданный исходный индекс
SELECT pgc.oid, pgc.relname, pgi.indisreplident
  FROM pg_class AS pgc,
     pg_index AS pgi
  WHERE pgc.oid = pgi.indexrelid
    AND pgi.indrelid IN (SELECT oid FROM pg_class WHERE relname = 'testt');
-- а тут написано что идентификатором служит индекс:
\d ts.testt 
-- Однако UPDATE и DELETE так и не работают
UPDATE ts.testt SET t = t || ' upd' WHERE i = 1;
DELETE FROM ts.testt WHERE i = 3;
-- Пустим в ход дефибриллятор:
ALTER TABLE ts.testt REPLICA IDENTITY DEFAULT;
ALTER TABLE ts.testt REPLICA IDENTITY USING INDEX testt_idx;
\d ts.testt
SELECT relname, relreplident -- i-index, d-default
  FROM pg_class 
  WHERE oid = 'ts.testt'::regclass;
-- Визуально в свойствах таблицы всё то же самое, но теперь всё работает
UPDATE ts.testt SET t = t || ' upd' WHERE i = 1;
DELETE FROM ts.testt WHERE i = 3;
DROP TABLE ts.testt;
DROP PUBLICATION testt_pub;
-- Не полагайтесь только на /d, всегда ищите и в системных каталогах!
-- Если индекс есть, то не факт, что он используется.
---</code></pre></div>
                    </div><br/>
<h2><a name="wrong_type"></a>Непреобразуемые типы</h2><br/>
<pre><code class="plaintext">При начальной синхронизации
ERROR:  invalid input syntax for type bigint: "\xaabbcc"
CONTEXT:  COPY testt, line 1, column t: "\xaabbcc"

После перехода в режим репликации
ERROR:  invalid input syntax for type bigint: "\xdeadbeef"
CONTEXT:  processing remote data for replication target relation "ts.testt" column "t", remote type bytea, local type bigint</code></pre><br/>
Ошибка наблюдается на любом этапе репликации, если в таблице на реплике есть хотя бы один столбец, в тип которого нельзя преобразовать полученный с мастера тип данных. Повторяется до тех пор, пока на реплике не будет исправлена таблица. Репликация при этом приостанавливается и продолжается после устранения причины ошибки. <br/>
<br/>
И здесь снова неполная информация о том, в какой таблице произошла ошибка. То есть при начальной синхронизации в строке с контекстом есть информация о таблице, но не о схеме. Но, если уже после начальной синхронизации столбец был изменён, то информация будет полноценной.<br/>
<br/>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title">Воспроизведение</b>
                        <div class="spoiler_text"><pre><code class="sql">-- Подготавливаем мастер
CREATE TABLE ts.testt (i serial PRIMARY KEY, t bytea);
INSERT INTO ts.testt (t) VALUES('\xaabbcc'::bytea);
SELECT * FROM ts.testt;
CREATE PUBLICATION testt_pub FOR TABLE ts.testt;
-- Подготавливаем реплику
CREATE TABLE ts.testt (i bigserial PRIMARY KEY, t bigint);
CREATE SUBSCRIPTION testt_sub 
  CONNECTION 'host=192.168.122.182 
              dbname=test 
              user=log_rep_rolename 
              password=sadp!'
  PUBLICATION testt_pub;
SELECT pg_sleep(5.5);
SELECT * FROM ts.testt; 
-- Начальная синхронизация не прошла
-- Всё - ошибка в логах, теперь надо её исправить.
-- Вот это вот не поможет:
ALTER TABLE ts.testt ALTER COLUMN t SET DATA TYPE bytea USING t::bytea;
-- Только так:
ALTER TABLE ts.testt DROP COLUMN t, ADD COLUMN t bytea;
SELECT pg_sleep(5.5);
SELECT * FROM ts.testt; -- Убеждаемся в завершении начальной синхронизации
-- Начальная синхронизаация завершилась и на реплике
-- снова поменяем столбец на неправильный
ALTER TABLE ts.testt DROP COLUMN t, ADD COLUMN t bigint;
-- Вставим данные на мастере
INSERT INTO ts.testt (t) VALUES('\xdeadbeef'::bytea);
SELECT * FROM ts.testt;
-- Всё - репликация снова на паузе
SELECT * FROM ts.testt;
-- Снова ремонтируем, но делаем такой тип данных,
-- в который можно преобразовать bytea
ALTER TABLE ts.testt DROP COLUMN t, ADD COLUMN t text; 
SELECT pg_sleep(5.5);
SELECT * FROM ts.testt; -- Убеждаемся в работе репликации
-- Чистим реплику
DROP SUBSCRIPTION testt_sub;
DROP TABLE ts.testt;
-- Чистим мастер
DROP PUBLICATION testt_pub;
DROP TABLE ts.testt;
---</code></pre></div>
                    </div><br/>
<h2>И такое может пригодиться, если что-то натворили непонятное</h2><br/>
<pre><code class="sql">-- Удаление слота на мастере
SELECT pg_drop_replication_slot('test_sub');
-- Удаление подписки на реплике при отсутствующем слоте
ALTER SUBSCRIPTION testt_sub DISABLE;
ALTER SUBSCRIPTION testt_sub SET (slot_name=NONE);
DROP SUBSCRIPTION testt_sub;</code></pre><br/>
<h2>Общие замечания</h2><br/>
Лучше первичных ключей нет на свете репликационных идентификаторов. В случае, когда в таблице отсутствует <code>PRIMARY KEY</code> и его добавление невозможно, то всегда имеется возможность создать его используя <a href="https://postgrespro.ru/docs/postgresql/10/sql-createindex#SQL-CREATEINDEX-CONCURRENTLY">неблокирующее построение индекса</a> с последующим назначением его ограничением первичного ключа. <br/>
<br/>
Выполнять создание индексов желательно до переноса схемы данных, с тем, чтоб они перенеслись на реплику в составе схемы БД, ну или не забыть создать их и на реплике. К тому же на реплике возможно сразу создать первичный ключ с аналогичным составом столбцов ещё до начала репликации.<br/>
<br/>
Использовать <code>REPLICA IDENTITY FULL</code> стоит только если строки в таблице незначительного размера и редко изменяются. При использовании такого типа идентификатора желательно воздержаться от изменения структуры принимающей таблицы.<br/>
<br/>
Если после переноса схемы вам необходимо поменять в ней некоторые таблицы, то возможно проверять безопасность изменений в новой базе используя специально восстановленную резервную копию мастера как источник данных и устанавливая <code>log_min_messages=debug1</code> для проверки правильности работы репликации по части <code>UPDATE</code> и <code>DELETE</code>. Изменение этого параметра не требует перезапуска сервера, поэтому возможно его переключать в любое время, например на время проверки внесенных изменений.<br/>
<br/>
После начала репликации на мастере нельзя добавлять столбцы, а если добавлять, то начинать надо с реплики.<br/>
<br/>
Новые столбцы с <code>NOT NULL</code> на реплике хороши только если в комплекте идёт <code>DEFAULT</code>.<br/>
<br/>
Ошибки могут случаться, но в большинстве случаев они некритичные и легко устраняются, только нужно с умом подойти к выбору репликационных идентификаторов. Если речь идёт не об обновлении, а о более сложных схемах применения логической репликации, то к проектированию системы в целом нужно подойти очень ответственно, иначе можно отправить всё в нокдаун или потерять данные.<br/>
<br/>
И на сладкое: можно добиться того, что системные каталоги на реплике сохранят информацию о подписках, которые, как казалось, были удалены. Тут может помочь только реинициализация кластера БД. В таком случае команда <code>\dRs</code> показывает наличие подписки, а <code>SELECT * FROM pg_subscription;</code> — нет. При этом на реплике все необходимые для обслуживания процессы запускаются, но ничего полезного не делают, кроме множества ошибок в логах (не можем подключиться, слота нет...), даже при специально повторно созданных объектах и слотах. То есть было утеряно некоторое количество внутренней информации о подписке. За месяц экспериментов такое положение дел было достигнуто только два раза, и оба раза это произошло после отправки хоста тестовых виртуалок в ждущий или спящий режим. Хоть и получалось так не всегда — не делайте так. Но случиться такое с хост-системой всё-таки может, так что про такую вероятность нужно знать.</div></div></div> <DIV class="v-portal" style="display:none;"></DIV></div> <!----> <!----></div> <div class="tm-article-presenter__meta"><div class="tm-separated-list tm-article-presenter__meta-list"><span class="tm-separated-list__title">Теги:</span> <ul class="tm-separated-list__list"><li class="tm-separated-list__item"><a href="https://habr.com/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5Bpostgersql%5D" class="tm-tags-list__link">postgersql</a></li><li class="tm-separated-list__item"><a href="https://habr.com/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5Bpostgres%20pro%5D" class="tm-tags-list__link">postgres pro</a></li><li class="tm-separated-list__item"><a href="https://habr.com/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5B%D0%BB%D0%BE%D0%B3%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B0%D1%8F%20%D1%80%D0%B5%D0%BF%D0%BB%D0%B8%D0%BA%D0%B0%D1%86%D0%B8%D1%8F%5D" class="tm-tags-list__link">логическая репликация</a></li></ul></div> <div class="tm-separated-list tm-article-presenter__meta-list"><span class="tm-separated-list__title">Хабы:</span> <ul class="tm-separated-list__list"><li class="tm-separated-list__item"><a href="https://habr.com/ru/company/postgrespro/blog/" class="tm-hubs-list__link router-link-active">
    Блог компании Postgres Professional
  </a></li><li class="tm-separated-list__item"><a href="https://habr.com/ru/hub/postgresql/" class="tm-hubs-list__link">
    PostgreSQL
  </a></li><li class="tm-separated-list__item"><a href="https://habr.com/ru/hub/db_admins/" class="tm-hubs-list__link">
    Администрирование баз данных
  </a></li><li class="tm-separated-list__item"><a href="https://habr.com/ru/hub/data_engineering/" class="tm-hubs-list__link">
    Data Engineering
  </a></li></ul></div></div></article></div> <!----></div> <div class="tm-article-sticky-panel"><div class="tm-data-icons tm-article-sticky-panel__icons"><div class="tm-article-rating tm-data-icons__item"><div class="tm-votes-meter tm-article-rating__votes-switcher"><svg height="24" width="24" class="tm-svg-img tm-votes-meter__icon tm-votes-meter__icon_appearance-article"><title>Всего голосов 11: ↑10 и ↓1</title> <use xlink:href="/img/megazord-v25.4b679db1.svg#counter-rating"></use></svg> <span title="Всего голосов 11: ↑10 и ↓1" class="tm-votes-meter__value tm-votes-meter__value_positive tm-votes-meter__value_appearance-article tm-votes-meter__value_rating">+9</span></div> <DIV class="v-portal" style="display:none;"></DIV></div> <!----> <span title="Количество просмотров" class="tm-icon-counter tm-data-icons__item"><svg height="24" width="24" class="tm-svg-img tm-icon-counter__icon"><title>Просмотры</title> <use xlink:href="/img/megazord-v25.4b679db1.svg#counter-views"></use></svg> <span class="tm-icon-counter__value">12K</span></span> <button title="Добавить в закладки" type="button" class="bookmarks-button tm-data-icons__item"><span title="Добавить в закладки" class="tm-svg-icon__wrapper bookmarks-button__icon"><svg height="24" width="24" class="tm-svg-img tm-svg-icon"><title>Добавить в закладки</title> <use xlink:href="/img/megazord-v25.4b679db1.svg#counter-favorite"></use></svg></span> <span title="Количество пользователей, добавивших публикацию в закладки" class="bookmarks-button__counter">
    74
  </span></button> <!----> <div title="Поделиться" class="tm-sharing tm-data-icons__item"><button type="button" class="tm-sharing__button"><svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" class="tm-sharing__icon"><path fill="currentColor" d="M13.8 13.8V18l7.2-6.6L13.8 5v3.9C5 8.9 3 18.6 3 18.6c2.5-4.4 6-4.8 10.8-4.8z"></path></svg></button> <DIV class="v-portal" style="display:none;"></DIV></div> <DIV class="v-portal" style="display:none;"></DIV></div> </div></div> <DIV class="v-portal" style="display:none;"></DIV> <div class="tm-article-presenter__footer"><div class="tm-article-blocks"><!----> <section class="tm-block tm-block_spacing-bottom"><!----> <div class="tm-block__body tm-block__body_variant-balanced"><div class="tm-article-author"><div class="tm-article-author__company"><div class="tm-article-author__company-card"><div class="tm-company-snippet"><a href="https://habr.com/ru/company/postgrespro/profile/" class="tm-company-snippet__logo-link"><div class="tm-entity-image"><img alt="" height="40" src="https://habrastorage.org/getpro/habr/company/4e0/339/621/4e0339621abc865fefb88f9e9f44748f.jpg" width="40" class="tm-entity-image__pic"></div></a> <div class="tm-company-snippet__info"><a href="https://habr.com/ru/company/postgrespro/profile/" class="tm-company-snippet__title">Postgres Professional</a> <div class="tm-company-snippet__description">Разработчик СУБД Postgres Pro</div></div></div> <div class="tm-article-author__buttons"><!----> <!----></div></div> <div class="tm-article-author__company-contacts"><a href="https://facebook.com/PostgresProfessional" rel="noopener" target="_blank" class="tm-article-author__contact">
      Facebook
    </a><a href="https://twitter.com/PostgresPro" rel="noopener" target="_blank" class="tm-article-author__contact">
      Twitter
    </a><a href="https://vk.com/public101507899" rel="noopener" target="_blank" class="tm-article-author__contact">
      ВКонтакте
    </a><a href="https://plus.google.com/+PostgresproRuCompany" rel="noopener" target="_blank" class="tm-article-author__contact">
      Google+
    </a><a href="https://postgrespro.livejournal.com/" rel="noopener" target="_blank" class="tm-article-author__contact">
      LiveJournal
    </a></div> <div class="tm-article-author__separator"></div></div> <div class="tm-user-card tm-article-author__user-card tm-user-card_variant-article"><div class="tm-user-card__info-container"><div class="tm-user-card__header"><div class="tm-user-card__header-data"><a href="https://habr.com/ru/users/korva/" class="tm-user-card__userpic tm-user-card__userpic_size-40"><div class="tm-entity-image"><img alt="" src="https://habrastorage.org/getpro/habr/avatars/11b/0d4/905/11b0d4905c5dbe422c3998cfc9aa59cc.jpg" class="tm-entity-image__pic"></div></a> <div class="tm-user-card__meta"><div title=" 15 голосов " class="tm-karma tm-user-card__karma"><div class="tm-karma__votes tm-karma__votes_positive">
    3
  </div> <div class="tm-karma__text">
    Карма
  </div></div> <div title="Рейтинг пользователя" class="tm-rating tm-user-card__rating"><div class="tm-rating__header"> <div class="tm-rating__counter">0</div></div> <div class="tm-rating__text">
    Рейтинг
  </div></div></div></div></div> <div class="tm-user-card__info tm-user-card__info_variant-article"><div class="tm-user-card__title tm-user-card__title_variant-article"><span class="tm-user-card__name tm-user-card__name_variant-article">Коротких Василий</span> <a href="https://habr.com/ru/users/korva/" class="tm-user-card__nickname tm-user-card__nickname_variant-article">
          @korva
        </a> <!----></div> <p class="tm-user-card__short-info tm-user-card__short-info_variant-article">Пользователь</p></div></div> <div class="tm-user-card__buttons tm-user-card__buttons_variant-article"><!----> <!----> <!----> <!----> <!----></div></div> <!----></div> <DIV class="v-portal" style="display:none;"></DIV></div> <!----></section> <div class="tm-article-blocks__comments"><div class="tm-article-page-comments"><div class="tm-article-comments-counter-link tm-article-comments-counter-button"><a href="https://habr.com/ru/company/postgrespro/blog/489308/comments/" class="tm-article-comments-counter-link__link tm-article-comments-counter-link__link_button-style"><svg height="24" width="24" class="tm-svg-img tm-article-comments-counter-link__icon tm-article-comments-counter-link__icon_contrasted"><title>Комментарии</title> <use xlink:href="/img/megazord-v25.4b679db1.svg#counter-comments"></use></svg> <span class="tm-article-comments-counter-link__value tm-article-comments-counter-link__value_contrasted">
       Комментарии 5 
    </span></a> <!----></div></div></div>  <!----> <!----> <!----> </div></div></div></div></div> <div class="tm-page__sidebar"><div class="tm-layout-sidebar"><div class="tm-layout-sidebar__placeholder_initial"></div> <div class="tm-sexy-sidebar tm-sexy-sidebar_initial" style="margin-top:0px;"><!----> <section class="tm-block tm-block_spacing-bottom"><header class="tm-block__header"><h2 class="tm-block__title">Информация</h2> <!----></header> <div class="tm-block__body"><div class="tm-company-basic-info"><dl class="tm-description-list tm-description-list_variant-columns-nowrap"><dt class="tm-description-list__title tm-description-list__title_variant-columns-nowrap">Дата основания</dt> <dd class="tm-description-list__body tm-description-list__body_variant-columns-nowrap"><time datetime="2015-01-26T21:00:00.000Z" title="2015-01-27, 00:00">27  января  2015</time></dd></dl> <dl class="tm-description-list tm-description-list_variant-columns-nowrap"><dt class="tm-description-list__title tm-description-list__title_variant-columns-nowrap">Местоположение</dt> <dd class="tm-description-list__body tm-description-list__body_variant-columns-nowrap">
    Россия
  </dd></dl> <dl class="tm-description-list tm-description-list_variant-columns-nowrap"><dt class="tm-description-list__title tm-description-list__title_variant-columns-nowrap">Сайт</dt> <dd class="tm-description-list__body tm-description-list__body_variant-columns-nowrap"><a href="http://www.postgrespro.ru/" target="_blank" class="tm-company-basic-info__link">
      www.postgrespro.ru
    </a></dd></dl> <dl class="tm-description-list tm-description-list_variant-columns-nowrap"><dt class="tm-description-list__title tm-description-list__title_variant-columns-nowrap">Численность</dt> <dd class="tm-description-list__body tm-description-list__body_variant-columns-nowrap">
    101–200 человек
  </dd></dl> <dl class="tm-description-list tm-description-list_variant-columns-nowrap"><dt class="tm-description-list__title tm-description-list__title_variant-columns-nowrap">Дата регистрации</dt> <dd class="tm-description-list__body tm-description-list__body_variant-columns-nowrap"><time datetime="2015-09-30T07:41:09.000Z" title="2015-09-30, 10:41">30  сентября  2015</time></dd></dl> <dl class="tm-description-list tm-description-list_variant-columns-nowrap"><dt class="tm-description-list__title tm-description-list__title_variant-columns-nowrap">Представитель</dt> <dd class="tm-description-list__body tm-description-list__body_variant-columns-nowrap"><a href="https://habr.com/ru/users/x-wao/" class="tm-company-basic-info__link">
      Иван Панченко
    </a></dd></dl></div></div> <!----></section> <div class="tm-company-widgets"></div> <!----></div></div></div></div></div></div></main> <!----></div> <div class="tm-footer-menu"><div class="tm-page-width"><div class="tm-footer-menu__container"><div class="tm-footer-menu__block"><h3 class="tm-footer-menu__block-title">
          Ваш аккаунт
        </h3> <div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><li class="tm-footer-menu__list-item"><a href="https://habr.com/kek/v1/auth/habrahabr/?back=/ru/company/postgrespro/blog/489308/&amp;hl=ru" rel="nofollow" target="_self">
                Войти
              </a></li><li class="tm-footer-menu__list-item"><a href="https://habr.com/kek/v1/auth/habrahabr-register/?back=/ru/company/postgrespro/blog/489308/&amp;hl=ru" rel="nofollow" target="_self">
                Регистрация
              </a></li></ul></div></div><div class="tm-footer-menu__block"><h3 class="tm-footer-menu__block-title">
          Разделы
        </h3> <div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><li class="tm-footer-menu__list-item"><a href="https://habr.com/ru/" class="footer-menu__item-link router-link-active">
                Публикации
              </a></li><li class="tm-footer-menu__list-item"><a href="https://habr.com/ru/news/" class="footer-menu__item-link">
                Новости
              </a></li><li class="tm-footer-menu__list-item"><a href="https://habr.com/ru/hubs/" class="footer-menu__item-link">
                Хабы
              </a></li><li class="tm-footer-menu__list-item"><a href="https://habr.com/ru/companies/" class="footer-menu__item-link">
                Компании
              </a></li><li class="tm-footer-menu__list-item"><a href="https://habr.com/ru/users/" class="footer-menu__item-link">
                Авторы
              </a></li><li class="tm-footer-menu__list-item"><a href="https://habr.com/ru/sandbox/" class="footer-menu__item-link">
                Песочница
              </a></li></ul></div></div><div class="tm-footer-menu__block"><h3 class="tm-footer-menu__block-title">
          Информация
        </h3> <div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><li class="tm-footer-menu__list-item"><a href="https://habr.com/ru/docs/help/" class="footer-menu__item-link">
                Устройство сайта
              </a></li><li class="tm-footer-menu__list-item"><a href="https://habr.com/ru/docs/authors/codex/" class="footer-menu__item-link">
                Для авторов
              </a></li><li class="tm-footer-menu__list-item"><a href="https://habr.com/ru/docs/companies/corpblogs/" class="footer-menu__item-link">
                Для компаний
              </a></li><li class="tm-footer-menu__list-item"><a href="https://habr.com/ru/docs/docs/transparency/" class="footer-menu__item-link">
                Документы
              </a></li><li class="tm-footer-menu__list-item"><a href="https://account.habr.com/info/agreement" target="_blank">
                Соглашение
              </a></li><li class="tm-footer-menu__list-item"><a href="https://account.habr.com/info/confidential/" target="_blank">
                Конфиденциальность
              </a></li></ul></div></div><div class="tm-footer-menu__block"><h3 class="tm-footer-menu__block-title">
          Услуги
        </h3> <div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><li class="tm-footer-menu__list-item"><a href="https://docs.google.com/presentation/d/e/2PACX-1vQLwRfQmXibiUlWaRg-BAc38s7oM3lJiaPju7qmdJsp8ysIvZ_G-Npem0njJLMozE2bPHMpDqiI5hhy/pub?start=false&amp;loop=false&amp;delayms=60000&amp;slide=id.g91a03369cd_4_297" target="_blank">
                Реклама
              </a></li><li class="tm-footer-menu__list-item"><a href="https://habrastorage.org/storage/stuff/habr/service_price.pdf" target="_blank">
                Тарифы
              </a></li><li class="tm-footer-menu__list-item"><a href="https://docs.google.com/presentation/d/e/2PACX-1vQJJds8-Di7BQSP_guHxICN7woVYoN5NP_22ra-BIo4bqnTT9FR6fB-Ku2P0AoRpX0Ds-LRkDeAoD8F/pub?start=false&amp;loop=false&amp;delayms=60000" target="_blank">
                Контент
              </a></li><li class="tm-footer-menu__list-item"><a href="https://tmtm.timepad.ru/" target="_blank">
                Семинары
              </a></li><li class="tm-footer-menu__list-item"><a href="https://habr.com/ru/megaprojects/" class="footer-menu__item-link">
                Мегапроекты
              </a></li></ul></div></div></div></div></div> <div class="tm-footer"><div class="tm-page-width"><div class="tm-footer__container"><!----> <div class="tm-footer__social"><a href="https://www.facebook.com/habrahabr.ru" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Facebook</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-facebook"></use></svg></a><a href="https://twitter.com/habr_com" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Twitter</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-twitter"></use></svg></a><a href="https://vk.com/habr" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>VK</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-vkontakte"></use></svg></a><a href="https://telegram.me/habr_com" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Telegram</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-telegram"></use></svg></a><a href="https://www.youtube.com/channel/UCd_sTwKqVrweTt4oAKY5y4w" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Youtube</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-youtube"></use></svg></a><a href="https://zen.yandex.ru/habr" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Яндекс Дзен</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-zen"></use></svg></a></div> <DIV class="v-portal" style="display:none;"></DIV> <button class="tm-footer__link"><!---->
        Настройка языка
      </button> <a href="https://habr.com/ru/about" class="tm-footer__link">
        О сайте
      </a> <a href="https://habr.com/ru/feedback/" class="tm-footer__link">
        Техническая поддержка
      </a> <!----> <a href="https://habr.com/berserk-mode-nope" class="tm-footer__link">
        Вернуться на старую версию
      </a> <div class="tm-footer-copyright"><span class="tm-copyright"><span class="tm-copyright__years">© 2006–2022 </span> <span class="tm-copyright__name">«<a href="https://company.habr.com/" rel="noopener" target="_blank" class="tm-copyright__link">Habr</a>»</span></span></div></div></div></div> <!----> <!----></div> <div class="vue-portal-target"></div></div>
<script>window.__INITIAL_STATE__={"adblock":{"hasAcceptableAdsFilter":false,"hasAdblock":false},"articlesList":{"articlesList":{"489308":{"id":"489308","timePublished":"2021-02-28T19:38:29+00:00","isCorporative":true,"lang":"ru","titleHtml":"Логическая репликация в PostgreSQL. Репликационные идентификаторы и популярные ошибки","leadData":{"textHtml":"\u003Cdiv style=\"text-align:center;\"\u003E\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fwebt\u002Frc\u002F4w\u002Fc4\u002Frc4wc4pblkhrdji9tkuwdwvt2ro.jpeg\" alt=\"image\"\u003E\u003C\u002Fdiv\u003E\u003Cbr\u003E\r\nНачиная с 10 версии, перенести данные с одной базы PostgreSQL на другую несложно, с обновлением, без обновления — неважно. Об этом немало сказано и сказанное сводится к следующему: на мастере, 10 версии и выше, устанавливаем параметр конфигурации \u003Ccode\u003Ewal_level=&quot;logical&quot;\u003C\u002Fcode\u003E. В pg_hba.conf добавляем такую строку:\u003Cbr\u003E\r\n\u003Cbr\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"plaintext\"\u003Ehost    db_name    postgres    192.168.1.3\u002F32     trust\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u003E\r\nЗатем рестартуем на мастере postgres и выполняем на реплике из-под пользователя postgres:\u003Cbr\u003E\r\n\u003Cbr\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"bash\"\u003Epg_dumpall --database=postgres --host=192.168.1.2 --no-password --globals-only --no-privileges | psql\npg_dump --dbname db_name --host=192.168.1.2 --no-password --create --schema-only | psql\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u003E\r\nТеперь подключаемся на мастере пользователем \u003Ccode\u003Epostgres\u003C\u002Fcode\u003E к базе \u003Ccode\u003Edb_name\u003C\u002Fcode\u003E и создаём публикацию:\u003Cbr\u003E\r\n\u003Cbr\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"pgsql\"\u003ECREATE PUBLICATION db_pub FOR ALL TABLES;\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u003E\r\nа на реплике создаём подписку:\u003Cbr\u003E\r\n\u003Cbr\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"pgsql\"\u003ECREATE SUBSCRIPTION db_sub CONNECTION 'host=192.168.1.2 dbname=db_name' PUBLICATION db_pub;\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u003E\r\nПо завершении репликации переключаем приложение или балансировщик на новую базу.\u003Cbr\u003E\r\n\u003Cbr\u003E\r\nТеперь вы знаете постгрес (и с какой стороны доить слонеску) и можете идти устраиваться ДБА.\u003Cbr\u003E\r\n\u003Csup\u003EДля любознательных есть пара небольших деталей под катом.\u003C\u002Fsup\u003E\u003Cbr\u003E","imageUrl":null,"buttonTextHtml":"Читать дальше &rarr;","image":null},"editorVersion":"1.0","postType":"article","postLabels":[{"type":"technotext2021","data":{"url":"https:\u002F\u002Fcontenting.io\u002F2021.html"}},{"type":"tutorial","data":null}],"author":{"scoreStats":{"score":3,"votesCount":15},"rating":0,"relatedData":null,"contacts":[],"authorContacts":[],"paymentDetails":{"paymentYandexMoney":null,"paymentPayPalMe":null,"paymentWebmoney":null},"id":"2290294","alias":"korva","fullname":"Коротких Василий","avatarUrl":"\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Favatars\u002F11b\u002F0d4\u002F905\u002F11b0d4905c5dbe422c3998cfc9aa59cc.jpg","speciality":null},"statistics":{"commentsCount":5,"favoritesCount":74,"readingCount":12042,"score":9,"votesCount":11},"hubs":[{"relatedData":null,"id":"19663","alias":"postgrespro","type":"corporative","title":"Блог компании Postgres Professional","titleHtml":"Блог компании Postgres Professional","isProfiled":false},{"relatedData":null,"id":"358","alias":"postgresql","type":"collective","title":"PostgreSQL","titleHtml":"PostgreSQL","isProfiled":true},{"relatedData":null,"id":"17681","alias":"db_admins","type":"collective","title":"Администрирование баз данных","titleHtml":"Администрирование баз данных","isProfiled":true},{"relatedData":null,"id":"22374","alias":"data_engineering","type":"collective","title":"Data Engineering","titleHtml":"Data Engineering","isProfiled":true}],"flows":[{"id":"1","alias":"develop","title":"Разработка"},{"id":"6","alias":"admin","title":"Администрирование"}],"relatedData":null,"textHtml":"\u003Cdiv xmlns=\"http:\u002F\u002Fwww.w3.org\u002F1999\u002Fxhtml\"\u003E\u003Cdiv style=\"text-align:center;\"\u003E\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw780q1\u002Fwebt\u002Frc\u002F4w\u002Fc4\u002Frc4wc4pblkhrdji9tkuwdwvt2ro.jpeg\" alt=\"image\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fwebt\u002Frc\u002F4w\u002Fc4\u002Frc4wc4pblkhrdji9tkuwdwvt2ro.jpeg\" data-blurred=\"true\"\u002F\u003E\u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\nНачиная с 10 версии, перенести данные с одной базы PostgreSQL на другую несложно, с обновлением, без обновления — неважно. Об этом немало сказано и сказанное сводится к следующему: на мастере, 10 версии и выше, устанавливаем параметр конфигурации \u003Ccode\u003Ewal_level=\"logical\"\u003C\u002Fcode\u003E. В pg_hba.conf добавляем такую строку:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"plaintext\"\u003Ehost    db_name    postgres    192.168.1.3\u002F32     trust\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nЗатем рестартуем на мастере postgres и выполняем на реплике из-под пользователя postgres:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"bash\"\u003Epg_dumpall --database=postgres --host=192.168.1.2 --no-password --globals-only --no-privileges | psql\npg_dump --dbname db_name --host=192.168.1.2 --no-password --create --schema-only | psql\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nТеперь подключаемся на мастере пользователем \u003Ccode\u003Epostgres\u003C\u002Fcode\u003E к базе \u003Ccode\u003Edb_name\u003C\u002Fcode\u003E и создаём публикацию:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"pgsql\"\u003ECREATE PUBLICATION db_pub FOR ALL TABLES;\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nа на реплике создаём подписку:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"pgsql\"\u003ECREATE SUBSCRIPTION db_sub CONNECTION 'host=192.168.1.2 dbname=db_name' PUBLICATION db_pub;\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nПо завершении репликации переключаем приложение или балансировщик на новую базу.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nТеперь вы знаете постгрес (и с какой стороны доить слонеску) и можете идти устраиваться ДБА.\u003Cbr\u002F\u003E\r\n\u003Csup\u003EДля любознательных есть пара небольших деталей под катом.\u003C\u002Fsup\u003E\u003Cbr\u002F\u003E\r\n\u003Ca name=\"habracut\"\u003E\u003C\u002Fa\u003E\u003Cbr\u002F\u003E\r\n\u003Ch2\u003EЗадачи, решаемые логической репликацией\u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\r\nДля чего может быть полезна логическая репликация, написано в \u003Ca href=\"https:\u002F\u002Fpostgrespro.ru\u002Fdocs\u002Fpostgresql\u002F12\u002Flogical-replication\"\u003Eдокументации\u003C\u002Fa\u003E:\u003Cbr\u002F\u003E\r\n\u003Cul\u003E\r\n\u003Cli\u003EПередача подписчикам инкрементальных изменений в одной базе данных или подмножестве базы данных, когда они происходят.\u003C\u002Fli\u003E\r\n\u003Cli\u003EСрабатывание триггеров для отдельных изменений, когда их получает подписчик.\u003C\u002Fli\u003E\r\n\u003Cli\u003EОбъединение нескольких баз данных в одну (например, для целей анализа).\u003C\u002Fli\u003E\r\n\u003Cli\u003EРепликация между разными основными версиями PostgreSQL.\u003C\u002Fli\u003E\r\n\u003Cli\u003EРепликация между экземплярами PostgreSQL на разных платформах (например, с Linux на Windows).\u003C\u002Fli\u003E\r\n\u003Cli\u003EПредоставление доступа к реплицированным данным другим группам пользователей.\u003C\u002Fli\u003E\r\n\u003Cli\u003EРазделение подмножества базы данных между несколькими базами данных.\u003C\u002Fli\u003E\r\n\u003C\u002Ful\u003E\u003Cbr\u002F\u003E\r\nЛогическая репликация удобна тем, что вначале переносится схема данных. На ней можно тестировать возможность репликации заливкой данных с предварительно восстановленных резервных копий; проверять гипотезы по устранению возникающих при репликации проблем и имеющихся в базе ошибок проектирования. Также в этом случае появляется возможность внести и проверить такие изменения в схеме, которые на рабочей системе делать опасно. \u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nЭто тот момент, когда можно сказать — «А помните, мы хотели уменьшить объём базы за счёт выравнивания? Давайте сейчас столбцы и перераспределим!». Также на стороне реплики возможно, например, провести перераспределение данных из одного столбца типа JSON в несколько других столбцов, или даже таблиц, либо наоборот, после чего заполнять уже доработанную и протестированную базу, при необходимости обрабатывая данные \u003Cs\u003Eнапильником\u003C\u002Fs\u003E триггерами. Можно какие-то поля отправить в TOAST, а какие-то наоборот — достать. В некоторых пределах можно поменять типы значений в столбцах. Также причиной выбора является возможность провести практически бесшовное обновление, одновременно с котором допустимо некоторое изменение схемы данных, а при некотором усердии — кардинальное перекраивание схемы данных. В общем, к списку добавляется один пункт:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cul\u003E\r\n\u003Cli\u003EТрансформация схемы данных, в определённых пределах, практически без перерыва в обслуживании.\u003C\u002Fli\u003E\r\n\u003C\u002Ful\u003E\u003Cbr\u002F\u003E\r\nНо, как и любой другой инструмент, логическая репликация имеет, помимо преимуществ, ещё и \u003Ca href=\"https:\u002F\u002Fpostgrespro.ru\u002Fdocs\u002Fpostgresql\u002F12\u002Flogical-replication-restrictions\"\u003Eограничения\u003C\u002Fa\u003E и недостатки. Знать их не помешает, ведь приведённый над катом пример будет работать без проблем только в сферической учебной БД. \u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ch2\u003EДокументация и примечания к выпускам\u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\r\nНадо помнить, что поведение СУБД в различных мажорных версиях может заметно разниться. Поэтому перед обновлением, да и вообще, важно ознакомиться с \u003Ca href=\"https:\u002F\u002Fpostgrespro.ru\u002Fdocs\u002Fpostgresql\u002F12\u002Flogical-replication\"\u003Eдокументацией\u003C\u002Fa\u003E и списком изменений (\u003Ca href=\"https:\u002F\u002Fpostgrespro.ru\u002Fdocs\u002Fpostgresql\u002F10\u002Frelease\"\u003E10\u003C\u002Fa\u003E, \u003Ca href=\"https:\u002F\u002Fpostgrespro.ru\u002Fdocs\u002Fpostgresql\u002F11\u002Frelease\"\u003E11\u003C\u002Fa\u003E, \u003Ca href=\"https:\u002F\u002Fpostgrespro.ru\u002Fdocs\u002Fpostgresql\u002F12\u002Frelease\"\u003E12\u003C\u002Fa\u003E, \u003Ca href=\"https:\u002F\u002Fpostgrespro.ru\u002Fdocs\u002Fpostgresql\u002F13\u002Frelease\"\u003E13\u003C\u002Fa\u003E) и определить, какие из них могут изменить поведение вашей БД. \u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nЗдесь не будет рассказываться о создании \u003Ca href=\"https:\u002F\u002Fpostgrespro.ru\u002Fdocs\u002Fpostgresql\u002F13\u002Fsql-createpublication\"\u003Eпубликаций\u003C\u002Fa\u003E и \u003Ca href=\"https:\u002F\u002Fpostgrespro.ru\u002Fdocs\u002Fpostgresql\u002F13\u002Fsql-createsubscription\"\u003Eподписок\u003C\u002Fa\u003E, всё это есть в документации. Статья носит обзорный характер и не служит заменой документации. \u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ch3\u003EПримечание\u003C\u002Fh3\u003E\u003Cbr\u002F\u003E\r\nВ статье приводится много примеров для воспроизведения которых лучше использовать \u003Ccode\u003Epsql\u003C\u002Fcode\u003E, так как \u003Ccode\u003Epgcli\u003C\u002Fcode\u003E работает немного по-другому и перетащенный туда скрипт работает с ущербом для наглядности. Также создайте базу \u003Ccode\u003Etest\u003C\u002Fcode\u003E, а в ней схему \u003Ccode\u003Ets\u003C\u002Fcode\u003E:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"sql\"\u003ECREATE DATABASE test;\n\\c test\nCREATE SCHEMA ts; \nREVOKE ALL PRIVILEGES \n  ON DATABASE test\n  FROM public; -- ведь у вас на проде всё точно так же?\n---\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nНе все скрипты можно перетаскивать как есть, в некоторых придётся поменять IP-адреса.\u003Cbr\u002F\u003E\r\n\u003Cb\u003E\u003Ci\u003EПриведённые примеры кода ни в коем случае не выполняйте на экземплярах СУБД, которые кем-либо используются. Некоторые примеры приведены для демонстрации падения СУБД и могут принести немало неприятностей. Лучше всего создать пару ВМ и экспериментировать на них.\u003C\u002Fi\u003E\u003C\u002Fb\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ch2\u003EОбновление до последней корректирующей (минорной) версии\u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\r\nПервое, что нужно запланировать и сделать при подготовке к использованию логической репликации — обновиться на последнюю минорную версию, особенно если в создаваемых публикациях планируется использовать предложение \u003Ccode\u003EFOR ALL TABLES\u003C\u002Fcode\u003E.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nПочему стоит обновиться? Например, поэтому:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Col\u003E\r\n\u003Cli\u003EВ версиях 10.8 и 11.3 был исправлен \u003Ca href=\"https:\u002F\u002Fwww.postgresql.org\u002Fmessage-id\u002Fflat\u002Ff3f151f7-c4dd-1646-b998-f60bd6217dd3@2ndquadrant.com\"\u003Eбаг\u003C\u002Fa\u003E с обработкой изменений, вносящихся во временные и нежурналируемые таблицы. Данные в таких таблицах в логической репликации не участвуют, поэтому им не требуется настройка репликационных идентификаторов, но, при попытке обновить в таких таблицах данные, сервер выдавал сообщение об ошибке: \u003Ccode\u003EERROR: cannot update table \"logical_replication_test\" because it does not have a replica identity and publishes updates\u003C\u002Fcode\u003E и отменял транзакцию. Хорошего в этом мало, поэтому, если ваше приложение использует временные или нежурналируемые таблицы, то обновление обязательно;\u003C\u002Fli\u003E\r\n\u003Cli\u003EВ версиях 10.11 и 11.6 был устранён \u003Ca href=\"https:\u002F\u002Fwww.postgresql.org\u002Fmessage-id\u002Fflat\u002Fa9139c29-7ddd-973b-aa7f-71fed9c38d75%40minerva.info\"\u003Eвывод ошибки\u003C\u002Fa\u003E в случае, когда состав столбцов идентификации на мастере и на реплике различался. Правда и репликация изменения или удаления строк в таком случае \u003Ca href=\"#uncosistecy\"\u003Eпрекращается\u003C\u002Fa\u003E;\u003C\u002Fli\u003E\r\n\u003Cli\u003EВ версиях 10.12, 11.7, 12.2 был устранено несколько багов, которые приводили к невозможности значительно изменять схему таблиц на реплике по сравнению со схемой таблиц на мастере. Например, на реплике нельзя было создавать дополнительные столбцы с функцией в качестве значения по умолчанию (\"… clmname numeric DEFAULT random() ...\").\u003C\u002Fli\u003E\r\n\u003Cli\u003EВ версиях 10.16, 11.11, 12.6 13.2 устранили утечки памяти в процессах walsender при передаче новых снимков для логического декодирования\u003C\u002Fli\u003E\r\n\u003C\u002Fol\u003E\u003Cbr\u002F\u003E\r\nКак видите, для снижения километража истрёпанных нервов, предпочтительнее обновиться, пусть это и займёт некоторое время.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ch2\u003EСоздание ролей и строк аутентификации в pg_hba.conf\u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\r\nПосле минорного обновления следует создать те роли, которые планируется использовать для создания публикации и подписки. При этом требования к ролям на мастере и реплике немного \u003Ca href=\"https:\u002F\u002Fpostgrespro.ru\u002Fdocs\u002Fpostgresql\u002F12\u002Flogical-replication-security\"\u003Eразличаются\u003C\u002Fa\u003E. \u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nВ целом на реплике можно вообще не создавать отдельную роль, так как создание подписки разрешается только суперпользователям и применение полученных изменений происходит с правами суперпользователя. Поэтому на реплике можно пользоваться ролью \u003Ccode\u003Epostgres\u003C\u002Fcode\u003E. \u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nНа мастере быть суперпользователем не обязательно, но если планируется обновление, то этот вариант удобнее. Конечно, можно обойтись и без выделенной роли, но на мастере роль предпочтительно создать для того, чтоб ограничить возможность подключения только тем сервером, на который происходит репликация.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nСоздать роль можно такой командой:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"sql\"\u003ESET password_encryption = 'scram-sha-256';\nCREATE ROLE log_rep_rolename \n  WITH SUPERUSER \n       LOGIN\n       PASSWORD 'sadp!'; -- sadp! = StrongAndDifficultPassword! \n-- По возможности избегайте кавычек (', \") в пароле,\n-- его предстоит в строке подключения указывать.\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nВ pg_hba.conf на мастере нужно добавить две записи: одну для локального подключения, другую для подключения с реплики. Предпочтительно указывать точные адреса реплик — лучше сто записей в pg_hba, чем одна дыра в безопасности.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"plaintext\"\u003Ehost  test  log_rep_rolename  127.0.0.1\u002F32                     scram-sha-256\nhost  test  log_rep_rolename  192.168.122.95  255.255.255.255  scram-sha-256\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nОбратите внимание что, несмотря на то что логическая репликация основана в значительной мере на потоковой, указывается не специальная запись \u003Ccode\u003Ereplication\u003C\u002Fcode\u003E, а имя базы или \u003Ccode\u003Eall\u003C\u002Fcode\u003E — указание на все базы. Если указать \u003Ccode\u003Ereplication\u003C\u002Fcode\u003E, то создать подписку на реплике не получится из-за ошибки аутентификации.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nПосле этого перезагружаем настройки из-под суперпользователя:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"sql\"\u003ESELECT pg_reload_conf();\n---\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Ch2\u003EРепликационные идентификаторы\u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\r\nВесь процесс логической репликации в принципе строится на идее \u003Ci\u003Eрепликационных идентификаторов\u003C\u002Fi\u003E. Поэтому дальнейшая подготовка состоит в проверке наличия во всех реплицируемых таблицах либо первичного ключа, либо индекса, соответствующего некоторым минимальным требованиям и задействованного в \u003Ccode\u003EREPLICA IDENTITY USING INDEX\u003C\u002Fcode\u003E, либо назначении \u003Ccode\u003EREPLICA IDENTITY FULL\u003C\u002Fcode\u003E. То есть проверка наличия в таблицах \u003Ci\u003Eрепликационных идентификаторов\u003C\u002Fi\u003E. Они нужны для однозначной идентификации изменяемых или удаляемых строк при репликации команд \u003Ccode\u003EUPDATE\u003C\u002Fcode\u003E и \u003Ccode\u003EDELETE\u003C\u002Fcode\u003E и передаются на реплику в специальном поле для каждой записи.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nРепликационные идентификаторы можно не настраивать, или даже отключить, если планируется реплицировать только команды \u003Ccode\u003EINSERT\u003C\u002Fcode\u003E. Главное не забыть правильно создать публикацию — исключить из неё команды \u003Ccode\u003EUPDATE\u003C\u002Fcode\u003E и \u003Ccode\u003EDELETE\u003C\u002Fcode\u003E. Но если вам на реплике нужны актуальные данные из активно изменяющихся таблиц, а первичные ключи или уникальные \u003Ccode\u003ENOT NULL\u003C\u002Fcode\u003E индексы в таблицах отсутствуют, то репликационные идентификаторы придётся настраивать с нуля. Не выполнив это условие, можно добиться того, что \u003Ccode\u003EUPDATE\u003C\u002Fcode\u003E и \u003Ccode\u003EDELETE\u003C\u002Fcode\u003E будут приводить к \u003Ca href=\"#update_delete_fail\"\u003Eотмене транзакций\u003C\u002Fa\u003E на мастере, малоприятный факт на рабочей базе.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cdiv class=\"spoiler\" role=\"button\" tabindex=\"0\"\u003E\n                        \u003Cb class=\"spoiler_title\"\u003EПоиск таблиц, не имеющих репликационных идентификаторов\u003C\u002Fb\u003E\n                        \u003Cdiv class=\"spoiler_text\"\u003E\u003Cpre\u003E\u003Ccode class=\"sql\"\u003ESELECT pgn.nspname || '.' || pgc.relname AS \"Таблицы без репликационных идентификаторов\"\n  FROM pg_class AS pgc,\n       pg_namespace AS pgn\n  WHERE pgn.nspname !~ '^(?:pg_.*|information_schema)$'\n    AND pgc.relreplident IN ('n', 'd')\n    AND pgc.relkind IN ('r', 'p') \n    AND pgc.oid NOT IN (SELECT pgi.indrelid FROM pg_index AS pgi WHERE pgi.indisprimary)\n    AND pgc.relnamespace = pgn.oid\n    ORDER BY 1;\n---\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003C\u002Fdiv\u003E\n                    \u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\n\u003Ch3\u003EЧто может выступать в качестве репликационного идентификатора\u003C\u002Fh3\u003E\u003Cbr\u002F\u003E\r\nКак понятно из названия репликационных идентификаторов — они должны идентифицировать строки таблиц. Если в вашей таблице есть поле или комбинация полей, которая никогда не повторяется и поэтому позволяет идентифицировать строку, её следует либо объявить первичным ключом, либо создать по ней уникальный индекс. \u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nЕсли столбцов пригодных к роли репликационных идентификаторов нет, что очень странно, то придётся их создавать. Каждое значение в таком столбце должно быть уникальным. В качестве источника уникальности могут выступать как естественные, так и искусственные ключи и их комбинации — зависит от архитектуры базы данных. При этом неважно что именно использовать в качестве естественных ключей, главное, чтоб они выполняли роль однозначного идентификатора. В качестве искусственных ключей используются, как правило, различные последовательности и типы UUID. \u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ch3\u003EПоследовательности\u003C\u002Fh3\u003E\u003Cbr\u002F\u003E\r\nИспользовать последовательности при создании репликационных идентификаторов можно двумя с половиной способами: ручное указание вызова функции получения следующего значения последовательности, например \u003Ccode\u003E\u003Ca href=\"https:\u002F\u002Fpostgrespro.ru\u002Fdocs\u002Fpostgresql\u002F12\u002Ffunctions-sequence\"\u003Enextval\u003C\u002Fa\u003E\u003C\u002Fcode\u003E; назначение столбцу последовательного псевдотипа \u003Ccode\u003E\u003Ca href=\"https:\u002F\u002Fpostgrespro.ru\u002Fdocs\u002Fpostgresql\u002F12\u002Fdatatype-numeric#DATATYPE-SERIAL\"\u003Eserial\u003C\u002Fa\u003E\u003C\u002Fcode\u003E; использование \u003Ci\u003Eстолбцов идентификации\u003C\u002Fi\u003E в соответствии со стандартом SQL. Вполне рабочим вариантом может быть отсутствие значения по умолчанию, ведь можно возложить эту обязанность на приложение, но столбец должен быть \u003Ccode\u003ENOT NULL\u003C\u002Fcode\u003E.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cb\u003ESEQUENCE и serial\u003C\u002Fb\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nНаиболее гибким и мощным является использование различных \u003Ca href=\"https:\u002F\u002Fpostgrespro.ru\u002Fdocs\u002Fpostgresql\u002F12\u002Fsql-createsequence\"\u003E\u003Ccode\u003ESEQUENCE\u003C\u002Fcode\u003E\u003C\u002Fa\u003E. В таком случае, после создания последовательности, значения по умолчанию для столбцов необходимо прописывать самостоятельно. При необходимости назначить таблицу-владельца последовательности также придётся поработать руками.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nТип \u003Ccode\u003E\u003Ca href=\"https:\u002F\u002Fpostgrespro.ru\u002Fdocs\u002Fpostgresql\u002F12\u002Fdatatype-numeric#DATATYPE-SERIAL\"\u003Eserial\u003C\u002Fa\u003E\u003C\u002Fcode\u003E это синтаксический сахар для обычного способа создания последовательностей, этакий шаблон. Всё что нужно сделать, это назначить столбцу тип smallserial\u002Fserial\u002Fbigserial.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nИспользование типа \u003Ccode\u003Eserial\u003C\u002Fcode\u003E менее гибко, но его использование позволяет избавиться от необходимости создавать последовательности вручную. Также такой последовательности автоматически назначается свойство \u003Ccode\u003EOWNED BY\u003C\u002Fcode\u003E. Это указание на столбец таблицы, при создании которого была создана последовательность. \u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nТакую последовательность в дальнейшем нельзя удалить, не удалив это указание. И здесь кроется опасность — удалив такую последовательность с указанием ключевого слова \u003Ccode\u003ECASCADE\u003C\u002Fcode\u003E можно устроить локальный армагеддон. В привязанном к удалённой последовательности столбце останется включенным свойство \u003Ccode\u003ENOT NULL\u003C\u002Fcode\u003E, а вот свойство \u003Ccode\u003EDEFAULT\u003C\u002Fcode\u003E обнулится.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nУ полей \u003Ccode\u003Eserial\u003C\u002Fcode\u003E есть ещё одна неприятная \u003Ca href=\"https:\u002F\u002Fwww.2ndquadrant.com\u002Fen\u002Fblog\u002Fpostgresql-10-identity-columns\"\u003Eособенность\u003C\u002Fa\u003E — пользователь без права на использование автоматически созданной последовательности, и с правами на \u003Ccode\u003EINSERT\u003C\u002Fcode\u003E в таблицу, практически вставку выполнять не сможет, если только не укажет значение поля \u003Ccode\u003Eserial\u003C\u002Fcode\u003E вручную. Если не укажет, то получит ошибку доступа к соответствующей последовательности. В принципе это не проблема, нужно не забывать давать права на использование последовательности вместе с правами на вставку в таблицу.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cb\u003EНесколько таблиц на одной последовательности\u003C\u002Fb\u003E\u003Cbr\u002F\u003E\r\nЕсли нужно подключить к одной последовательности несколько таблиц, — делать это нужно самостоятельно. Для этого задаётся получение \u003Ccode\u003Enextval(нужная_последовательность)\u003C\u002Fcode\u003E в свойстве \u003Ccode\u003EDEFAULT\u003C\u002Fcode\u003E интересующего вас столбца. Воспользоваться можно и той последовательностью, что была создана с использованием \u003Ccode\u003Eserial\u003C\u002Fcode\u003E — никто не мешает вручную прописать её для других таблиц, разве что потом будут некоторые проблемы с удалением самой первой таблицы: нужно будет поменять или удалить ссылку на таблицу-владельца такой последовательности: \u003Ccode\u003EALTER SEQUENCE name_of_your_seq OWNED BY NONE\u003C\u002Fcode\u003E.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cdiv class=\"spoiler\" role=\"button\" tabindex=\"0\"\u003E\n                        \u003Cb class=\"spoiler_title\"\u003EВоспроизведение\u003C\u002Fb\u003E\n                        \u003Cdiv class=\"spoiler_text\"\u003E\u003Cpre\u003E\u003Ccode class=\"sql\"\u003ECREATE TABLE t1 (i serial, t text);\nCREATE TABLE t2 (i int NOT NULL DEFAULT nextval('t1_i_seq'), t text);\nINSERT INTO t2 (t) VALUES('The first value in table t2');\nINSERT INTO t1 (t) VALUES('The first value in table t1');\nSELECT * FROM t1;\nSELECT * FROM t2;\n\\d t2\nDROP TABLE t1;\nDROP SEQUENCE t1_i_seq;\nDROP TABLE t1 CASCADE;\nINSERT INTO t2 (t) VALUES('Maybe the second value in table t2');\n\\d t2\nDROP TABLE t2;\n---\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003C\u002Fdiv\u003E\n                    \u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\n\u003Cb\u003EСтолбцы идентификации\u003C\u002Fb\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nПришедшие из стандарта SQL cтолбцы идентификации задаются либо при создании таблицы, либо ими могут стать имеющиеся столбцы, либо можно добавить такие столбцы отдельно. \u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nПоследовательность, созданную для столбца идентификации, в отличие от первых полутора вариантов, не стоит использовать в других таблицах. В дальнейшем это помешает удалить исходную таблицу, а если удалить её с предложением \u003Ccode\u003ECASCADE\u003C\u002Fcode\u003E, то свойство \u003Ccode\u003EDEFAULT\u003C\u002Fcode\u003E у таблиц использовавших эту последовательность обнулится. При этом свойство \u003Ccode\u003ENOT NULL\u003C\u002Fcode\u003E никуда не денется.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nВ результате появится шанс наблюдать на мастере орды \u003Ccode\u003Enull value in column \"i\" violates not-null constraint\u003C\u002Fcode\u003E. С последовательностями, созданными с помощью \u003Ccode\u003Eserial\u003C\u002Fcode\u003E тоже такое бывает, но для них это исправимо — поменяйте принадлежность последовательности либо на нужный столбец нужной таблицы, либо сделайте её «бесхозяйной». С последовательностями столбцов идентификации это не работает.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nПервичными ключами столбцы идентификации автоматически не становятся, это просто синтаксис назначения столбцу особых свойств, несколько отличающихся от обычных последовательностей. В частности, при типе \u003Ccode\u003Eserial\u003C\u002Fcode\u003E вы можете спокойно проводить вставку любых произвольных значений в ключевые поля, за исключением имеющихся конечно (если на столбце включен \u003Ccode\u003EPRIMARY KEY\u003C\u002Fcode\u003E). \u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nПонятно, что это приведёт к тому, что однажды последовательность выдаст вставленные ранее произвольные значения и получившая их транзакция прервётся с ошибкой \u003Ca href=\"#duplicate_key\"\u003E\u003Ccode\u003Eduplicate key\u003C\u002Fcode\u003E\u003C\u002Fa\u003E. Использование столбцов идентификации позволит не беспокоиться о таком развитии событий — в столбцы идентификации, созданные с ключом \u003Ccode\u003EALWAYS\u003C\u002Fcode\u003E, вставить произвольное число не так просто, нужно использовать специальную форму команды \u003Ccode\u003EINSERT\u003C\u002Fcode\u003E. При создании таких столбцов поддерживаются те же параметры, что и при создании обычной последовательности.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cb\u003EUniversally Unique IDentifiers\u003C\u002Fb\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nЕсли назначить столбцу тип \u003Ca href=\"https:\u002F\u002Fpostgrespro.ru\u002Fdocs\u002Fpostgresql\u002F12\u002Fdatatype-uuid\"\u003EUUID\u003C\u002Fa\u003E, то значение для такого столбца не будет генерироваться автоматически. Для получения нового значения UUID необходимо пользоваться одним из двух дополнительных модулей: \u003Ca href=\"https:\u002F\u002Fpostgrespro.ru\u002Fdocs\u002Fpostgresql\u002F12\u002Fuuid-ossp\"\u003Euuid-ossp\u003C\u002Fa\u003E или \u003Ca href=\"https:\u002F\u002Fpostgrespro.ru\u002Fdocs\u002Fpostgresql\u002F12\u002Fuuid-ossp\"\u003Epgcrypto\u003C\u002Fa\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nВ отличие от последовательностей UUID имеет длину не 16\u002F32\u002F64 бита, а 128 бит, — что нужно учитывать при расчётах нагрузки на сетевую подсистему. Зато у него есть то преимущество, что UUID генерирует такие строки, содержимое которых не повторяется в распределённых системах. \u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nК слову, при использовании последовательностей можно использовать независимые последовательности с добавлением префикса, уникального для каждого участвующего во взаимообмене данными сервера. Столбец в таком случае придётся сделать текстовым, но даже так получится экономичнее.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nВ простейшем случае получать значения UUID можно через расширение \u003Ccode\u003Epg_crypto\u003C\u002Fcode\u003E. В нём есть только одна функция получения UUID:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"sql\"\u003ECREATE EXTENSION pgcrypto;\nSELECT gen_random_uuid();\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nМодуль \u003Ccode\u003Euuid-ossp\u003C\u002Fcode\u003E, в отличие от \u003Ccode\u003Epg_crypto\u003C\u002Fcode\u003E предоставляет больше возможностей по части выбора типа UUID. Если PostgreSQL установлен из пакетов, то можно сразу устанавливать расширение, только его имя обязательно нужно заключить в двойные кавычки, так как оно содержит дефис. Если собираете PostgreSQL из исходников, то нужно воспользоваться ключом --with-uuid=ossp (работает в Debian, как в RHEL — не знаю). Для этого, в дополнение к уже установленному постгресу, понадобится поставить несколько пакетов:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"bash\"\u003E# Debian Buster\n#    пакет postgresql-10 можно установить до \n#    или после компиляции и установки расширения.\nsudo apt-get install gcc libossp-uuid-dev libreadline-dev make zlib1g-dev\nwget https:\u002F\u002Fftp.postgresql.org\u002Fpub\u002Fsource\u002Fv10.16\u002Fpostgresql-10.16.tar.gz\ngunzip postgresql-10.16.tar.gz\ntar xf postgresql-10.16.tar\ncd postgresql-10.16\n.\u002Fconfigure --with-uuid=ossp\nmake\nmake install\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"sql\"\u003ECREATE EXTENSION \"uuid-ossp\";\nSELECT uuid_generate_v1();\nSELECT uuid_generate_v1mc();\nSELECT uuid_generate_v3(uuid_ns_url(), 'https:\u002F\u002Fpostgrespro.ru\u002F');\nSELECT uuid_generate_v4();\nSELECT uuid_generate_v5(uuid_ns_dns(), 'postgrespro.ru');\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Ch2\u003EПервичные ключи и уникальные индексы\u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\r\nОпределившись с источниками уникальности нужно указать какой столбец, или какие столбцы, надлежит использовать как репликационные идентификаторы. По умолчанию ими являются первичные ключи. Они, как и уникальные индексы, позволяют добавлять на стороне реплики произвольное число столбцов, не опасаясь приостановки репликации при операциях \u003Ccode\u003EUPDATE\u003C\u002Fcode\u003E и \u003Ccode\u003EDELETE\u003C\u002Fcode\u003E.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nГлавное, чтобы у добавленных столбцов не было назначено свойство \u003Ccode\u003ENOT NULL\u003C\u002Fcode\u003E с отсутствующим значением по умолчанию — при начальной репликации и репликации команды \u003Ccode\u003EINSERT\u003C\u002Fcode\u003E возникнет ошибка на стороне реплики, устранять которую возможно только на стороне реплики. На стороне мастера тут уже ничего не поделаешь, разве что удалить слот репликации — чтоб журнал предзаписи не переполнялся, и мастер не создавал каждые пять секунд процесс декодирования. Также можно запретить доступ через pg_hba.conf или на балансировщике, затем исправить неполадки на реплике и снова разрешить доступ.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nПеред началом репликации таблицы первичные ключи должны быть настроены с обоих сторон, а имеющиеся в реплицируемой таблице столбцы, даже не являющиеся репликационными идентификаторами, должны присутствовать и в реплицированной таблице. То есть на мастере нельзя удалять столбцы, если они есть на реплике.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nПри непосредственном создании первичных ключей таблица блокируется на запись блокировкой \u003Ccode\u003ESHARE ROW EXCLUSIVE\u003C\u002Fcode\u003E. Поэтому предпочтительно использовать предварительное создание уникального индекса в режиме \u003Ccode\u003ECONCURRENTLY\u003C\u002Fcode\u003E и затем уже привязку его в качестве первичного ключа. Да — это ресурсоёмкая операция, зато доступность БД на запись не страдает.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nОбратите внимание на то, что если вы создаёте первичный ключ на столбце, не имеющем свойства \u003Ccode\u003ENOT NULL\u003C\u002Fcode\u003E, то такое свойство будет создано автоматически, но после после удаления ограничения автоматически не удалится. \u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cdiv class=\"spoiler\" role=\"button\" tabindex=\"0\"\u003E\n                        \u003Cb class=\"spoiler_title\"\u003EДемонстрация появления ограничения NOT NULL\u003C\u002Fb\u003E\n                        \u003Cdiv class=\"spoiler_text\"\u003E\u003Cpre\u003E\u003Ccode class=\"sql\"\u003ECREATE TABLE ts.testt (i serial, clmn_1 text, clmn_2 int);\n\\d ts.testt\n\u002F*                          Table \"ts.testt\"\n Column |  Type   | Nullable |             Default             \n--------+---------+----------+---------------------------------\n i      | integer | not null | nextval('testt_i_seq'::regclass)\n clmn_1 | text    |          | \n clmn_2 | integer |          |                                   *\u002F\nALTER TABLE ts.testt ADD PRIMARY KEY (i, clmn_1);\n\\d ts.testt\n\u002F*                          Table \"ts.testt\"\n Column |  Type   | Nullable |             Default             \n--------+---------+----------+---------------------------------\n i      | integer | not null | nextval('testt_i_seq'::regclass)\n clmn_1 | text    | not null | \n clmn_2 | integer |          | \nIndexes:\n    \"testt_pkey\" PRIMARY KEY, btree (i, clmn_1)                  *\u002F\nALTER TABLE ts.testt DROP CONSTRAINT testt_pkey;\n\\d ts.testt\n\u002F*                          Table \"ts.testt\"\n Column |  Type   | Nullable |             Default             \n--------+---------+----------+---------------------------------\n i      | integer | not null | nextval('testt_i_seq'::regclass)\n clmn_1 | text    | not null | \n clmn_2 | integer |          |                                   *\u002F\nALTER TABLE ts.testt ADD PRIMARY KEY (i);\n\\d ts.testt\n\u002F*                          Table \"ts.testt\"\n Column |  Type   | Nullable |             Default             \n--------+---------+----------+---------------------------------\n i      | integer | not null | nextval('testt_i_seq'::regclass)\n clmn_1 | text    | not null | \n clmn_2 | integer |          | \nIndexes:\n    \"testt_pkey\" PRIMARY KEY, btree (i)                          *\u002F\nALTER TABLE ts.testt ALTER COLUMN clmn_1 DROP NOT NULL;\n\\d ts.testt\n\u002F*                          Table \"ts.testt\"\n Column |  Type   | Nullable |             Default             \n--------+---------+----------+---------------------------------\n i      | integer | not null | nextval('testt_i_seq'::regclass)\n clmn_1 | text    |          | \n clmn_2 | integer |          | \nIndexes:\n    \"testt_pkey\" PRIMARY KEY, btree (i)                          *\u002F\nDROP TABLE ts.testt;\n---\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003C\u002Fdiv\u003E\n                    \u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\n\u003Cdiv class=\"spoiler\" role=\"button\" tabindex=\"0\"\u003E\n                        \u003Cb class=\"spoiler_title\"\u003EПример работы с первичными ключами и последовательностями\u003C\u002Fb\u003E\n                        \u003Cdiv class=\"spoiler_text\"\u003E\u003Cpre\u003E\u003Ccode class=\"sql\"\u003E-- ПОСЛЕДОВАТЕЛЬНОСТИ\n-- Сначала создаём последовательность\nCREATE SEQUENCE ts.testt_sequence AS bigint \n  INCREMENT BY 1 \n  MINVALUE 1 \n  NO MAXVALUE \n  START WITH 1 \n  OWNED BY NONE;\n\\ds+ ts.testt_sequence\n-- Затем создаём таблицу\n-- Либо сразу с последовательностью\nCREATE TABLE ts.testt (\n  i bigint \n    PRIMARY KEY \n    NOT NULL \n    DEFAULT nextval('ts.testt_sequence'::regclass), \n  ac text);\n\\d+ ts.testt\nDROP TABLE ts.testt;\n-- Либо, если таблица и колонка уже существовали, добавляем недостающее\nCREATE TABLE ts.testt (i bigint, ac text);\nINSERT INTO ts.testt (i, ac) VALUES (1, '1'), (1, '2'), (2, '3'), (3, '4');\nSELECT * FROM ts.testt;\nALTER TABLE ts.testt ALTER COLUMN i SET DEFAULT nextval('ts.testt_sequence');\nINSERT INTO ts.testt (ac) VALUES ('5'), ('6'), ('7'), ('8');\nSELECT * FROM ts.testt;\nUPDATE ts.testt SET i = nextval('ts.testt_sequence'::regclass);\nSELECT * FROM ts.testt;\nALTER TABLE ts.testt ALTER COLUMN i SET NOT NULL;\nALTER TABLE ts.testt ADD PRIMARY KEY (i);\n\\d+ ts.testt\nDROP TABLE ts.testt;\nDROP SEQUENCE ts.testt_sequence;\n--\n-- C использованием типа serial можно не создавать последовательность,\n-- она будет создана автоматически\nCREATE TABLE ts.testt (\n  i bigserial PRIMARY KEY, \n  ac text);\n\\d+ ts.testt\n-- В качестве первичного ключа можно задать несколько колонок\n-- Сначала удалим старый первичный ключ\nALTER TABLE ts.testt DROP CONSTRAINT testt_pkey;\n\\d+ ts.testt\n-- Затем создадим новый, двухколоночный.\nALTER TABLE ts.testt ADD PRIMARY KEY (i, ac);\n\\d+ ts.testt\nDROP TABLE ts.testt;\n--\n-- СТОЛБЦЫ ИДЕНТИФИКАЦИИ\n-- Можно сразу создать таблицу с соответствующими столбцами\nCREATE TABLE ts.testt (\n  i bigint\n    GENERATED ALWAYS AS IDENTITY (\n      INCREMENT BY 1 \n      MINVALUE 1 \n      START WITH 1) \n    PRIMARY KEY,\n  ac text);\n\\d+ ts.testt\n\\d ts.testt_i_seq\n-- Меняем ALWAYS на BY DEFAULT\nALTER TABLE ts.testt ALTER COLUMN i SET GENERATED BY DEFAULT;\n\\d+ ts.testt\n\\d ts.testt_i_seq\n-- Удаляем IDENTITY со столбца\nALTER TABLE ts.testt ALTER COLUMN i DROP IDENTITY;\n\\d+ ts.testt\n\\d ts.testt_i_seq\n-- Можно добавить IDENTITY имеющемуся столбцу \nALTER TABLE ts.testt \n  ALTER COLUMN i ADD GENERATED ALWAYS AS IDENTITY (START WITH 1001);\n\\d+ ts.testt\n\\d ts.testt_i_seq\nSELECT * FROM ts.testt_i_seq;\n-- Можно добавить новый столбец с IDENTITY\nALTER TABLE ts.testt \n  ADD COLUMN impk bigint GENERATED ALWAYS AS IDENTITY;\n\\d+ ts.testt\n\\d ts.testt_impk_seq\n-- В этот раз создадим первичный ключ через\n-- предварительное создание уникального индекса\n-- который создадим неблокирующим способом:\nCREATE UNIQUE INDEX CONCURRENTLY testt_hm_idx ON ts.testt (i, impk);\nALTER TABLE ts.testt DROP CONSTRAINT testt_pkey,\n    ADD CONSTRAINT hm_pkey PRIMARY KEY USING INDEX testt_hm_idx;\n\\d+ ts.testt\nDROP TABLE ts.testt;\n---\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003C\u002Fdiv\u003E\n                    \u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\n\u003Cb\u003EУникальные индексы\u003C\u002Fb\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nНаравне с первичными ключами можно использовать уникальные индексы, но их использование в качестве идентификатора репликации необходимо указывать явно с помощью предложения \u003Ccode\u003E... REPLICA IDENTITY USING INDEX name_of_index ...\u003C\u002Fcode\u003E и с ними нужно быть \u003Ca href=\"#pk_and_idx_is_ud_fail\"\u003Eпоосторожнее\u003C\u002Fa\u003E. В отличие от первичных ключей столбцы, на которых строится индекс, нужно самостоятельно снабдить ограничением \u003Ccode\u003ENOT NULL\u003C\u002Fcode\u003E. \u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nТребования к индексам перечислены в документации: \u003Ci\u003Eиндекс должен быть уникальным, не частичным, не отложенным и включать только столбцы, помеченные NOT NULL\u003C\u002Fi\u003E. Состав столбцов, по которым построен индекс на мастере, должен совпадать с их составом на реплике. Если в нужных таблицах в реплицируемой схеме нет первичных ключей — можно на мастере создать уникальный индекс, назначить его репликационным идентификатором, а после переноса схемы на реплику — создать там идентичный по составу и порядку столбцов первичный ключ. Можно и наоборот.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cdiv class=\"spoiler\" role=\"button\" tabindex=\"0\"\u003E\n                        \u003Cb class=\"spoiler_title\"\u003EПример репликации, где на мастере индекс, а на реплике ПК\u003C\u002Fb\u003E\n                        \u003Cdiv class=\"spoiler_text\"\u003E\u003Cpre\u003E\u003Ccode class=\"sql\"\u003E-- Подготавливаем мастер\nCREATE TABLE ts.testt (i serial, t text NOT NULL DEFAULT random(), d text DEFAULT random());\nCREATE UNIQUE INDEX CONCURRENTLY testt_idx ON ts.testt USING btree (i, t);\nALTER TABLE ts.testt REPLICA IDENTITY USING INDEX testt_idx;\nINSERT INTO ts.testt (t, d) VALUES ('001', 'first'), ('002', 'second'), ('003', 'third');\nCREATE PUBLICATION testt_pub for TABLE ts.testt;\nSELECT * FROM ts.testt;\n-- Подготавливаем реплику\nCREATE TABLE ts.testt (i serial, t text NOT NULL DEFAULT random(), d text DEFAULT random());\nALTER TABLE ts.testt ADD PRIMARY KEY (t, i);\nCREATE SUBSCRIPTION testt_sub \n  CONNECTION 'host=192.168.122.182 \n              dbname=test \n              user=log_rep_rolename \n              password=sadp!'\n  PUBLICATION testt_pub;\nSELECT pg_sleep(5.5);\nSELECT * FROM ts.testt;\n-- Выполняем на мастере вставку строки\nINSERT INTO ts.testt (t, d) VALUES ('004', 'fourth');\nSELECT * FROM ts.testt;\n-- Проверяем на реплике - произошла репликация или нет\nSELECT * FROM ts.testt;\n-- Выполняем на мастере UPDATE\nUPDATE ts.testt SET t = t || ' upd' WHERE random() \u003E= 0.5;\nINSERT INTO ts.testt (t, d) VALUES ('005', 'AFTER UPDATE');\nSELECT * FROM ts.testt;\n-- Проверяем на реплике - произошла репликация или нет\nSELECT * FROM ts.testt; \n-- Выполняем на мастере DELETE\nDELETE FROM ts.testt WHERE random() \u003E= 0.5;\nINSERT INTO ts.testt (t, d) VALUES ('006', 'AFTER DELETE');\nSELECT * FROM ts.testt;\n-- Проверяем на реплике - произошла репликация или нет\nSELECT * FROM ts.testt;\n-- Чистим реплику\nDROP SUBSCRIPTION IF EXISTS testt_sub;\nDROP TABLE IF EXISTS ts.testt;\n-- Чистим мастер\nDROP PUBLICATION IF EXISTS testt_pub;\nDROP TABLE IF EXISTS ts.testt;\n---\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003C\u002Fdiv\u003E\n                    \u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\n\u003Cb\u003EREPLICA IDENTITY FULL\u003C\u002Fb\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nВ отличие от первичных ключей и индексов при \u003Ccode\u003EREPLICA IDENTITY FULL\u003C\u002Fcode\u003E идентификатором служит вся строка. В этом случае в журнал предзаписи попадает вся старая строка и по протоколу репликации также передаётся вся старая строка. Не передаются только значения полей \u003Ccode\u003ETOAST\u003C\u002Fcode\u003E — если изменения их не коснулись. Исходя из этого можно представить, насколько разрастается объём хранимых и передаваемых данных. \u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nПоэтому от применения \u003Ccode\u003EREPLICA IDENTITY FULL\u003C\u002Fcode\u003E нужно максимально воздерживаться. Мало того — ошибки в его использовании могут привести к необходимости рестарта репликации. Когда используется \u003Ccode\u003EREPLICA IDENTITY FULL\u003C\u002Fcode\u003E, то состав столбцов в таблице на мастере и реплике преимущественно должен совпадать (порядок столбцов значения не имеет), иначе изменение и удаление данных реплицироваться не будет и последствия будут различаться в зависимости от того, где есть лишние столбцы — на мастере или на реплике.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nЕсли лишние столбцы будут на мастере и публикация будет создана для команд \u003Ccode\u003EUPDATE\u003C\u002Fcode\u003E и \u003Ccode\u003EDELETE\u003C\u002Fcode\u003E — репликация приостановится до тех пор, пока на реплике будут отсутствовать нужные столбцы. \u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nВставка данных и начальная синхронизация не так строго ограничены по части состава столбцов — на реплике могут быть дополнительные столбцы, и они даже могут содержать какие-то данные. Но репликация будет идти благополучно для всех команд только если добавленные на реплике столбцы не содержат данных. Это связано с тем, что поля со значением \u003Ccode\u003ENULL\u003C\u002Fcode\u003E в идентификации строк не участвуют. \u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nОднако пользы от такого способа добавления столбцов немного — при обычном добавлении столбцов, без данных, перезаписи таблицы не происходит, поэтому добавлять пустые столбцы можно и на рабочей базе. \u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nЕсли же нужно менять данные на реплике, но на мастере нет возможности создать первичный ключ — его можно создать на реплике, тогда репликация всех команд будет происходить благополучно, хоть в дополнительных столбцах реплики и будут данные. Это работает, потому что в сообщениях протокола логической репликации, при \u003Ccode\u003EREPLICA IDENTITY FULL\u003C\u002Fcode\u003E на мастере, в качестве идентификатора отправляется вся строка старых данных и процесс применения сообщений выбирает из него значение того поля, которое на реплике является полем первичного ключа.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ccode\u003EREPLICA IDENTITY FULL\u003C\u002Fcode\u003E удобно использовать для трансляции небольших, редко изменяемых таблиц или для таблиц с небольшим размером строк — им не нужны индексы на мастере и данные очень быстро пишутся и отправляются. На реплике же можно и индексы строить, и первичные ключи создавать — вполне удобно. Но для обновляемых данных в масштабных таблицах применять его очень опрометчиво.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nВключить для таблицы этот идентификатор крайне просто:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"sql\"\u003EALTER TABLE ts.testt REPLICA IDENTITY FULL;\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cdiv class=\"spoiler\" role=\"button\" tabindex=\"0\"\u003E\n                        \u003Cb class=\"spoiler_title\"\u003EРабота с REPLICA IDENTITY FULL\u003C\u002Fb\u003E\n                        \u003Cdiv class=\"spoiler_text\"\u003E\u003Cpre\u003E\u003Ccode class=\"sql\"\u003E-- Подготавливаем мастер\nCREATE TABLE ts.testt (i serial, t text, d text DEFAULT now());\nALTER TABLE ts.testt REPLICA IDENTITY FULL;\nINSERT INTO ts.testt (t) VALUES ('first'), ('second'), ('third');\nCREATE PUBLICATION testt_pub for TABLE ts.testt;\nSELECT * FROM ts.testt;\n-- Подготавливаем реплику\nCREATE TABLE ts.testt (i serial, t text, d text);\nALTER TABLE ts.testt REPLICA IDENTITY FULL;\nCREATE SUBSCRIPTION testt_sub \n  CONNECTION 'host=192.168.122.182 \n              dbname=test \n              user=log_rep_rolename \n              password=sadp!'\n  PUBLICATION testt_pub;\nSELECT pg_sleep(5.5);\nSELECT * FROM ts.testt;\n-- Выполняем на мастере вставку строки\nINSERT INTO ts.testt (t) VALUES ('INSERTED');\nSELECT * FROM ts.testt;\n-- Проверяем на реплике - произошла репликация или нет\nSELECT * FROM ts.testt;\n-- Выполняем на мастере UPDATE\nUPDATE ts.testt SET t = t || ' upd' WHERE i = 1;\nINSERT INTO ts.testt (t) VALUES ('AFTER UPDATE');\nSELECT * FROM ts.testt;\n-- Проверяем на реплике - произошла репликация или нет\nSELECT * FROM ts.testt; \n-- Выполняем на мастере DELETE\nDELETE FROM ts.testt WHERE i = 1;\nINSERT INTO ts.testt (t) VALUES ('AFTER DELETE');\nSELECT * FROM ts.testt;\n-- Проверяем на реплике - произошла репликация или нет\nSELECT * FROM ts.testt;\n-- Чистим реплику\nDROP SUBSCRIPTION IF EXISTS testt_sub;\nDROP TABLE IF EXISTS ts.testt;\n-- Чистим мастер\nDROP PUBLICATION IF EXISTS testt_pub;\nDROP TABLE IF EXISTS ts.testt;\n---\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003C\u002Fdiv\u003E\n                    \u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\nЕсли на мастере \u003Ccode\u003EREPLICA IDENTITY FULL\u003C\u002Fcode\u003E задана, то на реплике её наличие роли не играет — но только при условии, что состав столбцов таблицы на реплике идентичен таковому на мастере. Иначе на реплике будут применяться только команды \u003Ccode\u003EINSERT\u003C\u002Fcode\u003E, а если у вас 11 версия мастера — то и \u003Ccode\u003ETRUNCATE\u003C\u002Fcode\u003E. Команды \u003Ccode\u003EUPDATE\u003C\u002Fcode\u003E и \u003Ccode\u003EDELETE\u003C\u002Fcode\u003E будут применяться только если дополнительные столбцы в изменяемой\u002Fудаляемой строке будут равны NULL.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cdiv class=\"spoiler\" role=\"button\" tabindex=\"0\"\u003E\n                        \u003Cb class=\"spoiler_title\"\u003EПример реплики с REPLICA IDENTITY NOTHING\u003C\u002Fb\u003E\n                        \u003Cdiv class=\"spoiler_text\"\u003E\u003Cpre\u003E\u003Ccode class=\"sql\"\u003E-- Подготавливаем мастер\nCREATE TABLE ts.testt (i serial, \n                       t text, \n                       d text);\nALTER TABLE ts.testt REPLICA IDENTITY FULL;\nINSERT INTO ts.testt (t, d) VALUES ('001', 'first'), ('002', 'second'), ('003', 'third');\nCREATE PUBLICATION testt_pub for TABLE ts.testt;\nSELECT * FROM ts.testt;\n-- Подготавливаем реплику\nSELECT pg_reload_conf();\nCREATE TABLE ts.testt (d text, \n                       t text,\n                       i serial);\nALTER TABLE ts.testt REPLICA IDENTITY NOTHING;\nCREATE SUBSCRIPTION testt_sub \n  CONNECTION 'host=192.168.122.182 \n              dbname=test \n              user=log_rep_rolename\n              password=sadp!'\n  PUBLICATION testt_pub;\nSELECT pg_sleep(5.5);\nSELECT * FROM ts.testt;\n-- Выполняем на мастере INSERT, UPDATE, DELETE\nINSERT INTO ts.testt (t, d) VALUES ('004', 'fourth');\nUPDATE ts.testt SET t = t || ' upd' WHERE i = 4;\nDELETE FROM ts.testt WHERE i = 1;\nSELECT * FROM ts.testt;\n-- Проверяем на реплике - произошла репликация или нет\nSELECT * FROM ts.testt;\n-- Чистим реплику\nDROP SUBSCRIPTION IF EXISTS testt_sub;\nDROP TABLE IF EXISTS ts.testt;\n-- Чистим мастер\nDROP PUBLICATION IF EXISTS testt_pub;\nDROP TABLE IF EXISTS ts.testt;\n---\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003C\u002Fdiv\u003E\n                    \u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\nЕсли нужно реплицировать исторические данные или провести только начальную синхронизацию — можно вообще убрать идентификаторы репликации: \u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"sql\"\u003EALTER TABLE ts.testt REPLICA IDENTITY NOTHING;\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nэто снизит нагрузку на журнал предзаписи, декодирование и сеть. Но нужно обязательно создавать публикацию только для команд \u003Ccode\u003EINSERT\u003C\u002Fcode\u003E, иначе обновление и удаление в этой таблице работать перестанут, независимо от того — есть подписка или нет.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ch3\u003EСостав и порядок столбцов\u003C\u002Fh3\u003E\u003Cbr\u002F\u003E\r\nВне зависимости от выбранных репликационных идентификаторов — порядок столбцов, даже ключевых — значения практически не имеет. Начальная синхронизация и репликация команд \u003Ccode\u003EINSERT\u003C\u002Fcode\u003E проходят без проблем, независимо от настройки репликационных идентификаторов — идентификаторы строк в этом случае не передаются.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nЕсли же бездумно добавлять столбцы к таблице с той или другой стороны, то, например, при \u003Ccode\u003EREPLICA IDENTITY FULL\u003C\u002Fcode\u003E, придётся перезапускать репликацию для такой таблицы. Причём, в зависимости от способа прицеливания в ногу, можно либо добиться \u003Ca href=\"#uncosistecy\"\u003Eнеконсистентности\u003C\u002Fa\u003E на реплике, либо ещё и \u003Ca href=\"#overgrowth_wal\"\u003Eраздуть\u003C\u002Fa\u003E на мастере журнал предзаписи до невероятных размеров. Что, в одном случае, не даст возможности восстановить согласованность данных в проблемной таблице на реплике и приведёт к необходимости перезаливки данных. Во втором случае такая возможность останется (условно) и реализуется автоматически — после выявления и устранения причины такой ситуации, однако целостность данных после этого всё равно останется под сомнением.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nС первичными ключами и индексами ситуация значительно лучше. Хоть на реплике и нельзя удалять столбцы если такие есть на мастере, зато появляется возможность добавлять новые. И не просто добавлять, а различными способами заполнять их данными, без опаски получить остановку репликации или неконсистентность.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cdiv class=\"spoiler\" role=\"button\" tabindex=\"0\"\u003E\n                        \u003Cb class=\"spoiler_title\"\u003EПример репликации с различным порядком столбцов\u003C\u002Fb\u003E\n                        \u003Cdiv class=\"spoiler_text\"\u003E\u003Cpre\u003E\u003Ccode class=\"sql\"\u003E-- Подготавливаем мастер\nCREATE TABLE ts.testt (i serial, \n                       t varchar NOT NULL DEFAULT random(), \n                       d varchar DEFAULT random());\nCREATE UNIQUE INDEX CONCURRENTLY testt_idx ON ts.testt USING btree (i, t);\nALTER TABLE ts.testt REPLICA IDENTITY USING INDEX testt_idx;\nINSERT INTO ts.testt (t, d) VALUES ('001', 'first'), ('002', 'second'), ('003', 'third');\nCREATE PUBLICATION testt_pub for TABLE ts.testt;\nSELECT * FROM ts.testt;\n-- Подготавливаем реплику (Обратите внимание на типы)\nCREATE TABLE ts.testt (d text DEFAULT random(), \n                       s text DEFAULT now(),\n                       t text NOT NULL DEFAULT random(), \n                       i bigserial);\nCREATE UNIQUE INDEX CONCURRENTLY testt_idx ON ts.testt USING btree (t, i);\nALTER TABLE ts.testt REPLICA IDENTITY USING INDEX testt_idx;\nCREATE SUBSCRIPTION testt_sub \n  CONNECTION 'host=192.168.122.182 \n              dbname=test \n              user=log_rep_rolename \n              password=sadp!'\n  PUBLICATION testt_pub;\nSELECT pg_sleep(5.5);\nSELECT * FROM ts.testt;\n-- Выполняем на мастере вставку строки\nINSERT INTO ts.testt (t, d) VALUES ('004', 'fourth');\nSELECT * FROM ts.testt;\n-- Проверяем на реплике - произошла репликация или нет\nSELECT * FROM ts.testt;\n-- Выполняем на мастере UPDATE\nUPDATE ts.testt SET t = t || ' upd' WHERE random() \u003E= 0.5;\nINSERT INTO ts.testt (t, d) VALUES ('005', 'AFTER UPDATE');\nSELECT * FROM ts.testt;\n-- Проверяем на реплике - произошла репликация или нет\nSELECT * FROM ts.testt; \n-- Выполняем на мастере DELETE\nDELETE FROM ts.testt WHERE random() \u003E= 0.5;\nINSERT INTO ts.testt (t, d) VALUES ('006', 'AFTER DELETE');\nSELECT * FROM ts.testt;\n-- Проверяем на реплике - произошла репликация или нет\nSELECT * FROM ts.testt;\n-- Чистим реплику\nDROP SUBSCRIPTION IF EXISTS testt_sub;\nDROP TABLE IF EXISTS ts.testt;\n-- Чистим мастер\nDROP PUBLICATION IF EXISTS testt_pub;\nDROP TABLE IF EXISTS ts.testt;\n---\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003C\u002Fdiv\u003E\n                    \u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\n\u003Ch2\u003EСклад грабель горизонтального хранения\u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\r\nПредупреждён — значит вооружен. Ниже приведены несколько самых распространённых сообщений об ошибках и просто общих рассуждений. Лучше прочитать эти сообщения здесь, чем на рабочих серверах — читаем и вооружаемся. Если у вас есть что-нибудь интересное на эту тему — расскажите в комментариях.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ch2\u003E\u003Ca name=\"update_delete_fail\"\u003E\u003C\u002Fa\u003EЕсли на мастере репликационные идентификаторы не заложены в бюджет\u003C\u002Fh2\u003EПо умолчанию публикация создаётся для команд \u003Ccode\u003EINSERT\u003C\u002Fcode\u003E, \u003Ccode\u003EUPDATE\u003C\u002Fcode\u003E и \u003Ccode\u003EDELETE\u003C\u002Fcode\u003E (и \u003Ccode\u003ETRUNCATE\u003C\u002Fcode\u003E, начиная с 11 версии). При этом проверки идентификаторов репликации в целевых таблицах не происходит, от этого может получиться так, что они будут не у всех таблиц. Мало того — после создания публикации допускается сброс или удаление репликационного идентификатора:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"pgsql\"\u003EALTER TABLE tablename REPLICA IDENTITY DEFAULT;\nALTER TABLE tablename REPLICA IDENTITY NOTHING;\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nПервое — сброс на значение по умолчанию, то есть на использование первичного ключа таблицы и если он есть — жить можно. Второе — отключение идентификаторов на таблице. Но если нет первичного ключа или идентификаторов вообще, то, при попытке выполнить на мастере обновление или удаление строк, будут получены соответствующие ошибки:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"plaintext\"\u003EERROR:  cannot update table \"tablename\" because it does not have a replica identity and publishes updates\nHINT:  To enable updating the table, set REPLICA IDENTITY using ALTER TABLE.\n\nERROR:  cannot delete from table \"tablename\" because it does not have a replica identity and publishes deletes\nHINT:  To enable deleting from the table, set REPLICA IDENTITY using ALTER TABLE.\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nТак будет в случае, когда публикация не создана исключительно для команд \u003Ccode\u003EINSERT\u003C\u002Fcode\u003E и, для одиннадцатой версии — \u003Ccode\u003ETRUNCATE\u003C\u002Fcode\u003E. Вариантов исправления такой ситуации два — изменить подписку на \u003Ccode\u003Epublish='insert'\u003C\u002Fcode\u003E или добавить репликационные идентификаторы.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cdiv class=\"spoiler\" role=\"button\" tabindex=\"0\"\u003E\n                        \u003Cb class=\"spoiler_title\"\u003EВоспроизведение\u003C\u002Fb\u003E\n                        \u003Cdiv class=\"spoiler_text\"\u003E\u003Cpre\u003E\u003Ccode class=\"sql\"\u003E-- Подготавливаем мастер\nCREATE TABLE ts.testt (i serial, \n                       t varchar, \n                       d varchar);\nALTER TABLE ts.testt REPLICA IDENTITY NOTHING;\nINSERT INTO ts.testt (t, d) VALUES ('001', 'first'), ('002', 'second'), ('003', 'third');\nCREATE PUBLICATION testt_pub for TABLE ts.testt;\nSELECT * FROM ts.testt;\n-- Проверяем INSERT\nINSERT INTO ts.testt (t, d) VALUES ('004', 'fourth');\n-- Проверяем UPDATE\nUPDATE ts.testt SET t = t || ' upd' WHERE i = 3;\n-- Проверяем DELETE\nDELETE FROM ts.testt WHERE i = 4;\nSELECT * FROM ts.testt;\n-- Исправляем публикацию\nALTER PUBLICATION testt_pub SET (publish = 'insert'); -- v.10\n--ALTER PUBLICATION testt_pub SET (publish = 'insert, truncate'); -- v. \u003E=11\n-- Проверяем UPDATE\nUPDATE ts.testt SET t = t || ' upd' WHERE i = 3;\n-- Проверяем DELETE\nDELETE FROM ts.testt WHERE i = 4;\nSELECT * FROM ts.testt;\n-- Чистим мастер\nDROP PUBLICATION IF EXISTS testt_pub;\nDROP TABLE IF EXISTS ts.testt;\n---\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003C\u002Fdiv\u003E\n                    \u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\n\u003Ch2\u003E\u003Ca name=\"uncosistecy\"\u003E\u003C\u002Fa\u003E... not find row.. .\u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"plaintext\"\u003EDEBUG:  logical replication did not find row for update in replication target relation \"your_table_name\"\nDEBUG:  logical replication could not find row for delete in replication target relation \"your_table_name\"\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E \u003Cbr\u002F\u003E\r\nПример сообщений которые можно увидеть когда:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cul\u003E\r\n\u003Cli\u003E на реплике добавили столбец и его значение не \u003Ccode\u003ENULL\u003C\u002Fcode\u003E;\u003C\u002Fli\u003E\r\n\u003Cli\u003E на реплике по какой-либо причине строки отсутствуют, а на мастере они есть;\u003C\u002Fli\u003E\r\n\u003Cli\u003E на реплике были изменены строки;\u003C\u002Fli\u003E\r\n\u003Cli\u003E на реплике нет строки с переданным значением репликационного идентификатора\u003C\u002Fli\u003E\r\n\u003C\u002Ful\u003E\u003Cbr\u002F\u003E\r\nЕсли на реплике сложилась одна из приведённых ситуаций, то, при обычном значении параметра \u003Ccode\u003Elog_min_messages=warning\u003C\u002Fcode\u003E, этих сообщений в логах реплики не появится. От того и о пропавших данных можно узнать, когда будет уже очень поздно. А можно и не узнать. С точки зрения СУБД в таком поведении нет ничего предосудительного, возможно таков был план. Но если это не был план, то для приложения это катастрофа, так что тут нужно быть предусмотрительным и внимательным.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nНаблюдать эти сообщения в логах возможно при \u003Ccode\u003Elog_min_messages=debug1\u003C\u002Fcode\u003E. Однако так увеличится объём логов, но консистентности данных не прибавится — реплика, получив сообщение об изменениях, не смогла найти изменяемую\u002Fудаляемую строку и благополучно выкинула сообщение на свалку истории, а второго шанса ей не предоставится. Мастер не будет уведомлен об этом и в свои логи писать ничего не станет. Следует учесть, что в этом режиме в лог будет записываться строка подключения, вместе с именем пользователя и его паролем — сомнительное преимущество использования такого уровня сообщений журнала. \u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nВ данном случае можно радоваться хотя бы тому, что на мастере такое поведение почти никак не скажется. В этом случае реплика получает сообщения репликации, затем, не применив их, отчитывается мастеру, что всё хорошо и журнал предзаписи не разрастается. Конечно, после такого инцидента придётся выправлять сложившееся положение дел: \u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Col\u003E\r\n\u003Cli\u003EНа мастере исключать таблицу из публикации; \u003C\u002Fli\u003E\r\n\u003Cli\u003EНа реплике обновлять подписку и вычищать таблицу;\u003C\u002Fli\u003E\r\n\u003Cli\u003EПривести состав столбцов к единому виду;\u003C\u002Fli\u003E\r\n\u003Cli\u003EВключать на мастере таблицу в публикацию; \u003C\u002Fli\u003E\r\n\u003Cli\u003EОбновлять подписку на реплике и ждать перезаливки данных.\u003C\u002Fli\u003E\r\n\u003C\u002Fol\u003E\u003Cbr\u002F\u003E\r\nА всего нужно было — не добавлять столбцы в таблицу на стороне реплики если используется \u003Ccode\u003EREPLICA IDENTITY FULL\u003C\u002Fcode\u003E или не изменять, бездумно, данные на реплике.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nВ отличие от \u003Ccode\u003EUPDATE\u003C\u002Fcode\u003E и \u003Ccode\u003EDELETE\u003C\u002Fcode\u003E, операция \u003Ccode\u003EINSERT\u003C\u002Fcode\u003E и начальная синхронизация будут нормально обрабатываться, даже если на реплике есть столбцы отсутствующие на мастере.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cdiv class=\"spoiler\" role=\"button\" tabindex=\"0\"\u003E\n                        \u003Cb class=\"spoiler_title\"\u003EВоспроизведение\u003C\u002Fb\u003E\n                        \u003Cdiv class=\"spoiler_text\"\u003E\u003Cpre\u003E\u003Ccode class=\"sql\"\u003E-- Подготавливаем мастер\nCREATE TABLE ts.testt (i serial, \n                       t varchar, \n                       d varchar);\nALTER TABLE ts.testt REPLICA IDENTITY FULL;\nINSERT INTO ts.testt (t, d) \n  VALUES ('001', 'first'), ('002', 'second'), ('003', 'third');\nCREATE PUBLICATION testt_pub for TABLE ts.testt;\nSELECT * FROM ts.testt;\n-- Подготавливаем реплику\nSELECT setting AS lmm FROM pg_settings WHERE name = 'log_min_messages' \\gset\nALTER SYSTEM SET log_min_messages=debug1;\nSELECT pg_reload_conf();\nCREATE TABLE ts.testt (i serial, \n                       t varchar, \n                       d varchar,\n                       x numeric);\nCREATE SUBSCRIPTION testt_sub \n  CONNECTION 'host=192.168.122.182 \n              dbname=test \n              user=log_rep_rolename \n              password=sadp!'\n  PUBLICATION testt_pub;\nSELECT pg_sleep(5.5);\nSELECT * FROM ts.testt;\n-- Выполняем на мастере UPDATE и DELETE\nUPDATE ts.testt SET t = t || ' upd' WHERE i = 2;\nDELETE FROM ts.testt WHERE i = 3;\nSELECT * FROM ts.testt;\n-- Проверяем на реплике - произошла репликация или нет\n-- Заодно меняем одну строчку и удаляем другую\nSELECT * FROM ts.testt;\nUPDATE ts.testt SET t = 'updated on the replica' WHERE i = 1;\nDELETE FROM ts.testt WHERE i = 2;\nSELECT * FROM ts.testt;\n-- На мастере обновляем строку которой уже нет на реплике\n-- а удаляем ту, которая есть, но уже отличается\n-- от версии на мастере. Для того чтоб убедиться в \n-- том, что репликация прошла - после изменений вставим строки\n-- если репликация приостановится, то вставленные строки\n-- не появятся на реплике.\nUPDATE ts.testt SET t = 'updated on the master' WHERE i = 2;\nDELETE FROM ts.testt WHERE i = 1;\nINSERT INTO ts.testt (t, d) \n  VALUES ('004', 'fourth'), ('005', 'fifth element'), ('006', 'sixth');\nSELECT * FROM ts.testt; \n-- Проверяем на реплике - произошла репликация или нет\nSELECT * FROM ts.testt; -- полимеры утрачены, смотрим логи\n-- Добавляем первичные ключи через предварительное создание\n-- уникального индекса.\n-- Cначала на реплике, иначе ошибки приостановят репликацию\nCREATE UNIQUE INDEX CONCURRENTLY testt_hm_idx ON ts.testt (i);\nALTER TABLE ts.testt\n  ADD CONSTRAINT hm_pkey PRIMARY KEY USING INDEX testt_hm_idx;\n-- Затем на мастере\nCREATE UNIQUE INDEX CONCURRENTLY testt_hm_idx ON ts.testt (i);\nALTER TABLE ts.testt\n  ADD CONSTRAINT hm_pkey PRIMARY KEY USING INDEX testt_hm_idx;\n-- Изменим значения полей на реплике\nUPDATE ts.testt SET t = 'updated on the replica again' WHERE i &lt;\u003E 1;\nSELECT * FROM ts.testt; \n-- Обновляем и удаляем пару строк на мастере.\n-- Для того чтоб убедиться в том, что репликация\n-- прошла - после изменений вставим строку.\n-- Если репликация приостановится, то вставленная строка\n-- не появится на реплике.\nUPDATE ts.testt SET t = 'recently updated on the master' WHERE i = 6;\nDELETE FROM ts.testt WHERE i = 4;\nINSERT INTO ts.testt (t, d) \n  VALUES ('007', 'seventh');\nSELECT * FROM ts.testt; \n-- Проверяем на реплике - произошла репликация или нет\n-- i=4 удалён, i=6 обновлён, новая строка появилась\n-- вот что PK животворящий делает!\nSELECT * FROM ts.testt; \n-- Чистим реплику\nDROP SUBSCRIPTION IF EXISTS testt_sub;\nDROP TABLE IF EXISTS ts.testt;\nALTER SYSTEM SET log_min_messages = :lmm;\nSELECT pg_reload_conf();\n-- Чистим мастер\nDROP PUBLICATION IF EXISTS testt_pub;\nDROP TABLE IF EXISTS ts.testt;\n---\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003C\u002Fdiv\u003E\n                    \u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\n\u003Ch2\u003E\u003Ca name=\"overgrowth_wal\"\u003E\u003C\u002Fa\u003EЛишний столбец на мастере\u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\r\nЕсли же случилось так, что кто-то удосужился создать лишний столбец на мастере, то на реплике начнёт появляться множество таких сообщений: \u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"plaintext\"\u003EDEBUG:  starting logical replication worker for subscription \"your_subscription_name\"\nDEBUG:  registering background worker \"logical replication worker for subscription 16766\"\nDEBUG:  starting background worker process \"logical replication worker for subscription 16766\"\nLOG:  logical replication apply worker for subscription \"your_subscription_name\" has started\nDEBUG:  connecting to publisher using connection string \"host=192.168.122.182 dbname=your_db_name\"\nERROR:  logical replication target relation \"public.your_table_name\" is missing some replicated columns\nDEBUG:  unregistering background worker \"logical replication worker for subscription 16766\"\nLOG:  background worker \"logical replication worker\" (PID 10708) exited with exit code 1\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nА на мастере множество таких:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"plaintext\"\u003EDEBUG:  received replication command: IDENTIFY_SYSTEM\nDEBUG:  received replication command: START_REPLICATION SLOT \"your_subscription_name\" LOGICAL 0\u002F0 (proto_version '1', publication_names '\"your_publication_name\"')\nLOG:  starting logical decoding for slot \"your_subscription_name\"\nDETAIL:  streaming transactions committing after 0\u002F1AC5FAD0, reading WAL from 0\u002F1AC5FA98\nLOG:  logical decoding found consistent point at 0\u002F1AC5FA98\nDETAIL:  There are no running transactions.\nDEBUG:  got new restart lsn 0\u002F1AC5FC40 at 0\u002F1AC5FC40\nDEBUG:  \"your_subscription_name\" has now caught up with upstream server\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nТо есть вставка, изменение и удаление строк не принимается репликой, ведь на стороне реплики нет столбцов для поступивших данных. О сложившейся ситуации мастер «информируется». В этом случае на реплике постоянно создаётся и уничтожается новый процесс репликации для сбойной подписки.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nВ результате на мастере начнёт раздувать журнал предзаписи независимо от типа операции. Так можно довести и до останова сервера, не заметив вовремя разбухание журнала. Удаление столбца на стороне мастера не спасёт — логическое декодирование будет использовать записи из журнала предзаписи, а там добавленный столбец есть и никуда не денется. Также не спасёт и удаление таблицы из публикации — это связано с тем, что публикацией может пользоваться несколько подписок и такое лекарство окажется опаснее болезни, потому и возможность такую не реализовали. \u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nЛично я считаю, что для публикаций с одним подписчиком не помешает добавить такую возможность — но пока что разработчики так не думают. В общем имеется три варианта: \u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cul\u003E\r\n\u003Cli\u003EДобавить на реплику недостающий столбец и надеяться, что на обоих серверах их содержимое совпадает (\\x6c6f6c), иначе все операции \u003Ccode\u003EUPDATE\u003C\u002Fcode\u003E и \u003Ccode\u003EDELETE\u003C\u002Fcode\u003E по несовпадающим строкам пропадут и оставят после себя уже знакомые записи в логе \"\u003Ccode\u003E... not find row for ...\u003C\u002Fcode\u003E\" — это относится к \u003Ccode\u003EREPLICA IDENTITY FULL\u003C\u002Fcode\u003E. \u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nОтсутствие в добавленном столбце данных, имеющихся на мастере, приведет к тому, что пробка, конечно, рассосётся — только вот накопившиеся операции \u003Ccode\u003EINSERT\u003C\u002Fcode\u003E данных попадут в таблицу на реплике, а \u003Ccode\u003EUPDATE\u003C\u002Fcode\u003E и \u003Ccode\u003EDELETE\u003C\u002Fcode\u003E — нет. Потому что идентификатором строки будет вся строка, а в одном из столбцов данные не совпадают. \u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nВыбор так себе, но так можно относительно безопасно разгрести журнал предзаписи на мастере и не доводить до второго способа. Ну а далее — чистим публикацию от проблемной таблицы, обновляем подписку, добавляем таблицу обратно в публикацию, добавляем в таблицу недостающие столбцы, обновляем подписку, ждём. Если же на обоих серверах нормальные репликационные идентификаторы — первичный ключ или уникальный индекс — репликация восстановится без потерь данных.\u003C\u002Fli\u003E\r\n\u003Cli\u003EУдалить подписку целиком и создать вновь, не забыв очистить таблицу перед пересозданием, ну и столбцы в неё добавить. Сработает потому, что удалится слот на стороне мастера.\u003C\u002Fli\u003E\r\n\u003Cli\u003EМожно, на основе общего с мастером столбца, создать на реплике первичный ключ, или уникальный индекс в качестве \u003Ccode\u003EREPLICA IDENTITY\u003C\u002Fcode\u003E. После этого добавить недостающий столбец. Однако, при этом нужно быть уверенным, что значения в выбранном для репликационного идентификатора столбце — уникальны для всех строк таблицы. Тут возникает вопрос — почему первичный ключ не был создан сразу?\u003C\u002Fli\u003E\r\n\u003C\u002Ful\u003E\u003Cbr\u002F\u003E\r\n\u003Cdiv class=\"spoiler\" role=\"button\" tabindex=\"0\"\u003E\n                        \u003Cb class=\"spoiler_title\"\u003EВоспроизведение\u003C\u002Fb\u003E\n                        \u003Cdiv class=\"spoiler_text\"\u003E\u003Cpre\u003E\u003Ccode class=\"sql\"\u003E-- Подготавливаем мастер\nCREATE TABLE ts.testt (i serial, \n                       t varchar, \n                       d varchar);\nALTER TABLE ts.testt REPLICA IDENTITY FULL;\nINSERT INTO ts.testt (t, d) \n  VALUES ('001', 'first'), ('002', 'second'), ('003', 'third');\nCREATE PUBLICATION testt_pub for TABLE ts.testt;\nSELECT * FROM ts.testt;\n-- Подготавливаем реплику\nCREATE TABLE ts.testt (i serial, \n                       t text);\nCREATE SUBSCRIPTION testt_sub \n  CONNECTION 'host=192.168.122.182 \n              dbname=test \n              user=log_rep_rolename \n              password=sadp!'\n  PUBLICATION testt_pub;\nSELECT pg_sleep(5.5);\nSELECT * FROM ts.testt;\n-- Смотрим логи, потом добавляем на реплике недостающий столбец\nALTER TABLE ts.testt ADD COLUMN d text;\nSELECT pg_sleep(5.5);\nSELECT * FROM ts.testt;\n-- Чистим реплику\nDROP SUBSCRIPTION IF EXISTS testt_sub;\nDROP TABLE IF EXISTS ts.testt;\n-- Чистим мастер\nDROP PUBLICATION IF EXISTS testt_pub;\nDROP TABLE IF EXISTS ts.testt;\n---\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003C\u002Fdiv\u003E\n                    \u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\n\u003Ch2\u003E\u003Ca name=\"duplicate_key\"\u003E\u003C\u002Fa\u003EДубликаты значений в столбцах репликационных идентификаторов или «Раньше думать надо было!»\u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"plaintext\"\u003EПри начальной синхронизации\nERROR:  duplicate key value violates unique constraint \"testt_pkey\"\nDETAIL:  Key (i)=(3) already exists.\nCONTEXT:  COPY testt, line 3  -- Заодно узнали какой командой переносятся данные при ничальной синхронизации\n\nПосле перехода в режим репликации\nERROR:  duplicate key value violates unique constraint \"testt_pkey\"\nDETAIL:  Key (i)=(4) already exists.\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nВозникают такие ошибки потому, что с мастера на реплику приходит новая строка с имеющимся на реплике значением репликационного идентификатора на основе первичного ключа или уникального индекса. При обновлении логической репликацией или простом переносе данных такие ошибки не появляются. Они появляются если база находится в доступе на запись для пользователей или приложений и те этим пользуются. По сути, это не ошибка PostgreSQL, это ошибка проектирования и вопросы нужно задавать себе.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nИсправлять такие инциденты не так уж и просто — сначала необходимо определить какая из двух конфликтующих строк неправильная, и насколько. Если неправильным является содержимое строки на реплике, то репликация продолжится после удаления с реплики такой строки. \u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nСовсем другое дело, когда неправильной является строка, пришедшая с мастера. В этом случае всё равно придётся либо удалять строку на реплике, либо назначать ей заведомо большой идентификатор; ждать завершения загрузки с мастера отставших транзакций; заменять пришедшую с мастера строку старой строкой с реплики.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nСитуация в обоих случаях усугубляется тем, что лишних строк может быть очень много. Настолько, что новые транзакции будут выполняться быстрее, чем будут разбираться конфликтные ситуации. И всё время, пока расследуется инцидент, размер журнала предзаписи будет разрастаться, а пользователи реплики не будут иметь возможности получать актуальные данные. \u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nЕсли предполагается использовать логическую репликацию не для обновления, а для обмена данными между различными базами — следует очень внимательно проработать вопрос об идентификации строк. Так как для идентификации, обычно, используются последовательности, то можно посоветовать пробежаться по слайдам доклада CTO Stickeroid Ai, Камиля Исламова \u003Ca href=\"https:\u002F\u002Fpgconf.ru\u002Fmedia\u002F2020\u002F02\u002F04\u002F%D0%9A%D0%B0%D0%BC%D0%B8%D0%BB%D1%8C%20%D0%98%D1%81%D0%BB%D0%B0%D0%BC%D0%BE%D0%B2%20-%20%D0%9C%D0%B5%D1%82%D0%BE%D0%B4%D1%8B%20%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F%20Sequences%20%D0%B2%20%D0%B1%D0%B8%D0%B7%D0%BD%D0%B5%D1%81-%D0%BB%D0%BE%D0%B3%D0%B8%D0%BA%D0%B5.pdf\"\u003Eо способах применения последовательностей в PostgreSQL\u003C\u002Fa\u003E и документацию по последовательностям, затем перепроектировать их в сбойной системе баз данных.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cdiv class=\"spoiler\" role=\"button\" tabindex=\"0\"\u003E\n                        \u003Cb class=\"spoiler_title\"\u003EВоспроизведение\u003C\u002Fb\u003E\n                        \u003Cdiv class=\"spoiler_text\"\u003E\u003Cpre\u003E\u003Ccode class=\"sql\"\u003E-- Подготавливаем мастер\nCREATE TABLE ts.testt (i serial PRIMARY KEY, \n                       t varchar);\nALTER TABLE ts.testt REPLICA IDENTITY FULL;\nINSERT INTO ts.testt (t) \n  VALUES ('001'), ('002'), ('003');\nCREATE PUBLICATION testt_pub for TABLE ts.testt;\nSELECT * FROM ts.testt;\n-- Подготавливаем реплику\nCREATE TABLE ts.testt (i bigserial PRIMARY KEY, \n                       t text);\nINSERT INTO ts.testt (i, t) \n  VALUES (3, '003 only replica value'),\n         (4, '004 only replica value');\nCREATE SUBSCRIPTION testt_sub \n  CONNECTION 'host=192.168.122.182 \n              dbname=test \n              user=log_rep_rolename \n              password=sadp!'\n  PUBLICATION testt_pub;\nSELECT pg_sleep(5.5);\nSELECT * FROM ts.testt;\n-- Смотрим логи, потом удаляем лишнюю строчку на реплике\n-- на мастере удалять не поможет - порядок применения\n-- сообщений репликации - транзакционный. Удаленная на мастере\n-- строка удалится на реплике только после разрешения инцидента.\nDELETE FROM ts.testt WHERE i = 3;\nSELECT pg_sleep(5.5);\nSELECT * FROM ts.testt;\n-- Чистим реплику\nDROP SUBSCRIPTION IF EXISTS testt_sub;\nDROP TABLE IF EXISTS ts.testt;\n-- Чистим мастер\nDROP PUBLICATION IF EXISTS testt_pub;\nDROP TABLE IF EXISTS ts.testt;\n---\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003C\u002Fdiv\u003E\n                    \u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\n\u003Ch2\u003E\u003Ca name=\"nnwd\"\u003E\u003C\u002Fa\u003EСтолбец NOT NULL без DEFAULT на реплике\u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"plaintext\"\u003EERROR:  null value in column \"column_name\" violates not-null constraint\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nДля любых столбцов на реплике не должно быть установлено свойство \u003Ccode\u003ENOT NULL\u003C\u002Fcode\u003E без указания значения по умолчанию. Особенно это касается тех столбцов, которые есть на мастере, потому что на реплике для них значение \u003Ccode\u003EDEFAULT\u003C\u002Fcode\u003E подставляться не будет — как пришел \u003Ccode\u003ENULL\u003C\u002Fcode\u003E, так и будет записываться. \u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nЕсли в дополнительные \u003Ccode\u003ENOT NULL\u003C\u002Fcode\u003E столбцы значение по умолчанию не поставить, то репликация приостановится с приведённой выше ошибкой. Как только удалите такой столбец, зададите ему значение по умолчанию или удалите ограничение \u003Ccode\u003ENOT NULL\u003C\u002Fcode\u003E — репликация возобновится без потери данных.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nЕсли в реплицируемой таблице на стороне мастера изначально есть значения \u003Ccode\u003ENULL\u003C\u002Fcode\u003E — сначала необходимо заполнить такие поля, либо удалить ограничение \u003Ccode\u003ENOT NULL\u003C\u002Fcode\u003E на реплике.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nПри появлении такой ошибки в начале репликации можно узнать из логов название проблемной таблицы, но не схему в которой она расположена:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"plaintext\"\u003EERROR:  null value in column \"d\" violates not-null constraint\nDETAIL:  Failing row contains (3, 003, null).\nCONTEXT:  COPY testt, line 3: \"3    003     \\N\"\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nЕсли же начальная синхронизация давно закончилась и репликация идёт полным ходом, то в логах записи о таблице не будет — придётся искать вручную.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cdiv class=\"spoiler\" role=\"button\" tabindex=\"0\"\u003E\n                        \u003Cb class=\"spoiler_title\"\u003EВоспроизведение\u003C\u002Fb\u003E\n                        \u003Cdiv class=\"spoiler_text\"\u003E\u003Cpre\u003E\u003Ccode class=\"sql\"\u003E-- Подготавливаем мастер\nCREATE TABLE ts.testt (i serial PRIMARY KEY, t text, d text);\nINSERT INTO ts.testt (t, d) VALUES ('001', 'first'), ('002', 'second'), ('003', NULL);\nCREATE PUBLICATION testt_pub for TABLE ts.testt;\nSELECT * FROM ts.testt;\n-- Подготавливаем реплику\nCREATE TABLE ts.testt (i serial PRIMARY KEY, t text, d text NOT NULL DEFAULT 'null from master');\nCREATE SUBSCRIPTION testt_sub \n  CONNECTION 'host=192.168.122.182 \n              dbname=test \n              user=log_rep_rolename \n              password=sadp!'\n  PUBLICATION testt_pub;\nSELECT pg_sleep(5.5);\nSELECT * FROM ts.testt;\n-- Начальная синхронизация не сработала - смотрите логи\n-- Исправляем проблему со столбцом d\n-- Добавляем новый столбец, которого нет на мастере\nALTER TABLE ts.testt ALTER COLUMN d DROP NOT NULL,\n                     ALTER COLUMN d DROP DEFAULT;\nSELECT pg_sleep(5.5);\nSELECT * FROM ts.testt;\nALTER TABLE ts.testt ADD COLUMN x text NOT NULL DEFAULT 'start default';\nALTER TABLE ts.testt ALTER COLUMN x DROP DEFAULT;\nSELECT * FROM ts.testt;\n-- Выполняем на мастере вставку\nINSERT INTO ts.testt (t) VALUES ('004');\nSELECT * FROM ts.testt;\n-- Проверяем логи реплике - там уже куча ошибок\n-- Затем исправляем на реплике проблему\n-- Либо убираем NOT NULL\n--   ALTER TABLE ts.testt ALTER COLUMN x DROP NOT NULL;\n-- Либо добавляем DEFAULT\n--   ALTER TABLE ts.testt ALTER COLUMN x SET DEFAULT 'second default';\n-- Либо удаляем столбец\n--   ALTER TABLE ts.testt DROP COLUMN x;\n-- Проверяем на реплике - произошла репликация или нет\nSELECT pg_sleep(5.5);\nSELECT * FROM ts.testt;\n-- Чистим реплику\nDROP SUBSCRIPTION IF EXISTS testt_sub;\nDROP TABLE IF EXISTS ts.testt;\n-- Чистим мастер\nDROP PUBLICATION IF EXISTS testt_pub;\nDROP TABLE IF EXISTS ts.testt;\n---\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003C\u002Fdiv\u003E\n                    \u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\n\u003Ch2\u003E\u003Ca name=\"mhpk_rhnpk_ud\"\u003E\u003C\u002Fa\u003EНа мастере есть первичный ключ, на реплике он отсутствует\u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"plaintext\"\u003EERROR:  logical replication target relation \"ts.testt\" has neither REPLICA IDENTITY index nor PRIMARY KEY and published relation does not have REPLICA IDENTITY FULL\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nОшибка наблюдается при репликации команд \u003Ccode\u003EUPDATE\u003C\u002Fcode\u003E и \u003Ccode\u003EDELETE\u003C\u002Fcode\u003E, если в таблице на реплике отсутствует первичный ключ, который есть на мастере. Повторяется до тех пор, пока на реплике не будет создан соответствующий первичный ключ. Репликация при этом приостанавливается и продолжается после устранения причины ошибки. Состав столбцов на обоих серверах либо идентичен, либо на реплике могут быть дополнительные столбцы; порядок столбцов может различаться.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cdiv class=\"spoiler\" role=\"button\" tabindex=\"0\"\u003E\n                        \u003Cb class=\"spoiler_title\"\u003EВоспроизведение\u003C\u002Fb\u003E\n                        \u003Cdiv class=\"spoiler_text\"\u003E\u003Cpre\u003E\u003Ccode class=\"sql\"\u003E-- Подготавливаем мастер\nCREATE TABLE ts.testt (i serial PRIMARY KEY, t text, d text);\nINSERT INTO ts.testt (t, d) VALUES ('001', 'first'), ('002', 'second'), ('003', 'third');\nCREATE PUBLICATION testt_pub for TABLE ts.testt;\nSELECT * FROM ts.testt;\n-- Подготавливаем реплику\nCREATE TABLE ts.testt (i serial, t text, d text); \nCREATE SUBSCRIPTION testt_sub \n  CONNECTION 'host=192.168.122.182 \n              dbname=test \n              user=log_rep_rolename \n              password=sadp!'\n  PUBLICATION testt_pub;\nSELECT pg_sleep(5.5);\nSELECT * FROM ts.testt;\n-- Выполняем на мастере обновление\nUPDATE ts.testt SET t = t || ' updated' WHERE i = 1;\nINSERT INTO ts.testt (t, d) VALUES ('004', 'AFTER UPDATE');\nSELECT * FROM ts.testt;\n-- Проверяем на реплике - произошла репликация или нет\nSELECT pg_sleep(5.5);\nSELECT * FROM ts.testt; -- репликация не произошла\n-- Исправляем на реплике отсутствие первичного ключа, ждём, проверяем репликацию, удаляем первичный ключ для воспроизведения ошибки при удалении строки.\nALTER TABLE ts.testt ADD PRIMARY KEY (i);\nSELECT pg_sleep(5.5);\nSELECT * FROM ts.testt; -- репликация возобновилась\nALTER TABLE ts.testt DROP CONSTRAINT testt_pkey;\n-- Выполняем на мастере удаление\nDELETE FROM ts.testt WHERE i = 1;\nINSERT INTO ts.testt (t, d) VALUES ('005', 'AFTER DELETE');\nSELECT * FROM ts.testt;\n-- Проверяем на реплике - произошла репликация или нет\nSELECT pg_sleep(5.5);\nSELECT * FROM ts.testt; -- репликация не произошла\n-- Исправляем на реплике отсутствие первичного ключа, ждём, проверяем репликацию\nALTER TABLE ts.testt ADD PRIMARY KEY (i);\nSELECT pg_sleep(5.5);\nSELECT * FROM ts.testt; -- репликация возобновилась\n-- Чистим реплику\nDROP SUBSCRIPTION IF EXISTS testt_sub;\nDROP TABLE IF EXISTS ts.testt;\n-- Чистим мастер\nDROP PUBLICATION IF EXISTS testt_pub;\nDROP TABLE IF EXISTS ts.testt;\n---\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003C\u002Fdiv\u003E\n                    \u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ch2\u003E\u003Ca name=\"dpk\"\u003E\u003C\u002Fa\u003EНа мастере и реплике первичные ключи или индексы построены на разных столбцах\u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"plaintext\"\u003EERROR:  publisher did not send replica identity column expected by the logical replication target relation \"ts.testt\"\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nОшибка появляется при репликации команд \u003Ccode\u003EUPDATE\u003C\u002Fcode\u003E и \u003Ccode\u003EDELETE\u003C\u002Fcode\u003E, если в таблице на реплике первичный ключ (индекс) построен не на том столбце, на котором построен первичный ключ (индекс) на мастере. Повторяется до тех пор, пока на реплике не будет удалён неправильный и не будет создан правильный первичный ключ (индекс). \u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nРепликация при этом приостанавливается и продолжается после устранения причины ошибки. На реплике могут быть дополнительные столбцы, порядок столбцов может различаться.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cdiv class=\"spoiler\" role=\"button\" tabindex=\"0\"\u003E\n                        \u003Cb class=\"spoiler_title\"\u003EВоспроизведение\u003C\u002Fb\u003E\n                        \u003Cdiv class=\"spoiler_text\"\u003E\u003Cpre\u003E\u003Ccode class=\"sql\"\u003E-- Подготавливаем мастер\nCREATE TABLE ts.testt (i serial PRIMARY KEY, t text, d text);\nINSERT INTO ts.testt (t, d) VALUES ('001', 'first'), ('002', 'second'), ('003', 'third');\nCREATE PUBLICATION testt_pub for TABLE ts.testt;\nSELECT * FROM ts.testt;\n-- Подготавливаем реплику\nCREATE TABLE ts.testt (i serial, t text PRIMARY KEY, d text); \nCREATE SUBSCRIPTION testt_sub \n  CONNECTION 'host=192.168.122.182 \n              dbname=test \n              user=log_rep_rolename \n              password=sadp!'\n  PUBLICATION testt_pub;\nSELECT pg_sleep(5.5);\nSELECT * FROM ts.testt;\n-- Выполняем на мастере обновление\nUPDATE ts.testt SET t = t || ' upd' WHERE i = 1;\nINSERT INTO ts.testt (t, d) VALUES ('004', 'AFTER UPDATE');\nSELECT * FROM ts.testt;\n-- Проверяем на реплике - произошла репликация или нет\nSELECT pg_sleep(5.5);\nSELECT * FROM ts.testt; -- посмотреть ошибки\n-- Исправляем на реплике неправильный первичный ключ, ждём, проверяем репликацию, возвращаем неправильный первичный ключ для воспроизведения ошибки при удалении строки.\nALTER TABLE ts.testt DROP CONSTRAINT testt_pkey;\nALTER TABLE ts.testt ADD PRIMARY KEY (i);\nSELECT pg_sleep(5.5);\nSELECT * FROM ts.testt; -- репликация возобновилась\nALTER TABLE ts.testt DROP CONSTRAINT testt_pkey;\nALTER TABLE ts.testt ADD PRIMARY KEY (t);\n-- Выполняем на мастере удаление\nDELETE FROM ts.testt WHERE i = 1;\nINSERT INTO ts.testt (t, d) VALUES ('005', 'AFTER DELETE');\nSELECT * FROM ts.testt;\n-- Проверяем на реплике - произошла репликация или нет\nSELECT pg_sleep(5.5);\nSELECT * FROM ts.testt; -- репликация не произошла\n-- Исправляем на реплике неправильный первичный ключ, ждём, проверяем репликацию.\nALTER TABLE ts.testt DROP CONSTRAINT testt_pkey;\nALTER TABLE ts.testt ADD PRIMARY KEY (i);\nSELECT pg_sleep(5.5);\nSELECT * FROM ts.testt; -- репликация возобновилась\n-- Чистим реплику\nDROP SUBSCRIPTION IF EXISTS testt_sub;\nDROP TABLE IF EXISTS ts.testt;\n-- Чистим мастер\nDROP PUBLICATION IF EXISTS testt_pub;\nDROP TABLE ts.testt;\n---\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003C\u002Fdiv\u003E\n                    \u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\n\u003Ch2\u003E\u003Ca name=\"pk_and_idx_is_ud_fail\"\u003E\u003C\u002Fa\u003EФантомного индекса боль\u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"plaintext\"\u003EERROR:  cannot delete from table \"test\" because it does not have a replica identity and publishes deletes\nHINT:  To enable deleting from the table, set REPLICA IDENTITY using ALTER TABLE.\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nОшибка очень интересная и наблюдается на мастере при выполнении команд \u003Ccode\u003EUPDATE\u003C\u002Fcode\u003E и \u003Ccode\u003EDELETE\u003C\u002Fcode\u003E, если в таблице на мастере в качестве репликационного идентификатора использовался уникальный индекс, который потом удалили, например потому, что создали взамен первичный ключ, или просто так удалили (всяко быват, уж мы их ругам-ругам, ничо не помогат). \u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nОшибку эту можно получить только на мастере и только на таблицах, включенных в публикации, поддерживающие \u003Ccode\u003EUPDATE\u003C\u002Fcode\u003E и \u003Ccode\u003EDELETE\u003C\u002Fcode\u003E. Вообще эта ошибка означает именно отсутствие любого репликационного идентификатора, но в данном случае всё немного интереснее — идентификатором остаётся индекс, который удалили.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nЧтоб исправить ошибку нужно вернуть \u003Ccode\u003EREPLICA IDENTITY DEFAULT\u003C\u002Fcode\u003E, перенацелив тем самым поиcк идентификатора туда, где он есть — на первичный ключ. Также можно воссоздать индекс и снова перенацелиться на него, так как oid у него будет уже другой, и система не будет его видеть. \u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nЕсли же нет времени строить индексы и первичные ключи — включаем \u003Ccode\u003EREPLICA IDENTITY FULL\u003C\u002Fcode\u003E, а уж затем восстанавливаем индексы и так далее. В рабочих системах начинать изменения нужно с реплики, иначе вылезут другие ошибки.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nИдентифицировать именно такой вариант развития событий не так уж и просто, хотя бы потому, что никому такое в голову не придёт. И, не приведи вселенная, если ещё до вас кто-то удалил и снова создал индекс — выявить причину происходящего будет практически невозможно.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cdiv class=\"spoiler\" role=\"button\" tabindex=\"0\"\u003E\n                        \u003Cb class=\"spoiler_title\"\u003EВоспроизведение\u003C\u002Fb\u003E\n                        \u003Cdiv class=\"spoiler_text\"\u003E\u003Cpre\u003E\u003Ccode class=\"sql\"\u003E-- Воспроизводить на мастере\n-- Создаём таблицу\nCREATE TABLE ts.testt (i serial, t text, d text);\n-- Создаём индекс\nCREATE UNIQUE INDEX CONCURRENTLY testt_idx ON ts.testt USING btree (i);\n-- Назначаем индекс в качестве репликационного идентификатора\nALTER TABLE ts.testt REPLICA IDENTITY USING INDEX testt_idx;\n-- Информация о таблице отображает индекс как REPLICA IDENTITY\n\\d ts.testt\n-- Смотрим что назначено репликационным идентификатором\n-- relreplident = i, т.е. индекс\nSELECT relname, relreplident -- i-index, d-default\n  FROM pg_class \n  WHERE oid = 'ts.testt'::regclass;\n-- Без следующей строки ошибка воспроизводится, но не так наглядно.\nALTER TABLE ts.testt ADD CONSTRAINT pkey PRIMARY KEY (i); \n-- Добавился первичный ключ в информации по таблице\n\\d ts.testt\n-- Смотрим что назначено репликационным идентификатором\n-- всё ещё relreplident = i, т.е. индекс\n-- так и должно быть, ведь ПК как РИ не назначали\nSELECT relname, relreplident -- i-index, d-default\n  FROM pg_class \n  WHERE oid = 'ts.testt'::regclass;\nCREATE PUBLICATION testt_pub for TABLE ts.testt;\nINSERT INTO ts.testt (t, d) VALUES ('001', 'first'), ('002', 'second'), ('003', 'third');\nDROP INDEX ts.testt_idx;\n-- После удаления индекса - информации про него нет\n\\d ts.testt\n-- Смотрим что назначено репликационным идентификатором\n-- всё ещё relreplident = i, т.е. индекс\n-- несмотря на то, что индекса уже нет, он всё ещё РИ\nSELECT relname, relreplident -- i-index, d-default\n  FROM pg_class \n  WHERE oid = 'ts.testt'::regclass;\n-- Сейчас будут ошибки, а посмотришь на \\d testt выполненный выше\n-- то непонятно, как же так - первичный ключ ведь есть.\n-- есть-то он есть, да вот только запрос к pg_class\n-- показывает что идентификатором служит индекс - i, а не d - default\n-- а индекс-то этот уже удалён\nUPDATE ts.testt SET t = t || ' upd' WHERE i = 1;\nDELETE FROM ts.testt WHERE i = 3;\n-- Cоздаём одноимённый индекс обратно и попробуйте\n-- найти в чем причина ошибки - индекс-то существует, идентификатором\n-- он вроде как назначен...\nCREATE UNIQUE INDEX CONCURRENTLY testt_idx ON ts.testt USING btree (i);\nALTER TABLE ts.testt REPLICA IDENTITY USING INDEX testt_idx;\n-- Смотрим есть ли индексы на таблице со столбцом indisreplident=t \n-- и такой индекс есть, это воссозданный исходный индекс\nSELECT pgc.oid, pgc.relname, pgi.indisreplident\n  FROM pg_class AS pgc,\n     pg_index AS pgi\n  WHERE pgc.oid = pgi.indexrelid\n    AND pgi.indrelid IN (SELECT oid FROM pg_class WHERE relname = 'testt');\n-- а тут написано что идентификатором служит индекс:\n\\d ts.testt \n-- Однако UPDATE и DELETE так и не работают\nUPDATE ts.testt SET t = t || ' upd' WHERE i = 1;\nDELETE FROM ts.testt WHERE i = 3;\n-- Пустим в ход дефибриллятор:\nALTER TABLE ts.testt REPLICA IDENTITY DEFAULT;\nALTER TABLE ts.testt REPLICA IDENTITY USING INDEX testt_idx;\n\\d ts.testt\nSELECT relname, relreplident -- i-index, d-default\n  FROM pg_class \n  WHERE oid = 'ts.testt'::regclass;\n-- Визуально в свойствах таблицы всё то же самое, но теперь всё работает\nUPDATE ts.testt SET t = t || ' upd' WHERE i = 1;\nDELETE FROM ts.testt WHERE i = 3;\nDROP TABLE ts.testt;\nDROP PUBLICATION testt_pub;\n-- Не полагайтесь только на \u002Fd, всегда ищите и в системных каталогах!\n-- Если индекс есть, то не факт, что он используется.\n---\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003C\u002Fdiv\u003E\n                    \u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\n\u003Ch2\u003E\u003Ca name=\"wrong_type\"\u003E\u003C\u002Fa\u003EНепреобразуемые типы\u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"plaintext\"\u003EПри начальной синхронизации\nERROR:  invalid input syntax for type bigint: \"\\xaabbcc\"\nCONTEXT:  COPY testt, line 1, column t: \"\\xaabbcc\"\n\nПосле перехода в режим репликации\nERROR:  invalid input syntax for type bigint: \"\\xdeadbeef\"\nCONTEXT:  processing remote data for replication target relation \"ts.testt\" column \"t\", remote type bytea, local type bigint\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nОшибка наблюдается на любом этапе репликации, если в таблице на реплике есть хотя бы один столбец, в тип которого нельзя преобразовать полученный с мастера тип данных. Повторяется до тех пор, пока на реплике не будет исправлена таблица. Репликация при этом приостанавливается и продолжается после устранения причины ошибки. \u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nИ здесь снова неполная информация о том, в какой таблице произошла ошибка. То есть при начальной синхронизации в строке с контекстом есть информация о таблице, но не о схеме. Но, если уже после начальной синхронизации столбец был изменён, то информация будет полноценной.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cdiv class=\"spoiler\" role=\"button\" tabindex=\"0\"\u003E\n                        \u003Cb class=\"spoiler_title\"\u003EВоспроизведение\u003C\u002Fb\u003E\n                        \u003Cdiv class=\"spoiler_text\"\u003E\u003Cpre\u003E\u003Ccode class=\"sql\"\u003E-- Подготавливаем мастер\nCREATE TABLE ts.testt (i serial PRIMARY KEY, t bytea);\nINSERT INTO ts.testt (t) VALUES('\\xaabbcc'::bytea);\nSELECT * FROM ts.testt;\nCREATE PUBLICATION testt_pub FOR TABLE ts.testt;\n-- Подготавливаем реплику\nCREATE TABLE ts.testt (i bigserial PRIMARY KEY, t bigint);\nCREATE SUBSCRIPTION testt_sub \n  CONNECTION 'host=192.168.122.182 \n              dbname=test \n              user=log_rep_rolename \n              password=sadp!'\n  PUBLICATION testt_pub;\nSELECT pg_sleep(5.5);\nSELECT * FROM ts.testt; \n-- Начальная синхронизация не прошла\n-- Всё - ошибка в логах, теперь надо её исправить.\n-- Вот это вот не поможет:\nALTER TABLE ts.testt ALTER COLUMN t SET DATA TYPE bytea USING t::bytea;\n-- Только так:\nALTER TABLE ts.testt DROP COLUMN t, ADD COLUMN t bytea;\nSELECT pg_sleep(5.5);\nSELECT * FROM ts.testt; -- Убеждаемся в завершении начальной синхронизации\n-- Начальная синхронизаация завершилась и на реплике\n-- снова поменяем столбец на неправильный\nALTER TABLE ts.testt DROP COLUMN t, ADD COLUMN t bigint;\n-- Вставим данные на мастере\nINSERT INTO ts.testt (t) VALUES('\\xdeadbeef'::bytea);\nSELECT * FROM ts.testt;\n-- Всё - репликация снова на паузе\nSELECT * FROM ts.testt;\n-- Снова ремонтируем, но делаем такой тип данных,\n-- в который можно преобразовать bytea\nALTER TABLE ts.testt DROP COLUMN t, ADD COLUMN t text; \nSELECT pg_sleep(5.5);\nSELECT * FROM ts.testt; -- Убеждаемся в работе репликации\n-- Чистим реплику\nDROP SUBSCRIPTION testt_sub;\nDROP TABLE ts.testt;\n-- Чистим мастер\nDROP PUBLICATION testt_pub;\nDROP TABLE ts.testt;\n---\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003C\u002Fdiv\u003E\n                    \u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\n\u003Ch2\u003EИ такое может пригодиться, если что-то натворили непонятное\u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"sql\"\u003E-- Удаление слота на мастере\nSELECT pg_drop_replication_slot('test_sub');\n-- Удаление подписки на реплике при отсутствующем слоте\nALTER SUBSCRIPTION testt_sub DISABLE;\nALTER SUBSCRIPTION testt_sub SET (slot_name=NONE);\nDROP SUBSCRIPTION testt_sub;\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Ch2\u003EОбщие замечания\u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\r\nЛучше первичных ключей нет на свете репликационных идентификаторов. В случае, когда в таблице отсутствует \u003Ccode\u003EPRIMARY KEY\u003C\u002Fcode\u003E и его добавление невозможно, то всегда имеется возможность создать его используя \u003Ca href=\"https:\u002F\u002Fpostgrespro.ru\u002Fdocs\u002Fpostgresql\u002F10\u002Fsql-createindex#SQL-CREATEINDEX-CONCURRENTLY\"\u003Eнеблокирующее построение индекса\u003C\u002Fa\u003E с последующим назначением его ограничением первичного ключа. \u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nВыполнять создание индексов желательно до переноса схемы данных, с тем, чтоб они перенеслись на реплику в составе схемы БД, ну или не забыть создать их и на реплике. К тому же на реплике возможно сразу создать первичный ключ с аналогичным составом столбцов ещё до начала репликации.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nИспользовать \u003Ccode\u003EREPLICA IDENTITY FULL\u003C\u002Fcode\u003E стоит только если строки в таблице незначительного размера и редко изменяются. При использовании такого типа идентификатора желательно воздержаться от изменения структуры принимающей таблицы.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nЕсли после переноса схемы вам необходимо поменять в ней некоторые таблицы, то возможно проверять безопасность изменений в новой базе используя специально восстановленную резервную копию мастера как источник данных и устанавливая \u003Ccode\u003Elog_min_messages=debug1\u003C\u002Fcode\u003E для проверки правильности работы репликации по части \u003Ccode\u003EUPDATE\u003C\u002Fcode\u003E и \u003Ccode\u003EDELETE\u003C\u002Fcode\u003E. Изменение этого параметра не требует перезапуска сервера, поэтому возможно его переключать в любое время, например на время проверки внесенных изменений.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nПосле начала репликации на мастере нельзя добавлять столбцы, а если добавлять, то начинать надо с реплики.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nНовые столбцы с \u003Ccode\u003ENOT NULL\u003C\u002Fcode\u003E на реплике хороши только если в комплекте идёт \u003Ccode\u003EDEFAULT\u003C\u002Fcode\u003E.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nОшибки могут случаться, но в большинстве случаев они некритичные и легко устраняются, только нужно с умом подойти к выбору репликационных идентификаторов. Если речь идёт не об обновлении, а о более сложных схемах применения логической репликации, то к проектированию системы в целом нужно подойти очень ответственно, иначе можно отправить всё в нокдаун или потерять данные.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nИ на сладкое: можно добиться того, что системные каталоги на реплике сохранят информацию о подписках, которые, как казалось, были удалены. Тут может помочь только реинициализация кластера БД. В таком случае команда \u003Ccode\u003E\\dRs\u003C\u002Fcode\u003E показывает наличие подписки, а \u003Ccode\u003ESELECT * FROM pg_subscription;\u003C\u002Fcode\u003E — нет. При этом на реплике все необходимые для обслуживания процессы запускаются, но ничего полезного не делают, кроме множества ошибок в логах (не можем подключиться, слота нет...), даже при специально повторно созданных объектах и слотах. То есть было утеряно некоторое количество внутренней информации о подписке. За месяц экспериментов такое положение дел было достигнуто только два раза, и оба раза это произошло после отправки хоста тестовых виртуалок в ждущий или спящий режим. Хоть и получалось так не всегда — не делайте так. Но случиться такое с хост-системой всё-таки может, так что про такую вероятность нужно знать.\u003C\u002Fdiv\u003E","tags":[{"titleHtml":"postgersql"},{"titleHtml":"postgres pro"},{"titleHtml":"логическая репликация"}],"metadata":{"stylesUrls":[],"scriptUrls":[],"shareImageUrl":"https:\u002F\u002Fhabr.com\u002Fshare\u002Fpublication\u002F489308\u002F9a7062c6b3f4eeb532c9d000cc28b24c\u002F","shareImageWidth":1200,"shareImageHeight":630,"vkShareImageUrl":"https:\u002F\u002Fhabr.com\u002Fshare\u002Fpublication\u002F489308\u002F9a7062c6b3f4eeb532c9d000cc28b24c\u002F?format=vk","schemaJsonLd":"{\"@context\":\"http:\\\u002F\\\u002Fschema.org\",\"@type\":\"Article\",\"mainEntityOfPage\":{\"@type\":\"WebPage\",\"@id\":\"https:\\\u002F\\\u002Fhabr.com\\\u002Fru\\\u002Fcompany\\\u002Fpostgrespro\\\u002Fblog\\\u002F489308\\\u002F\"},\"headline\":\"Логическая репликация в PostgreSQL. Репликационные идентификаторы и популярные ошибки\",\"datePublished\":\"2021-02-28T22:38:29+03:00\",\"dateModified\":\"2021-03-01T19:30:29+03:00\",\"author\":{\"@type\":\"Person\",\"name\":\"Коротких Василий\"},\"publisher\":{\"@type\":\"Organization\",\"name\":\"Habr\",\"logo\":{\"@type\":\"ImageObject\",\"url\":\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fwebt\\\u002Fa_\\\u002Flk\\\u002F9m\\\u002Fa_lk9mjkccjox-zccjrpfolmkmq.png\"}},\"description\":\"Начиная с 10 версии, перенести данные с одной базы PostgreSQL на другую несложно, с обновлением, без обновления &mdash; неважно. Об этом немало сказано и сказанное св...\",\"url\":\"https:\\\u002F\\\u002Fhabr.com\\\u002Fru\\\u002Fcompany\\\u002Fpostgrespro\\\u002Fblog\\\u002F489308\\\u002F#post-content-body\",\"about\":[\"c_postgrespro\",\"h_postgresql\",\"h_db_admins\",\"h_data_engineering\",\"f_develop\",\"f_admin\"],\"image\":[\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fwebt\\\u002Frc\\\u002F4w\\\u002Fc4\\\u002Frc4wc4pblkhrdji9tkuwdwvt2ro.jpeg\"]}","metaDescription":"Начиная с 10 версии, перенести данные с одной базы PostgreSQL на другую несложно, с обновлением, без обновления — неважно. Об этом немало сказано и сказанное сводится к следующему: на мастере, 10...","mainImageUrl":null,"amp":false,"customTrackerLinks":[]},"polls":[],"commentsEnabled":true,"rulesRemindEnabled":false,"votesEnabled":true,"status":"published","plannedPublishTime":null,"checked":null,"isEditorial":false}},"articlesIds":{},"isLoading":false,"pagesCount":{},"route":{},"reasonsList":null,"view":"cards","lastVisitedRoute":{},"ssrCommentsArticleIds":[""],"karma":{}},"authorContribution":{"authors":{}},"betaTest":{"currentAnnouncement":null,"announcements":{},"announcementCards":null,"announcementComments":{},"announcementCommentThreads":{},"announcementCommentingStatuses":{},"archivedList":[]},"authorStatistics":{"articleRefs":{},"articleIds":{},"pagesCount":{},"route":{},"viewsCount":[],"maxStatsCount":{}},"career":{"seoLandings":[],"hubs":""},"comments":{"articleComments":{},"searchCommentsResults":null,"previewComment":null,"pagesCount":null,"commentAccess":{},"scrollParents":{},"pageArticleComments":{"lastViewedComment":0,"postId":null,"lastCommentTimestamp":"","moderated":[],"moderatedIds":[],"commentRoute":""}},"companies":{"companyRefs":{"postgrespro":{"alias":"postgrespro","imageUrl":"\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fcompany\u002F4e0\u002F339\u002F621\u002F4e0339621abc865fefb88f9e9f44748f.jpg","titleHtml":"Postgres Professional","descriptionHtml":"Разработчик СУБД Postgres Pro","relatedData":null,"statistics":{"postsCount":159,"newsCount":0,"vacanciesCount":0,"employeesCount":23,"careerRating":null,"subscribersCount":50249,"rating":140.03,"invest":null},"foundationDate":{"year":"2015","month":"01","day":"27"},"location":{"city":{"id":"447159","title":"Москва"},"region":{"id":"1885","title":"Москва и Московская обл."},"country":{"id":"168","title":"Россия"}},"siteUrl":"http:\u002F\u002Fwww.postgrespro.ru\u002F","staffNumber":"101–200 человек","registrationDate":"2015-09-30T07:41:09+00:00","representativeUser":{"alias":"x-wao","fullname":"Иван Панченко"},"contacts":[{"title":"Facebook","url":"https:\u002F\u002Ffacebook.com\u002FPostgresProfessional"},{"title":"Twitter","url":"https:\u002F\u002Ftwitter.com\u002FPostgresPro"},{"title":"ВКонтакте","url":"https:\u002F\u002Fvk.com\u002Fpublic101507899"},{"title":"Google+","url":"https:\u002F\u002Fplus.google.com\u002F+PostgresproRuCompany"},{"title":"LiveJournal","url":"https:\u002F\u002Fpostgrespro.livejournal.com\u002F"}],"settings":{"analyticsSettings":[{"type":"ga","trackingId":"UA-55152600-4"}],"branding":null,"status":"active","isStartup":false},"metadata":{"titleHtml":"Postgres Professional, Москва - Разработчик СУБД Postgres Pro с 27 января 2015 г.","title":"Postgres Professional, Москва - Разработчик СУБД Postgres Pro с 27 января 2015 г.","keywords":["PostgreSQL","SQL","Занимательные задачки","Open source","Системное администрирование","postgresql","postgres","субд","dbms","базы данных","sql","data bases","rdbms","рсубд","index","indexing","оптимизация","postgres pro","новый редактор никуда не годится","планирование","c","open source","vacuum","(:","wal"],"descriptionHtml":"159 статей от авторов компании Postgres Professional","description":"159 статей от авторов компании Postgres Professional"},"aDeskSettings":null,"careerAlias":"postgrespro"}},"companyIds":{},"companyTopIds":{},"pagesCount":{},"companyProfiles":{},"companiesCategories":[],"companiesCategoriesTotalCount":0,"companiesWidgets":{},"companiesWorkers":{},"companiesFans":{},"route":{},"isLoading":false,"companyWorkersLoading":false,"companyFansLoading":false,"vacancies":{},"workplaceInfo":null},"companyAdmin":{"companyInfo":null,"companyInfoLoading":false,"faqArticles":null,"brandingPreviewImageUrl":null},"companiesContribution":{"hubs":{},"flows":{},"companyRefs":{}},"companyHubsContribution":{"contributionRefs":{"hubRefs":{},"hubIds":{}}},"conversation":{"messages":[],"respondent":null,"isLoadMore":false},"conversations":{"conversations":[],"unreadCount":0,"pagesCount":0,"isLoadMore":false},"desktopState":{"desktopFl":null,"desktopHl":null,"isChecked":false,"isLoginDemanded":false},"docs":{"menu":{},"articles":{},"mainMenu":[],"loading":{"main":false,"dropdown":false,"article":false}},"feature":{"isProbablyVisible":"true"},"flows":{"flows":[{"alias":"develop","id":1,"route":{"name":"FLOW_PAGE","params":{"flowName":"develop"}}},{"alias":"admin","id":6,"route":{"name":"FLOW_PAGE","params":{"flowName":"admin"}}},{"alias":"design","id":2,"route":{"name":"FLOW_PAGE","params":{"flowName":"design"}}},{"alias":"management","id":3,"route":{"name":"FLOW_PAGE","params":{"flowName":"management"}}},{"alias":"marketing","id":4,"route":{"name":"FLOW_PAGE","params":{"flowName":"marketing"}}},{"alias":"popsci","id":7,"route":{"name":"FLOW_PAGE","params":{"flowName":"popsci"}}}]},"global":{"isPwa":false,"device":"desktop","isHabrCom":true},"hubs":{"hubRefs":{},"hubIds":{},"pagesCount":{},"isLoading":false,"route":{}},"hubsBlock":{"hubRefs":{},"hubIds":{}},"i18n":{"fl":"ru","hl":"ru"},"info":{"infoPage":{},"isLoading":true},"location":{"urlStruct":{"protocol":null,"slashes":null,"auth":null,"host":null,"port":null,"hostname":null,"hash":null,"search":null,"query":{},"pathname":null,"path":null,"href":""},"searchQuery":null},"me":{"user":null,"ppgDemanded":false,"karmaResetInfo":{"canReincarnate":null,"wasReincarnated":null,"currentScore":null},"notes":null},"mostReadingList":{"mostReadingListIds":[],"mostReadingListRefs":null,"promoPost":null},"pinnedPost":{"pinnedPost":null},"ppa":{"articles":{},"card":null,"transactions":null,"totalTransactions":null,"isAccessible":null},"projectsBlocks":{"activeBlocks":{}},"promoData":{"isLoading":false,"hasLoaded":false,"featurer":null,"megaposts":null,"promoLinks":null,"promoPosts":null},"pullRefresh":{"shouldRefresh":false},"sandbox":{"articleIds":[],"articleRefs":{},"pagesCount":null,"route":{},"lastVisitedRoute":{},"isLoading":false},"search":{"searchQueryError":null},"settingsOther":{"inputs":{"uiLang":{"errors":[],"ref":null,"value":""},"articlesLangEnglish":{"errors":[],"ref":null,"value":false},"articlesLangRussian":{"errors":[],"ref":null,"value":false},"agreement":{"errors":[],"ref":null,"value":false},"email":{"errors":[],"ref":null,"value":true},"digest":{"errors":[],"ref":null,"value":true}}},"similarList":{"similarListIds":[],"similarListRefs":null},"ssr":{"error":null,"isDataLoaded":false,"isDataLoading":false,"isHydrationFailed":false,"isServer":false},"technotext":{"nominationsList":[]},"userHubsContribution":{"contributionRefs":{"hubRefs":{},"hubIds":{}}},"userInvites":{"availableInvites":0,"usedInvitesIds":[],"usedInvitesRefs":{},"usedInvitesPagesCount":0,"unusedInvitesIds":[],"unusedInvitesRefs":{},"unusedInvitesPagesCount":0},"users":{"authorRefs":{},"authorIds":{},"pagesCount":{},"authorProfiles":{},"userHubs":{},"userInvitations":{},"authorFollowers":{},"authorFollowed":{},"userSpecialization":{},"karmaStats":[],"statistics":null,"isLoading":false,"authorFollowersLoading":false,"authorFollowedLoading":false,"userHubsLoading":false,"userInvitationsLoading":false,"route":{}},"viewport":{"prevScrollY":{},"scrollY":0,"width":0},"tracker":{"items":{},"pagesCache":{},"markedViewedSilently":{},"markedRead":{},"unreadCounters":{"applications":null,"system":null,"mentions":null,"subscribers":null,"posts_and_comments":null},"unviewedCounters":{"applications":null,"system":null,"mentions":null,"subscribers":null,"posts_and_comments":null}}};(function(){var s;(s=document.currentScript||document.scripts[document.scripts.length-1]).parentNode.removeChild(s);}());</script>
<script src="https://assets.habr.com/habr-web/js/chunk-vendors.da6c6b36.js" defer></script><script src="https://assets.habr.com/habr-web/js/app.92df6f6d.js" defer></script>



    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    </script>
  
  <script type="text/javascript" >
    (function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
    m[i].l=1*new Date();k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})
    (window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");

    ym(24049213, "init", {
      defer:true,
      trackLinks:true,
      accurateTrackBounce:true,
      webvisor:false,
    });
  </script>
  <noscript>
    <div>
      <img src="https://mc.yandex.ru/watch/24049213" style="position:absolute; left:-9999px;" alt="" />
    </div>
  </noscript>
  
    <script type="text/javascript">
      window.addEventListener('load', function () {
        setTimeout(() => {
          const img = new Image();
          img.src = 'https://vk.com/rtrg?p=VK-RTRG-421343-57vKE';
        }, 0);
      });
    </script>
  
<script src="https://habr.com/js/ads.js" onload="window['zhY4i4nJ9K'] = true"></script>
</body>
</html>
