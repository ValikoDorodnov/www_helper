<!DOCTYPE html>
<html lang="ru" data-vue-meta="%7B%22lang%22:%7B%22ssr%22:%22ru%22%7D%7D">
<head >
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1.0,viewport-fit=cover">
  <meta name="referrer" content="unsafe-url">
  <title>Функциональное программирование для всех / Хабр</title>
  <style>
    /* cyrillic-ext */
    @font-face {
      font-family: 'Fira Sans';
      font-style: normal;
      font-weight: 500;
      font-display: swap;
      src: url(https://fonts.gstatic.com/s/firasans/v11/va9B4kDNxMZdWfMOD5VnZKveSxf6TF0.woff2) format('woff2');
      unicode-range: U+0460-052F, U+1C80-1C88, U+20B4, U+2DE0-2DFF, U+A640-A69F, U+FE2E-FE2F;
    }

    /* cyrillic */
    @font-face {
      font-family: 'Fira Sans';
      font-style: normal;
      font-weight: 500;
      font-display: swap;
      src: url(https://fonts.gstatic.com/s/firasans/v11/va9B4kDNxMZdWfMOD5VnZKveQhf6TF0.woff2) format('woff2');
      unicode-range: U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116;
    }

    /* latin-ext */
    @font-face {
      font-family: 'Fira Sans';
      font-style: normal;
      font-weight: 500;
      font-display: swap;
      src: url(https://fonts.gstatic.com/s/firasans/v11/va9B4kDNxMZdWfMOD5VnZKveSBf6TF0.woff2) format('woff2');
      unicode-range: U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;
    }

    /* latin */
    @font-face {
      font-family: 'Fira Sans';
      font-style: normal;
      font-weight: 500;
      font-display: swap;
      src: url(https://fonts.gstatic.com/s/firasans/v11/va9B4kDNxMZdWfMOD5VnZKveRhf6.woff2) format('woff2');
      unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
    }

    /* non-breaking hyphen */
    @font-face {
      font-family: 'Fira Sans';
      font-style: normal;
      font-weight: 500;
      font-display: swap;
      src: url(https://fonts.gstatic.com/l/font?kit=KFOlCnqEu92Fr1MmEU9vBh0_IsHAlmrO6g&skey=ee881451c540fdec&v=v29) format('woff2');
      unicode-range: U+02011;
    }
  </style>
  <link rel="preload" href="https://assets.habr.com/habr-web/css/chunk-vendors.e7843cc0.css" as="style"><link rel="preload" href="https://assets.habr.com/habr-web/js/chunk-vendors.da6c6b36.js" as="script"><link rel="preload" href="https://assets.habr.com/habr-web/css/app.4de4e95a.css" as="style"><link rel="preload" href="https://assets.habr.com/habr-web/js/app.92df6f6d.js" as="script">
  <link rel="stylesheet" href="https://assets.habr.com/habr-web/css/chunk-vendors.e7843cc0.css"><link rel="stylesheet" href="https://assets.habr.com/habr-web/css/app.4de4e95a.css">
  <script>window.i18nFetch = new Promise((res, rej) => {
          const xhr = new XMLHttpRequest();
          xhr.open('GET', '/js/i18n/ru-compiled.2822d469ec31a56409ac330bbcf7fcbf.json');
          xhr.responseType = 'json';
          xhr.onload = function(e) {
            if (this.status === 200) {
              res({ru: xhr.response});
            } else {
              rej(e);
            }
          };
          xhr.send();
        });</script>
  
  <script data-vue-meta="ssr" type="application/ld+json" data-vmid="ldjson-schema">{"@context":"http:\/\/schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/habr.com\/ru\/post\/142351\/"},"headline":"Функциональное программирование для всех","datePublished":"2012-04-19T11:45:50+04:00","dateModified":"2012-04-23T10:47:00+04:00","author":{"@type":"Person","name":"Щекн-Итрч"},"publisher":{"@type":"Organization","name":"Habr","logo":{"@type":"ImageObject","url":"https:\/\/habrastorage.org\/webt\/a_\/lk\/9m\/a_lk9mjkccjox-zccjrpfolmkmq.png"}},"description":"Доброго времени суток. Это статья &mdash; перевод заинтересовавшего меня поста в блоге аспиранта Университета штата Нью-Йорк в Стоуни-Брук. Статья в доступной форме о...","url":"https:\/\/habr.com\/ru\/post\/142351\/#post-content-body","about":["h_programming","f_develop"],"image":["https:\/\/habr.com\/share\/publication\/142351\/487329d734b8f36abb4dbce73727e353\/"]}</script>
  <script src="https://www.googletagservices.com/tag/js/gpt.js" async></script>
  <style>.grecaptcha-badge{visibility: hidden;}</style>
  <meta name="habr-version" content="2.64.0">
  
  <meta data-vue-meta="ssr" property="fb:app_id" content="444736788986613"><meta data-vue-meta="ssr" property="fb:pages" content="472597926099084"><meta data-vue-meta="ssr" name="twitter:card" content="summary_large_image"><meta data-vue-meta="ssr" name="twitter:site" content="@habr_com"><meta data-vue-meta="ssr" property="og:site_name" content="Хабр" data-vmid="og:site_name"><meta data-vue-meta="ssr" property="og:title" content="Функциональное программирование для всех" data-vmid="og:title"><meta data-vue-meta="ssr" name="twitter:title" content="Функциональное программирование для всех" data-vmid="twitter:title"><meta data-vue-meta="ssr" name="aiturec:title" content="Функциональное программирование для всех" data-vmid="aiturec:title"><meta data-vue-meta="ssr" name="description" content="Доброго времени суток. Это статья — перевод заинтересовавшего меня поста в блоге аспиранта Университета штата Нью-Йорк в Стоуни-Брук. Статья в доступной форме описывает основные концепции..." data-vmid="description"><meta data-vue-meta="ssr" itemprop="description" content="Доброго времени суток. Это статья — перевод заинтересовавшего меня поста в блоге аспиранта Университета штата Нью-Йорк в Стоуни-Брук. Статья в доступной форме описывает основные концепции..." data-vmid="description:itemprop"><meta data-vue-meta="ssr" property="og:description" content="Доброго времени суток. Это статья — перевод заинтересовавшего меня поста в блоге аспиранта Университета штата Нью-Йорк в Стоуни-Брук. Статья в доступной форме описывает основные концепции..." data-vmid="og:description"><meta data-vue-meta="ssr" name="twitter:description" content="Доброго времени суток. Это статья — перевод заинтересовавшего меня поста в блоге аспиранта Университета штата Нью-Йорк в Стоуни-Брук. Статья в доступной форме описывает основные концепции..." data-vmid="twitter:description"><meta data-vue-meta="ssr" property="aiturec:description" content="Доброго времени суток. Это статья — перевод заинтересовавшего меня поста в блоге аспиранта Университета штата Нью-Йорк в Стоуни-Брук. Статья в доступной форме описывает основные концепции..." data-vmid="aiturec:description"><meta data-vue-meta="ssr" itemprop="image" content="https://habr.com/share/publication/142351/487329d734b8f36abb4dbce73727e353/" data-vmid="image:itemprop"><meta data-vue-meta="ssr" property="og:image" content="https://habr.com/share/publication/142351/487329d734b8f36abb4dbce73727e353/" data-vmid="og:image"><meta data-vue-meta="ssr" property="og:image:width" content="1200" data-vmid="og:image:width"><meta data-vue-meta="ssr" property="og:image:height" content="630" data-vmid="og:image:height"><meta data-vue-meta="ssr" property="aiturec:image" content="https://habr.com/share/publication/142351/487329d734b8f36abb4dbce73727e353/" data-vmid="aiturec:image"><meta data-vue-meta="ssr" name="twitter:image" content="https://habr.com/share/publication/142351/487329d734b8f36abb4dbce73727e353/" data-vmid="twitter:image"><meta data-vue-meta="ssr" property="vk:image" content="https://habr.com/share/publication/142351/487329d734b8f36abb4dbce73727e353/?format=vk" data-vmid="vk:image"><meta data-vue-meta="ssr" property="aiturec:item_id" content="142351" data-vmid="aiturec:item_id"><meta data-vue-meta="ssr" property="aiturec:datetime" content="2012-04-19T07:45:50.000Z" data-vmid="aiturec:datetime"><meta data-vue-meta="ssr" content="https://habr.com/ru/post/142351/" property="og:url" data-vmid="og:url"><meta data-vue-meta="ssr" property="og:type" content="article" data-vmid="og:type"><meta data-vue-meta="ssr" property="og:locale" content="ru_RU" data-vmid="og:locale"><meta data-vue-meta="ssr" name="keywords" content="функциональное программирование, ликбез, история">
  <link data-vue-meta="ssr" href="https://habr.com/ru/rss/post/142351/?fl=ru" type="application/rss+xml" title="" rel="alternate" name="rss"><link data-vue-meta="ssr" href="index.html.1.129.html" rel="canonical" data-vmid="canonical"><link data-vue-meta="ssr" data-vmid="hreflang"><link data-vue-meta="ssr" image_src="image" href="https://habr.com/share/publication/142351/487329d734b8f36abb4dbce73727e353/" data-vmid="image:href">
  <meta name="apple-mobile-web-app-status-bar-style" content="#303b44">
  <meta name="msapplication-TileColor" content="#629FBC">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="mobile-web-app-capable" content="yes">
  <link
    rel="shortcut icon"
    type="image/png"
    sizes="16x16"
    href="https://assets.habr.com/habr-web/img/favicons/favicon-16.png"
  >
  <link
    rel="shortcut icon"
    type="image/png"
    sizes="32x32"
    href="https://assets.habr.com/habr-web/img/favicons/favicon-32.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="76x76"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-76.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="120x120"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-120.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="152x152"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-152.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="180x180"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-180.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="256x256"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-256.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1136x640.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2436x1125.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1792x828.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_828x1792.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1334x750.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1242x2668.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 736px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2208x1242.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1125x2436.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 736px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1242x2208.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2732x2048.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2688x1242.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 834px) and (device-height: 1112px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2224x1668.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_750x1334.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2048x2732.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2388x1668.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 834px) and (device-height: 1112px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1668x2224.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_640x1136.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1668x2388.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2048x1536.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1536x2048.png"
  >
  <link
    rel="mask-icon"
    color="#77a2b6"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-120.svg"
  >
  <link
    crossorigin="use-credentials"
    href="https://habr.com/manifest.webmanifest"
    rel="manifest"
  >
</head>
<body>


<div id="app" data-server-rendered="true" data-async-called="true"><div class="tm-layout__wrapper"><!----> <div></div> <!----> <header class="tm-header"><div class="tm-page-width"><div class="tm-header__container"><!----> <span class="tm-header__logo-wrap"><a href="https://habr.com/ru/" class="tm-header__logo tm-header__logo_ru"><svg height="16" width="16" class="tm-svg-img tm-header__icon"><title>Хабр</title> <use xlink:href="/img/habr-logo-ru.svg#logo"></use></svg></a> <span class="tm-header__beta-sign" style="display:none;">β</span></span> <div class="tm-dropdown tm-header__projects"><div class="tm-dropdown__head"><button class="tm-header__dropdown-toggle"><svg height="16" width="16" class="tm-svg-img tm-header__icon tm-header__icon_dropdown"><title>Открыть список</title> <use xlink:href="/img/megazord-v25.4b679db1.svg#arrow-down"></use></svg></button></div> <!----></div> <a href="https://habr.com/ru/sandbox/start/" class="tm-header__become-author-btn">
            Как стать автором
          </a> <div class="tm-feature tm-header__feature tm-feature_variant-inline"><!----></div> <!----> <!----></div></div></header> <div class="tm-layout"><div class="tm-page-progress-bar"></div> <div data-menu-sticky="true" class="tm-base-layout__header tm-base-layout__header_is-sticky"><div class="tm-page-width"><div class="tm-base-layout__header-wrapper"><div class="tm-main-menu"><div class="tm-main-menu__section"><nav class="tm-main-menu__section-content"><!----> <a href="https://habr.com/ru/flows/all" class="tm-main-menu__item">
        Все потоки
      </a> <a href="https://habr.com/ru/flows/develop/" class="tm-main-menu__item">
          Разработка
        </a><a href="https://habr.com/ru/flows/admin/" class="tm-main-menu__item">
          Администрирование
        </a><a href="https://habr.com/ru/flows/design/" class="tm-main-menu__item">
          Дизайн
        </a><a href="https://habr.com/ru/flows/management/" class="tm-main-menu__item">
          Менеджмент
        </a><a href="https://habr.com/ru/flows/marketing/" class="tm-main-menu__item">
          Маркетинг
        </a><a href="https://habr.com/ru/flows/popsci/" class="tm-main-menu__item">
          Научпоп
        </a></nav></div></div> <div class="tm-header-user-menu tm-base-layout__user-menu"><a href="https://habr.com/ru/search/" class="tm-header-user-menu__item tm-header-user-menu__search"><svg height="24" width="24" class="tm-svg-img tm-header-user-menu__icon tm-header-user-menu__icon_search tm-header-user-menu__icon_dark"><title>Поиск</title> <use xlink:href="/img/megazord-v25.4b679db1.svg#search"></use></svg></a> <!----> <!----> <!----> <div class="tm-header-user-menu__item tm-header-user-menu__user_desktop"><div class="tm-dropdown"><div class="tm-dropdown__head"><svg height="24" width="24" data-test-id="menu-toggle-guest" class="tm-svg-img tm-header-user-menu__icon"><title>Профиль</title> <use xlink:href="/img/megazord-v25.4b679db1.svg#header-user"></use></svg> <!----></div> <!----></div> <!----></div> <!----></div></div></div></div> <!----> <div class="tm-page-width"></div> <main class="tm-layout__container"><div hl="ru" data-async-called="true" class="tm-page"><div class="tm-page-width"><!----> <div class="tm-page__wrapper"><div class="tm-page__main tm-page__main_has-sidebar"><div class="pull-down"><div class="pull-down__header" style="height:0px;"><div class="pull-down__content" style="bottom:10px;"><svg height="24" width="24" class="tm-svg-img pull-down__arrow"><title>Обновить</title> <use xlink:href="/img/megazord-v25.4b679db1.svg#pull-arrow"></use></svg></div></div> <div class="tm-article-presenter"> <div class="tm-article-presenter__body"><div class="tm-misprint-area"><div class="tm-misprint-area__wrapper"><article class="tm-article-presenter__content tm-article-presenter__content_narrow"><div class="tm-article-presenter__header"> <div class="tm-article-snippet tm-article-presenter__snippet"><div class="tm-article-snippet__meta-container"><div class="tm-article-snippet__meta"><span class="tm-user-info tm-article-snippet__author"><a href="https://habr.com/ru/users/sheknitrtch/" title="sheknitrtch" class="tm-user-info__userpic"><div class="tm-entity-image"><img alt="" height="24" src="https://habrastorage.org/r/w32/getpro/habr/avatars/206/c3f/14a/206c3f14aacc1aa7d90051046ff47bf3.jpg" width="24" class="tm-entity-image__pic"></div></a> <span class="tm-user-info__user"><a href="https://habr.com/ru/users/sheknitrtch/" class="tm-user-info__username">
      sheknitrtch
    </a> </span></span> <span class="tm-article-snippet__datetime-published"><time datetime="2012-04-19T07:45:50.000Z" title="2012-04-19, 11:45">19  апреля  2012 в 11:45</time></span></div> <!----></div> <h1 lang="ru" class="tm-article-snippet__title tm-article-snippet__title_h1"><span>Функциональное программирование для всех</span></h1> <div class="tm-article-snippet__hubs"><span class="tm-article-snippet__hubs-item"><a href="https://habr.com/ru/hub/programming/" class="tm-article-snippet__hubs-item-link"><span>Программирование</span> <span title="Профильный хаб" class="tm-article-snippet__profiled-hub">*</span></a></span></div> <div class="tm-article-snippet__labels"><div class="tm-article-snippet__label tm-article-snippet__label_variant-translation"><span>
        Перевод
      </span></div></div> <!----> <!----></div></div> <div class="tm-article-presenter__origin"><a href="http://www.defmacro.org/ramblings/fp.html" target="_blank" class="tm-article-presenter__origin-link">
                Автор оригинала:
                <span>
                  Slava Akhmechet
                </span></a></div> <div data-gallery-root="" lang="ru" class="tm-article-body"><div></div> <div id="post-content-body"><div><div class="article-formatted-body article-formatted-body_version-1"><div xmlns="http://www.w3.org/1999/xhtml"><img src="https://habrastorage.org/r/w1560/storage2/e8b/2ce/ec8/e8b2ceec8c7ade11a7e02a4e7a4d57e0.png" align="left" data-src="https://habrastorage.org/storage2/e8b/2ce/ec8/e8b2ceec8c7ade11a7e02a4e7a4d57e0.png"/><br/>
Доброго времени суток. Это статья — перевод заинтересовавшего меня поста в блоге аспиранта Университета штата Нью-Йорк в Стоуни-Брук. Статья в доступной форме описывает основные концепции функционального программирования, их преимущества и недостатки. Думаю она будет полезна широкому кругу читателей, которые сомневаются, нужно ли им углубляться в мир функционального программирования или нет. Пожелания, предложения и замечания по переводу и терминологии принимаются по личной почте.<br/>
<br/>
<i>Мнение переводчика может иногда не совпадать с мнением автора, но переводить статью было крайне занимательно.</i><br/>
<br/>
<b>UPD:</b> альтернативный вариант перевода вы можете найти на <a href="http://www.rsdn.ru/article/funcprog/fp.xml">rsdn</a> (спасибо <a href="https://habrahabr.ru/users/flamingo/" class="user_link">flamingo</a> за ссылку).<br/>
<a name="habracut"></a><br/>
<i>Понедельник, 19 июня, 2006</i><br/>
<br/>
<h2>Введение</h2><br/>
Программисты — прокрастинаторы (то есть лентяи). Прийти, сделать кофе, проверить почту, почитать RSS летну, почитать новости, проверить свежие статьи на техническом сайте, полистать политические дискуссии на программистском форуме. Смыть, повторить, чтобы ничего не пропустить. Пойти на обед. Вернуться, уткнутся в IDE на несколько минут. Проверить почту. Приготовить кофе. И вот неожиданно день подходит к концу.<br/>
<br/>
Но время от времени в поле зрения оказываются занятные (затруднительные, многообещающие) статьи и посты в блогах. Если вы ищете в правильном месте, то как минимум одна такая статья будет встречаться вам каждые несколько дней. В этих постах сложно разобраться, на это требуется время, поэтому они накапливаются в папке «Прочитать». Прежде, чем вы успеете понять что к чему, окажется что уже накопилась куча ссылок и папка, полная PDF файлов. Вам, и понадобится целый год и хижина посреди леса, где на мили вокруг нет ни души, чтобы во всём этом разобраться. И желательно, чтобы кто-нибудь каждое утро приносил еду и забирал мусор, пока вы прогуливаетесь к реке.<br/>
<br/>
Я не знаю, какой у вас список, но большая часть моего списка касается функционального программирования. Такие статьи обычно самые сложные. Часто они написаны сухим академическим языком, и даже «ветераны Wall Street с десятилетним стажем» не понимают о чем говорится в статьях по функциональному программированию (ФП). Если вы зададите вопрос менеджеру проекта в Citi Group или в Deutsche Bank <a name="ref_1_up"></a><sup><a href="index.html.1.129.html#ref_1_down">[1]</a></sup> почему они выбрали JMS вместо Erlang, то услышите в ответ, что они не могут использовать академический язык для промышленных разработок. Проблема в том, что большинство комплексных систем с самыми жесткими требованиями были написаны с использованием элементов функционального программирования. Что-то не сходится.<br/>
<br/>
Действительно статьи о ФП трудны для понимания, но их можно написать проще. Причина возникшей пропасти знаний чисто историческая. По сути в концепции ФП нет ничего сложного. Взгляните на эту статью, как на «доступное руководство по ФП», как на мостик между нашими императивными умами и миром ФП. Заварите себе кофе и продолжим. Надеюсь, что уже очень скоро коллеги начнут шутить по поводу ваших ФП комментариев.<br/>
<br/>
Так что же такое ФП? Откуда оно пошло? На что оно годно? Если оно действительно так полезно, как об этом твердят защитники ФП, то почему его не используют чаще в промышленных масштабах? Почему только люди с PhD склоняются к функциональным языкам? Но что ещё важнее, почему так чертовски трудно освоить функциональные языки? Что скрывается за всеми этими замыканиями, продолжениями, каррированием, ленивые вычисления и отсутствие побочных эффектов? Как это всё можно использовать в проекте, который не охватывает целую вселенную? Почему это всё так далеко от того хорошего, что свято и дорого нашим императивным сердцам? Скоро мы во всём разберёмся. Для начала давайте поймём в чём причина огромной пропасти между академическими статьями и реальным миром. Чтобы ответить на этот вопрос достаточно прогуляться в парке.<br/>
<br/>
<h2>Прогулка в парке</h2><br/>
Садитесь в машину времени. Наша прогулка в парке произошла более 2 тысяч лет назад в один из тех солнечных дней давно забытой весны 380 года до н.э. За городскими стенами Афин под ласковыми тенями оливковых деревьев Платон прогуливался в направлении Академии с красивым мальчиком рабом. Стояла чудесная погода, обед приятной тяжестью отдавался в животе, и разговор плавно перешёл на философские темы.<br/>
<br/>
«Посмотри на тех двух студентов», сказал Платон, аккуратно подбирая слова, чтобы придать вопросу образовательного смысла. «Кто из них, по-твоему, выше?» Мальчик раб посмотрел в сторону бассейна, возле которого стояли два человека. «Они приблизительно одного роста», ответил мальчик. «Что ты имеешь в виду под словами 'приблизительно одного роста'?», спросил Платон. «Ну, отсюда они выглядят одинаково, но я уверен, что если мы подойдём поближе, то я смогу увидеть разницу в росте.»<br/>
<br/>
Платон улыбнулся. Он вёл мальчика в правильном направлении. «То есть ты хочешь сказать, что в мире нет идеально совпадающих вещей?» Мальчик призадумался и ответил: «Да, я так думаю. Всегда существует маленькая разница, даже если мы не можем её увидеть.» Он дошёл до самой сути! «Тогда если нет идеально совпадающих вещей в этом мире, то как ты понимаешь концепцию 'идеального' равенства?» Это ввело мальчика в ступор. Он ответил: «Я не знаю».<br/>
<br/>
Так родилась первая попытка понять природу математики. Платон предположил, что в нашем мире всё лишь приближение идеала. Он также осознал, что люди способны понять концепцию идеала, хотя никогда с ним не сталкивались. Он пришёл к выводу, что идеальные математические формы должны существовать в другом мире, и что мы каким-то образом знаем о них из связей с этой «альтернативной» вселенной. Очевидно, что мы не можем увидеть идеальный круг. Но при этом мы понимаем, что из себя представляет идеальный круг, и как он может быть описан математически. Что же тогда математика? Почему вселенная описывается математическими законами? Всё ли может описать математика? <a name="ref_2_up"></a><sup><a href="index.html.1.129.html#ref_2_down">[2]</a></sup><br/>
<br/>
<a href="http://ru.wikipedia.org/wiki/Философия_математики">Философия математики</a> очень сложный предмет. Как и большинство философских дисциплин, она скорее задаёт вопросы, чем отвечает на них. Учёные в большинстве своём согласны с тем фактом, что математика — это настоящая головоломка: в основе лежит набор базовых непротиворечивых принципов и набор правил, как этими принципами оперировать. Затем мы можем комбинировать правила, получая всё более и более сложные законы. Математики называют такой метод «формальной системой» или «исчислением». Например, можно построить формальную систему для Тетриса. По сути работающий Тетрис и есть сам по себе формальная система, просто она записана в необычном виде.<br/>
<br/>
Цивилизация пушистых существ с Альфы Центавра не сможет прочесть нашу формальную систему Тетриса или круга, потому что их единственный орган чувств может воспринимать только запахи. Возможно они никогда не построят Тетрис, но наверняка у них будет формальная система для круга. Скорее всего у нас не получится с ней ознакомиться, так как наше обоняние не настолько развито. Но как только будет расшифрован язык представления (путём различных сенсорных инструментов и стандартной техники обратного инженеринга), базовые концепции станут понятны любой интеллектуально развитой цивилизации.<br/>
<br/>
Даже если бы не существовало ни одной разумной цивилизации во вселенной, формальная система для Тетриса и круга всё равно были бы логически верными. Просто не нашлось бы существ, способных эти системы найти и формализовать. Если внезапно появится разумная расса пришельцев, то они, скорее всего, разработают свою формальную систему для описания вселенной. Конечно, маловероятно, что они изобретут Тетрис, потому что во вселенной нет аналогов этой игре. Тетрис — это один пример из огромного числа формальных систем, загадок, которые не имеют отношения к окружающей действительности. Даже такое понятие как натуральные числа не всегда можно отнести к реальному миру, ведь можно представить себе настолько большое число, что его нельзя применить к чему-либо во вселенной, но при этом оно будет конечным.<br/>
<br/>
<h2>Немного истории <a name="ref_3_up"></a><sup><a href="index.html.1.129.html#ref_3_down">[3]</a></sup></h2><br/>
Давайте повернём колёса нашей машины времени и переместимся немного ближе, в 1930-е. Великая депрессия опустошила Новый и Старый свет. Почти все семьи из всех социальных слоев почувствовали на себе громадный экономический спад. Осталось совсем мало убежищ, в которых люди могли не боятся бедности. Некоторым людям повезло оказаться в таких убежищах. Нас интересуют математики в Принстонском университете.<br/>
<br/>
Новые корпуса, построенные в готическом стиле, придавали университету ауру безопасности. Специалисты по логике со всей страны приглашались в Принстон для основания нового подразделения. В то время, как большинство американцев с трудом добывали себе пропитание, высокие потолки, стены с узорами из дерева, ежедневные дискуссии за чашечкой чая, и прогулки в лесу, составляли условия проживания в Принстоне.<br/>
<br/>
Одним из математиков, проживавших в таком расточительном образе жизни, был молодой человек по имени Алонзо Чёрч (Alonzo Church). Алонзо получил степень бакалавра в Принстоне и его уговорили остаться в аспирантуре. Алонзо чувствовал, что окружающая обстановка была чересчур роскошной. Он редко появлялся на обсуждении математических проблем за чашечкой чая и не любил гулять в лесу. Алонзо был одиночкой: он был более плодовит, когда работал один. Тем не менее он регулярно встречался с другими обитателями Принстона. Среди которых были Алан Тьюринг (Alan Turing), Джон фон Нейман (John von Neumann) и Курт Гёдель (Kurt Gödel).<br/>
<br/>
Эти четверо интересовались формальными системами. Они не уделяли особого внимания физическому миру, их интересовала работа с абстрактными математическими головоломками. В их головоломках было нечто общее: математики изучали вопросы вычислений. Если у нас есть машина с бесконечными вычислительными возможностями, то какие задачи можно на ней решать? Можно ли решать задачи автоматически? Существуют ли неразрешимые задачи и почему? Будут ли машины с разной архитектурой одинаковыми по мощности?<br/>
<br/>
Совместно с другими учёными Алонзо разработал формальную систему названную Лямбда-исчислением. Система по сути была языком программирования для одной из воображаемых машин. Она была основана на функциях, которые принимают в качестве аргументов функции, и возвращают функцию. Такая функция была обозначена греческой буквой Лямбда, что дало название всей системе <a name="ref_4_up"></a><sup><a href="index.html.1.129.html#ref_4_down">[4]</a></sup>. Используя эту систему Алонзо удалось построить рассуждения касательно вышеописанных вопросов и вывести ответы на них.<br/>
<br/>
Независимо от Алонзо, Алан Тьюринг проводил подобное исследование. Он разработал другую формальную систему (которую сейчас называют Машиной Тьюринга), и используя её пришёл к выводам, подобным Алонзо. Позже было доказано, что машина Тьюринга и лябда-исчисление имеют одинаковую мощность.<br/>
<br/>
В этот момент наша история останавливается. Я бы подытожил статью, и вы переключились бы на другую страницу, если бы не началась Вторая мировая война. Мир пылал. Войска США очень интенсивно использовали артиллерию. Чтобы повысить точность армия наняла большую группу математиков, которые постоянно решали дифференциальные уравнения, необходимые для баллистических таблиц стрельбы. Быстро стало понятно, что такая задача слишком сложна для ручного решения, для преодоления этой проблемы было разработано специальное оборудование. Первой машиной для решения баллистических таблиц был Mark I построенный IBM — она весила 5 тонн, состояла из 750'000 деталей и могла совершать 3 операции в секунду.<br/>
<br/>
Гонка, конечно, на этом не закончилась. В 1949 общественности был показан Электронный Дискретный Переменный Автоматический Компьютер (Electronic Discrete Variable Automatic Computer, EDVAC). Это был первый пример реализации архитектуры фон Неймана, и был первой действительно работающей машиной Тьюринга. На некоторое время работы Алонзо Чёрча были отложены в сторонку.<br/>
<br/>
В конце 50-ых профессор Массачусетского технологического института (MIT) Джон Маккарти (John McCarthy ), тоже выпускник Принстона, начал проявлять интерес к работе Алонзо Чёрча. В 1958 году он представил язык обработки списков, <b>Lis</b>t <b>P</b>rocessing language (Lisp). Lisp задумывался как имплементация Лямбда-исчисления Алонзо, которая работает на компьютерах фон Неймана. Многие компьютерные учёные отметили выразительную мощь Lisp-а. В 1973 году группа программистов в лаборатории искусственного интеллекта в Массачусетском технологическом институте разработали железо, которое они назвали Lisp-машиной. Это была аппаратная реализация лямбда-исчислений Алонзо.<br/>
<br/>
<h2>Функциональное программирование</h2><br/>
Функциональное программирование — это практическая реализация идей Алонзо Чёрча. Не все идеи Лямбда-исчисления переросли в практическую сферу, так как лямбда-исчисления не учитывали физических ограничений. Тем не менее, как и ОО программирование, функциональное программирование — это набор идей, а не набор четких указаний. Существует много функциональных языков, и большинство из них делают одни схожие вещи по разному. В данной статье я объясню наиболее широко используемые идеи из функциональных языков используя примеры на Java (да, вы можете писать функциональные программы на Java если у вас есть склонности к мазохизму). В следующих нескольких разделах мы возьмём язык Java и внесём в него изменения, чтобы он превратился в пригодный к использованию функциональный язык. Начнём наше путешествие.<br/>
<br/>
Лямбда исчисление было придумано для изучения проблем, связанным с вычислениями. Функциональное программирование, стало быть, в первую очередь имеет дело с вычислениями, и, на удивление, использует для этого функции. Функция — это базовый элемент функционального программирования. Функции используются почти для всего, даже для простейших расчётов. Даже переменные заменяются функциями. В функциональном программировании переменные — это просто синонимы (alias) для выражений (чтобы нам не пришлось писать всё в одну строку). Их нельзя изменять. В каждую переменную можно записать только один раз. В терминах Java это означает, что все переменные объявляются как <code>final</code> (или <code>const</code> если имеем дело с C++). В ФП нет не-<code>final</code> переменных<br/>
<br/>
<pre><code class="java">final int i = 5;
final int j = i + 3;
</code></pre><br/>
Так как все переменные финальные, то можно сформулировать два утверждения. Нет смысла постоянно писать ключевое слово <code>final</code>, и нет смысла называть переменные … переменными. Теперь мы внесём два изменения в Java: каждое объявление переменной будет финальным, мы будем обращаться к переменным как к символам.<br/>
<br/>
Теперь вы, наверное, удивляетесь, как вообще можно написать что-либо достаточно сложное на таком языке. Если все символы неизменяемые, то мы в принципе не можем поменять состояние программы! Это не совсем верно. Когда Алонзо работал над лямбда-исчислением, у него не было нужды сохранять состояние, чтобы изменить его позже. Его интересовало проведение операций над данными. Тем не менее, было доказано, что лямбда исчисление эквивалентно машине Тьюринга. В нём можно делать всё то же, что возможно в императивных языках. Как же нам достичь тех же результатов?<br/>
<br/>
Оказывается, что функциональные программы могут хранить состояние, только они не используют для этого переменные. Они используют функции. Состояние хранится в параметрах функции, в стеке. Если хотите сохранить состояние, чтобы потом изменить его через время, то нужно написать рекурсивную функцию. Например, давайте напишем программу, которая переворачивает Java строку. Не забудьте, что все переменные объявляются как <code>final</code> <a name="ref_5_up"></a><sup><a href="index.html.1.129.html#ref_5_down">[5]</a></sup>.<br/>
<br/>
<pre><code class="java">String reverse(String arg) {
    if(arg.length == 0) {
        return arg;
    }
    else {
        return reverse(arg.substring(1, arg.length)) + arg.substring(0, 1);
    }
}
</code></pre><br/>
Эта функция довольно медленная, потому что она повторно вызывает сама себя <a name="ref_6_up"></a><sup><a href="index.html.1.129.html#ref_6_down">[6]</a></sup>. Здесь возможна утечка памяти, так как множество раз создаются временные объекты. Но это функциональный стиль. Вам может показать странным, как люди могут так программировать. Ну, я как раз собирался вам рассказать.<br/>
<br/>
<h2>Преимущества функционального программирования</h2><br/>
Вы, наверное, думаете, что я не смогу привести доводы в оправдание монструозной функции выше. Когда я только начинал изучать функциональное программирование, я тоже так думал. Я ошибался. Есть очень хорошие аргументы в пользу такого стиля. Некоторые из них субъективные. Например, программисты заявляют, что функциональные программы проще понять. Я не буду приводить таких аргументов, потому что всем известно, что лёгкость понимания — это очень субъективная вещь. К счастью для меня, есть ещё куча объективных аргументов.<br/>
<br/>
<h2>Unit тестирование</h2><br/>
Так как в ФП каждый символ является неизменяемым, то функции не имеют побочных действий. Вы не можете менять значения переменных, к тому же функция не может поменять значение вне своей области видимости, и тем самым повлиять на другие функции (как это может случится с полями класса или глобальными переменными). Это означает, что единственный результат выполнения функции — это возвращаемое значение. А единственное, что может повлиять на возвращаемое значение — это аргументы, передаваемые в функцию.<br/>
<br/>
Вот она, голубая мечта unit-тестеров. Можно протестировать каждую функцию в программе используя только нужные аргументы. Нет необходимости вызывать функции в правильном порядке или воссоздавать правильное внешнее состояние. Всё что вам нужно, это передать аргументы, которые соответствуют граничным случаям. Если все функции в вашей программе проходят Unit-тесты, то вы можете быть намного более уверены в качестве вашего ПО, чем в случае императивных языков программирования. В Java или C++ проверки возвращаемого значения не достаточно — функция может поменять внешнее состояние, которое тоже подлежит проверке. В ФП такой проблемы нет.<br/>
<br/>
<h2>Отладка</h2><br/>
Если функциональная программа ведёт себя не так, как вы ожидаете, то отладка — это пара пустяков. Вы всегда можете воспроизвести проблему, потому что ошибка в функции не зависит от постороннего кода, который выполнялся ранее. В императивной программе ошибка проявляется только на некоторое время. Вам придется пройти через ряд шагов, не относящихся к багу, из-за того, что работа функции зависит от внешнего состояния и побочных эффектов других функций. В ФП ситуация намного проще — если возвращаемое значение неправильное, то оно всегда будет неправильным, не зависимо от того, какие куски кода выполнялись прежде.<br/>
<br/>
Как только вы воспроизведёте ошибку, найти её источник — тривиальная задача. Это даже приятно. Как только вы остановите выполнение программы, перед вами будет весь стек вызовов. Вы можете просмотреть аргументы вызова каждой функции, прямо как в императивном языке. С тем отличием, что в императивной программе этого не достаточно, ведь функции зависят от значений полей, глобальных переменных и состояний других классов. Функция в ФП зависит только от своих аргументов, и эта информация оказывается прямо у вас перед глазами! Даже больше, в императивной программе проверки возвращаемого значения не достаточно для того, чтобы сказать, правильно ли ведёт себя кусок кода. Вам придётся выследить десятки объектов за пределами функции, чтобы удостовериться, что всё работает правильно. В функциональном программировании всё, что нужно сделать — это взглянуть на возвращаемое значение!<br/>
<br/>
Проходясь по стеку, вы обращаете внимание на передаваемые аргументы и возвращаемые значения. Как только возвращаемое значение отклоняется от нормы, вы углубляетесь в функцию и двигаетесь дальше. Так повторяется несколько раз пока вы не найдёте источник ошибки!<br/>
<br/>
<h2>Многопоточность</h2><br/>
Функциональная программа сразу готова к распараллеливанию без каких-либо изменений. Вам не придётся задумываться о deadlock-ах или состояниях гонки (race conditions) потому что вам не нужны блокировки! Ни один кусочек данных в функциональной программе не меняется дважды одним и тем же потоком или разными. Это означает, что вы можете легко добавить потоков к вашей программе даже не задумываясь при этом о проблемах, присущих императивным языкам.<br/>
<br/>
Если дела обстоят подобным образом, то почему так редко функциональные языки программирования используются в многопоточных приложениях? На самом деле чаще, чем вы думаете. Компания Ericsson разработала функциональный язык под названием <a href="http://www.erlang.org/">Erlang</a> для использования на отказоустойчивых и масштабируемых телекоммуникационных коммутаторах. Многие отметили преимущества Erlang-а и стали его <a href="http://www.erlang.org/faq/faq.html#AEN50">использовать</a>. Мы говорим о телекоммуникациях и системах контроля трафика, которые далеко не так просто масштабируются, как типичные системы, разработанные на Wall Street. Вообще-то, системы написанные на Erlang, не такие масштабируемые и надёжные, как Java системы. Erlang системы просто сверхнадёжные.<br/>
<br/>
На этом история многопоточности не заканчивается. Если вы пишете по сути однопоточное приложение, то компилятор всё равно может оптимизировать функциональную программу так, чтобы она использовала несколько CPU. Посмотрим на следующий кусок кода.<br/>
<br/>
<pre><code class="java">String s1 = somewhatLongOperation1();
String s2 = somewhatLongOperation2();
String s3 = concatenate(s1, s2);
</code></pre><br/>
Компилятор функционального языка может проанализировать код, классифицировать функции, которые создают строки <code>s1</code> и <code>s2</code>, как функции потребляющие много времени, и запустить их параллельно. Это невозможно сделать в императивном языке, потому что каждая функция может изменять внешнее состояние и код, идущий непосредственно после вызова, может зависеть от неё. В ФП автоматический анализ функций и поиск подходящих кандидатов для распараллеливания — это тривиальнейшая задача, как автоматический <code>inline</code>! В этом смысле функциональный стиль программирования соответствует требованиям завтрашнего дня. Разработчики железа уже не могут заставить CPU работать быстрее. Вместо этого они наращивают количество ядер и заявляют о четырёхкратном увеличении скорости многопоточных вычислений. Конечно они очень вовремя забывают сказать, что ваш новый процессор покажет прирост только в программах, разработанных с учётом распараллеливания. Среди императивного ПО таких очень мало. Зато 100% функциональных программ готовы к многопоточности из коробки.<br/>
<br/>
<h2>Развёртывание по горячему</h2><br/>
В старые времена для установки обновлений Windows приходилось перезагружать компьютер. Много раз. После установки новой версии медиа проигрывателя. В Windows XP произошли значительные изменения, но ситуация всё ещё далека от идеальной (сегодня я запустил Windows Update на работе и теперь надоедливое напоминание не оставит меня в покое, пока не перезагружусь). В Unix системах модель обновления была получше. Для установки обновлений приходилось останавливать некоторые компоненты, но не всю ОС. Хотя ситуация выглядит лучше, но для большого класса серверных приложений это всё ещё не приемлемо. Телекоммуникационные системы должны быть включены 100% времени, ведь если из-за обновления человек не сможет вызвать скорую, то жизни могут быть потеряны. Фирмы с Wall Streets тоже не желают останавливать сервера на выходных, чтобы установить обновления.<br/>
<br/>
В идеале нужно обновить все нужные участки кода не останавливая систему в принципе. В императивном мире это невозможно [пер. в Smalltalk-е очень даже возможно]. Представьте себе выгрузку Java класса на лету и перезагрузка новой версии. Если бы мы так сделали, то все экземпляры класса стали бы нерабочими, потому что потерялось бы состояние, которое они хранили. Нам пришлось бы писать хитрый код, для контроля версий. Пришлось бы серриализовать все созданные экземпляры класса, потом уничтожить их, создать экземпляры нового класса, попытаться загрузить серриализованные данные в надежде, что миграция пройдёт нормально и новые экземпляры будут валидными. И кроме того, миграционный код необходимо писать каждый раз вручную. И ещё миграционный код должен сохранять ссылки между объектами. В теории ещё куда ни шло, но на практике это никогда не заработает.<br/>
<br/>
В функциональной программе всё состояние хранится в стеке в виде аргументов функций. Это позволяет значительно упростить развёртывание по горячему! По сути всё что нужно сделать — это вычислить разницу между кодом на рабочем сервере и новой версией, и установить изменения в коде. Остальное будет сделано языковыми инструментами автоматически! Если вы думаете, что это научная фантастика, то дважды подумайте. Инженеры, имеющие дело с Erlang, годами <a href="http://www.erlang.org/doc/reference_manual/code_loading.html#12.3">обновляют</a> свои системы без остановки их работы.<br/>
<br/>
<h2>Доказательные вычисления и оптимизация (Machine Assisted Proofs and Optimizations)</h2><br/>
Еще одно интересное свойство функциональных языков программирования состоит в том, что их можно изучать с математической точки зрения. Так как функциональный язык — это реализация формальной системы, то все математические операции используемые на бумаге, могут быть применены и к функциональным программам. Компилятор, например, может конвертировать участок кода в эквивалентный, но более эффективный кусок, при этом математически обосновав их эквивалентность <a name="ref_7_up"></a><sup><a href="index.html.1.129.html#ref_7_down">[7]</a></sup>. Реляционные базы данных годами производят такие оптимизации. Ничто не мешает использовать аналогичные приёмы в обычных программах.<br/>
<br/>
Дополнительно вы можете использовать математический аппарат, чтобы доказать корректность участков ваших программ. При желании можно написать инструменты, которые анализируют код и автоматически создают Unit-тесты для граничных случаев! Такая функциональность бесценна для сверхнадёжных систем (rock solid systems). При разработке систем контроля кардиостимуляторов или управления воздушным трафиком такие инструменты просто необходимы. Если же ваши разработки не находятся в сфере критически важных приложений, то инструменты автоматической проверки всё равно дадут вам гигантское преимущество перед вашими конкурентами.<br/>
<br/>
<h2>Функции высшего порядка</h2><br/>
Помните, когда я говорил о преимуществах ФП, я отметил, что «всё выглядит красиво, но бесполезно, если мне придётся писать на корявом языке, в котором всё <code>final</code>». Это было заблуждением. Использование <code>final</code> повсеместно выглядит коряво только в императивных языках программирования, таких как Java. Функциональные языки программирования оперируют другими видами абстракций, такими, что вы забудете о том, что когда-то любили менять переменные. Один из таких инструментов — это функции высшего порядка.<br/>
<br/>
В ФП функция — это не тоже самое, что функция в Java или C. Это надмножество — они могут тоже самое, что Java функции и даже больше. Пусть у нас есть функция на C:<br/>
<br/>
<pre><code class="java">int add(int i, int j) {
    return i + j;
}
</code></pre><br/>
В ФП это не тоже самое, что обычная C функция. Давайте расширим наш Java компилятор, чтобы он поддерживал такую запись. Компилятор должен превратить объявление функции в следующий Java код (не забывайте, что везде присутствует неявный <code>final</code>):<br/>
<br/>
<pre><code class="java">class add_function_t {
    int add(int i, int j) {
        return i + j;
    }
}

add_function_t add = new add_function_t();
</code></pre><br/>
Символ <code>add</code> не совсем функция. Это маленький класс с одним методом. Теперь мы можем передавать <code>add</code> в качестве аргумента в другие функции. Мы можем записать его в другой символ. Мы можем создавать экземпляры <code>add_function_t</code> в runtime и они будут уничтожены сборщиком мусора, если станут ненужными. Функции становятся базовыми объектами, как числа и строки. Функции, которые оперируют функциями (принимают их в качестве аргументов) называются функциями высшего порядка. Пусть это вас не пугает. Понятие функций высшего порядка почти не отличается от понятия Java классов, которые оперируют друг другом (мы можем передавать классы в другие классы). Мы можем называть их «классы высшего порядка», но никто этим не заморачивается, потому что за Java не стоит строгое академическое сообщество.<br/>
<br/>
Как и когда нужно использовать функции высшего порядка? Я рад, что вы спросили. Вы пишите свою программу как один большой монолитный кусок кода не заботясь об иерархии классов. Если вы увидите, что какой-то участок кода повторяется в разных места, вы выносите его в отдельную функцию (к счастью в школах еще учат как это делать). Если вы замечаете, что часть логики в вашей функции должна вести себя по разному в некоторых ситуациях, то вы создаёте функцию высшего порядка. Запутались? Вот реальный пример из мой работы.<br/>
<br/>
Предположим, что у нас есть участок Java кода, который получает сообщение, преобразует его различными способами и передаёт на другой сервер.<br/>
<br/>
<pre><code class="java">    void handleMessage(Message msg) {
        // ...
        msg.setClientCode("ABCD_123");
        // ...
        
        sendMessage(msg);
    }
    
    // ...
}
</code></pre><br/>
Теперь представьте себе, что система поменялась, и теперь нужно распределять сообщения между двумя серверами вместо одного. Всё остаётся неизменным, кроме кода клиента — второй сервер хочет получать этот код в другом формате. Как нам справиться с этой ситуацией? Мы можем проверять, куда должно попасть сообщение, и в зависимости от этого устанавливать правильный код клиента. Например так:<br/>
<br/>
<pre><code class="java">class MessageHandler {
    void handleMessage(Message msg) {
        // ...
        if(msg.getDestination().equals("server1") {
            msg.setClientCode("ABCD_123");
        } else {
            msg.setClientCode("123_ABC");
        }
        // ...
        
        sendMessage(msg);
    }
    
    // ...
}
</code></pre><br/>
Но такой подход плохо масштабируется. При добавлении новых серверов функция будет расти линейно, и внесение изменений превратится в кошмар. Объектно ориентированный подход заключается в выделении общего суперкласса <code>MessageHandler</code> и вынесение логики определения кода клиента в подклассы:<br/>
<br/>
<pre><code class="java">abstract class MessageHandler {
    void handleMessage(Message msg) {
        // ...
        msg.setClientCode(getClientCode());
        // ...
        
        sendMessage(msg);
    }
    
    abstract String getClientCode();
    
    // ...
}


class MessageHandlerOne extends MessageHandler {
    String getClientCode() {
        return "ABCD_123";
    }
}


class MessageHandlerTwo extends MessageHandler {
    String getClientCode() {
        return "123_ABCD";
    }
}
</code></pre><br/>
Теперь для каждого сервера мы можем создать экземпляр соответствующего класса. Добавление новых сервером становится более удобным. Но для такого небольшого изменения многовато текста. Пришлось создать два новых типа чтобы просто добавить поддержку различного кода клиента! Теперь сделаем тоже самое в нашем языке с поддержкой функций высшего порядка:<br/>
<br/>
<pre><code class="java">class MessageHandler {
    void handleMessage(Message msg, Function getClientCode) {
        // ...
        Message msg1 = msg.setClientCode(getClientCode());
        // ...
        
        sendMessage(msg1);
    }
    
    // ...
}


String getClientCodeOne() {
    return "ABCD_123";
}


String getClientCodeTwo() {
    return "123_ABCD";
}


MessageHandler handler = new MessageHandler();
handler.handleMessage(someMsg, getClientCodeOne);
</code></pre><br/>
Мы не создавали новых типов и не усложняли иерархию классов. Мы просто передали функцию в качестве параметра. Мы достигли того же эффекта, как и в объектно-ориентированном аналоге, только с некоторыми преимуществами. Мы не привязывали себя к какой-либо иерархии классов: мы можем передавать любые другие функции в runtime и менять их в любой момент, сохраняя при этом высокий уровень модульности меньшим количеством кода. По сути компилятор создал объектно-ориентированный «клей» вместо нас! При этом сохраняются все остальные преимущества ФП. Конечно абстракции, предлагаемые функциональными языками на этом не заканчиваются. Функции высшего порядка это только начало<br/>
<br/>
<h2>Каррирование</h2><br/>
Большинство людей, с которыми я встречаюсь, прочли книгу <a href="http://www.amazon.com/gp/product/0201633612/103-9055240-2348603">«Паттерны проектирования»</a> Банды Четырёх. Любой уважающий себя программист будет говорить, что книга не привязана к какому-либо конкретному языку программирования, а паттерны применимы к разработке ПО в целом. Это благородное заявление. Но к сожалению оно далеко от истины.<br/>
<br/>
Функциональные языки невероятно выразительны. В функциональном языке вам не понадобятся паттерны проектирования, потому что язык настолько высокоуровневый, что вы легко начнёте программировать в концепциях, которые исключают все известные паттерны программирования. Одним из таких паттернов является Адаптер (чем он отличается от Фасада? Похоже, что кому-то понадобилось наштамповать побольше страниц, чтобы выполнить условия контракта). Этот паттерн оказывается ненужным если в языке есть поддержка каррирования.<br/>
<br/>
Паттерн Адаптер наиболее часто применяется к «стандартной» единице абстракции в Java — классу. В функциональных языках паттерн применяется к функциям. Паттерн берёт интерфейс и преобразует его в другой интерфейс, согласно определённым требованиям. Вот пример паттерна Адаптер:<br/>
<br/>
<pre><code class="java">int pow(int i, int j);
int square(int i)
{
    return pow(i, 2);
}
</code></pre><br/>
Этот код адаптирует интерфейс функции, возводящей число в произвольную степень, к интерфейсу функции, которая возводит число в квадрат. В аккадемических кругах этот простейший приём называется каррирование (в честь специалиста по логике Хаскелла Карри (Haskell Curry), который провёл ряд математических трюков, чтобы всё это формализовать). Так как в ФП функции используются повсеместно в качестве аргументов, каррирование используется очень часто, чтобы привести функции к интерфейсу, необходимому в том или ином месте. Так как интерфейс функции — это её аргументы, то каррирование используется для уменьшения количества аргументов (как в примере выше).<br/>
<br/>
Этот инструмент является встроенным в функциональные языки. Вам не нужно вручную создавать функцию, которая оборачивает оригинал. Функциональный язык сделает всё за вас. Как обычно давайте расширим наш язык, добавив в него каррирование.<br/>
<br/>
<pre><code class="java">square = int pow(int i, 2);
</code></pre><br/>
Этой строкой мы автоматически создаём функцию возведения в квадрат с одним аргументом. Новая функция будет вызывать функцию <code>pow</code>, подставляя 2 в качестве второго аргумента. С точки зрения Java, это будет выглядеть следующим образом:<br/>
<br/>
<pre><code class="java">class square_function_t {
    int square(int i) {
        return pow(i, 2);
    }
}
square_function_t square = new square_function_t();
</code></pre><br/>
Как видите, мы просто написали обёртку над оригинальной функцией. В ФП каррирование как раз и представляет из себя простой и удобный способ создания обёрток. Вы сосредотачиваетесь на задаче, а компилятор пишет необходимый код за вас! Всё очень просто, и происходит каждый раз, когда вы хотите использовать паттерн Адаптер (обёртку).<br/>
<br/>
<h2>Ленивые вычисления</h2><br/>
Ленивые (или отложенные) вычисления — это интересная техника, которая становится возможной как только вы усвоите функциональную философию. Мы уже встречали следующий кусок кода, когда говорили о многопоточности:<br/>
<br/>
<pre><code class="java">String s1 = somewhatLongOperation1();
String s2 = somewhatLongOperation2();
String s3 = concatenate(s1, s2);
</code></pre><br/>
В императивных языках программирования очерёдность вычисления не вызывает никаких вопросов. Поскольку каждая функция может повлиять или зависеть от внешнего состояния, то необходимо соблюдать чёткую очерёдность вызовов: сначала <code>somewhatLongOperation1</code>, затем <code>somewhatLongOperation2</code>, и <code>concatenate</code> в конце. Но не всё так просто в функциональных языках.<br/>
<br/>
Как мы уже видели ранее <code>somewhatLongOperation1</code> и <code>somewhatLongOperation2</code> могут быть запущены одновременно, потому что функции гарантированно не влияют и не зависят от глобального состояния. Но что, если мы не хотим выполнять их одновременно, нужно ли вызывать их последовательно? Ответ — нет. Эти вычисления должны быть запущены, только если какая-либо другая функция зависит от <code>s1</code> и <code>s2</code>. Нам даже не нужно выполнять их до тех пор, пока они понадобятся внутри <code>concatenate</code>. Если вместо <code>concatenate</code> мы подставим функцию, которая в зависимости от условия использует один аргумент из двух, то второй аргумент можно даже не вычислять! <a href="http://www.haskell.org/">Haskell</a> — это пример языка с отложенными вычислениями. В Haskell отсутствует гарантия какой-либо очередности вызовов (вообще!), потому что Haskell выполняет код по мере необходимости.<br/>
<br/>
Ленивые вычисления обладают рядом достоинств как и некоторыми недостатками. В следующем разделе мы обсудим достоинства и я объясню как уживаться с недостатками.<br/>
<br/>
<h2>Оптимизация</h2><br/>
Ленивые вычисления обеспечивают громадный потенциал для оптимизаций. Ленивый компилятор рассматривает код в точности как математик изучает алгебраические выражения — он может отменять некоторые вещи, отменять выполнение тех или иных участков кода, менять очерёдность вызовов для большей эффективности, даже располагать код таким образом, чтобы уменьшить количество ошибок, при этом гарантируя целостность программы. Это самое большое преимущество при описании программы строгими формальными примитивами — код подчиняется математическим законам и может быть изучен математическими методами.<br/>
<br/>
<h2>Абстрагирование структур управления</h2><br/>
Ленивые вычисления обеспечивают настолько высокий уровень абстракций, что становятся возможными удивительные вещи. Например, представим себе реализацию следующей управляющей структуры:<br/>
<br/>
<pre><code class="java">unless(stock.isEuropean()) {
    sendToSEC(stock);
}
</code></pre><br/>
Мы хотим, чтобы функция <code>sendToSEC</code> выполнялась только если фонд (stock) не европейский. Как можно реализовать <code>unless</code>? Без ленивый вычислений нам бы понадобилась система макросов, но в языках, подобных Haskell, это не обязательно. Мы можем объявить <code>unless</code> в виде функции!<br/>
<br/>
<pre><code class="java">void unless(boolean condition, List code) {
    if(!condition)
        code;
}
</code></pre><br/>
Заметьте, что <code>code</code> не будет выполняться, если <code>condition == true</code>. В строгих языках такое поведение невозможно повторить, так как аргументы будут вычислены прежде, чем <code>unless</code> будет вызвана.<br/>
<br/>
<h2>Бесконечные структуры данных</h2><br/>
Ленивые языки позволяют создавать бесконечные структуры данных, создание которых в строгих языках гораздо сложнее [пер. — только не в Python]. Например представьте себе последовательность Фибоначи. Очевидно, что мы не можем вычислить бесконечный список за конечное время и при этом сохранить его в памяти. В строгих языках, таких как Java, мы просто написали бы функцию, которая возвращает произвольный член последовательности. В языках подобных Haskell мы можем абстрагироваться и просто объявить бесконечный список чисел Фибоначи. Так как язык ленивый, то будут вычислены лишь необходимые части списка, которые реально используются в программе. Это позволяет абстрагироваться от большого числа проблем и посмотреть на них с более высокого уровня (например можно использовать функции обработки списков на бесконечных последовательностях).<br/>
<br/>
<h2>Недостатки</h2><br/>
Конечно бесплатный сыр бывает только в мышеловке. Ленивые вычисления тянут за собой ряд недостатков. В основном это недостатки от лени. В реальности очень часто нужен прямой порядок вычислений. Возьмём, например, следующий код:<br/>
<br/>
<pre><code class="java">System.out.println("Please enter your name: ");
System.in.readLine();
</code></pre><br/>
В ленивом языке никто не гарантирует, что первая строка выполнится раньше второй! Это означает, что мы не можем делать ввод-вывод, не можем нормально использовать нативные функции (ведь их нужно вызывать в определённом порядке, чтобы учитывать их побочные эффекты), и не можем взаимодействовать с внешним миром! Если мы введём механизм для упорядочивания выполнения кода, то потеряем преимущество математической строгости кода (а следом потеряем все плюшки функционального программирования). К счастью ещё не всё потеряно. Математики взялись за работу и придумали несколько приёмов для того, чтобы убедится в правильном порядке выполняемых инструкций не потеряв функционального духа. Мы получили лучшее от двух миров! Такие приёмы включают в себя продолжения (continuation), монады (monads) и однозначная типизация (uniqueness typing). В данной статье мы поработаем с продолжениями, а монады и однозначную типизацию отложим до следующего раза. Занятно, что продолжения очень полезная штука, которая используется не только для задания строгого порядка вычислений. Об этом мы тоже поговорим.<br/>
<br/>
<h2>Продолжения</h2><br/>
Продолжения в программировании играют такую же роль, как «Код да Винчи» в человеческой истории: удивительное разоблачение величайшей тайны человечества. Ну, может не совсем так, но они точно срывают покровы, как в своё время вы научились брать корень из -1.<br/>
<br/>
Когда мы рассматривали функции, мы изучили лишь половину правды, ведь мы исходили из предположения, что функция возвращает значение в вызывающую её функцию. В этом смысле продолжение — это обобщение функций. Функция не обязательно должна возвращать управление в то место, откуда её вызвали, а может возвращать в любое место программы. «Продолжение» — это параметр, который мы можем передать в функцию, чтобы указать точку возврата. Звучит намного страшнее, чем есть на самом деле. Давайте взглянем на следующий код:<br/>
<br/>
<pre><code class="java">int i = add(5, 10);
int j = square(i);
</code></pre><br/>
Функция <code>add</code> возвращает число 15, которое записывается в <code>i</code>, в том месте, где функция и была вызвана. Затем значение <code>i</code> используется при вызове <code>square</code>. Заметьте, что ленивый компилятор не может поменять очередность вычислений, ведь вторая строка зависит от результата первой. Мы можем переписать этот код с использованием Стиль Передачи Продолжения (Continuation Passing Style или CPS), когда <code>add</code> возвращает значение в функцию <code>square</code>.<br/>
<br/>
<pre><code class="java">int j = add(5, 10, square);
</code></pre><br/>
В таком случае <code>add</code> получает дополнительный аргумент — функцию, которая будет вызвана после того, как <code>add</code> закончит работать. В обоих примерах <code>j</code> будет равен 225.<br/>
<br/>
В этом и заключается первый приём, позволяющий задать порядок выполнения двух выражений. Вернёмся к нашему примеру с вводом-выводом<br/>
<br/>
<pre><code class="java">System.out.println("Please enter your name: ");
System.in.readLine();
</code></pre><br/>
Эти две строки не зависят друг от друга, и компилятор волен поменять их порядок по своему хотению. Но если мы перепишем в CPS, то тем самым добавим нужную зависимость, и компилятору придётся проводить вычисления одно за другим!<br/>
<br/>
<pre><code class="java">System.out.println("Please enter your name: ", System.in.readLine);
</code></pre><br/>
В таком случае <code>println</code> должен будет вызвать <code>readLine</code>, передав ему свой результат, и вернуть результат <code>readLine</code> в конце. В таком виде мы можем быть уверены, что эти функции будут вызваны по очереди, и что <code>readLine</code> вообще вызовется (ведь компилятор ожидает получить результат последней операции). В случае Java <code>println</code> возвращает <code>void</code>. Но если бы возвращалось какое-либо абстрактное значение (которое может служить аргументом <code>readLine</code>), то это решило бы нашу проблему! Конечно выстраивание таких цепочек функций сильно ухудшает читаемость кода, но с этим можно бороться. Мы можем добавить в наш язык синтаксических плюшек, которые позволят нам писать выражения как обычно, а компилятор автоматически выстраивал бы вычисления в цепочки. Теперь мы можем проводить вычисления в любом порядке, не потеряв при этом достоинств ФП (включая возможность исследовать программу математическими методами)! Если вас это сбивает с толку, то помните, что функции — это всего лишь экземпляры класса с единственным членом. Перепишите наш пример так, чтобы <code>println</code> и <code>readLine</code> были экземплярами классов, так вам станет понятней.<br/>
<br/>
Но на этом польза продолжений не заканчивается. Мы можем написать всю программу целиком используя CPS, чтобы каждая функция вызывалась с дополнительным параметром, продолжением, в которое передаётся результат. В принципе любую программу можно перевести на CPS, если воспринимать каждую функцию как частный случай продолжений. Такое преобразование можно произвести автоматически (в действительности многие компиляторы так и делают).<br/>
<br/>
Как только мы переведём программу к CPS виду, становится ясно, что у каждой инструкции есть продолжение, функция в которую будет передаваться результат, что в обычной программе было бы точкой вызова. Возьмём любую инструкцию из последнего примера, например <code>add(5,10)</code>. В программе, написанной в CPS виде, понятно что будет являться продолжением — это функция, которую <code>add</code> вызовет по окончанию работы. Но что будет продолжением в случае не-CPS программы? Мы, конечно, можем конвертировать программу в CPS, но нужно ли это?<br/>
<br/>
Оказывается, что в этом нет необходимости. Посмотрите внимательно на наше CPS преобразование. Если вы начнёте писать компилятор для него, то обнаружите, что для CPS версии не нужен стек! Функции никогда ничего не возвращают, в традиционном понимании слова «return», они просто вызывают другую функцию, подставляя результат вычислений. Отпадает необходимость проталкивать (push) аргументы в стек перед каждым вызовом, а потом извлекать (pop) их обратно. Мы можем просто хранить аргументы в каком-либо фиксированном участке памяти и использовать <code>jump</code> вместо обычного вызова. Нам нет нужны хранить первоначальные аргументы, ведь они больше никогда не понадобятся, ведь функции ничего не возвращают!<br/>
<br/>
Таким образом, программы в CPS стиле не нуждаются в стеке, но содержат дополнительный аргумент, в виде функции, которую нужно вызвать. Программы в не-CPS стиле лишены дополнительного аргумента, но используют стек. Что же хранится в стеке? Просто аргументы и указатель на участок памяти, куда должна вернуться функция. Ну как, вы уже догадались? В стеке храниться информация о продолжениях! Указатель на точку возврата в стеке — это то же самое, что и функция, которую нужно вызвать, в CPS программах! Чтобы выяснить, какое продолжение у <code>add(5,10)</code>, достаточно взять из стека точку возврата.<br/>
<br/>
Это было не трудно. Продолжение и указатель на точку возврата — это действительно одно и то же, только продолжение указывается явно, и по этому оно может отличаться от того места, где функция была вызвана. Если вы помните, что продолжение — это функция, а функция в нашем языке компилируется в экземпляр класса, то поймёте, что указатель на точку возврата в стеке и указатель на продолжение — это в действительности одно и то же, ведь наша функция (как экземпляр класса) — это всего лишь указатель. А значит, что в любой момент времени в вашей программы вы можете запросить текущее продолжение (по сути информацию из стека).<br/>
<br/>
Хорошо, теперь мы уяснили, что же такое текущее продолжение. Что это значит? Если мы возьмём текущее продолжение и сохраним его где-нибудь, мы тем самым сохраним текущее состояние программы — заморозим её. Это похоже на режим гибернации ОС. В объекте продолжения хранится информация, необходимая для возобновления выполнения программы с той точки, когда был запрошен объект продолжения. Операционная система постоянно так делает с вашими программами, когда переключает контекст между потоками. Разница лишь в том, что всё находится под контролем ОС. Если вы запросите объект продолжения (в Scheme это делается вызовом функции <code>call-with-current-continuation</code>), то вы получите объект с текущим продолжением — стеком (или в случае CPS — функцией следующего вызова). Вы можете сохранить этот объект в переменную (или даже на диск). Если вы решите «перезапустить» программу с этим продолжением, то состояние вашей программы «преобразуется» к состоянию на момент взятия объекта продолжения. Это то же самое, как переключение к приостановленному потоку, или пробуждение ОС после гибернации. С тем исключением, что вы можете проделывать это много раз подряд. После пробуждения ОС информация о гибернации уничтожается. Если этого не делать, то можно было бы восстанавливать состояние ОС с одной и той же точки. Это почти как путешествие по времени. С продолжениями вы можете себе такое позволить!<br/>
<br/>
В каких ситуациях продолжения будут полезны? Обычно если вы пытаетесь эмулировать состояние в системах лишенных такового по сути. Отличное применение продолжения нашли в Web-приложениях (например во фреймворке <a href="http://www.seaside.st/">Seaside</a> для языка Smalltalk). ASP.NET от Microsoft прикладывает огромные усилия, чтобы сохранять состояние между запросами, и облегчить вам жизнь. Если бы C# поддерживал продолжения, то сложность ASP.NET можно было бы уменьшить в два раза — достаточно было бы сохранять продолжение и восстанавливать его при следующем запросе. С точки зрения Web-программиста не было бы ни единого разрыва — программа продолжала бы свою работу со следующей строки! Продолжения — невероятно полезная абстракция для решения некоторых проблем. Учитывая то, что всё больше и больше традиционных толстых клиентов перемещаются в Web, важность продолжений будет со временем только расти.<br/>
<br/>
<h2>Сопоставление с образцом (Pattern matching)</h2><br/>
Сопоставление с образцом не такая уж новая или инновационная идея. На самом деле она имеет слабое отношение к функциональному программированию. Единственная причина, по которой его часто связывают с ФП, это то, что с некоторых пор в функциональных языках есть сопоставление с образцом, а в императивных — нет.<br/>
<br/>
Давайте начнём наше знакомство с Pattern matching следующим примером. Вот функция вычисления чисел Фибоначи на Java:<br/>
<br/>
<pre><code class="java">int fib(int n) {
    if(n == 0) return 1;
    if(n == 1) return 1;
        
    return fib(n - 2) + fib(n - 1);
}
</code></pre><br/>
А вот пример на Java-подобном языке с поддержкой Pattern matching-а<br/>
<br/>
<pre><code class="java">int fib(0) {
    return 1;
}
int fib(1) {
    return 1;
}
int fib(int n) {
    return fib(n - 2) + fib(n - 1);
}
</code></pre><br/>
В чём разница? Компилятор реализует ветвление за нас.<br/>
<br/>
Подумаешь, велика важность! Действительно важность не велика. Было подмечено, что большое количество функций содержат сложные <code>switch</code> конструкции (это отчасти верно для функциональных программ), и было принято решение выделить этот момент. Определение функции разбивается на несколько вариантов, и устанавливается паттерн на месте аргументов функции (это напоминает перегрузку методов). Когда происходит вызов функции, компилятор на лету сравнивает аргументы со всеми определениями и выбирает наиболее подходящий. Обычно выбор падает на самое специализированное определение функции. Например <code>int fib(int n)</code> может быть вызвана при <code>n</code> равном 1, но не будет, ведь <code>int fib(1)</code> — более специализированное определение.<br/>
<br/>
Сопоставление с образцом обычно выглядит сложнее, чем в нашем примере. Например сложная система Pattern matching позволяет писать следующий код:<br/>
<br/>
<pre><code class="java">int f(int n &lt; 10) { ... }
int f(int n) { ... }
</code></pre><br/>
Когда сопоставление с образцом может быть полезно? Список таких случаев на удивление очень большой! Каждый раз, когда вы используете сложные конструкции вложенных <code>if</code>, pattern matching может справиться лучше с меньшим количеством кода. В голову приходит хороший пример с функцией <code>WndProc</code>, которая реализуется в каждой Win32 программе (даже если она спрятана от программиста за высоким забором абстракций). Обычно сопоставление с образцом может даже проверять содержимое коллекций. Например, если вы передаёте массив в функцию, то вы можете отбирать все массивы, у которых первый элемент равен 1, а третий элемент больше 3.<br/>
<br/>
Ещё одним преимуществом Pattern matching является то, что в случае внесения изменений вам не придётся копаться в одной огромной функции. Вам достаточно будет добавить (или изменить) некоторые определения функций. Тем самым мы избавляется от целого пласта паттернов из знаменитой книги Банды Четырёх. Чем сложнее и ветвистее условия, тем полезнее будет использовать Pattern matching. Как только вы начнёте их использовать, то удивитесь, как вы могли раньше без них обходится.<br/>
<br/>
<h2>Замыкания</h2><br/>
До сих пор мы обсуждали особенности ФП в контексте «чисто» функциональных языков — языков, которые являются реализацией лямбда исчисления и не содержат особенностей, противоречащих формальной системе Чёрча. Тем не менее, многие черты функциональных языков используются за пределами лямбда исчисления. Хотя реализация аксиоматической системы интересна с точки зрения программирования в терминах математических выражений, это не всегда может быть применимо на практике. Многие языки предпочитают использовать элементы функциональных языков не придерживаясь строгой функциональной доктрины. Некоторые такие языки (например Common Lisp) не требуют от переменных быть <code>final</code> — их значения можно менять. Они даже не требуют, чтобы функции зависели только от своих аргументов — функциям дозволенно обращаться к состоянию за пределом своей области видимости. Но при этом они включают в себя такие особенности, как функции высшего порядка. Передача функции в не-чистом языке немного отличается от аналогичной операции в пределах лямбда исчисления и требует наличия интересной особенности под названием: лексическое замыкание. Давайте взглянем на следующий пример. Помните, что в данном случае переменные не <code>final</code> и функция может обращаться к переменным за пределом своей области видимости:<br/>
<br/>
<pre><code class="java">Function makePowerFn(int power) {
   int powerFn(int base) {
       return pow(base, power);
   }


   return powerFn;
}


Function square = makePowerFn(2);
square(3); // returns 9
</code></pre><br/>
Функция <code>make-power-fn</code> возвращает функцию, которая принимает один аргумент и возводит его в определённую степень. Что произойдёт, когда мы попробуем вычислить <code>square(3)</code>? Переменная <code>power</code> находится вне области видимости <code>powerFn</code>, потому что <code>makePowerFn</code> уже завершилась, и её стек уничтожен. Как же тогда работает <code>square</code>? Язык должен каким-либо образом сохранить значение <code>power</code>, чтобы функция <code>square</code> могла работать. А что если мы создадим ещё одну функцию <code>cube</code>, которая возводит число в третью степень? Язык должен будет сохранять два значения <code>power</code> для каждой созданной в <code>make-power-fn</code> функции. Феномен хранения этих значений и называется замыканием. Замыкание не только сохраняет аргументы верхней функции. Например замыкание может выглядеть следующим образом:<br/>
<br/>
<pre><code class="java">Function makeIncrementer() {
   int n = 0;


   int increment() {
       return ++n;
   }
}


Function inc1 = makeIncrementer();
Function inc2 = makeIncrementer();


inc1(); // returns 1;
inc1(); // returns 2;
inc1(); // returns 3;
inc2(); // returns 1;
inc2(); // returns 2;
inc2(); // returns 3;
</code></pre><br/>
В процессе выполнения значения <code>n</code> сохраняются, и счётчики имеют доступ к ним. Более того у каждого счётчика своя копия <code>n</code>, не смотря на то, что они должны были исчезнуть после того, как функция <code>makeIncrementer</code> отработает. Как же компилятор умудряется это скомпилировать? Что происходит за кулисами замыканий? К счастью у нас есть волшебный пропуск.<br/>
<br/>
Всё сделано достаточно логично. С первого взгляда ясно, что локальные переменные больше не подчиняются правилам области видимости и их время жизни не определено. Очевидно, что они больше не хранятся в стеке — их нужно держать в куче (heap) <a name="ref_8_up"></a><sup><a href="index.html.1.129.html#ref_8_down">[8]</a></sup>. Замыкание, следовательно, сделано как обычная функция, которую мы обсуждали ранее, за исключением того, что в нём есть дополнительная ссылка на окружающие переменные:<br/>
<br/>
<pre><code class="java">class some_function_t {
   SymbolTable parentScope;
   
   // ...
}
</code></pre><br/>
Если замыкание обращается к переменной, которой нет в локальной области видимости, тогда оно принимает во внимание родительскую область. Вот и всё! Замыкание связывает функциональный мир с миром ООП. Каждый раз, когда вы создаёте класс, который хранит некоторое состояние, и передаёте его куда-то, вспомните про замыкания. Замыкание — это всего лишь объект, который создаёт «атрибуты» на лету, забирая их из области видимости, чтобы вам не пришлось делать это самим.<br/>
<br/>
<h2>Что теперь?</h2><br/>
Эта статья проходится лишь по верхушке айсберга Функционального Программирования. Вы можете копнуть глубже и увидеть нечто действительно большое, а в нашем случае ещё и хорошее. В будущем я планирую написать о теории категорий, монадах, функциональных структурах данных, системе типов в функциональных языках, функциональной многопоточности, функциональных базах данных, и ещё о многих вещах. Если у меня получится написать (и изучить в процессе) хотя бы о половине из этих тем, моя жизнь пройдёт не зря. А пока, <a href="http://www.google.com">Google</a> — ваш верный друг.<br/>
<br/>
<h2>Комментарии?</h2><br/>
Если у вас есть вопросы, комментарии или предложения, черканите записочку на адрес coffeemug [собачка] gmail.com. Буду рад любым вашим отзывам.<br/>
<br/>
<h2>Примечания</h2><br/>
<a name="ref_1_down"></a><a href="index.html.1.129.html#ref_1_up">[1]</a>. Когда я искал работу осенью 2005 года, я частенько задавал этот вопрос. Было очень занятно видеть пустой взгляд вместо ответа. Я-то думал, что за зарплату $300,000 у этих людей должно быть хорошее понимание всех доступных инструментов.<br/>
<br/>
<a name="ref_2_down"></a><a href="index.html.1.129.html#ref_2_up">[2]</a>. Этот вопрос неоднозначный. Физики и математики вынуждены признать, что нет ничего предельно ясного во вселенной, что можно было бы описать математически.<br/>
<br/>
<a name="ref_3_down"></a><a href="index.html.1.129.html#ref_3_up">[3]</a>. Я ненавидел уроки истории, которые предлагали только сухую хронологию дат, имён и событий. Для меня история — это жизни людей, которые изменили мир. Это те их личные причины, которая стоят за их действиями, и механизмы, которыми они оказывали влияние на миллионы душ. По этой причине исторический раздел этой статьи безнадёжно неполон. Здесь описываются только наиболее значимые люди и события.<br/>
<br/>
<a name="ref_4_down"></a><a href="index.html.1.129.html#ref_4_up">[4]</a>. Когда я только начинал изучать функциональное программирование, меня очень нервировал термин «лямбда», потому что я не мог до конца понять, что же он обозначает. В данном контексте лямбда — это функция. А греческая буква используется для удобства математической записи. Каждый раз, когда вы слышите «лямбда» в разговоре о функциональном программировании, переводите это про себя в «функцию».<br/>
<br/>
<a name="ref_5_down"></a><a href="index.html.1.129.html#ref_5_up">[5]</a>. Занимательно, что строки в Java не изменяются. Интересно было бы выяснить причину такого вероломства, но не будем отвлекаться.<br/>
<br/>
<a name="ref_6_down"></a><a href="index.html.1.129.html#ref_6_up">[6]</a>. Большинство компиляторов функциональных языков умеют оптимизировать рекурсивные функции превращая их в циклы по мере возможностей. Это называется <a href="http://ru.wikipedia.org/wiki/Хвостовая_рекурсия">оптимизация хвостовой рекурсии</a>.<br/>
<br/>
<a name="ref_7_down"></a><a href="index.html.1.129.html#ref_7_up">[7]</a>. Обратное не всегда верно. Если иногда возможно доказать эквивалентность двух участков кода, но в общем случае это не возможно.<br/>
<br/>
<a name="ref_8_down"></a><a href="index.html.1.129.html#ref_8_up">[8]</a>. На самом деле это не медленнее, чем хранить в стеке, поскольку при использовании сборщика мусора выделение памяти занимает O(1) операций.</div></div></div> <DIV class="v-portal" style="display:none;"></DIV></div> <!----> <!----></div> <div class="tm-article-presenter__meta"><div class="tm-separated-list tm-article-presenter__meta-list"><span class="tm-separated-list__title">Теги:</span> <ul class="tm-separated-list__list"><li class="tm-separated-list__item"><a href="https://habr.com/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5B%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%BE%D0%BD%D0%B0%D0%BB%D1%8C%D0%BD%D0%BE%D0%B5%20%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%5D" class="tm-tags-list__link">функциональное программирование</a></li><li class="tm-separated-list__item"><a href="https://habr.com/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5B%D0%BB%D0%B8%D0%BA%D0%B1%D0%B5%D0%B7%5D" class="tm-tags-list__link">ликбез</a></li><li class="tm-separated-list__item"><a href="https://habr.com/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5B%D0%B8%D1%81%D1%82%D0%BE%D1%80%D0%B8%D1%8F%5D" class="tm-tags-list__link">история</a></li></ul></div> <div class="tm-separated-list tm-article-presenter__meta-list"><span class="tm-separated-list__title">Хабы:</span> <ul class="tm-separated-list__list"><li class="tm-separated-list__item"><a href="https://habr.com/ru/hub/programming/" class="tm-hubs-list__link">
    Программирование
  </a></li></ul></div></div></article></div> <!----></div> <div class="tm-article-sticky-panel"><div class="tm-data-icons tm-article-sticky-panel__icons"><div class="tm-article-rating tm-data-icons__item"><div class="tm-votes-meter tm-article-rating__votes-switcher"><svg height="24" width="24" class="tm-svg-img tm-votes-meter__icon tm-votes-meter__icon_appearance-article"><title>Всего голосов 188: ↑181 и ↓7</title> <use xlink:href="/img/megazord-v25.4b679db1.svg#counter-rating"></use></svg> <span title="Всего голосов 188: ↑181 и ↓7" class="tm-votes-meter__value tm-votes-meter__value_positive tm-votes-meter__value_appearance-article tm-votes-meter__value_rating">+174</span></div> <DIV class="v-portal" style="display:none;"></DIV></div> <!----> <span title="Количество просмотров" class="tm-icon-counter tm-data-icons__item"><svg height="24" width="24" class="tm-svg-img tm-icon-counter__icon"><title>Просмотры</title> <use xlink:href="/img/megazord-v25.4b679db1.svg#counter-views"></use></svg> <span class="tm-icon-counter__value">332K</span></span> <button title="Добавить в закладки" type="button" class="bookmarks-button tm-data-icons__item"><span title="Добавить в закладки" class="tm-svg-icon__wrapper bookmarks-button__icon"><svg height="24" width="24" class="tm-svg-img tm-svg-icon"><title>Добавить в закладки</title> <use xlink:href="/img/megazord-v25.4b679db1.svg#counter-favorite"></use></svg></span> <span title="Количество пользователей, добавивших публикацию в закладки" class="bookmarks-button__counter">
    2176
  </span></button> <!----> <div title="Поделиться" class="tm-sharing tm-data-icons__item"><button type="button" class="tm-sharing__button"><svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" class="tm-sharing__icon"><path fill="currentColor" d="M13.8 13.8V18l7.2-6.6L13.8 5v3.9C5 8.9 3 18.6 3 18.6c2.5-4.4 6-4.8 10.8-4.8z"></path></svg></button> <DIV class="v-portal" style="display:none;"></DIV></div> <DIV class="v-portal" style="display:none;"></DIV></div> </div></div> <DIV class="v-portal" style="display:none;"></DIV> <div class="tm-article-presenter__footer"><div class="tm-article-blocks"><!----> <section class="tm-block tm-block_spacing-bottom"><!----> <div class="tm-block__body tm-block__body_variant-balanced"><div class="tm-article-author"> <div class="tm-user-card tm-article-author__user-card tm-user-card_variant-article"><div class="tm-user-card__info-container"><div class="tm-user-card__header"><div class="tm-user-card__header-data"><a href="https://habr.com/ru/users/sheknitrtch/" class="tm-user-card__userpic tm-user-card__userpic_size-40"><div class="tm-entity-image"><img alt="" src="https://habrastorage.org/getpro/habr/avatars/206/c3f/14a/206c3f14aacc1aa7d90051046ff47bf3.jpg" class="tm-entity-image__pic"></div></a> <div class="tm-user-card__meta"><div title=" 150 голосов " class="tm-karma tm-user-card__karma"><div class="tm-karma__votes tm-karma__votes_positive">
    120
  </div> <div class="tm-karma__text">
    Карма
  </div></div> <div title="Рейтинг пользователя" class="tm-rating tm-user-card__rating"><div class="tm-rating__header"> <div class="tm-rating__counter">0</div></div> <div class="tm-rating__text">
    Рейтинг
  </div></div></div></div></div> <div class="tm-user-card__info tm-user-card__info_variant-article"><div class="tm-user-card__title tm-user-card__title_variant-article"><span class="tm-user-card__name tm-user-card__name_variant-article">Щекн-Итрч</span> <a href="https://habr.com/ru/users/sheknitrtch/" class="tm-user-card__nickname tm-user-card__nickname_variant-article">
          @sheknitrtch
        </a> <!----></div> <p class="tm-user-card__short-info tm-user-card__short-info_variant-article">Пользователь</p></div></div> <div class="tm-user-card__buttons tm-user-card__buttons_variant-article"><!----> <!----> <!----> <!----> <!----></div></div> <!----></div> <DIV class="v-portal" style="display:none;"></DIV></div> <!----></section> <div class="tm-article-blocks__comments"><div class="tm-article-page-comments"><div class="tm-article-comments-counter-link tm-article-comments-counter-button"><a href="https://habr.com/ru/post/142351/comments/" class="tm-article-comments-counter-link__link tm-article-comments-counter-link__link_button-style"><svg height="24" width="24" class="tm-svg-img tm-article-comments-counter-link__icon tm-article-comments-counter-link__icon_contrasted"><title>Комментарии</title> <use xlink:href="/img/megazord-v25.4b679db1.svg#counter-comments"></use></svg> <span class="tm-article-comments-counter-link__value tm-article-comments-counter-link__value_contrasted">
       Комментарии 151 
    </span></a> <!----></div></div></div> <div class="tm-ad-banner__container tm-page-article__banner"><!----> <div id="articleBottomBanner5072" class="tm-ad-banner"></div></div> <!----> <!----> <!----> <!----> </div></div></div></div></div> <div class="tm-page__sidebar"><div class="tm-layout-sidebar"><div class="tm-layout-sidebar__ads tm-layout-sidebar__ads_initial"><div class="tm-ad-banner__container tm-layout-sidebar__banner"><!----> <div id="sidebarBanner5073" class="tm-ad-banner"></div></div></div> <div class="tm-sexy-sidebar tm-sexy-sidebar_initial" style="margin-top:0px;"><!----> <!----></div></div></div></div></div></div></main> <!----></div> <div class="tm-footer-menu"><div class="tm-page-width"><div class="tm-footer-menu__container"><div class="tm-footer-menu__block"><h3 class="tm-footer-menu__block-title">
          Ваш аккаунт
        </h3> <div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><li class="tm-footer-menu__list-item"><a href="https://habr.com/kek/v1/auth/habrahabr/?back=/ru/post/142351/&amp;hl=ru" rel="nofollow" target="_self">
                Войти
              </a></li><li class="tm-footer-menu__list-item"><a href="https://habr.com/kek/v1/auth/habrahabr-register/?back=/ru/post/142351/&amp;hl=ru" rel="nofollow" target="_self">
                Регистрация
              </a></li></ul></div></div><div class="tm-footer-menu__block"><h3 class="tm-footer-menu__block-title">
          Разделы
        </h3> <div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><li class="tm-footer-menu__list-item"><a href="https://habr.com/ru/" class="footer-menu__item-link router-link-active">
                Публикации
              </a></li><li class="tm-footer-menu__list-item"><a href="https://habr.com/ru/news/" class="footer-menu__item-link">
                Новости
              </a></li><li class="tm-footer-menu__list-item"><a href="https://habr.com/ru/hubs/" class="footer-menu__item-link">
                Хабы
              </a></li><li class="tm-footer-menu__list-item"><a href="https://habr.com/ru/companies/" class="footer-menu__item-link">
                Компании
              </a></li><li class="tm-footer-menu__list-item"><a href="https://habr.com/ru/users/" class="footer-menu__item-link">
                Авторы
              </a></li><li class="tm-footer-menu__list-item"><a href="https://habr.com/ru/sandbox/" class="footer-menu__item-link">
                Песочница
              </a></li></ul></div></div><div class="tm-footer-menu__block"><h3 class="tm-footer-menu__block-title">
          Информация
        </h3> <div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><li class="tm-footer-menu__list-item"><a href="https://habr.com/ru/docs/help/" class="footer-menu__item-link">
                Устройство сайта
              </a></li><li class="tm-footer-menu__list-item"><a href="https://habr.com/ru/docs/authors/codex/" class="footer-menu__item-link">
                Для авторов
              </a></li><li class="tm-footer-menu__list-item"><a href="https://habr.com/ru/docs/companies/corpblogs/" class="footer-menu__item-link">
                Для компаний
              </a></li><li class="tm-footer-menu__list-item"><a href="https://habr.com/ru/docs/docs/transparency/" class="footer-menu__item-link">
                Документы
              </a></li><li class="tm-footer-menu__list-item"><a href="https://account.habr.com/info/agreement" target="_blank">
                Соглашение
              </a></li><li class="tm-footer-menu__list-item"><a href="https://account.habr.com/info/confidential/" target="_blank">
                Конфиденциальность
              </a></li></ul></div></div><div class="tm-footer-menu__block"><h3 class="tm-footer-menu__block-title">
          Услуги
        </h3> <div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><li class="tm-footer-menu__list-item"><a href="https://docs.google.com/presentation/d/e/2PACX-1vQLwRfQmXibiUlWaRg-BAc38s7oM3lJiaPju7qmdJsp8ysIvZ_G-Npem0njJLMozE2bPHMpDqiI5hhy/pub?start=false&amp;loop=false&amp;delayms=60000&amp;slide=id.g91a03369cd_4_297" target="_blank">
                Реклама
              </a></li><li class="tm-footer-menu__list-item"><a href="https://habrastorage.org/storage/stuff/habr/service_price.pdf" target="_blank">
                Тарифы
              </a></li><li class="tm-footer-menu__list-item"><a href="https://docs.google.com/presentation/d/e/2PACX-1vQJJds8-Di7BQSP_guHxICN7woVYoN5NP_22ra-BIo4bqnTT9FR6fB-Ku2P0AoRpX0Ds-LRkDeAoD8F/pub?start=false&amp;loop=false&amp;delayms=60000" target="_blank">
                Контент
              </a></li><li class="tm-footer-menu__list-item"><a href="https://tmtm.timepad.ru/" target="_blank">
                Семинары
              </a></li><li class="tm-footer-menu__list-item"><a href="https://habr.com/ru/megaprojects/" class="footer-menu__item-link">
                Мегапроекты
              </a></li></ul></div></div></div></div></div> <div class="tm-footer"><div class="tm-page-width"><div class="tm-footer__container"><!----> <div class="tm-footer__social"><a href="https://www.facebook.com/habrahabr.ru" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Facebook</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-facebook"></use></svg></a><a href="https://twitter.com/habr_com" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Twitter</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-twitter"></use></svg></a><a href="https://vk.com/habr" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>VK</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-vkontakte"></use></svg></a><a href="https://telegram.me/habr_com" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Telegram</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-telegram"></use></svg></a><a href="https://www.youtube.com/channel/UCd_sTwKqVrweTt4oAKY5y4w" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Youtube</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-youtube"></use></svg></a><a href="https://zen.yandex.ru/habr" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Яндекс Дзен</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-zen"></use></svg></a></div> <DIV class="v-portal" style="display:none;"></DIV> <button class="tm-footer__link"><!---->
        Настройка языка
      </button> <a href="https://habr.com/ru/about" class="tm-footer__link">
        О сайте
      </a> <a href="https://habr.com/ru/feedback/" class="tm-footer__link">
        Техническая поддержка
      </a> <!----> <a href="https://habr.com/berserk-mode-nope" class="tm-footer__link">
        Вернуться на старую версию
      </a> <div class="tm-footer-copyright"><span class="tm-copyright"><span class="tm-copyright__years">© 2006–2022 </span> <span class="tm-copyright__name">«<a href="https://company.habr.com/" rel="noopener" target="_blank" class="tm-copyright__link">Habr</a>»</span></span></div></div></div></div> <!----> <!----></div> <div class="vue-portal-target"></div></div>
<script>window.__INITIAL_STATE__={"adblock":{"hasAcceptableAdsFilter":false,"hasAdblock":false},"articlesList":{"articlesList":{"142351":{"id":"142351","timePublished":"2012-04-19T07:45:50+00:00","isCorporative":false,"lang":"ru","titleHtml":"Функциональное программирование для всех","leadData":{"textHtml":"\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fstorage2\u002Fe8b\u002F2ce\u002Fec8\u002Fe8b2ceec8c7ade11a7e02a4e7a4d57e0.png\" align=\"left\"\u002F\u003E\u003Cbr\u002F\u003E\r\nДоброго времени суток. Это статья — перевод заинтересовавшего меня поста в блоге аспиранта Университета штата Нью-Йорк в Стоуни-Брук. Статья в доступной форме описывает основные концепции функционального программирования, их преимущества и недостатки. Думаю она будет полезна широкому кругу читателей, которые сомневаются, нужно ли им углубляться в мир функционального программирования или нет. Пожелания, предложения и замечания по переводу и терминологии принимаются по личной почте.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ci\u003EМнение переводчика может иногда не совпадать с мнением автора, но переводить статью было крайне занимательно.\u003C\u002Fi\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cb\u003EUPD:\u003C\u002Fb\u003E альтернативный вариант перевода вы можете найти на \u003Ca href=\"http:\u002F\u002Fwww.rsdn.ru\u002Farticle\u002Ffuncprog\u002Ffp.xml\"\u003Ersdn\u003C\u002Fa\u003E (спасибо \u003Ca href=\"https:\u002F\u002Fhabrahabr.ru\u002Fusers\u002Fflamingo\u002F\" class=\"user_link\"\u003Eflamingo\u003C\u002Fa\u003E за ссылку).\u003Cbr\u002F\u003E\r\n","imageUrl":null,"buttonTextHtml":"Читать дальше &rarr;","image":null},"editorVersion":"1.0","postType":"article","postLabels":[{"type":"translation","data":{"originalAuthorName":"Slava Akhmechet","originalUrl":"http:\u002F\u002Fwww.defmacro.org\u002Framblings\u002Ffp.html"}}],"author":{"scoreStats":{"score":120,"votesCount":150},"rating":0,"relatedData":null,"contacts":[],"authorContacts":[],"paymentDetails":{"paymentYandexMoney":null,"paymentPayPalMe":null,"paymentWebmoney":null},"id":"70827","alias":"sheknitrtch","fullname":"Щекн-Итрч","avatarUrl":"\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Favatars\u002F206\u002Fc3f\u002F14a\u002F206c3f14aacc1aa7d90051046ff47bf3.jpg","speciality":null},"statistics":{"commentsCount":151,"favoritesCount":2176,"readingCount":331827,"score":174,"votesCount":188},"hubs":[{"relatedData":null,"id":"359","alias":"programming","type":"collective","title":"Программирование","titleHtml":"Программирование","isProfiled":true}],"flows":[{"id":"1","alias":"develop","title":"Разработка"}],"relatedData":null,"textHtml":"\u003Cdiv xmlns=\"http:\u002F\u002Fwww.w3.org\u002F1999\u002Fxhtml\"\u003E\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw1560\u002Fstorage2\u002Fe8b\u002F2ce\u002Fec8\u002Fe8b2ceec8c7ade11a7e02a4e7a4d57e0.png\" align=\"left\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fstorage2\u002Fe8b\u002F2ce\u002Fec8\u002Fe8b2ceec8c7ade11a7e02a4e7a4d57e0.png\"\u002F\u003E\u003Cbr\u002F\u003E\r\nДоброго времени суток. Это статья — перевод заинтересовавшего меня поста в блоге аспиранта Университета штата Нью-Йорк в Стоуни-Брук. Статья в доступной форме описывает основные концепции функционального программирования, их преимущества и недостатки. Думаю она будет полезна широкому кругу читателей, которые сомневаются, нужно ли им углубляться в мир функционального программирования или нет. Пожелания, предложения и замечания по переводу и терминологии принимаются по личной почте.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ci\u003EМнение переводчика может иногда не совпадать с мнением автора, но переводить статью было крайне занимательно.\u003C\u002Fi\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cb\u003EUPD:\u003C\u002Fb\u003E альтернативный вариант перевода вы можете найти на \u003Ca href=\"http:\u002F\u002Fwww.rsdn.ru\u002Farticle\u002Ffuncprog\u002Ffp.xml\"\u003Ersdn\u003C\u002Fa\u003E (спасибо \u003Ca href=\"https:\u002F\u002Fhabrahabr.ru\u002Fusers\u002Fflamingo\u002F\" class=\"user_link\"\u003Eflamingo\u003C\u002Fa\u003E за ссылку).\u003Cbr\u002F\u003E\r\n\u003Ca name=\"habracut\"\u003E\u003C\u002Fa\u003E\u003Cbr\u002F\u003E\r\n\u003Ci\u003EПонедельник, 19 июня, 2006\u003C\u002Fi\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ch2\u003EВведение\u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\r\nПрограммисты — прокрастинаторы (то есть лентяи). Прийти, сделать кофе, проверить почту, почитать RSS летну, почитать новости, проверить свежие статьи на техническом сайте, полистать политические дискуссии на программистском форуме. Смыть, повторить, чтобы ничего не пропустить. Пойти на обед. Вернуться, уткнутся в IDE на несколько минут. Проверить почту. Приготовить кофе. И вот неожиданно день подходит к концу.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nНо время от времени в поле зрения оказываются занятные (затруднительные, многообещающие) статьи и посты в блогах. Если вы ищете в правильном месте, то как минимум одна такая статья будет встречаться вам каждые несколько дней. В этих постах сложно разобраться, на это требуется время, поэтому они накапливаются в папке «Прочитать». Прежде, чем вы успеете понять что к чему, окажется что уже накопилась куча ссылок и папка, полная PDF файлов. Вам, и понадобится целый год и хижина посреди леса, где на мили вокруг нет ни души, чтобы во всём этом разобраться. И желательно, чтобы кто-нибудь каждое утро приносил еду и забирал мусор, пока вы прогуливаетесь к реке.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nЯ не знаю, какой у вас список, но большая часть моего списка касается функционального программирования. Такие статьи обычно самые сложные. Часто они написаны сухим академическим языком, и даже «ветераны Wall Street с десятилетним стажем» не понимают о чем говорится в статьях по функциональному программированию (ФП). Если вы зададите вопрос менеджеру проекта в Citi Group или в Deutsche Bank \u003Ca name=\"ref_1_up\"\u003E\u003C\u002Fa\u003E\u003Csup\u003E\u003Ca href=\"#ref_1_down\"\u003E[1]\u003C\u002Fa\u003E\u003C\u002Fsup\u003E почему они выбрали JMS вместо Erlang, то услышите в ответ, что они не могут использовать академический язык для промышленных разработок. Проблема в том, что большинство комплексных систем с самыми жесткими требованиями были написаны с использованием элементов функционального программирования. Что-то не сходится.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nДействительно статьи о ФП трудны для понимания, но их можно написать проще. Причина возникшей пропасти знаний чисто историческая. По сути в концепции ФП нет ничего сложного. Взгляните на эту статью, как на «доступное руководство по ФП», как на мостик между нашими императивными умами и миром ФП. Заварите себе кофе и продолжим. Надеюсь, что уже очень скоро коллеги начнут шутить по поводу ваших ФП комментариев.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nТак что же такое ФП? Откуда оно пошло? На что оно годно? Если оно действительно так полезно, как об этом твердят защитники ФП, то почему его не используют чаще в промышленных масштабах? Почему только люди с PhD склоняются к функциональным языкам? Но что ещё важнее, почему так чертовски трудно освоить функциональные языки? Что скрывается за всеми этими замыканиями, продолжениями, каррированием, ленивые вычисления и отсутствие побочных эффектов? Как это всё можно использовать в проекте, который не охватывает целую вселенную? Почему это всё так далеко от того хорошего, что свято и дорого нашим императивным сердцам? Скоро мы во всём разберёмся. Для начала давайте поймём в чём причина огромной пропасти между академическими статьями и реальным миром. Чтобы ответить на этот вопрос достаточно прогуляться в парке.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ch2\u003EПрогулка в парке\u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\r\nСадитесь в машину времени. Наша прогулка в парке произошла более 2 тысяч лет назад в один из тех солнечных дней давно забытой весны 380 года до н.э. За городскими стенами Афин под ласковыми тенями оливковых деревьев Платон прогуливался в направлении Академии с красивым мальчиком рабом. Стояла чудесная погода, обед приятной тяжестью отдавался в животе, и разговор плавно перешёл на философские темы.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n«Посмотри на тех двух студентов», сказал Платон, аккуратно подбирая слова, чтобы придать вопросу образовательного смысла. «Кто из них, по-твоему, выше?» Мальчик раб посмотрел в сторону бассейна, возле которого стояли два человека. «Они приблизительно одного роста», ответил мальчик. «Что ты имеешь в виду под словами 'приблизительно одного роста'?», спросил Платон. «Ну, отсюда они выглядят одинаково, но я уверен, что если мы подойдём поближе, то я смогу увидеть разницу в росте.»\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nПлатон улыбнулся. Он вёл мальчика в правильном направлении. «То есть ты хочешь сказать, что в мире нет идеально совпадающих вещей?» Мальчик призадумался и ответил: «Да, я так думаю. Всегда существует маленькая разница, даже если мы не можем её увидеть.» Он дошёл до самой сути! «Тогда если нет идеально совпадающих вещей в этом мире, то как ты понимаешь концепцию 'идеального' равенства?» Это ввело мальчика в ступор. Он ответил: «Я не знаю».\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nТак родилась первая попытка понять природу математики. Платон предположил, что в нашем мире всё лишь приближение идеала. Он также осознал, что люди способны понять концепцию идеала, хотя никогда с ним не сталкивались. Он пришёл к выводу, что идеальные математические формы должны существовать в другом мире, и что мы каким-то образом знаем о них из связей с этой «альтернативной» вселенной. Очевидно, что мы не можем увидеть идеальный круг. Но при этом мы понимаем, что из себя представляет идеальный круг, и как он может быть описан математически. Что же тогда математика? Почему вселенная описывается математическими законами? Всё ли может описать математика? \u003Ca name=\"ref_2_up\"\u003E\u003C\u002Fa\u003E\u003Csup\u003E\u003Ca href=\"#ref_2_down\"\u003E[2]\u003C\u002Fa\u003E\u003C\u002Fsup\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ca href=\"http:\u002F\u002Fru.wikipedia.org\u002Fwiki\u002FФилософия_математики\"\u003EФилософия математики\u003C\u002Fa\u003E очень сложный предмет. Как и большинство философских дисциплин, она скорее задаёт вопросы, чем отвечает на них. Учёные в большинстве своём согласны с тем фактом, что математика — это настоящая головоломка: в основе лежит набор базовых непротиворечивых принципов и набор правил, как этими принципами оперировать. Затем мы можем комбинировать правила, получая всё более и более сложные законы. Математики называют такой метод «формальной системой» или «исчислением». Например, можно построить формальную систему для Тетриса. По сути работающий Тетрис и есть сам по себе формальная система, просто она записана в необычном виде.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nЦивилизация пушистых существ с Альфы Центавра не сможет прочесть нашу формальную систему Тетриса или круга, потому что их единственный орган чувств может воспринимать только запахи. Возможно они никогда не построят Тетрис, но наверняка у них будет формальная система для круга. Скорее всего у нас не получится с ней ознакомиться, так как наше обоняние не настолько развито. Но как только будет расшифрован язык представления (путём различных сенсорных инструментов и стандартной техники обратного инженеринга), базовые концепции станут понятны любой интеллектуально развитой цивилизации.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nДаже если бы не существовало ни одной разумной цивилизации во вселенной, формальная система для Тетриса и круга всё равно были бы логически верными. Просто не нашлось бы существ, способных эти системы найти и формализовать. Если внезапно появится разумная расса пришельцев, то они, скорее всего, разработают свою формальную систему для описания вселенной. Конечно, маловероятно, что они изобретут Тетрис, потому что во вселенной нет аналогов этой игре. Тетрис — это один пример из огромного числа формальных систем, загадок, которые не имеют отношения к окружающей действительности. Даже такое понятие как натуральные числа не всегда можно отнести к реальному миру, ведь можно представить себе настолько большое число, что его нельзя применить к чему-либо во вселенной, но при этом оно будет конечным.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ch2\u003EНемного истории \u003Ca name=\"ref_3_up\"\u003E\u003C\u002Fa\u003E\u003Csup\u003E\u003Ca href=\"#ref_3_down\"\u003E[3]\u003C\u002Fa\u003E\u003C\u002Fsup\u003E\u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\r\nДавайте повернём колёса нашей машины времени и переместимся немного ближе, в 1930-е. Великая депрессия опустошила Новый и Старый свет. Почти все семьи из всех социальных слоев почувствовали на себе громадный экономический спад. Осталось совсем мало убежищ, в которых люди могли не боятся бедности. Некоторым людям повезло оказаться в таких убежищах. Нас интересуют математики в Принстонском университете.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nНовые корпуса, построенные в готическом стиле, придавали университету ауру безопасности. Специалисты по логике со всей страны приглашались в Принстон для основания нового подразделения. В то время, как большинство американцев с трудом добывали себе пропитание, высокие потолки, стены с узорами из дерева, ежедневные дискуссии за чашечкой чая, и прогулки в лесу, составляли условия проживания в Принстоне.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nОдним из математиков, проживавших в таком расточительном образе жизни, был молодой человек по имени Алонзо Чёрч (Alonzo Church). Алонзо получил степень бакалавра в Принстоне и его уговорили остаться в аспирантуре. Алонзо чувствовал, что окружающая обстановка была чересчур роскошной. Он редко появлялся на обсуждении математических проблем за чашечкой чая и не любил гулять в лесу. Алонзо был одиночкой: он был более плодовит, когда работал один. Тем не менее он регулярно встречался с другими обитателями Принстона. Среди которых были Алан Тьюринг (Alan Turing), Джон фон Нейман (John von Neumann) и Курт Гёдель (Kurt Gödel).\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nЭти четверо интересовались формальными системами. Они не уделяли особого внимания физическому миру, их интересовала работа с абстрактными математическими головоломками. В их головоломках было нечто общее: математики изучали вопросы вычислений. Если у нас есть машина с бесконечными вычислительными возможностями, то какие задачи можно на ней решать? Можно ли решать задачи автоматически? Существуют ли неразрешимые задачи и почему? Будут ли машины с разной архитектурой одинаковыми по мощности?\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nСовместно с другими учёными Алонзо разработал формальную систему названную Лямбда-исчислением. Система по сути была языком программирования для одной из воображаемых машин. Она была основана на функциях, которые принимают в качестве аргументов функции, и возвращают функцию. Такая функция была обозначена греческой буквой Лямбда, что дало название всей системе \u003Ca name=\"ref_4_up\"\u003E\u003C\u002Fa\u003E\u003Csup\u003E\u003Ca href=\"#ref_4_down\"\u003E[4]\u003C\u002Fa\u003E\u003C\u002Fsup\u003E. Используя эту систему Алонзо удалось построить рассуждения касательно вышеописанных вопросов и вывести ответы на них.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nНезависимо от Алонзо, Алан Тьюринг проводил подобное исследование. Он разработал другую формальную систему (которую сейчас называют Машиной Тьюринга), и используя её пришёл к выводам, подобным Алонзо. Позже было доказано, что машина Тьюринга и лябда-исчисление имеют одинаковую мощность.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nВ этот момент наша история останавливается. Я бы подытожил статью, и вы переключились бы на другую страницу, если бы не началась Вторая мировая война. Мир пылал. Войска США очень интенсивно использовали артиллерию. Чтобы повысить точность армия наняла большую группу математиков, которые постоянно решали дифференциальные уравнения, необходимые для баллистических таблиц стрельбы. Быстро стало понятно, что такая задача слишком сложна для ручного решения, для преодоления этой проблемы было разработано специальное оборудование. Первой машиной для решения баллистических таблиц был Mark I построенный IBM — она весила 5 тонн, состояла из 750'000 деталей и могла совершать 3 операции в секунду.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nГонка, конечно, на этом не закончилась. В 1949 общественности был показан Электронный Дискретный Переменный Автоматический Компьютер (Electronic Discrete Variable Automatic Computer, EDVAC). Это был первый пример реализации архитектуры фон Неймана, и был первой действительно работающей машиной Тьюринга. На некоторое время работы Алонзо Чёрча были отложены в сторонку.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nВ конце 50-ых профессор Массачусетского технологического института (MIT) Джон Маккарти (John McCarthy ), тоже выпускник Принстона, начал проявлять интерес к работе Алонзо Чёрча. В 1958 году он представил язык обработки списков, \u003Cb\u003ELis\u003C\u002Fb\u003Et \u003Cb\u003EP\u003C\u002Fb\u003Erocessing language (Lisp). Lisp задумывался как имплементация Лямбда-исчисления Алонзо, которая работает на компьютерах фон Неймана. Многие компьютерные учёные отметили выразительную мощь Lisp-а. В 1973 году группа программистов в лаборатории искусственного интеллекта в Массачусетском технологическом институте разработали железо, которое они назвали Lisp-машиной. Это была аппаратная реализация лямбда-исчислений Алонзо.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ch2\u003EФункциональное программирование\u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\r\nФункциональное программирование — это практическая реализация идей Алонзо Чёрча. Не все идеи Лямбда-исчисления переросли в практическую сферу, так как лямбда-исчисления не учитывали физических ограничений. Тем не менее, как и ОО программирование, функциональное программирование — это набор идей, а не набор четких указаний. Существует много функциональных языков, и большинство из них делают одни схожие вещи по разному. В данной статье я объясню наиболее широко используемые идеи из функциональных языков используя примеры на Java (да, вы можете писать функциональные программы на Java если у вас есть склонности к мазохизму). В следующих нескольких разделах мы возьмём язык Java и внесём в него изменения, чтобы он превратился в пригодный к использованию функциональный язык. Начнём наше путешествие.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nЛямбда исчисление было придумано для изучения проблем, связанным с вычислениями. Функциональное программирование, стало быть, в первую очередь имеет дело с вычислениями, и, на удивление, использует для этого функции. Функция — это базовый элемент функционального программирования. Функции используются почти для всего, даже для простейших расчётов. Даже переменные заменяются функциями. В функциональном программировании переменные — это просто синонимы (alias) для выражений (чтобы нам не пришлось писать всё в одну строку). Их нельзя изменять. В каждую переменную можно записать только один раз. В терминах Java это означает, что все переменные объявляются как \u003Ccode\u003Efinal\u003C\u002Fcode\u003E (или \u003Ccode\u003Econst\u003C\u002Fcode\u003E если имеем дело с C++). В ФП нет не-\u003Ccode\u003Efinal\u003C\u002Fcode\u003E переменных\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"java\"\u003Efinal int i = 5;\nfinal int j = i + 3;\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nТак как все переменные финальные, то можно сформулировать два утверждения. Нет смысла постоянно писать ключевое слово \u003Ccode\u003Efinal\u003C\u002Fcode\u003E, и нет смысла называть переменные … переменными. Теперь мы внесём два изменения в Java: каждое объявление переменной будет финальным, мы будем обращаться к переменным как к символам.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nТеперь вы, наверное, удивляетесь, как вообще можно написать что-либо достаточно сложное на таком языке. Если все символы неизменяемые, то мы в принципе не можем поменять состояние программы! Это не совсем верно. Когда Алонзо работал над лямбда-исчислением, у него не было нужды сохранять состояние, чтобы изменить его позже. Его интересовало проведение операций над данными. Тем не менее, было доказано, что лямбда исчисление эквивалентно машине Тьюринга. В нём можно делать всё то же, что возможно в императивных языках. Как же нам достичь тех же результатов?\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nОказывается, что функциональные программы могут хранить состояние, только они не используют для этого переменные. Они используют функции. Состояние хранится в параметрах функции, в стеке. Если хотите сохранить состояние, чтобы потом изменить его через время, то нужно написать рекурсивную функцию. Например, давайте напишем программу, которая переворачивает Java строку. Не забудьте, что все переменные объявляются как \u003Ccode\u003Efinal\u003C\u002Fcode\u003E \u003Ca name=\"ref_5_up\"\u003E\u003C\u002Fa\u003E\u003Csup\u003E\u003Ca href=\"#ref_5_down\"\u003E[5]\u003C\u002Fa\u003E\u003C\u002Fsup\u003E.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"java\"\u003EString reverse(String arg) {\n    if(arg.length == 0) {\n        return arg;\n    }\n    else {\n        return reverse(arg.substring(1, arg.length)) + arg.substring(0, 1);\n    }\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nЭта функция довольно медленная, потому что она повторно вызывает сама себя \u003Ca name=\"ref_6_up\"\u003E\u003C\u002Fa\u003E\u003Csup\u003E\u003Ca href=\"#ref_6_down\"\u003E[6]\u003C\u002Fa\u003E\u003C\u002Fsup\u003E. Здесь возможна утечка памяти, так как множество раз создаются временные объекты. Но это функциональный стиль. Вам может показать странным, как люди могут так программировать. Ну, я как раз собирался вам рассказать.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ch2\u003EПреимущества функционального программирования\u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\r\nВы, наверное, думаете, что я не смогу привести доводы в оправдание монструозной функции выше. Когда я только начинал изучать функциональное программирование, я тоже так думал. Я ошибался. Есть очень хорошие аргументы в пользу такого стиля. Некоторые из них субъективные. Например, программисты заявляют, что функциональные программы проще понять. Я не буду приводить таких аргументов, потому что всем известно, что лёгкость понимания — это очень субъективная вещь. К счастью для меня, есть ещё куча объективных аргументов.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ch2\u003EUnit тестирование\u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\r\nТак как в ФП каждый символ является неизменяемым, то функции не имеют побочных действий. Вы не можете менять значения переменных, к тому же функция не может поменять значение вне своей области видимости, и тем самым повлиять на другие функции (как это может случится с полями класса или глобальными переменными). Это означает, что единственный результат выполнения функции — это возвращаемое значение. А единственное, что может повлиять на возвращаемое значение — это аргументы, передаваемые в функцию.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nВот она, голубая мечта unit-тестеров. Можно протестировать каждую функцию в программе используя только нужные аргументы. Нет необходимости вызывать функции в правильном порядке или воссоздавать правильное внешнее состояние. Всё что вам нужно, это передать аргументы, которые соответствуют граничным случаям. Если все функции в вашей программе проходят Unit-тесты, то вы можете быть намного более уверены в качестве вашего ПО, чем в случае императивных языков программирования. В Java или C++ проверки возвращаемого значения не достаточно — функция может поменять внешнее состояние, которое тоже подлежит проверке. В ФП такой проблемы нет.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ch2\u003EОтладка\u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\r\nЕсли функциональная программа ведёт себя не так, как вы ожидаете, то отладка — это пара пустяков. Вы всегда можете воспроизвести проблему, потому что ошибка в функции не зависит от постороннего кода, который выполнялся ранее. В императивной программе ошибка проявляется только на некоторое время. Вам придется пройти через ряд шагов, не относящихся к багу, из-за того, что работа функции зависит от внешнего состояния и побочных эффектов других функций. В ФП ситуация намного проще — если возвращаемое значение неправильное, то оно всегда будет неправильным, не зависимо от того, какие куски кода выполнялись прежде.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nКак только вы воспроизведёте ошибку, найти её источник — тривиальная задача. Это даже приятно. Как только вы остановите выполнение программы, перед вами будет весь стек вызовов. Вы можете просмотреть аргументы вызова каждой функции, прямо как в императивном языке. С тем отличием, что в императивной программе этого не достаточно, ведь функции зависят от значений полей, глобальных переменных и состояний других классов. Функция в ФП зависит только от своих аргументов, и эта информация оказывается прямо у вас перед глазами! Даже больше, в императивной программе проверки возвращаемого значения не достаточно для того, чтобы сказать, правильно ли ведёт себя кусок кода. Вам придётся выследить десятки объектов за пределами функции, чтобы удостовериться, что всё работает правильно. В функциональном программировании всё, что нужно сделать — это взглянуть на возвращаемое значение!\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nПроходясь по стеку, вы обращаете внимание на передаваемые аргументы и возвращаемые значения. Как только возвращаемое значение отклоняется от нормы, вы углубляетесь в функцию и двигаетесь дальше. Так повторяется несколько раз пока вы не найдёте источник ошибки!\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ch2\u003EМногопоточность\u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\r\nФункциональная программа сразу готова к распараллеливанию без каких-либо изменений. Вам не придётся задумываться о deadlock-ах или состояниях гонки (race conditions) потому что вам не нужны блокировки! Ни один кусочек данных в функциональной программе не меняется дважды одним и тем же потоком или разными. Это означает, что вы можете легко добавить потоков к вашей программе даже не задумываясь при этом о проблемах, присущих императивным языкам.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nЕсли дела обстоят подобным образом, то почему так редко функциональные языки программирования используются в многопоточных приложениях? На самом деле чаще, чем вы думаете. Компания Ericsson разработала функциональный язык под названием \u003Ca href=\"http:\u002F\u002Fwww.erlang.org\u002F\"\u003EErlang\u003C\u002Fa\u003E для использования на отказоустойчивых и масштабируемых телекоммуникационных коммутаторах. Многие отметили преимущества Erlang-а и стали его \u003Ca href=\"http:\u002F\u002Fwww.erlang.org\u002Ffaq\u002Ffaq.html#AEN50\"\u003Eиспользовать\u003C\u002Fa\u003E. Мы говорим о телекоммуникациях и системах контроля трафика, которые далеко не так просто масштабируются, как типичные системы, разработанные на Wall Street. Вообще-то, системы написанные на Erlang, не такие масштабируемые и надёжные, как Java системы. Erlang системы просто сверхнадёжные.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nНа этом история многопоточности не заканчивается. Если вы пишете по сути однопоточное приложение, то компилятор всё равно может оптимизировать функциональную программу так, чтобы она использовала несколько CPU. Посмотрим на следующий кусок кода.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"java\"\u003EString s1 = somewhatLongOperation1();\nString s2 = somewhatLongOperation2();\nString s3 = concatenate(s1, s2);\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nКомпилятор функционального языка может проанализировать код, классифицировать функции, которые создают строки \u003Ccode\u003Es1\u003C\u002Fcode\u003E и \u003Ccode\u003Es2\u003C\u002Fcode\u003E, как функции потребляющие много времени, и запустить их параллельно. Это невозможно сделать в императивном языке, потому что каждая функция может изменять внешнее состояние и код, идущий непосредственно после вызова, может зависеть от неё. В ФП автоматический анализ функций и поиск подходящих кандидатов для распараллеливания — это тривиальнейшая задача, как автоматический \u003Ccode\u003Einline\u003C\u002Fcode\u003E! В этом смысле функциональный стиль программирования соответствует требованиям завтрашнего дня. Разработчики железа уже не могут заставить CPU работать быстрее. Вместо этого они наращивают количество ядер и заявляют о четырёхкратном увеличении скорости многопоточных вычислений. Конечно они очень вовремя забывают сказать, что ваш новый процессор покажет прирост только в программах, разработанных с учётом распараллеливания. Среди императивного ПО таких очень мало. Зато 100% функциональных программ готовы к многопоточности из коробки.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ch2\u003EРазвёртывание по горячему\u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\r\nВ старые времена для установки обновлений Windows приходилось перезагружать компьютер. Много раз. После установки новой версии медиа проигрывателя. В Windows XP произошли значительные изменения, но ситуация всё ещё далека от идеальной (сегодня я запустил Windows Update на работе и теперь надоедливое напоминание не оставит меня в покое, пока не перезагружусь). В Unix системах модель обновления была получше. Для установки обновлений приходилось останавливать некоторые компоненты, но не всю ОС. Хотя ситуация выглядит лучше, но для большого класса серверных приложений это всё ещё не приемлемо. Телекоммуникационные системы должны быть включены 100% времени, ведь если из-за обновления человек не сможет вызвать скорую, то жизни могут быть потеряны. Фирмы с Wall Streets тоже не желают останавливать сервера на выходных, чтобы установить обновления.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nВ идеале нужно обновить все нужные участки кода не останавливая систему в принципе. В императивном мире это невозможно [пер. в Smalltalk-е очень даже возможно]. Представьте себе выгрузку Java класса на лету и перезагрузка новой версии. Если бы мы так сделали, то все экземпляры класса стали бы нерабочими, потому что потерялось бы состояние, которое они хранили. Нам пришлось бы писать хитрый код, для контроля версий. Пришлось бы серриализовать все созданные экземпляры класса, потом уничтожить их, создать экземпляры нового класса, попытаться загрузить серриализованные данные в надежде, что миграция пройдёт нормально и новые экземпляры будут валидными. И кроме того, миграционный код необходимо писать каждый раз вручную. И ещё миграционный код должен сохранять ссылки между объектами. В теории ещё куда ни шло, но на практике это никогда не заработает.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nВ функциональной программе всё состояние хранится в стеке в виде аргументов функций. Это позволяет значительно упростить развёртывание по горячему! По сути всё что нужно сделать — это вычислить разницу между кодом на рабочем сервере и новой версией, и установить изменения в коде. Остальное будет сделано языковыми инструментами автоматически! Если вы думаете, что это научная фантастика, то дважды подумайте. Инженеры, имеющие дело с Erlang, годами \u003Ca href=\"http:\u002F\u002Fwww.erlang.org\u002Fdoc\u002Freference_manual\u002Fcode_loading.html#12.3\"\u003Eобновляют\u003C\u002Fa\u003E свои системы без остановки их работы.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ch2\u003EДоказательные вычисления и оптимизация (Machine Assisted Proofs and Optimizations)\u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\r\nЕще одно интересное свойство функциональных языков программирования состоит в том, что их можно изучать с математической точки зрения. Так как функциональный язык — это реализация формальной системы, то все математические операции используемые на бумаге, могут быть применены и к функциональным программам. Компилятор, например, может конвертировать участок кода в эквивалентный, но более эффективный кусок, при этом математически обосновав их эквивалентность \u003Ca name=\"ref_7_up\"\u003E\u003C\u002Fa\u003E\u003Csup\u003E\u003Ca href=\"#ref_7_down\"\u003E[7]\u003C\u002Fa\u003E\u003C\u002Fsup\u003E. Реляционные базы данных годами производят такие оптимизации. Ничто не мешает использовать аналогичные приёмы в обычных программах.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nДополнительно вы можете использовать математический аппарат, чтобы доказать корректность участков ваших программ. При желании можно написать инструменты, которые анализируют код и автоматически создают Unit-тесты для граничных случаев! Такая функциональность бесценна для сверхнадёжных систем (rock solid systems). При разработке систем контроля кардиостимуляторов или управления воздушным трафиком такие инструменты просто необходимы. Если же ваши разработки не находятся в сфере критически важных приложений, то инструменты автоматической проверки всё равно дадут вам гигантское преимущество перед вашими конкурентами.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ch2\u003EФункции высшего порядка\u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\r\nПомните, когда я говорил о преимуществах ФП, я отметил, что «всё выглядит красиво, но бесполезно, если мне придётся писать на корявом языке, в котором всё \u003Ccode\u003Efinal\u003C\u002Fcode\u003E». Это было заблуждением. Использование \u003Ccode\u003Efinal\u003C\u002Fcode\u003E повсеместно выглядит коряво только в императивных языках программирования, таких как Java. Функциональные языки программирования оперируют другими видами абстракций, такими, что вы забудете о том, что когда-то любили менять переменные. Один из таких инструментов — это функции высшего порядка.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nВ ФП функция — это не тоже самое, что функция в Java или C. Это надмножество — они могут тоже самое, что Java функции и даже больше. Пусть у нас есть функция на C:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"java\"\u003Eint add(int i, int j) {\n    return i + j;\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nВ ФП это не тоже самое, что обычная C функция. Давайте расширим наш Java компилятор, чтобы он поддерживал такую запись. Компилятор должен превратить объявление функции в следующий Java код (не забывайте, что везде присутствует неявный \u003Ccode\u003Efinal\u003C\u002Fcode\u003E):\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"java\"\u003Eclass add_function_t {\n    int add(int i, int j) {\n        return i + j;\n    }\n}\n\nadd_function_t add = new add_function_t();\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nСимвол \u003Ccode\u003Eadd\u003C\u002Fcode\u003E не совсем функция. Это маленький класс с одним методом. Теперь мы можем передавать \u003Ccode\u003Eadd\u003C\u002Fcode\u003E в качестве аргумента в другие функции. Мы можем записать его в другой символ. Мы можем создавать экземпляры \u003Ccode\u003Eadd_function_t\u003C\u002Fcode\u003E в runtime и они будут уничтожены сборщиком мусора, если станут ненужными. Функции становятся базовыми объектами, как числа и строки. Функции, которые оперируют функциями (принимают их в качестве аргументов) называются функциями высшего порядка. Пусть это вас не пугает. Понятие функций высшего порядка почти не отличается от понятия Java классов, которые оперируют друг другом (мы можем передавать классы в другие классы). Мы можем называть их «классы высшего порядка», но никто этим не заморачивается, потому что за Java не стоит строгое академическое сообщество.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nКак и когда нужно использовать функции высшего порядка? Я рад, что вы спросили. Вы пишите свою программу как один большой монолитный кусок кода не заботясь об иерархии классов. Если вы увидите, что какой-то участок кода повторяется в разных места, вы выносите его в отдельную функцию (к счастью в школах еще учат как это делать). Если вы замечаете, что часть логики в вашей функции должна вести себя по разному в некоторых ситуациях, то вы создаёте функцию высшего порядка. Запутались? Вот реальный пример из мой работы.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nПредположим, что у нас есть участок Java кода, который получает сообщение, преобразует его различными способами и передаёт на другой сервер.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"java\"\u003E    void handleMessage(Message msg) {\n        \u002F\u002F ...\n        msg.setClientCode(\"ABCD_123\");\n        \u002F\u002F ...\n        \n        sendMessage(msg);\n    }\n    \n    \u002F\u002F ...\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nТеперь представьте себе, что система поменялась, и теперь нужно распределять сообщения между двумя серверами вместо одного. Всё остаётся неизменным, кроме кода клиента — второй сервер хочет получать этот код в другом формате. Как нам справиться с этой ситуацией? Мы можем проверять, куда должно попасть сообщение, и в зависимости от этого устанавливать правильный код клиента. Например так:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"java\"\u003Eclass MessageHandler {\n    void handleMessage(Message msg) {\n        \u002F\u002F ...\n        if(msg.getDestination().equals(\"server1\") {\n            msg.setClientCode(\"ABCD_123\");\n        } else {\n            msg.setClientCode(\"123_ABC\");\n        }\n        \u002F\u002F ...\n        \n        sendMessage(msg);\n    }\n    \n    \u002F\u002F ...\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nНо такой подход плохо масштабируется. При добавлении новых серверов функция будет расти линейно, и внесение изменений превратится в кошмар. Объектно ориентированный подход заключается в выделении общего суперкласса \u003Ccode\u003EMessageHandler\u003C\u002Fcode\u003E и вынесение логики определения кода клиента в подклассы:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"java\"\u003Eabstract class MessageHandler {\n    void handleMessage(Message msg) {\n        \u002F\u002F ...\n        msg.setClientCode(getClientCode());\n        \u002F\u002F ...\n        \n        sendMessage(msg);\n    }\n    \n    abstract String getClientCode();\n    \n    \u002F\u002F ...\n}\n\n\nclass MessageHandlerOne extends MessageHandler {\n    String getClientCode() {\n        return \"ABCD_123\";\n    }\n}\n\n\nclass MessageHandlerTwo extends MessageHandler {\n    String getClientCode() {\n        return \"123_ABCD\";\n    }\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nТеперь для каждого сервера мы можем создать экземпляр соответствующего класса. Добавление новых сервером становится более удобным. Но для такого небольшого изменения многовато текста. Пришлось создать два новых типа чтобы просто добавить поддержку различного кода клиента! Теперь сделаем тоже самое в нашем языке с поддержкой функций высшего порядка:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"java\"\u003Eclass MessageHandler {\n    void handleMessage(Message msg, Function getClientCode) {\n        \u002F\u002F ...\n        Message msg1 = msg.setClientCode(getClientCode());\n        \u002F\u002F ...\n        \n        sendMessage(msg1);\n    }\n    \n    \u002F\u002F ...\n}\n\n\nString getClientCodeOne() {\n    return \"ABCD_123\";\n}\n\n\nString getClientCodeTwo() {\n    return \"123_ABCD\";\n}\n\n\nMessageHandler handler = new MessageHandler();\nhandler.handleMessage(someMsg, getClientCodeOne);\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nМы не создавали новых типов и не усложняли иерархию классов. Мы просто передали функцию в качестве параметра. Мы достигли того же эффекта, как и в объектно-ориентированном аналоге, только с некоторыми преимуществами. Мы не привязывали себя к какой-либо иерархии классов: мы можем передавать любые другие функции в runtime и менять их в любой момент, сохраняя при этом высокий уровень модульности меньшим количеством кода. По сути компилятор создал объектно-ориентированный «клей» вместо нас! При этом сохраняются все остальные преимущества ФП. Конечно абстракции, предлагаемые функциональными языками на этом не заканчиваются. Функции высшего порядка это только начало\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ch2\u003EКаррирование\u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\r\nБольшинство людей, с которыми я встречаюсь, прочли книгу \u003Ca href=\"http:\u002F\u002Fwww.amazon.com\u002Fgp\u002Fproduct\u002F0201633612\u002F103-9055240-2348603\"\u003E«Паттерны проектирования»\u003C\u002Fa\u003E Банды Четырёх. Любой уважающий себя программист будет говорить, что книга не привязана к какому-либо конкретному языку программирования, а паттерны применимы к разработке ПО в целом. Это благородное заявление. Но к сожалению оно далеко от истины.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nФункциональные языки невероятно выразительны. В функциональном языке вам не понадобятся паттерны проектирования, потому что язык настолько высокоуровневый, что вы легко начнёте программировать в концепциях, которые исключают все известные паттерны программирования. Одним из таких паттернов является Адаптер (чем он отличается от Фасада? Похоже, что кому-то понадобилось наштамповать побольше страниц, чтобы выполнить условия контракта). Этот паттерн оказывается ненужным если в языке есть поддержка каррирования.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nПаттерн Адаптер наиболее часто применяется к «стандартной» единице абстракции в Java — классу. В функциональных языках паттерн применяется к функциям. Паттерн берёт интерфейс и преобразует его в другой интерфейс, согласно определённым требованиям. Вот пример паттерна Адаптер:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"java\"\u003Eint pow(int i, int j);\nint square(int i)\n{\n    return pow(i, 2);\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nЭтот код адаптирует интерфейс функции, возводящей число в произвольную степень, к интерфейсу функции, которая возводит число в квадрат. В аккадемических кругах этот простейший приём называется каррирование (в честь специалиста по логике Хаскелла Карри (Haskell Curry), который провёл ряд математических трюков, чтобы всё это формализовать). Так как в ФП функции используются повсеместно в качестве аргументов, каррирование используется очень часто, чтобы привести функции к интерфейсу, необходимому в том или ином месте. Так как интерфейс функции — это её аргументы, то каррирование используется для уменьшения количества аргументов (как в примере выше).\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nЭтот инструмент является встроенным в функциональные языки. Вам не нужно вручную создавать функцию, которая оборачивает оригинал. Функциональный язык сделает всё за вас. Как обычно давайте расширим наш язык, добавив в него каррирование.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"java\"\u003Esquare = int pow(int i, 2);\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nЭтой строкой мы автоматически создаём функцию возведения в квадрат с одним аргументом. Новая функция будет вызывать функцию \u003Ccode\u003Epow\u003C\u002Fcode\u003E, подставляя 2 в качестве второго аргумента. С точки зрения Java, это будет выглядеть следующим образом:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"java\"\u003Eclass square_function_t {\n    int square(int i) {\n        return pow(i, 2);\n    }\n}\nsquare_function_t square = new square_function_t();\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nКак видите, мы просто написали обёртку над оригинальной функцией. В ФП каррирование как раз и представляет из себя простой и удобный способ создания обёрток. Вы сосредотачиваетесь на задаче, а компилятор пишет необходимый код за вас! Всё очень просто, и происходит каждый раз, когда вы хотите использовать паттерн Адаптер (обёртку).\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ch2\u003EЛенивые вычисления\u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\r\nЛенивые (или отложенные) вычисления — это интересная техника, которая становится возможной как только вы усвоите функциональную философию. Мы уже встречали следующий кусок кода, когда говорили о многопоточности:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"java\"\u003EString s1 = somewhatLongOperation1();\nString s2 = somewhatLongOperation2();\nString s3 = concatenate(s1, s2);\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nВ императивных языках программирования очерёдность вычисления не вызывает никаких вопросов. Поскольку каждая функция может повлиять или зависеть от внешнего состояния, то необходимо соблюдать чёткую очерёдность вызовов: сначала \u003Ccode\u003EsomewhatLongOperation1\u003C\u002Fcode\u003E, затем \u003Ccode\u003EsomewhatLongOperation2\u003C\u002Fcode\u003E, и \u003Ccode\u003Econcatenate\u003C\u002Fcode\u003E в конце. Но не всё так просто в функциональных языках.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nКак мы уже видели ранее \u003Ccode\u003EsomewhatLongOperation1\u003C\u002Fcode\u003E и \u003Ccode\u003EsomewhatLongOperation2\u003C\u002Fcode\u003E могут быть запущены одновременно, потому что функции гарантированно не влияют и не зависят от глобального состояния. Но что, если мы не хотим выполнять их одновременно, нужно ли вызывать их последовательно? Ответ — нет. Эти вычисления должны быть запущены, только если какая-либо другая функция зависит от \u003Ccode\u003Es1\u003C\u002Fcode\u003E и \u003Ccode\u003Es2\u003C\u002Fcode\u003E. Нам даже не нужно выполнять их до тех пор, пока они понадобятся внутри \u003Ccode\u003Econcatenate\u003C\u002Fcode\u003E. Если вместо \u003Ccode\u003Econcatenate\u003C\u002Fcode\u003E мы подставим функцию, которая в зависимости от условия использует один аргумент из двух, то второй аргумент можно даже не вычислять! \u003Ca href=\"http:\u002F\u002Fwww.haskell.org\u002F\"\u003EHaskell\u003C\u002Fa\u003E — это пример языка с отложенными вычислениями. В Haskell отсутствует гарантия какой-либо очередности вызовов (вообще!), потому что Haskell выполняет код по мере необходимости.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nЛенивые вычисления обладают рядом достоинств как и некоторыми недостатками. В следующем разделе мы обсудим достоинства и я объясню как уживаться с недостатками.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ch2\u003EОптимизация\u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\r\nЛенивые вычисления обеспечивают громадный потенциал для оптимизаций. Ленивый компилятор рассматривает код в точности как математик изучает алгебраические выражения — он может отменять некоторые вещи, отменять выполнение тех или иных участков кода, менять очерёдность вызовов для большей эффективности, даже располагать код таким образом, чтобы уменьшить количество ошибок, при этом гарантируя целостность программы. Это самое большое преимущество при описании программы строгими формальными примитивами — код подчиняется математическим законам и может быть изучен математическими методами.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ch2\u003EАбстрагирование структур управления\u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\r\nЛенивые вычисления обеспечивают настолько высокий уровень абстракций, что становятся возможными удивительные вещи. Например, представим себе реализацию следующей управляющей структуры:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"java\"\u003Eunless(stock.isEuropean()) {\n    sendToSEC(stock);\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nМы хотим, чтобы функция \u003Ccode\u003EsendToSEC\u003C\u002Fcode\u003E выполнялась только если фонд (stock) не европейский. Как можно реализовать \u003Ccode\u003Eunless\u003C\u002Fcode\u003E? Без ленивый вычислений нам бы понадобилась система макросов, но в языках, подобных Haskell, это не обязательно. Мы можем объявить \u003Ccode\u003Eunless\u003C\u002Fcode\u003E в виде функции!\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"java\"\u003Evoid unless(boolean condition, List code) {\n    if(!condition)\n        code;\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nЗаметьте, что \u003Ccode\u003Ecode\u003C\u002Fcode\u003E не будет выполняться, если \u003Ccode\u003Econdition == true\u003C\u002Fcode\u003E. В строгих языках такое поведение невозможно повторить, так как аргументы будут вычислены прежде, чем \u003Ccode\u003Eunless\u003C\u002Fcode\u003E будет вызвана.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ch2\u003EБесконечные структуры данных\u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\r\nЛенивые языки позволяют создавать бесконечные структуры данных, создание которых в строгих языках гораздо сложнее [пер. — только не в Python]. Например представьте себе последовательность Фибоначи. Очевидно, что мы не можем вычислить бесконечный список за конечное время и при этом сохранить его в памяти. В строгих языках, таких как Java, мы просто написали бы функцию, которая возвращает произвольный член последовательности. В языках подобных Haskell мы можем абстрагироваться и просто объявить бесконечный список чисел Фибоначи. Так как язык ленивый, то будут вычислены лишь необходимые части списка, которые реально используются в программе. Это позволяет абстрагироваться от большого числа проблем и посмотреть на них с более высокого уровня (например можно использовать функции обработки списков на бесконечных последовательностях).\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ch2\u003EНедостатки\u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\r\nКонечно бесплатный сыр бывает только в мышеловке. Ленивые вычисления тянут за собой ряд недостатков. В основном это недостатки от лени. В реальности очень часто нужен прямой порядок вычислений. Возьмём, например, следующий код:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"java\"\u003ESystem.out.println(\"Please enter your name: \");\nSystem.in.readLine();\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nВ ленивом языке никто не гарантирует, что первая строка выполнится раньше второй! Это означает, что мы не можем делать ввод-вывод, не можем нормально использовать нативные функции (ведь их нужно вызывать в определённом порядке, чтобы учитывать их побочные эффекты), и не можем взаимодействовать с внешним миром! Если мы введём механизм для упорядочивания выполнения кода, то потеряем преимущество математической строгости кода (а следом потеряем все плюшки функционального программирования). К счастью ещё не всё потеряно. Математики взялись за работу и придумали несколько приёмов для того, чтобы убедится в правильном порядке выполняемых инструкций не потеряв функционального духа. Мы получили лучшее от двух миров! Такие приёмы включают в себя продолжения (continuation), монады (monads) и однозначная типизация (uniqueness typing). В данной статье мы поработаем с продолжениями, а монады и однозначную типизацию отложим до следующего раза. Занятно, что продолжения очень полезная штука, которая используется не только для задания строгого порядка вычислений. Об этом мы тоже поговорим.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ch2\u003EПродолжения\u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\r\nПродолжения в программировании играют такую же роль, как «Код да Винчи» в человеческой истории: удивительное разоблачение величайшей тайны человечества. Ну, может не совсем так, но они точно срывают покровы, как в своё время вы научились брать корень из -1.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nКогда мы рассматривали функции, мы изучили лишь половину правды, ведь мы исходили из предположения, что функция возвращает значение в вызывающую её функцию. В этом смысле продолжение — это обобщение функций. Функция не обязательно должна возвращать управление в то место, откуда её вызвали, а может возвращать в любое место программы. «Продолжение» — это параметр, который мы можем передать в функцию, чтобы указать точку возврата. Звучит намного страшнее, чем есть на самом деле. Давайте взглянем на следующий код:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"java\"\u003Eint i = add(5, 10);\nint j = square(i);\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nФункция \u003Ccode\u003Eadd\u003C\u002Fcode\u003E возвращает число 15, которое записывается в \u003Ccode\u003Ei\u003C\u002Fcode\u003E, в том месте, где функция и была вызвана. Затем значение \u003Ccode\u003Ei\u003C\u002Fcode\u003E используется при вызове \u003Ccode\u003Esquare\u003C\u002Fcode\u003E. Заметьте, что ленивый компилятор не может поменять очередность вычислений, ведь вторая строка зависит от результата первой. Мы можем переписать этот код с использованием Стиль Передачи Продолжения (Continuation Passing Style или CPS), когда \u003Ccode\u003Eadd\u003C\u002Fcode\u003E возвращает значение в функцию \u003Ccode\u003Esquare\u003C\u002Fcode\u003E.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"java\"\u003Eint j = add(5, 10, square);\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nВ таком случае \u003Ccode\u003Eadd\u003C\u002Fcode\u003E получает дополнительный аргумент — функцию, которая будет вызвана после того, как \u003Ccode\u003Eadd\u003C\u002Fcode\u003E закончит работать. В обоих примерах \u003Ccode\u003Ej\u003C\u002Fcode\u003E будет равен 225.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nВ этом и заключается первый приём, позволяющий задать порядок выполнения двух выражений. Вернёмся к нашему примеру с вводом-выводом\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"java\"\u003ESystem.out.println(\"Please enter your name: \");\nSystem.in.readLine();\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nЭти две строки не зависят друг от друга, и компилятор волен поменять их порядок по своему хотению. Но если мы перепишем в CPS, то тем самым добавим нужную зависимость, и компилятору придётся проводить вычисления одно за другим!\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"java\"\u003ESystem.out.println(\"Please enter your name: \", System.in.readLine);\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nВ таком случае \u003Ccode\u003Eprintln\u003C\u002Fcode\u003E должен будет вызвать \u003Ccode\u003EreadLine\u003C\u002Fcode\u003E, передав ему свой результат, и вернуть результат \u003Ccode\u003EreadLine\u003C\u002Fcode\u003E в конце. В таком виде мы можем быть уверены, что эти функции будут вызваны по очереди, и что \u003Ccode\u003EreadLine\u003C\u002Fcode\u003E вообще вызовется (ведь компилятор ожидает получить результат последней операции). В случае Java \u003Ccode\u003Eprintln\u003C\u002Fcode\u003E возвращает \u003Ccode\u003Evoid\u003C\u002Fcode\u003E. Но если бы возвращалось какое-либо абстрактное значение (которое может служить аргументом \u003Ccode\u003EreadLine\u003C\u002Fcode\u003E), то это решило бы нашу проблему! Конечно выстраивание таких цепочек функций сильно ухудшает читаемость кода, но с этим можно бороться. Мы можем добавить в наш язык синтаксических плюшек, которые позволят нам писать выражения как обычно, а компилятор автоматически выстраивал бы вычисления в цепочки. Теперь мы можем проводить вычисления в любом порядке, не потеряв при этом достоинств ФП (включая возможность исследовать программу математическими методами)! Если вас это сбивает с толку, то помните, что функции — это всего лишь экземпляры класса с единственным членом. Перепишите наш пример так, чтобы \u003Ccode\u003Eprintln\u003C\u002Fcode\u003E и \u003Ccode\u003EreadLine\u003C\u002Fcode\u003E были экземплярами классов, так вам станет понятней.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nНо на этом польза продолжений не заканчивается. Мы можем написать всю программу целиком используя CPS, чтобы каждая функция вызывалась с дополнительным параметром, продолжением, в которое передаётся результат. В принципе любую программу можно перевести на CPS, если воспринимать каждую функцию как частный случай продолжений. Такое преобразование можно произвести автоматически (в действительности многие компиляторы так и делают).\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nКак только мы переведём программу к CPS виду, становится ясно, что у каждой инструкции есть продолжение, функция в которую будет передаваться результат, что в обычной программе было бы точкой вызова. Возьмём любую инструкцию из последнего примера, например \u003Ccode\u003Eadd(5,10)\u003C\u002Fcode\u003E. В программе, написанной в CPS виде, понятно что будет являться продолжением — это функция, которую \u003Ccode\u003Eadd\u003C\u002Fcode\u003E вызовет по окончанию работы. Но что будет продолжением в случае не-CPS программы? Мы, конечно, можем конвертировать программу в CPS, но нужно ли это?\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nОказывается, что в этом нет необходимости. Посмотрите внимательно на наше CPS преобразование. Если вы начнёте писать компилятор для него, то обнаружите, что для CPS версии не нужен стек! Функции никогда ничего не возвращают, в традиционном понимании слова «return», они просто вызывают другую функцию, подставляя результат вычислений. Отпадает необходимость проталкивать (push) аргументы в стек перед каждым вызовом, а потом извлекать (pop) их обратно. Мы можем просто хранить аргументы в каком-либо фиксированном участке памяти и использовать \u003Ccode\u003Ejump\u003C\u002Fcode\u003E вместо обычного вызова. Нам нет нужны хранить первоначальные аргументы, ведь они больше никогда не понадобятся, ведь функции ничего не возвращают!\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nТаким образом, программы в CPS стиле не нуждаются в стеке, но содержат дополнительный аргумент, в виде функции, которую нужно вызвать. Программы в не-CPS стиле лишены дополнительного аргумента, но используют стек. Что же хранится в стеке? Просто аргументы и указатель на участок памяти, куда должна вернуться функция. Ну как, вы уже догадались? В стеке храниться информация о продолжениях! Указатель на точку возврата в стеке — это то же самое, что и функция, которую нужно вызвать, в CPS программах! Чтобы выяснить, какое продолжение у \u003Ccode\u003Eadd(5,10)\u003C\u002Fcode\u003E, достаточно взять из стека точку возврата.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nЭто было не трудно. Продолжение и указатель на точку возврата — это действительно одно и то же, только продолжение указывается явно, и по этому оно может отличаться от того места, где функция была вызвана. Если вы помните, что продолжение — это функция, а функция в нашем языке компилируется в экземпляр класса, то поймёте, что указатель на точку возврата в стеке и указатель на продолжение — это в действительности одно и то же, ведь наша функция (как экземпляр класса) — это всего лишь указатель. А значит, что в любой момент времени в вашей программы вы можете запросить текущее продолжение (по сути информацию из стека).\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nХорошо, теперь мы уяснили, что же такое текущее продолжение. Что это значит? Если мы возьмём текущее продолжение и сохраним его где-нибудь, мы тем самым сохраним текущее состояние программы — заморозим её. Это похоже на режим гибернации ОС. В объекте продолжения хранится информация, необходимая для возобновления выполнения программы с той точки, когда был запрошен объект продолжения. Операционная система постоянно так делает с вашими программами, когда переключает контекст между потоками. Разница лишь в том, что всё находится под контролем ОС. Если вы запросите объект продолжения (в Scheme это делается вызовом функции \u003Ccode\u003Ecall-with-current-continuation\u003C\u002Fcode\u003E), то вы получите объект с текущим продолжением — стеком (или в случае CPS — функцией следующего вызова). Вы можете сохранить этот объект в переменную (или даже на диск). Если вы решите «перезапустить» программу с этим продолжением, то состояние вашей программы «преобразуется» к состоянию на момент взятия объекта продолжения. Это то же самое, как переключение к приостановленному потоку, или пробуждение ОС после гибернации. С тем исключением, что вы можете проделывать это много раз подряд. После пробуждения ОС информация о гибернации уничтожается. Если этого не делать, то можно было бы восстанавливать состояние ОС с одной и той же точки. Это почти как путешествие по времени. С продолжениями вы можете себе такое позволить!\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nВ каких ситуациях продолжения будут полезны? Обычно если вы пытаетесь эмулировать состояние в системах лишенных такового по сути. Отличное применение продолжения нашли в Web-приложениях (например во фреймворке \u003Ca href=\"http:\u002F\u002Fwww.seaside.st\u002F\"\u003ESeaside\u003C\u002Fa\u003E для языка Smalltalk). ASP.NET от Microsoft прикладывает огромные усилия, чтобы сохранять состояние между запросами, и облегчить вам жизнь. Если бы C# поддерживал продолжения, то сложность ASP.NET можно было бы уменьшить в два раза — достаточно было бы сохранять продолжение и восстанавливать его при следующем запросе. С точки зрения Web-программиста не было бы ни единого разрыва — программа продолжала бы свою работу со следующей строки! Продолжения — невероятно полезная абстракция для решения некоторых проблем. Учитывая то, что всё больше и больше традиционных толстых клиентов перемещаются в Web, важность продолжений будет со временем только расти.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ch2\u003EСопоставление с образцом (Pattern matching)\u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\r\nСопоставление с образцом не такая уж новая или инновационная идея. На самом деле она имеет слабое отношение к функциональному программированию. Единственная причина, по которой его часто связывают с ФП, это то, что с некоторых пор в функциональных языках есть сопоставление с образцом, а в императивных — нет.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nДавайте начнём наше знакомство с Pattern matching следующим примером. Вот функция вычисления чисел Фибоначи на Java:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"java\"\u003Eint fib(int n) {\n    if(n == 0) return 1;\n    if(n == 1) return 1;\n        \n    return fib(n - 2) + fib(n - 1);\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nА вот пример на Java-подобном языке с поддержкой Pattern matching-а\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"java\"\u003Eint fib(0) {\n    return 1;\n}\nint fib(1) {\n    return 1;\n}\nint fib(int n) {\n    return fib(n - 2) + fib(n - 1);\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nВ чём разница? Компилятор реализует ветвление за нас.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nПодумаешь, велика важность! Действительно важность не велика. Было подмечено, что большое количество функций содержат сложные \u003Ccode\u003Eswitch\u003C\u002Fcode\u003E конструкции (это отчасти верно для функциональных программ), и было принято решение выделить этот момент. Определение функции разбивается на несколько вариантов, и устанавливается паттерн на месте аргументов функции (это напоминает перегрузку методов). Когда происходит вызов функции, компилятор на лету сравнивает аргументы со всеми определениями и выбирает наиболее подходящий. Обычно выбор падает на самое специализированное определение функции. Например \u003Ccode\u003Eint fib(int n)\u003C\u002Fcode\u003E может быть вызвана при \u003Ccode\u003En\u003C\u002Fcode\u003E равном 1, но не будет, ведь \u003Ccode\u003Eint fib(1)\u003C\u002Fcode\u003E — более специализированное определение.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nСопоставление с образцом обычно выглядит сложнее, чем в нашем примере. Например сложная система Pattern matching позволяет писать следующий код:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"java\"\u003Eint f(int n &lt; 10) { ... }\nint f(int n) { ... }\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nКогда сопоставление с образцом может быть полезно? Список таких случаев на удивление очень большой! Каждый раз, когда вы используете сложные конструкции вложенных \u003Ccode\u003Eif\u003C\u002Fcode\u003E, pattern matching может справиться лучше с меньшим количеством кода. В голову приходит хороший пример с функцией \u003Ccode\u003EWndProc\u003C\u002Fcode\u003E, которая реализуется в каждой Win32 программе (даже если она спрятана от программиста за высоким забором абстракций). Обычно сопоставление с образцом может даже проверять содержимое коллекций. Например, если вы передаёте массив в функцию, то вы можете отбирать все массивы, у которых первый элемент равен 1, а третий элемент больше 3.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nЕщё одним преимуществом Pattern matching является то, что в случае внесения изменений вам не придётся копаться в одной огромной функции. Вам достаточно будет добавить (или изменить) некоторые определения функций. Тем самым мы избавляется от целого пласта паттернов из знаменитой книги Банды Четырёх. Чем сложнее и ветвистее условия, тем полезнее будет использовать Pattern matching. Как только вы начнёте их использовать, то удивитесь, как вы могли раньше без них обходится.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ch2\u003EЗамыкания\u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\r\nДо сих пор мы обсуждали особенности ФП в контексте «чисто» функциональных языков — языков, которые являются реализацией лямбда исчисления и не содержат особенностей, противоречащих формальной системе Чёрча. Тем не менее, многие черты функциональных языков используются за пределами лямбда исчисления. Хотя реализация аксиоматической системы интересна с точки зрения программирования в терминах математических выражений, это не всегда может быть применимо на практике. Многие языки предпочитают использовать элементы функциональных языков не придерживаясь строгой функциональной доктрины. Некоторые такие языки (например Common Lisp) не требуют от переменных быть \u003Ccode\u003Efinal\u003C\u002Fcode\u003E — их значения можно менять. Они даже не требуют, чтобы функции зависели только от своих аргументов — функциям дозволенно обращаться к состоянию за пределом своей области видимости. Но при этом они включают в себя такие особенности, как функции высшего порядка. Передача функции в не-чистом языке немного отличается от аналогичной операции в пределах лямбда исчисления и требует наличия интересной особенности под названием: лексическое замыкание. Давайте взглянем на следующий пример. Помните, что в данном случае переменные не \u003Ccode\u003Efinal\u003C\u002Fcode\u003E и функция может обращаться к переменным за пределом своей области видимости:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"java\"\u003EFunction makePowerFn(int power) {\n   int powerFn(int base) {\n       return pow(base, power);\n   }\n\n\n   return powerFn;\n}\n\n\nFunction square = makePowerFn(2);\nsquare(3); \u002F\u002F returns 9\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nФункция \u003Ccode\u003Emake-power-fn\u003C\u002Fcode\u003E возвращает функцию, которая принимает один аргумент и возводит его в определённую степень. Что произойдёт, когда мы попробуем вычислить \u003Ccode\u003Esquare(3)\u003C\u002Fcode\u003E? Переменная \u003Ccode\u003Epower\u003C\u002Fcode\u003E находится вне области видимости \u003Ccode\u003EpowerFn\u003C\u002Fcode\u003E, потому что \u003Ccode\u003EmakePowerFn\u003C\u002Fcode\u003E уже завершилась, и её стек уничтожен. Как же тогда работает \u003Ccode\u003Esquare\u003C\u002Fcode\u003E? Язык должен каким-либо образом сохранить значение \u003Ccode\u003Epower\u003C\u002Fcode\u003E, чтобы функция \u003Ccode\u003Esquare\u003C\u002Fcode\u003E могла работать. А что если мы создадим ещё одну функцию \u003Ccode\u003Ecube\u003C\u002Fcode\u003E, которая возводит число в третью степень? Язык должен будет сохранять два значения \u003Ccode\u003Epower\u003C\u002Fcode\u003E для каждой созданной в \u003Ccode\u003Emake-power-fn\u003C\u002Fcode\u003E функции. Феномен хранения этих значений и называется замыканием. Замыкание не только сохраняет аргументы верхней функции. Например замыкание может выглядеть следующим образом:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"java\"\u003EFunction makeIncrementer() {\n   int n = 0;\n\n\n   int increment() {\n       return ++n;\n   }\n}\n\n\nFunction inc1 = makeIncrementer();\nFunction inc2 = makeIncrementer();\n\n\ninc1(); \u002F\u002F returns 1;\ninc1(); \u002F\u002F returns 2;\ninc1(); \u002F\u002F returns 3;\ninc2(); \u002F\u002F returns 1;\ninc2(); \u002F\u002F returns 2;\ninc2(); \u002F\u002F returns 3;\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nВ процессе выполнения значения \u003Ccode\u003En\u003C\u002Fcode\u003E сохраняются, и счётчики имеют доступ к ним. Более того у каждого счётчика своя копия \u003Ccode\u003En\u003C\u002Fcode\u003E, не смотря на то, что они должны были исчезнуть после того, как функция \u003Ccode\u003EmakeIncrementer\u003C\u002Fcode\u003E отработает. Как же компилятор умудряется это скомпилировать? Что происходит за кулисами замыканий? К счастью у нас есть волшебный пропуск.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nВсё сделано достаточно логично. С первого взгляда ясно, что локальные переменные больше не подчиняются правилам области видимости и их время жизни не определено. Очевидно, что они больше не хранятся в стеке — их нужно держать в куче (heap) \u003Ca name=\"ref_8_up\"\u003E\u003C\u002Fa\u003E\u003Csup\u003E\u003Ca href=\"#ref_8_down\"\u003E[8]\u003C\u002Fa\u003E\u003C\u002Fsup\u003E. Замыкание, следовательно, сделано как обычная функция, которую мы обсуждали ранее, за исключением того, что в нём есть дополнительная ссылка на окружающие переменные:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"java\"\u003Eclass some_function_t {\n   SymbolTable parentScope;\n   \n   \u002F\u002F ...\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nЕсли замыкание обращается к переменной, которой нет в локальной области видимости, тогда оно принимает во внимание родительскую область. Вот и всё! Замыкание связывает функциональный мир с миром ООП. Каждый раз, когда вы создаёте класс, который хранит некоторое состояние, и передаёте его куда-то, вспомните про замыкания. Замыкание — это всего лишь объект, который создаёт «атрибуты» на лету, забирая их из области видимости, чтобы вам не пришлось делать это самим.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ch2\u003EЧто теперь?\u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\r\nЭта статья проходится лишь по верхушке айсберга Функционального Программирования. Вы можете копнуть глубже и увидеть нечто действительно большое, а в нашем случае ещё и хорошее. В будущем я планирую написать о теории категорий, монадах, функциональных структурах данных, системе типов в функциональных языках, функциональной многопоточности, функциональных базах данных, и ещё о многих вещах. Если у меня получится написать (и изучить в процессе) хотя бы о половине из этих тем, моя жизнь пройдёт не зря. А пока, \u003Ca href=\"http:\u002F\u002Fwww.google.com\"\u003EGoogle\u003C\u002Fa\u003E — ваш верный друг.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ch2\u003EКомментарии?\u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\r\nЕсли у вас есть вопросы, комментарии или предложения, черканите записочку на адрес coffeemug [собачка] gmail.com. Буду рад любым вашим отзывам.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ch2\u003EПримечания\u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\r\n\u003Ca name=\"ref_1_down\"\u003E\u003C\u002Fa\u003E\u003Ca href=\"#ref_1_up\"\u003E[1]\u003C\u002Fa\u003E. Когда я искал работу осенью 2005 года, я частенько задавал этот вопрос. Было очень занятно видеть пустой взгляд вместо ответа. Я-то думал, что за зарплату $300,000 у этих людей должно быть хорошее понимание всех доступных инструментов.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ca name=\"ref_2_down\"\u003E\u003C\u002Fa\u003E\u003Ca href=\"#ref_2_up\"\u003E[2]\u003C\u002Fa\u003E. Этот вопрос неоднозначный. Физики и математики вынуждены признать, что нет ничего предельно ясного во вселенной, что можно было бы описать математически.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ca name=\"ref_3_down\"\u003E\u003C\u002Fa\u003E\u003Ca href=\"#ref_3_up\"\u003E[3]\u003C\u002Fa\u003E. Я ненавидел уроки истории, которые предлагали только сухую хронологию дат, имён и событий. Для меня история — это жизни людей, которые изменили мир. Это те их личные причины, которая стоят за их действиями, и механизмы, которыми они оказывали влияние на миллионы душ. По этой причине исторический раздел этой статьи безнадёжно неполон. Здесь описываются только наиболее значимые люди и события.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ca name=\"ref_4_down\"\u003E\u003C\u002Fa\u003E\u003Ca href=\"#ref_4_up\"\u003E[4]\u003C\u002Fa\u003E. Когда я только начинал изучать функциональное программирование, меня очень нервировал термин «лямбда», потому что я не мог до конца понять, что же он обозначает. В данном контексте лямбда — это функция. А греческая буква используется для удобства математической записи. Каждый раз, когда вы слышите «лямбда» в разговоре о функциональном программировании, переводите это про себя в «функцию».\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ca name=\"ref_5_down\"\u003E\u003C\u002Fa\u003E\u003Ca href=\"#ref_5_up\"\u003E[5]\u003C\u002Fa\u003E. Занимательно, что строки в Java не изменяются. Интересно было бы выяснить причину такого вероломства, но не будем отвлекаться.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ca name=\"ref_6_down\"\u003E\u003C\u002Fa\u003E\u003Ca href=\"#ref_6_up\"\u003E[6]\u003C\u002Fa\u003E. Большинство компиляторов функциональных языков умеют оптимизировать рекурсивные функции превращая их в циклы по мере возможностей. Это называется \u003Ca href=\"http:\u002F\u002Fru.wikipedia.org\u002Fwiki\u002FХвостовая_рекурсия\"\u003Eоптимизация хвостовой рекурсии\u003C\u002Fa\u003E.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ca name=\"ref_7_down\"\u003E\u003C\u002Fa\u003E\u003Ca href=\"#ref_7_up\"\u003E[7]\u003C\u002Fa\u003E. Обратное не всегда верно. Если иногда возможно доказать эквивалентность двух участков кода, но в общем случае это не возможно.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ca name=\"ref_8_down\"\u003E\u003C\u002Fa\u003E\u003Ca href=\"#ref_8_up\"\u003E[8]\u003C\u002Fa\u003E. На самом деле это не медленнее, чем хранить в стеке, поскольку при использовании сборщика мусора выделение памяти занимает O(1) операций.\u003C\u002Fdiv\u003E","tags":[{"titleHtml":"функциональное программирование"},{"titleHtml":"ликбез"},{"titleHtml":"история"}],"metadata":{"stylesUrls":[],"scriptUrls":[],"shareImageUrl":"https:\u002F\u002Fhabr.com\u002Fshare\u002Fpublication\u002F142351\u002F487329d734b8f36abb4dbce73727e353\u002F","shareImageWidth":1200,"shareImageHeight":630,"vkShareImageUrl":"https:\u002F\u002Fhabr.com\u002Fshare\u002Fpublication\u002F142351\u002F487329d734b8f36abb4dbce73727e353\u002F?format=vk","schemaJsonLd":"{\"@context\":\"http:\\\u002F\\\u002Fschema.org\",\"@type\":\"Article\",\"mainEntityOfPage\":{\"@type\":\"WebPage\",\"@id\":\"https:\\\u002F\\\u002Fhabr.com\\\u002Fru\\\u002Fpost\\\u002F142351\\\u002F\"},\"headline\":\"Функциональное программирование для всех\",\"datePublished\":\"2012-04-19T11:45:50+04:00\",\"dateModified\":\"2012-04-23T10:47:00+04:00\",\"author\":{\"@type\":\"Person\",\"name\":\"Щекн-Итрч\"},\"publisher\":{\"@type\":\"Organization\",\"name\":\"Habr\",\"logo\":{\"@type\":\"ImageObject\",\"url\":\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fwebt\\\u002Fa_\\\u002Flk\\\u002F9m\\\u002Fa_lk9mjkccjox-zccjrpfolmkmq.png\"}},\"description\":\"Доброго времени суток. Это статья &mdash; перевод заинтересовавшего меня поста в блоге аспиранта Университета штата Нью-Йорк в Стоуни-Брук. Статья в доступной форме о...\",\"url\":\"https:\\\u002F\\\u002Fhabr.com\\\u002Fru\\\u002Fpost\\\u002F142351\\\u002F#post-content-body\",\"about\":[\"h_programming\",\"f_develop\"],\"image\":[\"https:\\\u002F\\\u002Fhabr.com\\\u002Fshare\\\u002Fpublication\\\u002F142351\\\u002F487329d734b8f36abb4dbce73727e353\\\u002F\"]}","metaDescription":"Доброго времени суток. Это статья — перевод заинтересовавшего меня поста в блоге аспиранта Университета штата Нью-Йорк в Стоуни-Брук. Статья в доступной форме описывает основные концепции...","mainImageUrl":null,"amp":false,"customTrackerLinks":[]},"polls":[],"commentsEnabled":true,"rulesRemindEnabled":false,"votesEnabled":true,"status":"published","plannedPublishTime":null,"checked":null,"isEditorial":false}},"articlesIds":{},"isLoading":false,"pagesCount":{},"route":{},"reasonsList":null,"view":"cards","lastVisitedRoute":{},"ssrCommentsArticleIds":[""],"karma":{}},"authorContribution":{"authors":{}},"betaTest":{"currentAnnouncement":null,"announcements":{},"announcementCards":null,"announcementComments":{},"announcementCommentThreads":{},"announcementCommentingStatuses":{},"archivedList":[]},"authorStatistics":{"articleRefs":{},"articleIds":{},"pagesCount":{},"route":{},"viewsCount":[],"maxStatsCount":{}},"career":{"seoLandings":[],"hubs":"programming"},"comments":{"articleComments":{},"searchCommentsResults":null,"previewComment":null,"pagesCount":null,"commentAccess":{},"scrollParents":{},"pageArticleComments":{"lastViewedComment":0,"postId":null,"lastCommentTimestamp":"","moderated":[],"moderatedIds":[],"commentRoute":""}},"companies":{"companyRefs":{},"companyIds":{},"companyTopIds":{},"pagesCount":{},"companyProfiles":{},"companiesCategories":[],"companiesCategoriesTotalCount":0,"companiesWidgets":{},"companiesWorkers":{},"companiesFans":{},"route":{},"isLoading":false,"companyWorkersLoading":false,"companyFansLoading":false,"vacancies":{},"workplaceInfo":null},"companyAdmin":{"companyInfo":null,"companyInfoLoading":false,"faqArticles":null,"brandingPreviewImageUrl":null},"companiesContribution":{"hubs":{},"flows":{},"companyRefs":{}},"companyHubsContribution":{"contributionRefs":{"hubRefs":{},"hubIds":{}}},"conversation":{"messages":[],"respondent":null,"isLoadMore":false},"conversations":{"conversations":[],"unreadCount":0,"pagesCount":0,"isLoadMore":false},"desktopState":{"desktopFl":null,"desktopHl":null,"isChecked":false,"isLoginDemanded":false},"docs":{"menu":{},"articles":{},"mainMenu":[],"loading":{"main":false,"dropdown":false,"article":false}},"feature":{"isProbablyVisible":"true"},"flows":{"flows":[{"alias":"develop","id":1,"route":{"name":"FLOW_PAGE","params":{"flowName":"develop"}}},{"alias":"admin","id":6,"route":{"name":"FLOW_PAGE","params":{"flowName":"admin"}}},{"alias":"design","id":2,"route":{"name":"FLOW_PAGE","params":{"flowName":"design"}}},{"alias":"management","id":3,"route":{"name":"FLOW_PAGE","params":{"flowName":"management"}}},{"alias":"marketing","id":4,"route":{"name":"FLOW_PAGE","params":{"flowName":"marketing"}}},{"alias":"popsci","id":7,"route":{"name":"FLOW_PAGE","params":{"flowName":"popsci"}}}]},"global":{"isPwa":false,"device":"desktop","isHabrCom":true},"hubs":{"hubRefs":{},"hubIds":{},"pagesCount":{},"isLoading":false,"route":{}},"hubsBlock":{"hubRefs":{},"hubIds":{}},"i18n":{"fl":"ru","hl":"ru"},"info":{"infoPage":{},"isLoading":true},"location":{"urlStruct":{"protocol":null,"slashes":null,"auth":null,"host":null,"port":null,"hostname":null,"hash":null,"search":null,"query":{},"pathname":null,"path":null,"href":""},"searchQuery":null},"me":{"user":null,"ppgDemanded":false,"karmaResetInfo":{"canReincarnate":null,"wasReincarnated":null,"currentScore":null},"notes":null},"mostReadingList":{"mostReadingListIds":[],"mostReadingListRefs":null,"promoPost":null},"pinnedPost":{"pinnedPost":null},"ppa":{"articles":{},"card":null,"transactions":null,"totalTransactions":null,"isAccessible":null},"projectsBlocks":{"activeBlocks":{}},"promoData":{"isLoading":false,"hasLoaded":false,"featurer":null,"megaposts":null,"promoLinks":null,"promoPosts":null},"pullRefresh":{"shouldRefresh":false},"sandbox":{"articleIds":[],"articleRefs":{},"pagesCount":null,"route":{},"lastVisitedRoute":{},"isLoading":false},"search":{"searchQueryError":null},"settingsOther":{"inputs":{"uiLang":{"errors":[],"ref":null,"value":""},"articlesLangEnglish":{"errors":[],"ref":null,"value":false},"articlesLangRussian":{"errors":[],"ref":null,"value":false},"agreement":{"errors":[],"ref":null,"value":false},"email":{"errors":[],"ref":null,"value":true},"digest":{"errors":[],"ref":null,"value":true}}},"similarList":{"similarListIds":[],"similarListRefs":null},"ssr":{"error":null,"isDataLoaded":false,"isDataLoading":false,"isHydrationFailed":false,"isServer":false},"technotext":{"nominationsList":[]},"userHubsContribution":{"contributionRefs":{"hubRefs":{},"hubIds":{}}},"userInvites":{"availableInvites":0,"usedInvitesIds":[],"usedInvitesRefs":{},"usedInvitesPagesCount":0,"unusedInvitesIds":[],"unusedInvitesRefs":{},"unusedInvitesPagesCount":0},"users":{"authorRefs":{},"authorIds":{},"pagesCount":{},"authorProfiles":{},"userHubs":{},"userInvitations":{},"authorFollowers":{},"authorFollowed":{},"userSpecialization":{},"karmaStats":[],"statistics":null,"isLoading":false,"authorFollowersLoading":false,"authorFollowedLoading":false,"userHubsLoading":false,"userInvitationsLoading":false,"route":{}},"viewport":{"prevScrollY":{},"scrollY":0,"width":0},"tracker":{"items":{},"pagesCache":{},"markedViewedSilently":{},"markedRead":{},"unreadCounters":{"applications":null,"system":null,"mentions":null,"subscribers":null,"posts_and_comments":null},"unviewedCounters":{"applications":null,"system":null,"mentions":null,"subscribers":null,"posts_and_comments":null}}};(function(){var s;(s=document.currentScript||document.scripts[document.scripts.length-1]).parentNode.removeChild(s);}());</script>
<script src="https://assets.habr.com/habr-web/js/chunk-vendors.da6c6b36.js" defer></script><script src="https://assets.habr.com/habr-web/js/app.92df6f6d.js" defer></script>



    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    </script>
  
  <script type="text/javascript" >
    (function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
    m[i].l=1*new Date();k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})
    (window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");

    ym(24049213, "init", {
      defer:true,
      trackLinks:true,
      accurateTrackBounce:true,
      webvisor:false,
    });
  </script>
  <noscript>
    <div>
      <img src="https://mc.yandex.ru/watch/24049213" style="position:absolute; left:-9999px;" alt="" />
    </div>
  </noscript>
  
    <script type="text/javascript">
      window.addEventListener('load', function () {
        setTimeout(() => {
          const img = new Image();
          img.src = 'https://vk.com/rtrg?p=VK-RTRG-421343-57vKE';
        }, 0);
      });
    </script>
  
<script src="https://habr.com/js/ads.js" onload="window['zhY4i4nJ9K'] = true"></script>
</body>
</html>
