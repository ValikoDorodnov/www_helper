<!DOCTYPE html>
<html lang="ru" data-vue-meta="%7B%22lang%22:%7B%22ssr%22:%22ru%22%7D%7D">
<head >
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1.0,viewport-fit=cover">
  <meta name="referrer" content="unsafe-url">
  <title>Охота на мифический MVC. Построение пользовательского интерфейса / Хабр</title>
  <style>
    /* cyrillic-ext */
    @font-face {
      font-family: 'Fira Sans';
      font-style: normal;
      font-weight: 500;
      font-display: swap;
      src: url(https://fonts.gstatic.com/s/firasans/v11/va9B4kDNxMZdWfMOD5VnZKveSxf6TF0.woff2) format('woff2');
      unicode-range: U+0460-052F, U+1C80-1C88, U+20B4, U+2DE0-2DFF, U+A640-A69F, U+FE2E-FE2F;
    }

    /* cyrillic */
    @font-face {
      font-family: 'Fira Sans';
      font-style: normal;
      font-weight: 500;
      font-display: swap;
      src: url(https://fonts.gstatic.com/s/firasans/v11/va9B4kDNxMZdWfMOD5VnZKveQhf6TF0.woff2) format('woff2');
      unicode-range: U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116;
    }

    /* latin-ext */
    @font-face {
      font-family: 'Fira Sans';
      font-style: normal;
      font-weight: 500;
      font-display: swap;
      src: url(https://fonts.gstatic.com/s/firasans/v11/va9B4kDNxMZdWfMOD5VnZKveSBf6TF0.woff2) format('woff2');
      unicode-range: U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;
    }

    /* latin */
    @font-face {
      font-family: 'Fira Sans';
      font-style: normal;
      font-weight: 500;
      font-display: swap;
      src: url(https://fonts.gstatic.com/s/firasans/v11/va9B4kDNxMZdWfMOD5VnZKveRhf6.woff2) format('woff2');
      unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
    }

    /* non-breaking hyphen */
    @font-face {
      font-family: 'Fira Sans';
      font-style: normal;
      font-weight: 500;
      font-display: swap;
      src: url(https://fonts.gstatic.com/l/font?kit=KFOlCnqEu92Fr1MmEU9vBh0_IsHAlmrO6g&skey=ee881451c540fdec&v=v29) format('woff2');
      unicode-range: U+02011;
    }
  </style>
  <link rel="preload" href="https://assets.habr.com/habr-web/css/chunk-vendors.e7843cc0.css" as="style"><link rel="preload" href="https://assets.habr.com/habr-web/js/chunk-vendors.da6c6b36.js" as="script"><link rel="preload" href="https://assets.habr.com/habr-web/css/app.4de4e95a.css" as="style"><link rel="preload" href="https://assets.habr.com/habr-web/js/app.92df6f6d.js" as="script">
  <link rel="stylesheet" href="https://assets.habr.com/habr-web/css/chunk-vendors.e7843cc0.css"><link rel="stylesheet" href="https://assets.habr.com/habr-web/css/app.4de4e95a.css">
  <script>window.i18nFetch = new Promise((res, rej) => {
          const xhr = new XMLHttpRequest();
          xhr.open('GET', '/js/i18n/ru-compiled.2822d469ec31a56409ac330bbcf7fcbf.json');
          xhr.responseType = 'json';
          xhr.onload = function(e) {
            if (this.status === 200) {
              res({ru: xhr.response});
            } else {
              rej(e);
            }
          };
          xhr.send();
        });</script>
  
  <script data-vue-meta="ssr" type="application/ld+json" data-vmid="ldjson-schema">{"@context":"http:\/\/schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/habr.com\/ru\/post\/322700\/"},"headline":"Охота на мифический MVC. Построение пользовательского интерфейса","datePublished":"2017-02-27T15:39:31+03:00","dateModified":"2017-02-28T07:03:49+03:00","author":{"@type":"Person","name":"cobiot"},"publisher":{"@type":"Organization","name":"Habr","logo":{"@type":"ImageObject","url":"https:\/\/habrastorage.org\/webt\/a_\/lk\/9m\/a_lk9mjkccjox-zccjrpfolmkmq.png"}},"description":"Детектив по материалам IT. Часть вторая В этой части я покажу как изначально выглядело деление пользовательского интерфейса и что из себя представляли Вид и Конт...","url":"https:\/\/habr.com\/ru\/post\/322700\/#post-content-body","about":["h_analysis_design","h_refactoring","f_develop"],"image":["https:\/\/habr.com\/share\/publication\/322700\/69f193b3363819ddd9edb9c4895632c0\/"]}</script>
  <script src="https://www.googletagservices.com/tag/js/gpt.js" async></script>
  <style>.grecaptcha-badge{visibility: hidden;}</style>
  <meta name="habr-version" content="2.64.0">
  
  <meta data-vue-meta="ssr" property="fb:app_id" content="444736788986613"><meta data-vue-meta="ssr" property="fb:pages" content="472597926099084"><meta data-vue-meta="ssr" name="twitter:card" content="summary_large_image"><meta data-vue-meta="ssr" name="twitter:site" content="@habr_com"><meta data-vue-meta="ssr" property="og:site_name" content="Хабр" data-vmid="og:site_name"><meta data-vue-meta="ssr" property="og:title" content="Охота на мифический MVC. Построение пользовательского интерфейса" data-vmid="og:title"><meta data-vue-meta="ssr" name="twitter:title" content="Охота на мифический MVC. Построение пользовательского интерфейса" data-vmid="twitter:title"><meta data-vue-meta="ssr" name="aiturec:title" content="Охота на мифический MVC. Построение пользовательского интерфейса" data-vmid="aiturec:title"><meta data-vue-meta="ssr" name="description" content="Детектив по материалам IT. Часть вторая
В этой части я покажу как изначально выглядело деление пользовательского интерфейса и что из себя представляли Вид и Контроллер. Попробую рассказать почему в..." data-vmid="description"><meta data-vue-meta="ssr" itemprop="description" content="Детектив по материалам IT. Часть вторая
В этой части я покажу как изначально выглядело деление пользовательского интерфейса и что из себя представляли Вид и Контроллер. Попробую рассказать почему в..." data-vmid="description:itemprop"><meta data-vue-meta="ssr" property="og:description" content="Детектив по материалам IT. Часть вторая
В этой части я покажу как изначально выглядело деление пользовательского интерфейса и что из себя представляли Вид и Контроллер. Попробую рассказать почему в..." data-vmid="og:description"><meta data-vue-meta="ssr" name="twitter:description" content="Детектив по материалам IT. Часть вторая
В этой части я покажу как изначально выглядело деление пользовательского интерфейса и что из себя представляли Вид и Контроллер. Попробую рассказать почему в..." data-vmid="twitter:description"><meta data-vue-meta="ssr" property="aiturec:description" content="Детектив по материалам IT. Часть вторая
В этой части я покажу как изначально выглядело деление пользовательского интерфейса и что из себя представляли Вид и Контроллер. Попробую рассказать почему в..." data-vmid="aiturec:description"><meta data-vue-meta="ssr" itemprop="image" content="https://habr.com/share/publication/322700/69f193b3363819ddd9edb9c4895632c0/" data-vmid="image:itemprop"><meta data-vue-meta="ssr" property="og:image" content="https://habr.com/share/publication/322700/69f193b3363819ddd9edb9c4895632c0/" data-vmid="og:image"><meta data-vue-meta="ssr" property="og:image:width" content="1200" data-vmid="og:image:width"><meta data-vue-meta="ssr" property="og:image:height" content="630" data-vmid="og:image:height"><meta data-vue-meta="ssr" property="aiturec:image" content="https://habr.com/share/publication/322700/69f193b3363819ddd9edb9c4895632c0/" data-vmid="aiturec:image"><meta data-vue-meta="ssr" name="twitter:image" content="https://habr.com/share/publication/322700/69f193b3363819ddd9edb9c4895632c0/" data-vmid="twitter:image"><meta data-vue-meta="ssr" property="vk:image" content="https://habr.com/share/publication/322700/69f193b3363819ddd9edb9c4895632c0/?format=vk" data-vmid="vk:image"><meta data-vue-meta="ssr" property="aiturec:item_id" content="322700" data-vmid="aiturec:item_id"><meta data-vue-meta="ssr" property="aiturec:datetime" content="2017-02-27T12:39:31.000Z" data-vmid="aiturec:datetime"><meta data-vue-meta="ssr" content="https://habr.com/ru/post/322700/" property="og:url" data-vmid="og:url"><meta data-vue-meta="ssr" property="og:type" content="article" data-vmid="og:type"><meta data-vue-meta="ssr" property="og:locale" content="ru_RU" data-vmid="og:locale"><meta data-vue-meta="ssr" name="keywords" content="MVC, архитектура приложений">
  <link data-vue-meta="ssr" href="https://habr.com/ru/rss/post/322700/?fl=ru" type="application/rss+xml" title="" rel="alternate" name="rss"><link data-vue-meta="ssr" href="index.html.1.69.html" rel="canonical" data-vmid="canonical"><link data-vue-meta="ssr" data-vmid="hreflang"><link data-vue-meta="ssr" image_src="image" href="https://habr.com/share/publication/322700/69f193b3363819ddd9edb9c4895632c0/" data-vmid="image:href"><link data-vue-meta="ssr" rel="amphtml" href="https://habr.com/ru/amp/post/322700/">
  <meta name="apple-mobile-web-app-status-bar-style" content="#303b44">
  <meta name="msapplication-TileColor" content="#629FBC">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="mobile-web-app-capable" content="yes">
  <link
    rel="shortcut icon"
    type="image/png"
    sizes="16x16"
    href="https://assets.habr.com/habr-web/img/favicons/favicon-16.png"
  >
  <link
    rel="shortcut icon"
    type="image/png"
    sizes="32x32"
    href="https://assets.habr.com/habr-web/img/favicons/favicon-32.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="76x76"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-76.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="120x120"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-120.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="152x152"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-152.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="180x180"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-180.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="256x256"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-256.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1136x640.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2436x1125.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1792x828.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_828x1792.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1334x750.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1242x2668.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 736px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2208x1242.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1125x2436.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 736px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1242x2208.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2732x2048.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2688x1242.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 834px) and (device-height: 1112px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2224x1668.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_750x1334.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2048x2732.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2388x1668.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 834px) and (device-height: 1112px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1668x2224.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_640x1136.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1668x2388.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2048x1536.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1536x2048.png"
  >
  <link
    rel="mask-icon"
    color="#77a2b6"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-120.svg"
  >
  <link
    crossorigin="use-credentials"
    href="https://habr.com/manifest.webmanifest"
    rel="manifest"
  >
</head>
<body>


<div id="app" data-server-rendered="true" data-async-called="true"><div class="tm-layout__wrapper"><!----> <div></div> <!----> <header class="tm-header"><div class="tm-page-width"><div class="tm-header__container"><!----> <span class="tm-header__logo-wrap"><a href="https://habr.com/ru/" class="tm-header__logo tm-header__logo_ru"><svg height="16" width="16" class="tm-svg-img tm-header__icon"><title>Хабр</title> <use xlink:href="/img/habr-logo-ru.svg#logo"></use></svg></a> <span class="tm-header__beta-sign" style="display:none;">β</span></span> <div class="tm-dropdown tm-header__projects"><div class="tm-dropdown__head"><button class="tm-header__dropdown-toggle"><svg height="16" width="16" class="tm-svg-img tm-header__icon tm-header__icon_dropdown"><title>Открыть список</title> <use xlink:href="/img/megazord-v25.4b679db1.svg#arrow-down"></use></svg></button></div> <!----></div> <a href="https://habr.com/ru/sandbox/start/" class="tm-header__become-author-btn">
            Как стать автором
          </a> <div class="tm-feature tm-header__feature tm-feature_variant-inline"><!----></div> <!----> <!----></div></div></header> <div class="tm-layout"><div class="tm-page-progress-bar"></div> <div data-menu-sticky="true" class="tm-base-layout__header tm-base-layout__header_is-sticky"><div class="tm-page-width"><div class="tm-base-layout__header-wrapper"><div class="tm-main-menu"><div class="tm-main-menu__section"><nav class="tm-main-menu__section-content"><!----> <a href="https://habr.com/ru/flows/all" class="tm-main-menu__item">
        Все потоки
      </a> <a href="https://habr.com/ru/flows/develop/" class="tm-main-menu__item">
          Разработка
        </a><a href="https://habr.com/ru/flows/admin/" class="tm-main-menu__item">
          Администрирование
        </a><a href="https://habr.com/ru/flows/design/" class="tm-main-menu__item">
          Дизайн
        </a><a href="https://habr.com/ru/flows/management/" class="tm-main-menu__item">
          Менеджмент
        </a><a href="https://habr.com/ru/flows/marketing/" class="tm-main-menu__item">
          Маркетинг
        </a><a href="https://habr.com/ru/flows/popsci/" class="tm-main-menu__item">
          Научпоп
        </a></nav></div></div> <div class="tm-header-user-menu tm-base-layout__user-menu"><a href="https://habr.com/ru/search/" class="tm-header-user-menu__item tm-header-user-menu__search"><svg height="24" width="24" class="tm-svg-img tm-header-user-menu__icon tm-header-user-menu__icon_search tm-header-user-menu__icon_dark"><title>Поиск</title> <use xlink:href="/img/megazord-v25.4b679db1.svg#search"></use></svg></a> <!----> <!----> <!----> <div class="tm-header-user-menu__item tm-header-user-menu__user_desktop"><div class="tm-dropdown"><div class="tm-dropdown__head"><svg height="24" width="24" data-test-id="menu-toggle-guest" class="tm-svg-img tm-header-user-menu__icon"><title>Профиль</title> <use xlink:href="/img/megazord-v25.4b679db1.svg#header-user"></use></svg> <!----></div> <!----></div> <!----></div> <!----></div></div></div></div> <!----> <div class="tm-page-width"></div> <main class="tm-layout__container"><div hl="ru" data-async-called="true" class="tm-page"><div class="tm-page-width"><!----> <div class="tm-page__wrapper"><div class="tm-page__main tm-page__main_has-sidebar"><div class="pull-down"><div class="pull-down__header" style="height:0px;"><div class="pull-down__content" style="bottom:10px;"><svg height="24" width="24" class="tm-svg-img pull-down__arrow"><title>Обновить</title> <use xlink:href="/img/megazord-v25.4b679db1.svg#pull-arrow"></use></svg></div></div> <div class="tm-article-presenter"> <div class="tm-article-presenter__body"><div class="tm-misprint-area"><div class="tm-misprint-area__wrapper"><article class="tm-article-presenter__content tm-article-presenter__content_narrow"><div class="tm-article-presenter__header"> <div class="tm-article-snippet tm-article-presenter__snippet"><div class="tm-article-snippet__meta-container"><div class="tm-article-snippet__meta"><span class="tm-user-info tm-article-snippet__author"><a href="https://habr.com/ru/users/cobiot/" title="cobiot" class="tm-user-info__userpic"><div class="tm-entity-image"><svg height="24" width="24" class="tm-svg-img tm-image-placeholder tm-image-placeholder_blue"><!----> <use xlink:href="/img/megazord-v25.4b679db1.svg#placeholder-user"></use></svg></div></a> <span class="tm-user-info__user"><a href="https://habr.com/ru/users/cobiot/" class="tm-user-info__username">
      cobiot
    </a> </span></span> <span class="tm-article-snippet__datetime-published"><time datetime="2017-02-27T12:39:31.000Z" title="2017-02-27, 15:39">27  февраля  2017 в 15:39</time></span></div> <!----></div> <h1 lang="ru" class="tm-article-snippet__title tm-article-snippet__title_h1"><span>Охота на мифический MVC. Построение пользовательского интерфейса</span></h1> <div class="tm-article-snippet__hubs"><span class="tm-article-snippet__hubs-item"><a href="https://habr.com/ru/hub/analysis_design/" class="tm-article-snippet__hubs-item-link"><span>Анализ и проектирование систем</span> <span title="Профильный хаб" class="tm-article-snippet__profiled-hub">*</span></a></span><span class="tm-article-snippet__hubs-item"><a href="https://habr.com/ru/hub/refactoring/" class="tm-article-snippet__hubs-item-link"><span>Проектирование и рефакторинг</span> <span title="Профильный хаб" class="tm-article-snippet__profiled-hub">*</span></a></span></div> <!----> <!----> <!----></div></div> <!----> <div data-gallery-root="" lang="ru" class="tm-article-body"><div></div> <div id="post-content-body"><div><div class="article-formatted-body article-formatted-body_version-1"><div xmlns="http://www.w3.org/1999/xhtml"><h2 id="detektiv-po-materialam-it-chast-vtoraya">Детектив по материалам IT. Часть вторая</h2><br/>
<p>В этой части я покажу как изначально выглядело деление пользовательского интерфейса и что из себя представляли Вид и Контроллер. Попробую рассказать почему в современных GUI библиотеках используется их объединение и какие вообще интересные решения можно найти в этой области на сегодняшний день. Ссылки на первоисточники приведены в начале <a href="https://habrahabr.ru/post/321050/">первой части</a>.</p><br/>
<p>Начну с Вида. Не смотря на то, что Вид определяется как модуль, отображающий Модель – "<em>а view is a (visual) representation of its model</em>", на <strong>практике</strong> к Виду, как правило, просто относят все графические элементы GUI, то есть Видом считается все то, что мы <strong>видим</strong> на экране ЭВМ. </p><br/>
<p>Понятно, что тут содержится некое противоречие, поскольку такие графические компоненты как меню, кнопки, тулбары служат не для отображения информации о системе, а прежде всего для управления системой. Клавиатура и мышь всегда были средством управления программой и находились в «ведомости» Контроллера (как бы его не трактовали). Поэтому кажется нелогичным и странным, что кнопки, сделанные из пластмассы, считаются элементами управления и относятся к Контроллеру, а кнопки, нарисованные на экране, и по сути выполняющие те же самые функции (производить входящие события), почему то относят к Виду. </p><br/>
<p><img src="https://habrastorage.org/r/w1560/files/457/d0d/d26/457d0dd26f0947158968cabee4283fec.png" alt="View or Controller" data-src="https://habrastorage.org/files/457/d0d/d26/457d0dd26f0947158968cabee4283fec.png"/></p><a name="habracut"></a><br/>
<p>Кроме того, поскольку разумно считается что в графических элементах не хорошо «прописывать логику», то отсюда часто делается вывод, что Вид должен быть тонким и тупым (dumb View) и соответственно логику работы интерфейса можно обнаружить в самых неожиданных местах, вплоть до доменной модели (даже Фаулер пишет о «загрязнении» Модели настройками интерфейса <a href="https://habrahabr.ru/post/53536/">GUI Architectures</a>).</p><br/>
<p>И вновь для того, чтобы прояснить ситуацию предлагаю обратиться к «архитектурным принципам» и первоисточникам. Когда речь идет о декомпозиции то одно из основных «архитектурных» правил заключается в том, что делить на модули нужно прежде всего исходя из тех <strong>задач</strong>, которые решает система. Каждый модуль должен отвечать за решение какой-то определенной задачи (желательно одной) и выполнять соответствующую ей функцию. </p><br/>
<p>Соответственно, для того, чтобы понять как следует делить пользовательский интерфейс на модули, в первую очередь надо проанализировать что он делает и какие задачи решает. Ведь интерфейс это <strong>функция</strong>, а не графические элементы. И функция эта заключается в том, чтобы обеспечивать <strong>взаимо-действие</strong> пользователя с системой. Что означает:</p><br/>
<ol>
<li><strong>выводить</strong> и удобно отображать пользователю информацию о системе</li>
<li><strong>вводить</strong> данные и команды пользователя в систему (передавать их системе)</li>
</ol><br/>
<p>То есть, в общем случае пользовательский интерфейс является <strong>двунаправленным</strong> и решает <strong>две</strong> задачи, одна из которых связана с <strong>выводом</strong> и представлением информации, а вторая – с <strong>вводом</strong> команд и данных. Вот эти-то задачи и определяют то, как нужно делить интерфейс на модули. Вновь смотрим картинку из первоисточника (Реенскауг):</p><br/>
<p><img src="https://habrastorage.org/r/w1560/files/3b4/81a/6e1/3b481a6e1e88416f943593d5a20ee4e4.png" alt="View Controller Separation" data-src="https://habrastorage.org/files/3b4/81a/6e1/3b481a6e1e88416f943593d5a20ee4e4.png"/></p><br/>
<p>Как видно <strong>пользовательский интерфейс</strong> довольно естественно и логично делится на два относительно независимых <strong>функциональных</strong> модуля. Причем такое функциональное деление, основанное на решаемых задачах, универсально. Не важно звуковой это интерфейс, графический или сенсорный в нем должен быть модуль, отвечающий за <strong>Ввод</strong> управляющих команд и данных (отсюда и название Controller — управление), и модуль отвечающий <strong>Вывод</strong> и представление информации о системе и о том что в ней происходит (View — Вид, представление). </p><br/>
<p>А теперь давайте посмотрим, как же деление Вид/Контроллер <strong>выглядело</strong> на практике. И для того чтобы это сделать нам потребуется небольшой экскурс в историю. Дело в том, что вначале термина <strong>CONTROLLER</strong> вообще не существовало. Вместо него Реенскауг использовал термин <strong>EDITOR</strong> (<strong>MODEL-VIEW-EDITOR)</strong> и писал о разделении пользовательского интерфейса на View и Editor. "<em>The hardest part was to hit upon good names for the different architectural components. Model-View-Editor was the first set.</em>"(Trygve Reenskaug). Попробую объяснить почему. </p><br/>
<p>Не смотря на наличие технических возможностей (растровые экраны) во времена создания MVC и SmallTalk пользовательские интерфейсы преимущественно все еще оставались командными (<em>Command-driven Interface</em>) и представляли собой по сути обычные текстовые редакторы. В SmallTalk интерфейс так и назывался – Editor. И вот как он выглядел:</p><br/>
<p><img src="https://habrastorage.org/r/w1560/files/e8e/65f/800/e8e65f800a7647dcb85dfe36a6aa1735.png" alt="SmallTalk Editor" data-src="https://habrastorage.org/files/e8e/65f/800/e8e65f800a7647dcb85dfe36a6aa1735.png"/></p><br/>
<p>Можно сказать что Editor объединял в себе функции Контроллера и Вида. Он давал возможность относительно удобно вводить команды и данные (отображая нажатые клавиши и обрабатывая ввод с клавиатуры), и одновременно выводил информацию о выполнении команд и вообще о том что происходит в системе. </p><br/>
<p>Лишь постепенно этот Editor преобразовывался в то, что мы сейчас привыкли понимать под GUI. </p><br/>
<p>Вначале возникла простая но весьма плодотворная идея – разделить единое окно на множество панелей. Парадигма многопанельности появились существенно раньше MVC (многопанельные браузеры точно присутствовали уже в Smalltalk-76) и была значительным продвижением сама по себе. Она до сих пор активно используется практически во всех текстовых интерфейсах. </p><br/>
<p>Реенскауг ее, естественно, тоже использовал. Тут нужно иметь в виду, что Dynabook, вокруг которого в Xerox Parc создавались и smallTalk и графические интерфейсы и, в частности, MVC, задумывался как «детский компьютер». Поэтому стояла задача сделать работу с компьютерными программами доступной любому неподготовленному пользователю, в частности ребенку. Реенскауг исходил из того, что пользователь может вообще ничего не знать о программе и о том как она устроена. И для того чтобы он мог с программой взаимодействовать нужно каким-то образом отобразить ему основную информацию о системе и доменной модели, лежащей в ее основе, чтобы пользователь понимал с чем имеет дело. </p><br/>
<p>Выводилась такая информация на отдельных панелях, которые собственно и стали называться View. Как правило доменная модель отображалась при помощи нескольких различных Видов: "<em>MVC задумывался как общее решение, дающее возможность пользователям контролировать большие и сложные наборы данных… Он особенно полезен тогда, когда пользователю нужно видеть Модель одновременно в разных контекстах и/или с разных точек зрения.</em>" И поскольку Реенскауг считал, что графическое представление информации нагляднее чем текстовое, то в основном виды у него представляли собой разного рода графики и диаграммы.</p><br/>
<p>Далее. Так как пользователь ничего (или почти ничего) не знает о системе, а видит лишь всевозможные View, удобно и наглядно отображающие нужную ему информацию, то соответственно и управление системой должно было выглядеть так, как если бы пользователь управлял непосредственно самими View и тем что на них отображено. Поэтому для ввода команд стал использоваться не один «general Editor», а целое множество специализированных редакторов, каждый из которых был связан со своим Видом и был заточен на ввод команд (взаимодействие с доменной моделью) лишь в контексте этого Вида – <em>permits the user to modify the information that is presented by the view</em>. </p><br/>
<p>Таким образом, если для специалиста интерфейсом обычно служил некий общий редактор, дающий возможность вводить в систему любые команды (но для этого нужно было штудировать мануалы, знать команды и понимать, как система работает), то для неподготовленного пользователя минимальным интерфейсом становится пара – View и связанный с ней специализированный Editor (который собственно и будет впоследствии переименован в Контроллер). Такой интерфейс предоставлял весьма редуцированный набор команд и возможностей, зато им можно было пользоваться без предварительной подготовки. </p><br/>
<p>Первый доклад Реенскауга так и назывался: "THING-MODEL-VIEW-EDITOR. An Example from a planning system". В нем была представлена первая реализация MVC на примере системы планирования и управления неким большим проектом (своего рода task-manager). Доменной моделью являлась сеть (network) «активностей», которая описывала <em>что</em> должно быть сделано (активность), в каком порядке, за какое время, <em>кто</em> в каких активностях участвует и какие ресурсы для каждой активности требуются. Пример призван был показать что “<em>одна Модель может быть отображена с помощью многих различных Видов”</em> и вот как там выглядел пользовательский интерфейс: </p><br/>
<p><img src="https://habrastorage.org/r/w1560/files/94f/595/fcb/94f595fcb6e74732a8bb7fe8357da110.png" alt="Reenskaug MVC" data-src="https://habrastorage.org/files/94f/595/fcb/94f595fcb6e74732a8bb7fe8357da110.png"/></p><br/>
<p>Доменная модель отображалась с помощью трех различных диаграмм (Видов). Нужно отметить, что виды и у Реенскауга и в SmallTalk вовсе не были "пассивными", они самостоятельно обрабатывали относящиеся к ним действия пользователя, в частности позволяли делать скроллинг и выделение элементов: “<em>A ListView has fields where it remembers its frame, a list of textual items and a possible selection within the list. It is able to display its list on the screen within its frame, and reacts to messages asking it to scroll itself.</em>” Это важный момент и я еще к нему вернусь.</p><br/>
<p>Первая диаграмма отображает множество активностей, относящихся к некоторому проекту/сети и связи между ними. Подобно тому, как список позволяет выбрать/выделить некий свой элемент, данная диаграмма позволяла выбрать некую активность. С диаграммой связан редактор, который дает возможность запрашивать у системы и редактировать информацию, относящуюся к выбранной активности. Например: длительность активности, кто в ней участвует, какие активности предшествуют и тп</p><br/>
<p>Вторая диаграмма – GanttView (календарный или временной график Гантта) показывает расположение проекта и его активностей во времени. Эта диаграмма также позволяет выбрать некую активность. Редактор, связанный с GanttView дает возможность "<em>to pass on operations on the network and its activities that are related to this particular View</em>". В частности он позволяет изменить запланированную дату начала и окончания выбранной активности, а также осуществлять планирование и управление проектом/сетью как целым.</p><br/>
<p>Третья диаграмма — это диаграмма ресурсов, требуемых для осуществления активностей, в зависимости от времени. Любопытно то, что с этой диаграммой связан не редактор, а список и в зависимости от того какая активность в этом списке выбрана, диаграмма ресурсов отображает только те ресурсы, которые относятся к выбранной активности. Такое сочетание двух видов, один из которых "управляет" отображаемой информацией другого характерно для многих интерфейсов. А идея использовать для «управления» не текстовый редактор а список ляжет в основу большинства контроллеров в SmallTalk-80. </p><br/>
<p>Термин <strong>Controller</strong> возник практически перед самым уходом Реенскауга из Xerox PARC "<em>After long discussions, particularly with Adele Goldberg</em>". И из-за этого оригинальные работы Реенскауга бывает сложно читать, поскольку одним и тем же термином«Editor» он называет и весь интерфейс целиком (и в этом случае пишет о первичном разделении приложения на Model и Editor) и панели-редакторы которые связывались с соответствующими View для ввода команд и «управления View» и которые впоследствии собственно и стали Контроллерами – “<em>Контроллер из Smalltalk-80 у меня назывался <strong>Editor</strong></em>” (Реенскауг)</p><br/>
<p>Также к обязанностям Контроллера Реенскауг относил управление самим интерфейсом и в частности множеством входящих в него Видов: "<em>Controller was responsible for creating and coordinating its subordinate views</em>". Соответственно иногда он пишет, что Контроллер это связь между пользователем и системой, а иногда что это связь между пользователем и Видами и что Контроллер передает команды Видам. </p><br/>
<p>Тем не менее, как видно из примера, Реенскауговский «Editor-Controller» был вполне себе видим и имел графическое представление. </p><br/>
<p>Посмотрим как дело обстояло в SmallTalk-80. </p><br/>
<p><strong>Первое: в SmallTalk-80 текстовые редакторы, которые Реенскауг использовал для ввода команд, «официально» стали Контроллерами.</strong></p><br/>
<p>«<em>ParagraphEditor</em>» и «<em>TextEditor</em>», обладающие стандартными функциями ввода и редактирования текста, в SmallTalk-80 являлись потомками класса «<em>Controller</em>»: </p><br/>
<p>Поскольку, как уже упоминалось, редакторы объединяли в себе функции Ввода и Вывода, то они также использовались для <strong>отображения</strong> текстовой информации во многих Видах – TextView, TextEditorView.</p><br/>
<p>Стив Барбек дает по этому поводу довольно подробное разьяснение: "<em>Все контроллеры, которые принимают ввод с клавиатуры, являются наследниками «ParagraphEditor» в иерархии Контроллеров. «ParagraphEditor» предшествовал созданию парадигмы MVC. Он одновременно выполняет две функции – обрабатывает ввод текста с клавиатуры и отображает его на экране. Поэтому в некотором смысле он представляет собой нечто среднее между Видом и Контроллером. Виды, которые используют подклассы «ParagraphEditor» в качестве контроллера, полностью переворачивают стандартные роли – для того чтобы отобразить текст они посылают его своему контроллеру</em>" [<em>All controllers that accept keyboard text input are under the ParagraphEditor in the Controller hierarchy. ParagraphEditor predates the full development of the MVC paradigm. It handles both text input and text display functions, hence it is in some ways a cross between a view and a controller. The views which use it or its subcasses for a controller reverse the usual roles for display; they implement the display of text by sending controller display</em>].</p><br/>
<p>О причине подобных «парадоксов» я постараюсь написать дальше, пока же просто обратите на это внимание</p><br/>
<p><strong>Второе: в SmallTalk-80 с каждым Видом (подвидом) ОБЯЗАТЕЛЬНО был связан свой Контроллер, который давал возможность производить некие операции с той информацией, которую Вид отображает</strong></p><br/>
<p>Соответственно любое множество Видов (подвидов) входящих в состав пользовательского интерфейса на самом деле всегда сопровождалось точно таким же множеством связанных с ним Контроллеров. Опять таки у Стива Барбека этой теме посвящен целый раздел который так и называется — "Communication Between Controllers".</p><br/>
<p><strong>Третье: главное усовершенствование состояло в том, что для ввода команд преимущественно стала использоваться мышь, а не клавиатура.</strong></p><br/>
<p>В SmallTalk-80 помимо контроллеров-редакторов (<em>ParagraphEditor</em> и <em>TextEditor</em>) появляется <strong>MouseMenuController</strong>, который становится основным средством ввода команд. Пользовательские интерфейсы из Command-driven становятся Menu-driven (<a href="https://revisionworld.com/gcse-revision/ict/software/user-interfaces">User Interfaces</a>) </p><br/>
<p>Доступные команды для каждого Вида формировались явно в виде списка. А связанный с Видом MouseMenuController предоставлял для их отображения и удобного ввода <strong>специальное графическое средство</strong> – всплывающие <strong>pop-up menu</strong>, которые появлялись при нажатии соответствующей кнопки мыши. Вот так они выглядели: </p><br/>
<p><img src="https://habrastorage.org/r/w1560/files/f66/d7b/b37/f66d7bb3725f40b79befe4e252c86f56.png" alt="SmallTalk menu" data-src="https://habrastorage.org/files/f66/d7b/b37/f66d7bb3725f40b79befe4e252c86f56.png"/> </p><br/>
<p>Повторю: pop-up menu относились к MouseMenuController. Меню являлись специальным графическим инструментом/средством для удобного отображения и ввода команд (определенных в контексте некоторого вида), который Контроллер, связанный с этим Видом, предоставлял пользователю. Вот что пишет Краснер: "<em>Хотя меню можно рассматривать как пару вид-контроллер, но чаще всего они считаются входными устройствами и следовательно относятся к сфере контроллера… За создание всплывающих меню при нажатии какой-нибудь кнопки мыши отвечает класс MouseMenuController… По умолчанию PopUpMenus возвращают числовое значение которое вызвавший их контроллер использует для того чтобы определить какое действие ему нужно совершить… Из-за широкого использования всплывающих меню большинство контроллеров пользовательского интерфейса являются подклассами MouseMenuController</em>". </p><br/>
<p>Так что основной контроллер SmallTalk-80 (MouseMenuController) тоже имел свою графическую часть – <em>pop-up menu</em>, и разделение пользовательского интерфейса на Виды и Контроллеры стало выглядеть следующим образом (иллюстрация взята из статьи Гленна Краснера): </p><br/>
<p><img src="https://habrastorage.org/r/w1560/files/251/bb4/5ec/251bb45ec3d04b2ba7e297d1057428ca.png" alt="SmallTalk View Controller Separation" data-src="https://habrastorage.org/files/251/bb4/5ec/251bb45ec3d04b2ba7e297d1057428ca.png"/></p><br/>
<p>Меню относящиеся к MouseMenuController-ам можно видеть абсолютно во всех SmallTalk приложениях и примерах. Вот так с развернутыми меню выглядят уже упоминавшиеся Workspace и Inspector:</p><br/>
<p><img src="https://habrastorage.org/r/w1560/files/40f/385/a60/40f385a603d040989be0b141cd242b49.png" alt="SmallTalk MVC" data-src="https://habrastorage.org/files/40f/385/a60/40f385a603d040989be0b141cd242b49.png"/></p><br/>
<p>А вот так выглядит Browser, включающий в себя 5 Видов (подВидов) и соответствующих им Контроллеров</p><br/>
<p><img src="https://habrastorage.org/r/w1560/files/87e/ed1/5c8/87eed15c8a8a471ebff24efba7f140b5.png" alt="SmallTalk MVC" data-src="https://habrastorage.org/files/87e/ed1/5c8/87eed15c8a8a471ebff24efba7f140b5.png"/></p><br/>
<p>Предполагаю, что именно из-за широкого использования всплывающих меню Реенскауг и писал, что контроллер в smalltalk "<em>это эфемерный компонент, который View создает при необходимости в качестве связывающего звена между View и входными устройствами такими как мышь и клавиатура</em>".</p><br/>
<p>Так что, можем развеять очередной миф:</p><br/>
<blockquote><strong>Мифы: Все графические элементы пользовательского интерфейса относятся к Виду. Контроллер это исключительно логика обработки движений мыши, нажатий клавиш на клавиатуре и других входящих событий производимых пользователем.</strong></blockquote><p>На самом деле и в реализации Реенскауга и затем в Smalltalk-80 большинство Контроллеров имели «<strong>графическую составляющую, помогающую пользователю вводить команды и данные</strong>». И именно такие Контроллеры в основном использовались в пользовательских приложениях. Хотя, конечно же, были Контроллеры и без графической составляющей, но они в основном применялись для более низкоуровневых системных задач (об этом чуть позже). </p><br/>
<p>Если просуммировать, то получается что <strong>Контроллер</strong> это <strong>часть пользовательского интерфейса</strong>, которая отвечает за то чтобы 1) предоставить пользователю <strong>удобные средства для ввода команд и данных</strong>, а затем 2) действия пользователя <strong>перевести</strong> в вызовы соответствующих методов Модели и <strong>передать</strong> их ей.</p><br/>
<p>Вот как определял Контроллер сам Реенскауг: "<em>Контроллер это связь между пользователем и системой. Он предоставляет пользователю меню и другие средства для ввода команд и данных. Контроллер получает результат таких действий пользователя, транслирует их в соответствующие сообщения и передает эти сообщения</em>" [ <em>A controller is the link between a user and the system. It provides means for user output by presenting the user with menus or other means of giving commands and data. The controller receives such user output, translates it into the appropriate messages and pass these messages on</em>].</p><br/>
<p>Современные графические интерфейсы (GUI) для ввода команд используют весь спектр доступных средств: текстовые и графические меню, кнопки, всплывающие pop-up меню, всевозможные переключатели (как в реальных приборах), текстовые поля для ввода данных (TextEditor свелся к TextField). Все эти элементы служат в основном для управления, а не для отображения информации. По английски они так и называются — <strong>controls</strong> (элементы управления). </p><br/>
<p>И если продолжить аналогию, то разделение Вид/Контроллер в современных системах выглядело бы примерно следующим образом:</p><br/>
<p><img src="https://habrastorage.org/r/w1560/files/1bc/c44/6a5/1bcc446a57ed4e94b0749c456d5a431b.png" alt="View Controller" data-src="https://habrastorage.org/files/1bc/c44/6a5/1bcc446a57ed4e94b0749c456d5a431b.png"/></p><br/>
<p>Можно сказать, что Контроллер это «панель управления» (Control panel). А Вид это «обзорная панель» или «панель наблюдения за системой» включающая в себя текстовые описания, списки, таблицы, графики, шкалы, световые табло, и всевозможные индикаторы состояния. </p><br/>
<p>Красота MVC заключается в том, что его идеи универсальны и применимы не только к информационным системам. Не важно прибор это или программа, <strong>в простейшем случае</strong> интерфейс, как правило, содержит блок/панель управления, позволяющий вводить команды – Контроллер, и блок отображения информации – Вид. </p><br/>
<h2 id="realizaciya-vidov-i-kontrollerov">Реализация Видов и Контроллеров</h2><br/>
<p>Что нам это дает? Ну во первых, становится понятно что логика работы Вида никак не может быть помещена в Контроллер: </p><br/>
<p><img src="https://habrastorage.org/r/w1560/files/b97/cda/4b7/b97cda4b709e48f2aa05b086172fb8ce.png" alt="View Controller" data-src="https://habrastorage.org/files/b97/cda/4b7/b97cda4b709e48f2aa05b086172fb8ce.png"/></p><br/>
<p>Если всю логику работы GUI вынести в Контроллер, то это нарушало бы сразу несколько принципов:</p><br/>
<ul>
<li>главный принцип определяющий качество декомпозиции – <em>High Cohesion + Low Coupling</em>, который говорит что «резать» на модули нужно так, чтобы связи, особенно сильные, оставались преимущественно внутри модулей, а не между ними</li>
<li><em>Принцип единственной ответственности (Single responsibility principle)</em>. </li>
</ul><br/>
<p>Второе. Тонкий Вид, рассматриваемый исключительно как набор графических элементов, не выполняет никакой функции и поэтому в плане пере-использования мало полезен. Если же мы рассматриваем Вид как полноценный функциональный модуль, решающий довольно общую и востребованную задачу – визуализация и удобное представление данных, то при правильном подходе он становится идеальным кандидатом на пере-использование.</p><br/>
<p>В этом смысле разделение пользовательского интерфейса на Вид и Контроллер очень красивый шаг – Контроллер вобрал в себя большую часть зависимостей. Виду от Модели нужны лишь данные для отображения в определенном формате. Соответственно потенциально один и тот же Вид может быть использован для визуализации информации в разных приложениях.</p><br/>
<p>Последнее время активно разрабатывается и используется концепция <strong>Dashboard</strong>-ов (информационных панелей), для которых создаются наборы универсальных виджетов, позволяющих наглядно и удобно визуализировать «все что угодно». В отличие от «тупого вида» такие «<em>полноценные блоки визуализации</em>» (инкапсулирующие свою логику, настройки и способные работать самостоятельно) очень востребованы и ценны сами по себе. </p><br/>
<p><img src="https://habrastorage.org/r/w1560/files/a69/310/6c2/a693106c29ed4650bc71ef42d75613a1.png" alt="Dashboard" data-src="https://habrastorage.org/files/a69/310/6c2/a693106c29ed4650bc71ef42d75613a1.png"/></p><br/>
<p>Когда Вид и Контроллер, трактуются как функциональные модули, отвечающие за решение определенных задач, то становится понятно, что для того чтобы инкапсулировать свою логику работы им вовсе нет нужды смешивать ее с графикой. Ведь любой модуль, при необходимости, может быть разделен на подмодули и обладать своей внутренней структурой.</p><br/>
<p>Как мы выяснили основной Контроллер SmallTalk-80 — MouseMenuController вовсе не являлся «всего лишь обработчиком действий пользователя с мышью и клавиатурой», на самом деле он делал довольно много вещей: </p><br/>
<ol>
<li>Задавал набор и названия команд, доступных пользователю в контексте некоего Вида, </li>
<li>Определял логику того, как эти команды транслировать в вызовы соответствующих методов Модели </li>
<li>Отображал доступные команды </li>
<li>Обрабатывал низкоуровневые движения мыши и создавал высокоуровневые события, к которым удобно привязывать выполнение команд (Event Driven подход). </li>
</ol><br/>
<p><img src="https://habrastorage.org/r/w1560/files/4e5/12c/027/4e512c027f2643e188b9c98fb273e2cf.png" alt="SamllTalk Controller" data-src="https://habrastorage.org/files/4e5/12c/027/4e512c027f2643e188b9c98fb273e2cf.png"/></p><br/>
<p>Для таких Контроллеров просто «просилась» MVC архитектура. И в SmallTalk-80 она была использована: "<em>pop-up menu are implemented as a special kind of MVC class</em>" (Краснер). </p><br/>
<p>Тут важно понимать, что Модель в этом «внутреннем» MVC не имеет никакого отношения к доменной модели, это именно внутренняя вспомогательная модель, описывающая «состояние» самого контроллера (в частности то, какая команда выбрана) и логику изменения этого состояния. </p><br/>
<p>Аналогично дело обстоит и с Видом. </p><br/>
<blockquote><strong>Мифы: То, что Вид это всего лишь «графика», является такой же идеализацией как и то, что Контроллер это «исключительно логика».</strong></blockquote><p>Визуализация информации является непростой задачей, для решения которой, как правило, требуются дополнительные данные, характеризующие именно сам процесс отображения. Большинство Видов, используемых в реальных приложениях, это довольно сложные объекты со своим «состоянием» и логикой его изменения. </p><br/>
<p>Например, Вид редко когда может отобразить всю Модель целиком, обычно он отражает лишь какую-то ее часть и ему необходимо «знать» какая именно «часть Модели» должна быть отражена в данный момент. Многие виды позволяют «выделять» какие-то элементы, а значить им где-то нужно хранить информацию о выделениях. </p><br/>
<p>Где хранились такого рода дополнительные данные и логика их изменения? В принципе ответ очевиден и, если вы помните, Реенскауг ответил на этот вопрос – конечно же в самом Виде. Но! Не в перемешку с графикой, а в отдельном под-модуле/классе/скрипте, то есть в некоторой <strong>внутренней модели</strong>.</p><br/>
<p>И раз есть вспомогательные внутренние модели, то должны быть и специальные Контроллеры, которые этими внутренними моделями управляют. Такие Контроллеры изменяют исключительно состояние самого Вида и не имеют никакого отношения к Контроллеру приложения, изменяющему состояние доменной модели. Положением фрейма, например управлял ScrollController. То есть в общем случае Виды тоже имеют структуру MVC. Но пока отложим вопрос с Контроллерами и сосредоточится на главном — на внутренних моделях.</p><br/>
<p><img src="https://habrastorage.org/r/w1560/files/8dc/dca/76c/8dcdca76c8584b218561f65456c92af7.png" alt="MVC View" data-src="https://habrastorage.org/files/8dc/dca/76c/8dcdca76c8584b218561f65456c92af7.png"/></p><br/>
<p>Фаулер такие внутренние модели, являющиеся частью представления называет — <a href="http://martinfowler.com/eaaDev/PresentationModel.html">Presentation Model</a>: <em>Presentation Model pulls the state and behavior of the view out into a model class that is part of the presentation</em>.</p><br/>
<p><strong>И вот тут внимание!</strong> В первой части статьи подробно рассказывается о том, как в MVC был «потерян» Фасад и что из-за этого его роль на себе вынуждены брать другие компоненты. Так вот хотя Фаулер и пишет что "<em>Presentation Model is not a GUI friendly facade to a specific domain object</em>" на практике PresentationModel, ViewModel, ApplicationModel не только описывают состояние и поведение представления, но одновременно являются еще и <strong>Фасадами</strong> к доменной модели. </p><br/>
<p>В примере, который Фаулер подробно разбирает, хорошо видно, что его PresentationModel является именно смесью Фасада и модели представления. Ну а Microsoft прямо пишет: "<em>Presentation model class acts as a façade on the model with UI-specific state and behavior, by encapsulating the access to the model and providing a public interface that is easy to consume from the view</em>" (<a href="https://msdn.microsoft.com/en-us/library/ff921080.aspx">MSDN: Presentation Model</a>)</p><br/>
<p>Безусловно такой подход противоречит <em>Принципу единой ответственности</em>, но он существует, используется во фреймворках и в принципе работает. Поэтому о нем стоит знать. </p><br/>
<p>В отличие от него в Java подобного смешения стараются не допускать. В Java Swing «application-data models» и «GUI-state models» разделены гораздо более четко. Все, наверное, читали или слышали что Java Swing компоненты реализованы в виде MVC. И большинство наверняка уверены в том, что M в этой триаде это тот самый интерфейс к доменным данным. И по сути это правильно, почти…</p><br/>
<p>Давайте внимательно посмотрим на список <a href="https://docs.oracle.com/javase/7/docs/api/javax/swing/JList.html">JList</a>. У него действительно есть модель, обеспечивающая доступ к доменным данным – <a href="https://docs.oracle.com/javase/7/docs/api/javax/swing/ListModel.html">ListModel</a>. Но кроме нее у списка имеется еще одна модель — <a href="https://docs.oracle.com/javase/7/docs/api/javax/swing/ListSelectionModel.html">ListSelectionModel</a>, которая отвечает исключительно за внутреннюю логику выделения элементов списка (item selection). И вот эта модель как раз и является в чистом виде внутренней моделью представления – «GUI-state model»: </p><br/>
<p>"<em>The models provided by Swing fall into two general categories: GUI-state models and application-data models.</em></p><br/>
<p><em>GUI state models are interfaces that define the visual status of a GUI control, such as whether a button is pressed or armed, or which items are selected in a list. GUI-state models typically are relevant only in the context of a graphical user interface (GUI).</em></p><br/>
<p><em>An application-data model is an interface that represents some quantifiable data that has meaning primarily in the context of the application, such as the value of a cell in a table or the items displayed in a list. These data models provide a very powerful programming paradigm for Swing programs that need a clean separation between their application data/logic and their GUI</em>" (см статью от создателей <a href="http://www.eecs.yorku.ca/course_archive/2004-05/W/3461/FowlerArticle.pdf">A Swing Architecture Overview</a>).</p><br/>
<p>У таблицы <a href="http://docs.oracle.com/javase/7/docs/api/javax/swing/JTable.html?is-external=true">JTable</a> помимо application-data модели, обеспечивающей доступ к доменным данным – <a href="http://docs.oracle.com/javase/7/docs/api/javax/swing/table/TableModel.html">TableModel</a>, имеются целых две внутренних GUI-stateмодели — ListSelectionModel и <a href="http://docs.oracle.com/javase/7/docs/api/javax/swing/table/TableColumnModel.html">TableColumnModel</a>.</p><br/>
<p>А вот у кнопки <a href="https://docs.oracle.com/javase/7/docs/api/javax/swing/JButton.html">JButton</a> имеется лишь GUI-state модель – <a href="https://docs.oracle.com/javase/7/docs/api/javax/swing/ButtonModel.html">ButtonModel</a>. Что в принципе и логично. Кнопка не отображает доменных данных, это в чистом виде Контроллер с внутренней моделью, которая определяет состояние кнопки (нажата/не нажата). </p><br/>
<p>При использовании графических компонент нам, в основном, приходится иметь дело с application-data моделями, через которые собственно и осуществляется взаимодействие домена и интерфейса. С GUI-state моделями мы сталкиваемся лишь тогда, когда возникает необходимость изменить дефолтное поведение компонента. Поэтому это нормально и правильно что многие даже не знают о наличие GUI-state моделей. </p><br/>
<p><img src="https://habrastorage.org/r/w1560/files/dc5/6fd/873/dc56fd8734aa4118ae744044a9773b8d.png" alt="MVC JavaSwing GUI-state models" data-src="https://habrastorage.org/files/dc5/6fd/873/dc56fd8734aa4118ae744044a9773b8d.png"/></p><br/>
<p>Видно, что в таблице некоторые модели отмечены одновременно и как GUI и как data. Особых пояснений не дается, написано что это зависит от контекста использования модели. Я могу высказать по этому поводу лишь предположение. </p><br/>
<p>Все такого рода промежуточные модели относятся к компонентам, которые являются либо разновидностью скроллбара либо разновидностью переключателя (кнопка с состоянием). Такие компоненты предназначены прежде всего для управления и по сути представляют собой контроллер (в SmallTalk скроллбар и был контроллером — ScrollController) но с некоторым внутренним состоянием. Соответственно у таких компонент имеется лишь GUI-state модель и в дефолтной реализации состояние этих компонент никак не связано с состоянием доменной модели, а зависит лишь от действий пользователя, то есть от того, в какое состояние пользователь этот контрол/кнопку перевел. </p><br/>
<p>Но при этом <strong>выглядит</strong> состояние таких контроллеров так, как если бы оно было согласовано с состоянием доменной модели: мы перевели переключатель в состояние «On», в доменную модель передалась соответствующая команда, там что-то включилось… и доменная модель тоже перешла в некое состояние «On». Достигается такая псевдо-согласованность как правило "сама собой", автоматически.</p><br/>
<p>Тем не менее возможны ситуации когда может понадобиться настоящее реальное согласование доменной модели и состояния переключателя. В этом случае будет написана реализация ButtonModel, в которой метод isSelected() перестанет зависеть от действий пользователя с кнопкой, а вместо этого будет напрямую отображать состояние домена (некий его флаг). Кнопка при этом становится отчасти видом, а ButtonModel перестает быть внутренней GUI-state и становится application-data</p><br/>
<p>В заключение темы привожу схемы обоих описанных тут подходов чтобы каждый мог выбрать то, что ему больше подходит:</p><br/>
<p><img src="https://habrastorage.org/r/w1560/files/3c7/764/ed8/3c7764ed889e4bde850c6871d7b4db7b.png" alt="MVC PresentationModel" data-src="https://habrastorage.org/files/3c7/764/ed8/3c7764ed889e4bde850c6871d7b4db7b.png"/></p><br/>
<p>Я стараюсь первого варианта избегать. Мое ИМХО что подобное смешение хоть и соблазняет своей кажущейся простотой но на практике приводит к тому что PresentationModel превращается в большую "свалку". Представьте что есть реальный сложный интерфейс. Если использовать подход (2), то мы этот интерфейс разобьем на ui-модули, и каждый модуль будет инкапсулировать свою логику в виде небольшой внутренней ui-state модели. А вот если использовать подход (1), то логика работы всего этого большого интерфейса будет свалена в кучу вперемешку с логикой фасада в PresentationModel. Пока такая PresentationModel или ApplicationModel создается и управляется автоматически неким фреймворком все хорошо. Но если подобное писать ручками… то мозг начинает ломаться и часто это приводит к тому, что логика представления рано или поздно просачивается через фасад в доменную модель. Даже у такого гуру как Фаулер, в его детском примере это таки произошло (интересно, кто-нибудь еще заметил это место?). В архитектуре, где фасад и GUI-state модели разделены, вероятность такого рода ошибок значительно ниже. </p><br/>
<h2 id="obedinennyy-vidkontroller-uproschennyy-mvc">Объединенный ВидКонтроллер. «Упрощенный MVC»</h2><br/>
<p>Раз уж мы коснулись Java Swing, то нужно сказать еще об одной его важной особенности – в отличие от SmallTalk-80 где и скроллбар и pop-up меню были реализованы в виде полноценного MVC (с внутренней моделью, внутренним низкоуровневым контроллером и видом) Swing в реализации базовых gui компонент использует «упрощенный MVC», в котором Вид и Контроллер объединены в единый компонент, который одновременно отображает данные и обрабатывает действия пользователя. Обычно он так и называется: объединенный <em>ViewController</em> или <em>UI-object</em>, <em>IU-delegate</em>. Вот еще одна статья, где это подробно описывается: <a href="http://www.javaworld.com/article/2076632/core-java/mvc-meets-swing.html">MVC meets Swing</a>.</p><br/>
<p><img src="https://habrastorage.org/r/w1560/files/860/929/151/8609291517e7408cae14be9dc0461819.png" alt="MVC" data-src="https://habrastorage.org/files/860/929/151/8609291517e7408cae14be9dc0461819.png"/></p><br/>
<p>Самое интересное и неожиданное заключается в том, что такой «упрощенный MVC» де-факто используется в большинстве GUI библиотек и фреймворках пришедших на смену SmallTalk-80: VisualAge Smalltalk от IBM, Visual SmallTalk, VisualWorks SmallTalk, MacApp… (<a href="https://books.google.es/books?id=W8_Une9cbbgC&amp;pg=PA124&amp;lpg=PA124&amp;dq=smalltalk+mvc&amp;source=bl&amp;ots=oQrY1q7oDa&amp;sig=Rkeymilwgxn99K8ZJRCl4s-lqbQ&amp;hl=ru&amp;sa=X&amp;redir_esc=y#v=onepage&amp;q=smalltalk%20mvc&amp;f=false">Smalltalk, Objects, and Design</a> стр 124-125). </p><br/>
<p>Фактически классический вариант MVC, с обязательным разделением Видов и Контроллеров, особенно на низком уровне, только в SmallTalk-80 и был реализован. Почему? Опять таки я могу высказать лишь предположение. </p><br/>
<p>Основное отличие SmallTalk-80 от всех последующих систем заключалось в том что он работал <strong>без операционной системы</strong>. Поэтому весь объем низкоуровневой работы по отслеживанию движений мыши а также нажатий клавиш на клавиатуре приходилось выполнять Контроллеру. Контроллер в тех условиях был необходим, фактически он выполнял роль драйвера входящих устройств и кроме ссылок на Модель и Вид обязательно содержал ссылку на «сенсор». Соответсвенно именно эта сторона его деятельности акцентировалась и выходила на первый план. </p><br/>
<p>После того, как эту работу взяли на себя операционные системы, низкоуровневая «обработка действий пользователя» в большинстве случаев становится достаточно простой для того чтобы с ней мог справится сам Вид. </p><br/>
<p>И для простых компонент это оказывается плюсом, потому как разделение функций ввода и вывода хорошо работает для интерфейса в целом или для сложных компонент. А в случае создания базовых ui-компонент, как пишут создатели Swing: "<em>this split didn't work well in practical terms because the view and controller parts of a component required a tight coupling (for example, it was very difficult to write a generic controller that didn't know specifics about the view)</em>".</p><br/>
<p>На самом деле и в SmallTalk-80 Виды и Контроллеры тоже были <strong>очень тесно связанными</strong>: Контроллер всегда содержал ссылку на Вид, а Вид на Контроллер. Кроме того, соответствующие классы Вида и Контроллера обычно еще и разрабатывались совместно: "<em>Поскольку классы вида и контроллера часто разрабатывались совместно, для многих подклассов вида был определен класс контроллера, используемого по умолчанию, и метод для получения его экземпляра – defaultControllerClass. И конкретный контроллер связанный с видом часто создавался автоматически просто как экземпляр такого класса</em>" [<em>Because view and controller classes are often designed in consort, a view's controller is often simply initialized to an instance of the corresponding controller class. To support this, the message defaultControllerClass, that returns the class of the appropriate controller, is defined in many of the subclasses of View</em> – Glenn Krasner ].</p><br/>
<p>Что еще делал Контроллер? Помимо обработки низкоуровневых действий пользователя и создания высокоуровневых событий, Контроллер также содержал "логику перевода этих высокоуровневых событий в соответствующие методы Модели". Но как мы выяснили в первой части статьи, Моделями в SmallTalk-80 являлись не сами доменные объекты а интерфейсы и фасады к ним, причем клиент ориентированные. Такие Модели-фасады изначально формировались (были заточена) под требования клиента, так что команды, которые Контроллер отображал в popup menu, практически всегда однозначно соответствовали методам Модели.</p><br/>
<p>Вот что пишет Краснер: "<em>В конце концов сообщения контроллера почти всегда напрямую передавались модели; это означает что в ответ на выбор пункта меню «aMessage» контроллеру посылалось сообщение aMessage и в результате почти всегда вызывался метод модели, который так и назывался «aMessage».</em>" [<em>Finally, the controller messages were almost always passed directly on to the model; that is, the method for message aMessage, which was sent to the controller when the menu item aMessage was selected, was almost always implemented as ↑model aMessage</em>].</p><br/>
<p>В конце своей статьи Краснер приводит несколько примеров из которых видно, что Контроллеры приложений были «пустыми» и не содержали никакой логики. Их создание сводилось к тому что нужно было указать названия команд, отображаемых в pop-up меню, а затем для каждого названия указать метод модели, который должен был вызываться.</p><br/>
<p>По сути это означает, что вся логика находилась в моделях: бизнес-логика – в доменной модели, логика перевода команд пользователя в команды системы – в моделях-фасадах, логика работы самого GUI – в ui-state моделях. От Контроллера требовалось лишь связать вызовы методов этих моделей с соответствующими высокоуровневыми событиями (нажатие кнопки, выбор пункта меню) а это настолько тривиально что и эту функцию тоже легко может выполнить сам Вид. </p><br/>
<p>Следующий важный шаг заключается в том, что в современных GUI библиотеках исчезла и существовавшая в smallTalk-80 классификация самих базовых ui-компонент по типу Вид или Контроллер. Как выяснилось далеко не все графические элементы были Видами: pop-up меню относились к Контроллеру, скроллбар и TextEdit просто были Контроллерами. </p><br/>
<p>Сейчас такое разделение не делается и мы имеем «ui-компоненты» или «виджеты», которые изначально проектируются так, чтобы быть универсальными – они одновременно могут отображать информацию и создавать высокоуровневые события, к которым удобно привязывать выполнение команд. И таким образом могут играть роль Вида или Контроллера в зависимости от контекста.</p><br/>
<p>Дело в том, что многие ui-компоненты оказались похожи на ParagraphEditor, о котором писал Стив Барбек – они одновременно могут отображать информацию и позволяют ее изменять, объединяя в себе функции Вида и Контроллера. Такими <strong>интерактивными</strong> элементами являются текстовые поля, формы, всевозможные переключатели (toggle button, radio button, check box) и аналоги скроллбара...</p><br/>
<p><img src="https://habrastorage.org/r/w780q1/files/4bc/b46/d69/4bcb46d6989b46c5a8cd109d333c92fc.jpg" alt="MVC" data-src="https://habrastorage.org/files/4bc/b46/d69/4bcb46d6989b46c5a8cd109d333c92fc.jpg" data-blurred="true"/></p><br/>
<p>Для таких компонент грань Вид или Контроллер оказывается размытой. Один и тот же элемент (объект) может быть Видом или Контроллером в зависимости от контекста в котором он используется и от того какую <strong>функцию</strong> он в данный момент выполняет. Список, используемый для отображения и ввода команд, являлся частью Контроллера (popUpMenu), а тот же список используемый для отображения данных – частью Вида (ListView). Аналогично — текстовое поле. </p><br/>
<p>Как напишет Реенскауг в своих более поздних работах: "<em>Модель, Вид и Контроллер это на самом деле <strong>роли</strong>, которые могут исполняться объектами</em>" (<em>Model, View and Controller are actually roles that can be played by the objects</em>… – <a href="http://www.artima.com/articles/dci_vision.html">The DCI Architecture: A New Vision of Object-Oriented Programming</a><em>)</em>.</p><br/>
<p>То, что в SmallTalk-80 <strong>сами объекты</strong> пытались поделить на Модели, Виды и Контроллеры, вызывало лишь ненужную путаницу, которая в частности проявлялось в том, что TextView для отображения посылал текст своему Контроллеру.</p><br/>
<p>Так осталось ли что нибудь от Контроллера? На мой взгляд да. То, что команды в систему вводятся "с помощью мыши и клавиатуры" это ведь тоже своего рода миф. В действительности Контроллер всегда предоставлял пользователю некие средства (как правило графические) <strong>помогающие</strong> вводить команды. Сначала это были текстовые редакторы, отображающие нажатые пользователем клавиши, затем pop-up меню, отображающие список доступных команд и дающие возможность вводить их «в один клик». Современные gui-библиотеки предоставляют уже целый арсенал средств — кнопки, переключатели, текстовые и графические меню, слайдеры… И вот эта часть работы Контроллера – поиск все более наглядных, удобных и «интуитивно понятных» средств/форм для ввода команд и управления системами, продолжает быть актуальной. И каждый раз когда мы разрабатываем интерфейс или ui-компонент мы явно или неявно ее решаем. </p><br/>
<h2 id="interfeys-kak-composite">Интерфейс как Composite</h2><br/>
<p>Еще одна важная идея, которая безусловно осталась – это понимание того, что интерфейс нужно делить на модули, а не делать единым блоком или страницей. </p><br/>
<p>Как видно из примеров, большинство интерфейсов были составными и включали в себя множество Видов и Контроллеров.</p><br/>
<p>Для обозначения подобных сложно-составных Интерфейсов Реенскауг в своей второй более поздней работе использует специальный термин "Tool" (инструмент пользователя) и у него этой теме посвящен отдельный раздел, который так и называется “<strong>Tool as a Composite</strong>”.</p><br/>
<p><img src="https://habrastorage.org/r/w1560/files/f17/9a4/842/f179a4842aa749de9898f6c3d17f265c.png" alt="Reenskaug MVC" data-src="https://habrastorage.org/files/f17/9a4/842/f179a4842aa749de9898f6c3d17f265c.png"/></p><br/>
<p>На рисунке в качестве Tool приведен уже знакомый нам интерфейс из первого доклада Реенскауга состоящий из трех блоков (которые Реенскауг называет Editor). И вот что по этому поводу пишет Реенскауг:</p><br/>
<ul>
<li><em>The Model that is responsible for representing state, structure, and behavior of the user’s mental model.</em></li>
<li><em>One or more Editors that present relevant information in a suitable way and support the editing of this information when applicable.</em></li>
<li><em>A Tool that sets up the Editors and coordinates their operation. (E.g., the selection of a model object that is visible in several Editors).</em></li>
</ul><br/>
<p><em>Complex Editors may again be subdivided into a View and a Controller.This solution is a composite pattern.</em> </p><br/>
<p>Как видите, шаблон <em>Composite</em> у Реенскауга относится ко всему интерфейсу, а вовсе не к Виду. Откуда же взялась идея что <em>Composite</em> в MVC относится исключительно к Виду? </p><br/>
<p>Все просто – поскольку в SmallTalk-80 с каждым Видом <strong>обязательно</strong> был связан свой Контроллер, то <strong>в явном виде</strong> композиция там действительно задавалась только для Видов, а соответствующая композиция (иерархия) Контроллеров просто «вычислялась»: "<em>Since each view is associated with a unique controller, the view/subView tree induces a parallel controller tree within each topView</em>". Это решение было не особо удачным и приводило к хрупкости системы – стоило какой-нибудь Вид оставить без Контроллера и вся система рушилась. Поэтому в SmallTalk-80 был придуман «костыль» – Контроллер, который назывался «NoController». Этот контроллер ничего не делал и по умолчанию связывался с Видами, которые “исключительно отображали информацию” и не нуждались в контроллере. Его единственное назначение состояло в том, чтобы цепочка контроллеров, соответствующих Видам, не прерывалась. (подробно можно почитать У Стива Барбека в разделе “Communication Between Controllers”).</p><br/>
<p>Так что в действительности и в SmallTalk-80 и у Реенскауга пользовательский интерфейс всегда включал в себя не только композицию Видов, но и точно такую же композицию соответствующих им Контроллеров. </p><br/>
<p>И если уж говорить о шаблоне <em>Composite</em>, то, конечно же, более корректно относить его не к Виду а ко всему пользовательскому интерфейсу, как это сделано у Реенскауга и как это делается в современных GUI библиотеках. Интерфейсы больших приложений делятся на «gui-компоненты» или виджеты, которые в свою очередь могут делиться на более простые компоненты и образовывать древовидную структуру. </p><br/>
<p>Каждый такой gui-компонент является автономным модулем, который одновременно отображает некую информацию и обрабатывает относящиеся к нему действия пользователя, порождая высокоуровневые события к которым удобно привязывать выполнение команд (View+Controller). Также он инкапсулирует свою логику работы как правило в виде внутренней GUI-state модели. То есть по сути представляет собой MVC (или «упрощенный MVC»). И вот такие полноценные gui-компоненты уже действительно можно разрабатывать параллельно и независимо, а также переиспользовать. </p><br/>
<p>Следствием шаблона <em>Composite</em> и того, что каждый gui-компонент может быть реализован в виде небольшого MVC, является некая <strong>иерархичность</strong> или <strong>рекурсивность</strong> MVC. Из-за того что об этом редко пишут, аналоги этой идеи тоже пере-открываются. Вот известная статья на эту тему – <a href="http://www.javaworld.com/article/2076128/design-patterns/hmvc--the-layered-pattern-for-developing-strong-client-tiers.html?page=2">Hierarchical model–view–controller</a> и интересная дискуссия – <a href="http://c2.com/cgi/wiki?RecursiveModelViewController">Recursive Model View Controller</a>. А вот картинка из статьи:</p><br/>
<p><img src="https://habrastorage.org/r/w1560/files/27a/745/695/27a7456952f64302afb70197c9fd4cf0.gif" alt="Hierarchical model–view–controller" data-src="https://habrastorage.org/files/27a/745/695/27a7456952f64302afb70197c9fd4cf0.gif"/></p><br/>
<p>На практике построение интерфейсов из независимых и полноценных ui-компонент активно использует и развивает ebay. Подробно об этом можно почитать в их замечательной статье <a href="http://www.ebaytechblog.com/2014/10/02/dont-build-pages-build-modules/">Don’t Build Pages, Build Modules</a>: "<em>Когда дело касается view люди все еще мыслят страницами вместо того чтобы строить UI модули. Мы обнаружили что с ростом сложности страниц их становится экспоненциально сложнее поддерживать. Что мы хотим это разделить страницу на маленькие управляемые части, каждую из которых можно разрабатывать независимо. Мы хотим уйти от идеи непосредственно строить страницы. Вместо этого мы разбиваем страницу на логические UI модули и делаем это рекурсивно до тех пор пока модуль не станет <a href="http://addyosmani.com/first/"> FIRST</a>. Это означает что страница строится из высокоуровневых модулей, которые в свою очередь строятся из подмодулей</em>".</p><br/>
<p><img src="https://habrastorage.org/r/w1560/files/23b/c9c/e6d/23bc9ce6d9014255a5b86fe76cf7aacf.png" alt="MVC" data-src="https://habrastorage.org/files/23b/c9c/e6d/23bc9ce6d9014255a5b86fe76cf7aacf.png"/></p><br/>
<h2 id="summiruya">Суммируя</h2><br/>
<p>Я вовсе не хочу сказать что «original MVC» единственно правильный. Моя цель состояла лишь в том, чтобы показать, что он был намного сложнее и богаче чем те упрощенные схемки, которые нам обычно преподносятся в качестве MVC. Создавать на их основе реальные приложения это все равно что строить самолет на основе схем из детского конструктора и удивляться что он не летает. С другой стороны, если рассматривать MVC не как схему, а прежде всего, как набор архитектурных идей, то он действительно становится прост, логичен и очень понятен, и буквально выводится из этих идей. </p><br/>
<p>И когда есть понимание, что же именно делается, с помощью каких «инструментов», ради чего, то тогда MVC перестает быть «догмой» и его можно варьировать в зависимости от потребностей конкретного проекта. Да и термины становятся не так важны. </p><br/>
<p>Когда я слышу или читаю про фронт-контроллер или что "контроллер это единая точка входа в систему", то мне понятно что термином Контроллер у этих ребят называется Фасад. И это вовсе не означает что их архитектура неправильная. Наоборот, как минимум хорошо, что у них Фасад вообще есть, ну а дальше нужно смотреть, как он реализован, не оттягивает ли на себя реализацию бизнес логики и тп </p><br/>
<p>Когда говорится, что Контроллер это бизнес-логика, то и это не страшно… Просто принимаешь что в этом случае Контроллером называется доменная модель. Важно не то, как она называется, а то как она реализована и отделена ли от пользовательского интерфейса. </p><br/>
<p>Термин Вид часто используют как синоним термина Пользовательский Интерфейс. Так тоже "можно". </p><br/>
<p>Дело ведь не в терминах, а в сути. Мне кажется, что корень большинства проблем заключается в том, что как раз о сути MVC мало кто пишет. Вместо этого термины Модель, Вид и Контроллер вырываются из контекста архитектурных идей, им даются какие-то формальные определения, а затем они нередко применяются для обозначения модулей в некачественной декомпозиции, навешивается шаблон <em>Наблюдатель</em> и все это преподносится под «брендом MVC».</p><br/>
<p>Как писал Вирт: "<em>Самой трудной проектной задачей является нахождение наиболее адекватной декомпозиции системы на иерархически выстроенные модули, с минимизацией функций и дублирования кода</em>". </p><br/>
<p>Поэтому основная мысль, которую мне хотелось донести, заключается в том, что MVC он не про Модель, Вид и Контроллер, не про то как они связаны между собой и не про шаблон <em>Наблюдатель</em>. MVC он про то, как нужно грамотно разбивать систему на функционально осмысленные модули, слабо связанные друг с другом и полезные сами по себе. Модули, которые на самом деле можно разрабатывать и использовать независимо, переиспользовать… Что собственно и является основой любой хорошей архитектуры.</p><br/>
<p>А Модель, Вид и Контроллер это всего лишь результат <strong>начальной декомпозиции</strong>, предложенной нам талантливыми людьми. Также как паттерны <em>Фасад</em>, <em>Наблюдатель, Компоновщик</em> — это просто инструменты, которые ими были использованы для ослабления связанности и уменьшения сложности.</p><br/>
<p>Спасибо всем кто «дотянул» до конца. Будем очень признательны за обоснованную критику. Особенно интересно мнение людей близко знакомых со SmallTalk.</p></div></div></div> <DIV class="v-portal" style="display:none;"></DIV></div> <!----> <!----></div> <div class="tm-article-presenter__meta"><div class="tm-separated-list tm-article-presenter__meta-list"><span class="tm-separated-list__title">Теги:</span> <ul class="tm-separated-list__list"><li class="tm-separated-list__item"><a href="https://habr.com/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5BMVC%5D" class="tm-tags-list__link">MVC</a></li><li class="tm-separated-list__item"><a href="https://habr.com/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5B%D0%B0%D1%80%D1%85%D0%B8%D1%82%D0%B5%D0%BA%D1%82%D1%83%D1%80%D0%B0%20%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D0%B9%5D" class="tm-tags-list__link">архитектура приложений</a></li></ul></div> <div class="tm-separated-list tm-article-presenter__meta-list"><span class="tm-separated-list__title">Хабы:</span> <ul class="tm-separated-list__list"><li class="tm-separated-list__item"><a href="https://habr.com/ru/hub/analysis_design/" class="tm-hubs-list__link">
    Анализ и проектирование систем
  </a></li><li class="tm-separated-list__item"><a href="https://habr.com/ru/hub/refactoring/" class="tm-hubs-list__link">
    Проектирование и рефакторинг
  </a></li></ul></div></div></article></div> <!----></div> <div class="tm-article-sticky-panel"><div class="tm-data-icons tm-article-sticky-panel__icons"><div class="tm-article-rating tm-data-icons__item"><div class="tm-votes-meter tm-article-rating__votes-switcher"><svg height="24" width="24" class="tm-svg-img tm-votes-meter__icon tm-votes-meter__icon_appearance-article"><title>Всего голосов 19: ↑19 и ↓0</title> <use xlink:href="/img/megazord-v25.4b679db1.svg#counter-rating"></use></svg> <span title="Всего голосов 19: ↑19 и ↓0" class="tm-votes-meter__value tm-votes-meter__value_positive tm-votes-meter__value_appearance-article tm-votes-meter__value_rating">+19</span></div> <DIV class="v-portal" style="display:none;"></DIV></div> <!----> <span title="Количество просмотров" class="tm-icon-counter tm-data-icons__item"><svg height="24" width="24" class="tm-svg-img tm-icon-counter__icon"><title>Просмотры</title> <use xlink:href="/img/megazord-v25.4b679db1.svg#counter-views"></use></svg> <span class="tm-icon-counter__value">33K</span></span> <button title="Добавить в закладки" type="button" class="bookmarks-button tm-data-icons__item"><span title="Добавить в закладки" class="tm-svg-icon__wrapper bookmarks-button__icon"><svg height="24" width="24" class="tm-svg-img tm-svg-icon"><title>Добавить в закладки</title> <use xlink:href="/img/megazord-v25.4b679db1.svg#counter-favorite"></use></svg></span> <span title="Количество пользователей, добавивших публикацию в закладки" class="bookmarks-button__counter">
    230
  </span></button> <!----> <div title="Поделиться" class="tm-sharing tm-data-icons__item"><button type="button" class="tm-sharing__button"><svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" class="tm-sharing__icon"><path fill="currentColor" d="M13.8 13.8V18l7.2-6.6L13.8 5v3.9C5 8.9 3 18.6 3 18.6c2.5-4.4 6-4.8 10.8-4.8z"></path></svg></button> <DIV class="v-portal" style="display:none;"></DIV></div> <DIV class="v-portal" style="display:none;"></DIV></div> </div></div> <DIV class="v-portal" style="display:none;"></DIV> <div class="tm-article-presenter__footer"><div class="tm-article-blocks"><!----> <section class="tm-block tm-block_spacing-bottom"><!----> <div class="tm-block__body tm-block__body_variant-balanced"><div class="tm-article-author"> <div class="tm-user-card tm-article-author__user-card tm-user-card_variant-article"><div class="tm-user-card__info-container"><div class="tm-user-card__header"><div class="tm-user-card__header-data"><a href="https://habr.com/ru/users/cobiot/" class="tm-user-card__userpic tm-user-card__userpic_size-40"><div class="tm-entity-image"><svg class="tm-svg-img tm-image-placeholder tm-image-placeholder_blue"><!----> <use xlink:href="/img/megazord-v25.4b679db1.svg#placeholder-user"></use></svg></div></a> <div class="tm-user-card__meta"><div title=" 105 голосов " class="tm-karma tm-user-card__karma"><div class="tm-karma__votes tm-karma__votes_positive">
    97
  </div> <div class="tm-karma__text">
    Карма
  </div></div> <div title="Рейтинг пользователя" class="tm-rating tm-user-card__rating"><div class="tm-rating__header"> <div class="tm-rating__counter">0</div></div> <div class="tm-rating__text">
    Рейтинг
  </div></div></div></div></div> <div class="tm-user-card__info tm-user-card__info_variant-article"><div class="tm-user-card__title tm-user-card__title_variant-article"><!----> <a href="https://habr.com/ru/users/cobiot/" class="tm-user-card__nickname tm-user-card__nickname_variant-article">
          @cobiot
        </a> <!----></div> <p class="tm-user-card__short-info tm-user-card__short-info_variant-article">Пользователь</p></div></div> <div class="tm-user-card__buttons tm-user-card__buttons_variant-article"><!----> <!----> <!----> <!----> <!----></div></div> <!----></div> <DIV class="v-portal" style="display:none;"></DIV></div> <!----></section> <div class="tm-article-blocks__comments"><div class="tm-article-page-comments"><div class="tm-article-comments-counter-link tm-article-comments-counter-button"><a href="https://habr.com/ru/post/322700/comments/" class="tm-article-comments-counter-link__link tm-article-comments-counter-link__link_button-style"><svg height="24" width="24" class="tm-svg-img tm-article-comments-counter-link__icon tm-article-comments-counter-link__icon_contrasted"><title>Комментарии</title> <use xlink:href="/img/megazord-v25.4b679db1.svg#counter-comments"></use></svg> <span class="tm-article-comments-counter-link__value tm-article-comments-counter-link__value_contrasted">
       Комментарии 31 
    </span></a> <!----></div></div></div> <div class="tm-ad-banner__container tm-page-article__banner"><!----> <div id="articleBottomBanner927" class="tm-ad-banner"></div></div> <!----> <!----> <!----> <!----> </div></div></div></div></div> <div class="tm-page__sidebar"><div class="tm-layout-sidebar"><div class="tm-layout-sidebar__ads tm-layout-sidebar__ads_initial"><div class="tm-ad-banner__container tm-layout-sidebar__banner"><!----> <div id="sidebarBanner928" class="tm-ad-banner"></div></div></div> <div class="tm-sexy-sidebar tm-sexy-sidebar_initial" style="margin-top:0px;"><!----> <section data-async-called="true" class="tm-block tm-block_spacing-bottom"><header class="tm-block__header"><h2 class="tm-block__title">Работа</h2> <!----></header> <div class="tm-block__body"><div class="tm-vacancies-block__item"><a href="https://career.habr.com/vacancies/sistemnij_analitik" target="_blank" class="tm-vacancies-block__vacancy-title">
        Cистемный аналитик
      </a> <div class="tm-vacancies-block__vacancies-count">
        415
    вакансий
      </div></div></div> <footer class="tm-block__footer"><a href="https://career.habr.com/catalog" class="tm-block-extralink">
      Все вакансии
    </a></footer></section></div></div></div></div></div></div></main> <!----></div> <div class="tm-footer-menu"><div class="tm-page-width"><div class="tm-footer-menu__container"><div class="tm-footer-menu__block"><h3 class="tm-footer-menu__block-title">
          Ваш аккаунт
        </h3> <div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><li class="tm-footer-menu__list-item"><a href="https://habr.com/kek/v1/auth/habrahabr/?back=/ru/post/322700/&amp;hl=ru" rel="nofollow" target="_self">
                Войти
              </a></li><li class="tm-footer-menu__list-item"><a href="https://habr.com/kek/v1/auth/habrahabr-register/?back=/ru/post/322700/&amp;hl=ru" rel="nofollow" target="_self">
                Регистрация
              </a></li></ul></div></div><div class="tm-footer-menu__block"><h3 class="tm-footer-menu__block-title">
          Разделы
        </h3> <div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><li class="tm-footer-menu__list-item"><a href="https://habr.com/ru/" class="footer-menu__item-link router-link-active">
                Публикации
              </a></li><li class="tm-footer-menu__list-item"><a href="https://habr.com/ru/news/" class="footer-menu__item-link">
                Новости
              </a></li><li class="tm-footer-menu__list-item"><a href="https://habr.com/ru/hubs/" class="footer-menu__item-link">
                Хабы
              </a></li><li class="tm-footer-menu__list-item"><a href="https://habr.com/ru/companies/" class="footer-menu__item-link">
                Компании
              </a></li><li class="tm-footer-menu__list-item"><a href="https://habr.com/ru/users/" class="footer-menu__item-link">
                Авторы
              </a></li><li class="tm-footer-menu__list-item"><a href="https://habr.com/ru/sandbox/" class="footer-menu__item-link">
                Песочница
              </a></li></ul></div></div><div class="tm-footer-menu__block"><h3 class="tm-footer-menu__block-title">
          Информация
        </h3> <div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><li class="tm-footer-menu__list-item"><a href="https://habr.com/ru/docs/help/" class="footer-menu__item-link">
                Устройство сайта
              </a></li><li class="tm-footer-menu__list-item"><a href="https://habr.com/ru/docs/authors/codex/" class="footer-menu__item-link">
                Для авторов
              </a></li><li class="tm-footer-menu__list-item"><a href="https://habr.com/ru/docs/companies/corpblogs/" class="footer-menu__item-link">
                Для компаний
              </a></li><li class="tm-footer-menu__list-item"><a href="https://habr.com/ru/docs/docs/transparency/" class="footer-menu__item-link">
                Документы
              </a></li><li class="tm-footer-menu__list-item"><a href="https://account.habr.com/info/agreement" target="_blank">
                Соглашение
              </a></li><li class="tm-footer-menu__list-item"><a href="https://account.habr.com/info/confidential/" target="_blank">
                Конфиденциальность
              </a></li></ul></div></div><div class="tm-footer-menu__block"><h3 class="tm-footer-menu__block-title">
          Услуги
        </h3> <div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><li class="tm-footer-menu__list-item"><a href="https://docs.google.com/presentation/d/e/2PACX-1vQLwRfQmXibiUlWaRg-BAc38s7oM3lJiaPju7qmdJsp8ysIvZ_G-Npem0njJLMozE2bPHMpDqiI5hhy/pub?start=false&amp;loop=false&amp;delayms=60000&amp;slide=id.g91a03369cd_4_297" target="_blank">
                Реклама
              </a></li><li class="tm-footer-menu__list-item"><a href="https://habrastorage.org/storage/stuff/habr/service_price.pdf" target="_blank">
                Тарифы
              </a></li><li class="tm-footer-menu__list-item"><a href="https://docs.google.com/presentation/d/e/2PACX-1vQJJds8-Di7BQSP_guHxICN7woVYoN5NP_22ra-BIo4bqnTT9FR6fB-Ku2P0AoRpX0Ds-LRkDeAoD8F/pub?start=false&amp;loop=false&amp;delayms=60000" target="_blank">
                Контент
              </a></li><li class="tm-footer-menu__list-item"><a href="https://tmtm.timepad.ru/" target="_blank">
                Семинары
              </a></li><li class="tm-footer-menu__list-item"><a href="https://habr.com/ru/megaprojects/" class="footer-menu__item-link">
                Мегапроекты
              </a></li></ul></div></div></div></div></div> <div class="tm-footer"><div class="tm-page-width"><div class="tm-footer__container"><!----> <div class="tm-footer__social"><a href="https://www.facebook.com/habrahabr.ru" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Facebook</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-facebook"></use></svg></a><a href="https://twitter.com/habr_com" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Twitter</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-twitter"></use></svg></a><a href="https://vk.com/habr" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>VK</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-vkontakte"></use></svg></a><a href="https://telegram.me/habr_com" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Telegram</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-telegram"></use></svg></a><a href="https://www.youtube.com/channel/UCd_sTwKqVrweTt4oAKY5y4w" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Youtube</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-youtube"></use></svg></a><a href="https://zen.yandex.ru/habr" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Яндекс Дзен</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-zen"></use></svg></a></div> <DIV class="v-portal" style="display:none;"></DIV> <button class="tm-footer__link"><!---->
        Настройка языка
      </button> <a href="https://habr.com/ru/about" class="tm-footer__link">
        О сайте
      </a> <a href="https://habr.com/ru/feedback/" class="tm-footer__link">
        Техническая поддержка
      </a> <!----> <a href="https://habr.com/berserk-mode-nope" class="tm-footer__link">
        Вернуться на старую версию
      </a> <div class="tm-footer-copyright"><span class="tm-copyright"><span class="tm-copyright__years">© 2006–2022 </span> <span class="tm-copyright__name">«<a href="https://company.habr.com/" rel="noopener" target="_blank" class="tm-copyright__link">Habr</a>»</span></span></div></div></div></div> <!----> <!----></div> <div class="vue-portal-target"></div></div>
<script>window.__INITIAL_STATE__={"adblock":{"hasAcceptableAdsFilter":false,"hasAdblock":false},"articlesList":{"articlesList":{"322700":{"id":"322700","timePublished":"2017-02-27T12:39:31+00:00","isCorporative":false,"lang":"ru","titleHtml":"Охота на мифический MVC. Построение пользовательского интерфейса","leadData":{"textHtml":"\u003Ch2 id=\"detektiv-po-materialam-it-chast-vtoraya\"\u003EДетектив по материалам IT. Часть вторая\u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EВ этой части я покажу как изначально выглядело деление пользовательского интерфейса и что из себя представляли Вид и Контроллер. Попробую рассказать почему в современных GUI библиотеках используется их объединение и какие вообще интересные решения можно найти в этой области на сегодняшний день. Ссылки на первоисточники приведены в начале \u003Ca href=\"https:\u002F\u002Fhabrahabr.ru\u002Fpost\u002F321050\u002F\"\u003Eпервой части\u003C\u002Fa\u003E.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EНачну с Вида. Не смотря на то, что Вид определяется как модуль, отображающий Модель – &quot;\u003Cem\u003Eа view is a (visual) representation of its model\u003C\u002Fem\u003E&quot;, на \u003Cstrong\u003Eпрактике\u003C\u002Fstrong\u003E к Виду, как правило, просто относят все графические элементы GUI, то есть Видом считается все то, что мы \u003Cstrong\u003Eвидим\u003C\u002Fstrong\u003E на экране ЭВМ. \u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EПонятно, что тут содержится некое противоречие, поскольку такие графические компоненты как меню, кнопки, тулбары служат не для отображения информации о системе, а прежде всего для управления системой. Клавиатура и мышь всегда были средством управления программой и находились в «ведомости» Контроллера (как бы его не трактовали). Поэтому кажется нелогичным и странным, что кнопки, сделанные из пластмассы, считаются элементами управления и относятся к Контроллеру, а кнопки, нарисованные на экране, и по сути выполняющие те же самые функции (производить входящие события), почему то относят к Виду. \u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Ffiles\u002F457\u002Fd0d\u002Fd26\u002F457d0dd26f0947158968cabee4283fec.png\" alt=\"View or Controller\"\u002F\u003E\u003C\u002Fp\u003E","imageUrl":null,"buttonTextHtml":"Читать дальше &rarr;","image":null},"editorVersion":"1.0","postType":"article","postLabels":[],"author":{"scoreStats":{"score":97,"votesCount":105},"rating":0,"relatedData":null,"contacts":[],"authorContacts":[],"paymentDetails":{"paymentYandexMoney":null,"paymentPayPalMe":null,"paymentWebmoney":null},"id":"1160794","alias":"cobiot","fullname":null,"avatarUrl":null,"speciality":null},"statistics":{"commentsCount":31,"favoritesCount":230,"readingCount":33004,"score":19,"votesCount":19},"hubs":[{"relatedData":null,"id":"397","alias":"analysis_design","type":"collective","title":"Анализ и проектирование систем","titleHtml":"Анализ и проектирование систем","isProfiled":true},{"relatedData":null,"id":"7504","alias":"refactoring","type":"collective","title":"Проектирование и рефакторинг","titleHtml":"Проектирование и рефакторинг","isProfiled":true}],"flows":[{"id":"1","alias":"develop","title":"Разработка"}],"relatedData":null,"textHtml":"\u003Cdiv xmlns=\"http:\u002F\u002Fwww.w3.org\u002F1999\u002Fxhtml\"\u003E\u003Ch2 id=\"detektiv-po-materialam-it-chast-vtoraya\"\u003EДетектив по материалам IT. Часть вторая\u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EВ этой части я покажу как изначально выглядело деление пользовательского интерфейса и что из себя представляли Вид и Контроллер. Попробую рассказать почему в современных GUI библиотеках используется их объединение и какие вообще интересные решения можно найти в этой области на сегодняшний день. Ссылки на первоисточники приведены в начале \u003Ca href=\"https:\u002F\u002Fhabrahabr.ru\u002Fpost\u002F321050\u002F\"\u003Eпервой части\u003C\u002Fa\u003E.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EНачну с Вида. Не смотря на то, что Вид определяется как модуль, отображающий Модель – \"\u003Cem\u003Eа view is a (visual) representation of its model\u003C\u002Fem\u003E\", на \u003Cstrong\u003Eпрактике\u003C\u002Fstrong\u003E к Виду, как правило, просто относят все графические элементы GUI, то есть Видом считается все то, что мы \u003Cstrong\u003Eвидим\u003C\u002Fstrong\u003E на экране ЭВМ. \u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EПонятно, что тут содержится некое противоречие, поскольку такие графические компоненты как меню, кнопки, тулбары служат не для отображения информации о системе, а прежде всего для управления системой. Клавиатура и мышь всегда были средством управления программой и находились в «ведомости» Контроллера (как бы его не трактовали). Поэтому кажется нелогичным и странным, что кнопки, сделанные из пластмассы, считаются элементами управления и относятся к Контроллеру, а кнопки, нарисованные на экране, и по сути выполняющие те же самые функции (производить входящие события), почему то относят к Виду. \u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw1560\u002Ffiles\u002F457\u002Fd0d\u002Fd26\u002F457d0dd26f0947158968cabee4283fec.png\" alt=\"View or Controller\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Ffiles\u002F457\u002Fd0d\u002Fd26\u002F457d0dd26f0947158968cabee4283fec.png\"\u002F\u003E\u003C\u002Fp\u003E\u003Ca name=\"habracut\"\u003E\u003C\u002Fa\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EКроме того, поскольку разумно считается что в графических элементах не хорошо «прописывать логику», то отсюда часто делается вывод, что Вид должен быть тонким и тупым (dumb View) и соответственно логику работы интерфейса можно обнаружить в самых неожиданных местах, вплоть до доменной модели (даже Фаулер пишет о «загрязнении» Модели настройками интерфейса \u003Ca href=\"https:\u002F\u002Fhabrahabr.ru\u002Fpost\u002F53536\u002F\"\u003EGUI Architectures\u003C\u002Fa\u003E).\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EИ вновь для того, чтобы прояснить ситуацию предлагаю обратиться к «архитектурным принципам» и первоисточникам. Когда речь идет о декомпозиции то одно из основных «архитектурных» правил заключается в том, что делить на модули нужно прежде всего исходя из тех \u003Cstrong\u003Eзадач\u003C\u002Fstrong\u003E, которые решает система. Каждый модуль должен отвечать за решение какой-то определенной задачи (желательно одной) и выполнять соответствующую ей функцию. \u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EСоответственно, для того, чтобы понять как следует делить пользовательский интерфейс на модули, в первую очередь надо проанализировать что он делает и какие задачи решает. Ведь интерфейс это \u003Cstrong\u003Eфункция\u003C\u002Fstrong\u003E, а не графические элементы. И функция эта заключается в том, чтобы обеспечивать \u003Cstrong\u003Eвзаимо-действие\u003C\u002Fstrong\u003E пользователя с системой. Что означает:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Col\u003E\r\n\u003Cli\u003E\u003Cstrong\u003Eвыводить\u003C\u002Fstrong\u003E и удобно отображать пользователю информацию о системе\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Cstrong\u003Eвводить\u003C\u002Fstrong\u003E данные и команды пользователя в систему (передавать их системе)\u003C\u002Fli\u003E\r\n\u003C\u002Fol\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EТо есть, в общем случае пользовательский интерфейс является \u003Cstrong\u003Eдвунаправленным\u003C\u002Fstrong\u003E и решает \u003Cstrong\u003Eдве\u003C\u002Fstrong\u003E задачи, одна из которых связана с \u003Cstrong\u003Eвыводом\u003C\u002Fstrong\u003E и представлением информации, а вторая – с \u003Cstrong\u003Eвводом\u003C\u002Fstrong\u003E команд и данных. Вот эти-то задачи и определяют то, как нужно делить интерфейс на модули. Вновь смотрим картинку из первоисточника (Реенскауг):\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw1560\u002Ffiles\u002F3b4\u002F81a\u002F6e1\u002F3b481a6e1e88416f943593d5a20ee4e4.png\" alt=\"View Controller Separation\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Ffiles\u002F3b4\u002F81a\u002F6e1\u002F3b481a6e1e88416f943593d5a20ee4e4.png\"\u002F\u003E\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EКак видно \u003Cstrong\u003Eпользовательский интерфейс\u003C\u002Fstrong\u003E довольно естественно и логично делится на два относительно независимых \u003Cstrong\u003Eфункциональных\u003C\u002Fstrong\u003E модуля. Причем такое функциональное деление, основанное на решаемых задачах, универсально. Не важно звуковой это интерфейс, графический или сенсорный в нем должен быть модуль, отвечающий за \u003Cstrong\u003EВвод\u003C\u002Fstrong\u003E управляющих команд и данных (отсюда и название Controller — управление), и модуль отвечающий \u003Cstrong\u003EВывод\u003C\u002Fstrong\u003E и представление информации о системе и о том что в ней происходит (View — Вид, представление). \u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EА теперь давайте посмотрим, как же деление Вид\u002FКонтроллер \u003Cstrong\u003Eвыглядело\u003C\u002Fstrong\u003E на практике. И для того чтобы это сделать нам потребуется небольшой экскурс в историю. Дело в том, что вначале термина \u003Cstrong\u003ECONTROLLER\u003C\u002Fstrong\u003E вообще не существовало. Вместо него Реенскауг использовал термин \u003Cstrong\u003EEDITOR\u003C\u002Fstrong\u003E (\u003Cstrong\u003EMODEL-VIEW-EDITOR)\u003C\u002Fstrong\u003E и писал о разделении пользовательского интерфейса на View и Editor. \"\u003Cem\u003EThe hardest part was to hit upon good names for the different architectural components. Model-View-Editor was the first set.\u003C\u002Fem\u003E\"(Trygve Reenskaug). Попробую объяснить почему. \u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EНе смотря на наличие технических возможностей (растровые экраны) во времена создания MVC и SmallTalk пользовательские интерфейсы преимущественно все еще оставались командными (\u003Cem\u003ECommand-driven Interface\u003C\u002Fem\u003E) и представляли собой по сути обычные текстовые редакторы. В SmallTalk интерфейс так и назывался – Editor. И вот как он выглядел:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw1560\u002Ffiles\u002Fe8e\u002F65f\u002F800\u002Fe8e65f800a7647dcb85dfe36a6aa1735.png\" alt=\"SmallTalk Editor\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Ffiles\u002Fe8e\u002F65f\u002F800\u002Fe8e65f800a7647dcb85dfe36a6aa1735.png\"\u002F\u003E\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EМожно сказать что Editor объединял в себе функции Контроллера и Вида. Он давал возможность относительно удобно вводить команды и данные (отображая нажатые клавиши и обрабатывая ввод с клавиатуры), и одновременно выводил информацию о выполнении команд и вообще о том что происходит в системе. \u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EЛишь постепенно этот Editor преобразовывался в то, что мы сейчас привыкли понимать под GUI. \u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EВначале возникла простая но весьма плодотворная идея – разделить единое окно на множество панелей. Парадигма многопанельности появились существенно раньше MVC (многопанельные браузеры точно присутствовали уже в Smalltalk-76) и была значительным продвижением сама по себе. Она до сих пор активно используется практически во всех текстовых интерфейсах. \u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EРеенскауг ее, естественно, тоже использовал. Тут нужно иметь в виду, что Dynabook, вокруг которого в Xerox Parc создавались и smallTalk и графические интерфейсы и, в частности, MVC, задумывался как «детский компьютер». Поэтому стояла задача сделать работу с компьютерными программами доступной любому неподготовленному пользователю, в частности ребенку. Реенскауг исходил из того, что пользователь может вообще ничего не знать о программе и о том как она устроена. И для того чтобы он мог с программой взаимодействовать нужно каким-то образом отобразить ему основную информацию о системе и доменной модели, лежащей в ее основе, чтобы пользователь понимал с чем имеет дело. \u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EВыводилась такая информация на отдельных панелях, которые собственно и стали называться View. Как правило доменная модель отображалась при помощи нескольких различных Видов: \"\u003Cem\u003EMVC задумывался как общее решение, дающее возможность пользователям контролировать большие и сложные наборы данных… Он особенно полезен тогда, когда пользователю нужно видеть Модель одновременно в разных контекстах и\u002Fили с разных точек зрения.\u003C\u002Fem\u003E\" И поскольку Реенскауг считал, что графическое представление информации нагляднее чем текстовое, то в основном виды у него представляли собой разного рода графики и диаграммы.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EДалее. Так как пользователь ничего (или почти ничего) не знает о системе, а видит лишь всевозможные View, удобно и наглядно отображающие нужную ему информацию, то соответственно и управление системой должно было выглядеть так, как если бы пользователь управлял непосредственно самими View и тем что на них отображено. Поэтому для ввода команд стал использоваться не один «general Editor», а целое множество специализированных редакторов, каждый из которых был связан со своим Видом и был заточен на ввод команд (взаимодействие с доменной моделью) лишь в контексте этого Вида – \u003Cem\u003Epermits the user to modify the information that is presented by the view\u003C\u002Fem\u003E. \u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EТаким образом, если для специалиста интерфейсом обычно служил некий общий редактор, дающий возможность вводить в систему любые команды (но для этого нужно было штудировать мануалы, знать команды и понимать, как система работает), то для неподготовленного пользователя минимальным интерфейсом становится пара – View и связанный с ней специализированный Editor (который собственно и будет впоследствии переименован в Контроллер). Такой интерфейс предоставлял весьма редуцированный набор команд и возможностей, зато им можно было пользоваться без предварительной подготовки. \u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EПервый доклад Реенскауга так и назывался: \"THING-MODEL-VIEW-EDITOR. An Example from a planning system\". В нем была представлена первая реализация MVC на примере системы планирования и управления неким большим проектом (своего рода task-manager). Доменной моделью являлась сеть (network) «активностей», которая описывала \u003Cem\u003Eчто\u003C\u002Fem\u003E должно быть сделано (активность), в каком порядке, за какое время, \u003Cem\u003Eкто\u003C\u002Fem\u003E в каких активностях участвует и какие ресурсы для каждой активности требуются. Пример призван был показать что “\u003Cem\u003Eодна Модель может быть отображена с помощью многих различных Видов”\u003C\u002Fem\u003E и вот как там выглядел пользовательский интерфейс: \u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw1560\u002Ffiles\u002F94f\u002F595\u002Ffcb\u002F94f595fcb6e74732a8bb7fe8357da110.png\" alt=\"Reenskaug MVC\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Ffiles\u002F94f\u002F595\u002Ffcb\u002F94f595fcb6e74732a8bb7fe8357da110.png\"\u002F\u003E\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EДоменная модель отображалась с помощью трех различных диаграмм (Видов). Нужно отметить, что виды и у Реенскауга и в SmallTalk вовсе не были \"пассивными\", они самостоятельно обрабатывали относящиеся к ним действия пользователя, в частности позволяли делать скроллинг и выделение элементов: “\u003Cem\u003EA ListView has fields where it remembers its frame, a list of textual items and a possible selection within the list. It is able to display its list on the screen within its frame, and reacts to messages asking it to scroll itself.\u003C\u002Fem\u003E” Это важный момент и я еще к нему вернусь.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EПервая диаграмма отображает множество активностей, относящихся к некоторому проекту\u002Fсети и связи между ними. Подобно тому, как список позволяет выбрать\u002Fвыделить некий свой элемент, данная диаграмма позволяла выбрать некую активность. С диаграммой связан редактор, который дает возможность запрашивать у системы и редактировать информацию, относящуюся к выбранной активности. Например: длительность активности, кто в ней участвует, какие активности предшествуют и тп\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EВторая диаграмма – GanttView (календарный или временной график Гантта) показывает расположение проекта и его активностей во времени. Эта диаграмма также позволяет выбрать некую активность. Редактор, связанный с GanttView дает возможность \"\u003Cem\u003Eto pass on operations on the network and its activities that are related to this particular View\u003C\u002Fem\u003E\". В частности он позволяет изменить запланированную дату начала и окончания выбранной активности, а также осуществлять планирование и управление проектом\u002Fсетью как целым.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EТретья диаграмма — это диаграмма ресурсов, требуемых для осуществления активностей, в зависимости от времени. Любопытно то, что с этой диаграммой связан не редактор, а список и в зависимости от того какая активность в этом списке выбрана, диаграмма ресурсов отображает только те ресурсы, которые относятся к выбранной активности. Такое сочетание двух видов, один из которых \"управляет\" отображаемой информацией другого характерно для многих интерфейсов. А идея использовать для «управления» не текстовый редактор а список ляжет в основу большинства контроллеров в SmallTalk-80. \u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EТермин \u003Cstrong\u003EController\u003C\u002Fstrong\u003E возник практически перед самым уходом Реенскауга из Xerox PARC \"\u003Cem\u003EAfter long discussions, particularly with Adele Goldberg\u003C\u002Fem\u003E\". И из-за этого оригинальные работы Реенскауга бывает сложно читать, поскольку одним и тем же термином«Editor» он называет и весь интерфейс целиком (и в этом случае пишет о первичном разделении приложения на Model и Editor) и панели-редакторы которые связывались с соответствующими View для ввода команд и «управления View» и которые впоследствии собственно и стали Контроллерами – “\u003Cem\u003EКонтроллер из Smalltalk-80 у меня назывался \u003Cstrong\u003EEditor\u003C\u002Fstrong\u003E\u003C\u002Fem\u003E” (Реенскауг)\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EТакже к обязанностям Контроллера Реенскауг относил управление самим интерфейсом и в частности множеством входящих в него Видов: \"\u003Cem\u003EController was responsible for creating and coordinating its subordinate views\u003C\u002Fem\u003E\". Соответственно иногда он пишет, что Контроллер это связь между пользователем и системой, а иногда что это связь между пользователем и Видами и что Контроллер передает команды Видам. \u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EТем не менее, как видно из примера, Реенскауговский «Editor-Controller» был вполне себе видим и имел графическое представление. \u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EПосмотрим как дело обстояло в SmallTalk-80. \u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003E\u003Cstrong\u003EПервое: в SmallTalk-80 текстовые редакторы, которые Реенскауг использовал для ввода команд, «официально» стали Контроллерами.\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003E«\u003Cem\u003EParagraphEditor\u003C\u002Fem\u003E» и «\u003Cem\u003ETextEditor\u003C\u002Fem\u003E», обладающие стандартными функциями ввода и редактирования текста, в SmallTalk-80 являлись потомками класса «\u003Cem\u003EController\u003C\u002Fem\u003E»: \u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EПоскольку, как уже упоминалось, редакторы объединяли в себе функции Ввода и Вывода, то они также использовались для \u003Cstrong\u003Eотображения\u003C\u002Fstrong\u003E текстовой информации во многих Видах – TextView, TextEditorView.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EСтив Барбек дает по этому поводу довольно подробное разьяснение: \"\u003Cem\u003EВсе контроллеры, которые принимают ввод с клавиатуры, являются наследниками «ParagraphEditor» в иерархии Контроллеров. «ParagraphEditor» предшествовал созданию парадигмы MVC. Он одновременно выполняет две функции – обрабатывает ввод текста с клавиатуры и отображает его на экране. Поэтому в некотором смысле он представляет собой нечто среднее между Видом и Контроллером. Виды, которые используют подклассы «ParagraphEditor» в качестве контроллера, полностью переворачивают стандартные роли – для того чтобы отобразить текст они посылают его своему контроллеру\u003C\u002Fem\u003E\" [\u003Cem\u003EAll controllers that accept keyboard text input are under the ParagraphEditor in the Controller hierarchy. ParagraphEditor predates the full development of the MVC paradigm. It handles both text input and text display functions, hence it is in some ways a cross between a view and a controller. The views which use it or its subcasses for a controller reverse the usual roles for display; they implement the display of text by sending controller display\u003C\u002Fem\u003E].\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EО причине подобных «парадоксов» я постараюсь написать дальше, пока же просто обратите на это внимание\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003E\u003Cstrong\u003EВторое: в SmallTalk-80 с каждым Видом (подвидом) ОБЯЗАТЕЛЬНО был связан свой Контроллер, который давал возможность производить некие операции с той информацией, которую Вид отображает\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EСоответственно любое множество Видов (подвидов) входящих в состав пользовательского интерфейса на самом деле всегда сопровождалось точно таким же множеством связанных с ним Контроллеров. Опять таки у Стива Барбека этой теме посвящен целый раздел который так и называется — \"Communication Between Controllers\".\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003E\u003Cstrong\u003EТретье: главное усовершенствование состояло в том, что для ввода команд преимущественно стала использоваться мышь, а не клавиатура.\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EВ SmallTalk-80 помимо контроллеров-редакторов (\u003Cem\u003EParagraphEditor\u003C\u002Fem\u003E и \u003Cem\u003ETextEditor\u003C\u002Fem\u003E) появляется \u003Cstrong\u003EMouseMenuController\u003C\u002Fstrong\u003E, который становится основным средством ввода команд. Пользовательские интерфейсы из Command-driven становятся Menu-driven (\u003Ca href=\"https:\u002F\u002Frevisionworld.com\u002Fgcse-revision\u002Fict\u002Fsoftware\u002Fuser-interfaces\"\u003EUser Interfaces\u003C\u002Fa\u003E) \u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EДоступные команды для каждого Вида формировались явно в виде списка. А связанный с Видом MouseMenuController предоставлял для их отображения и удобного ввода \u003Cstrong\u003Eспециальное графическое средство\u003C\u002Fstrong\u003E – всплывающие \u003Cstrong\u003Epop-up menu\u003C\u002Fstrong\u003E, которые появлялись при нажатии соответствующей кнопки мыши. Вот так они выглядели: \u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw1560\u002Ffiles\u002Ff66\u002Fd7b\u002Fb37\u002Ff66d7bb3725f40b79befe4e252c86f56.png\" alt=\"SmallTalk menu\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Ffiles\u002Ff66\u002Fd7b\u002Fb37\u002Ff66d7bb3725f40b79befe4e252c86f56.png\"\u002F\u003E \u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EПовторю: pop-up menu относились к MouseMenuController. Меню являлись специальным графическим инструментом\u002Fсредством для удобного отображения и ввода команд (определенных в контексте некоторого вида), который Контроллер, связанный с этим Видом, предоставлял пользователю. Вот что пишет Краснер: \"\u003Cem\u003EХотя меню можно рассматривать как пару вид-контроллер, но чаще всего они считаются входными устройствами и следовательно относятся к сфере контроллера… За создание всплывающих меню при нажатии какой-нибудь кнопки мыши отвечает класс MouseMenuController… По умолчанию PopUpMenus возвращают числовое значение которое вызвавший их контроллер использует для того чтобы определить какое действие ему нужно совершить… Из-за широкого использования всплывающих меню большинство контроллеров пользовательского интерфейса являются подклассами MouseMenuController\u003C\u002Fem\u003E\". \u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EТак что основной контроллер SmallTalk-80 (MouseMenuController) тоже имел свою графическую часть – \u003Cem\u003Epop-up menu\u003C\u002Fem\u003E, и разделение пользовательского интерфейса на Виды и Контроллеры стало выглядеть следующим образом (иллюстрация взята из статьи Гленна Краснера): \u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw1560\u002Ffiles\u002F251\u002Fbb4\u002F5ec\u002F251bb45ec3d04b2ba7e297d1057428ca.png\" alt=\"SmallTalk View Controller Separation\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Ffiles\u002F251\u002Fbb4\u002F5ec\u002F251bb45ec3d04b2ba7e297d1057428ca.png\"\u002F\u003E\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EМеню относящиеся к MouseMenuController-ам можно видеть абсолютно во всех SmallTalk приложениях и примерах. Вот так с развернутыми меню выглядят уже упоминавшиеся Workspace и Inspector:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw1560\u002Ffiles\u002F40f\u002F385\u002Fa60\u002F40f385a603d040989be0b141cd242b49.png\" alt=\"SmallTalk MVC\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Ffiles\u002F40f\u002F385\u002Fa60\u002F40f385a603d040989be0b141cd242b49.png\"\u002F\u003E\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EА вот так выглядит Browser, включающий в себя 5 Видов (подВидов) и соответствующих им Контроллеров\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw1560\u002Ffiles\u002F87e\u002Fed1\u002F5c8\u002F87eed15c8a8a471ebff24efba7f140b5.png\" alt=\"SmallTalk MVC\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Ffiles\u002F87e\u002Fed1\u002F5c8\u002F87eed15c8a8a471ebff24efba7f140b5.png\"\u002F\u003E\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EПредполагаю, что именно из-за широкого использования всплывающих меню Реенскауг и писал, что контроллер в smalltalk \"\u003Cem\u003Eэто эфемерный компонент, который View создает при необходимости в качестве связывающего звена между View и входными устройствами такими как мышь и клавиатура\u003C\u002Fem\u003E\".\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EТак что, можем развеять очередной миф:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cblockquote\u003E\u003Cstrong\u003EМифы: Все графические элементы пользовательского интерфейса относятся к Виду. Контроллер это исключительно логика обработки движений мыши, нажатий клавиш на клавиатуре и других входящих событий производимых пользователем.\u003C\u002Fstrong\u003E\u003C\u002Fblockquote\u003E\u003Cp\u003EНа самом деле и в реализации Реенскауга и затем в Smalltalk-80 большинство Контроллеров имели «\u003Cstrong\u003Eграфическую составляющую, помогающую пользователю вводить команды и данные\u003C\u002Fstrong\u003E». И именно такие Контроллеры в основном использовались в пользовательских приложениях. Хотя, конечно же, были Контроллеры и без графической составляющей, но они в основном применялись для более низкоуровневых системных задач (об этом чуть позже). \u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EЕсли просуммировать, то получается что \u003Cstrong\u003EКонтроллер\u003C\u002Fstrong\u003E это \u003Cstrong\u003Eчасть пользовательского интерфейса\u003C\u002Fstrong\u003E, которая отвечает за то чтобы 1) предоставить пользователю \u003Cstrong\u003Eудобные средства для ввода команд и данных\u003C\u002Fstrong\u003E, а затем 2) действия пользователя \u003Cstrong\u003Eперевести\u003C\u002Fstrong\u003E в вызовы соответствующих методов Модели и \u003Cstrong\u003Eпередать\u003C\u002Fstrong\u003E их ей.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EВот как определял Контроллер сам Реенскауг: \"\u003Cem\u003EКонтроллер это связь между пользователем и системой. Он предоставляет пользователю меню и другие средства для ввода команд и данных. Контроллер получает результат таких действий пользователя, транслирует их в соответствующие сообщения и передает эти сообщения\u003C\u002Fem\u003E\" [ \u003Cem\u003EA controller is the link between a user and the system. It provides means for user output by presenting the user with menus or other means of giving commands and data. The controller receives such user output, translates it into the appropriate messages and pass these messages on\u003C\u002Fem\u003E].\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EСовременные графические интерфейсы (GUI) для ввода команд используют весь спектр доступных средств: текстовые и графические меню, кнопки, всплывающие pop-up меню, всевозможные переключатели (как в реальных приборах), текстовые поля для ввода данных (TextEditor свелся к TextField). Все эти элементы служат в основном для управления, а не для отображения информации. По английски они так и называются — \u003Cstrong\u003Econtrols\u003C\u002Fstrong\u003E (элементы управления). \u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EИ если продолжить аналогию, то разделение Вид\u002FКонтроллер в современных системах выглядело бы примерно следующим образом:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw1560\u002Ffiles\u002F1bc\u002Fc44\u002F6a5\u002F1bcc446a57ed4e94b0749c456d5a431b.png\" alt=\"View Controller\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Ffiles\u002F1bc\u002Fc44\u002F6a5\u002F1bcc446a57ed4e94b0749c456d5a431b.png\"\u002F\u003E\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EМожно сказать, что Контроллер это «панель управления» (Control panel). А Вид это «обзорная панель» или «панель наблюдения за системой» включающая в себя текстовые описания, списки, таблицы, графики, шкалы, световые табло, и всевозможные индикаторы состояния. \u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EКрасота MVC заключается в том, что его идеи универсальны и применимы не только к информационным системам. Не важно прибор это или программа, \u003Cstrong\u003Eв простейшем случае\u003C\u002Fstrong\u003E интерфейс, как правило, содержит блок\u002Fпанель управления, позволяющий вводить команды – Контроллер, и блок отображения информации – Вид. \u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Ch2 id=\"realizaciya-vidov-i-kontrollerov\"\u003EРеализация Видов и Контроллеров\u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EЧто нам это дает? Ну во первых, становится понятно что логика работы Вида никак не может быть помещена в Контроллер: \u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw1560\u002Ffiles\u002Fb97\u002Fcda\u002F4b7\u002Fb97cda4b709e48f2aa05b086172fb8ce.png\" alt=\"View Controller\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Ffiles\u002Fb97\u002Fcda\u002F4b7\u002Fb97cda4b709e48f2aa05b086172fb8ce.png\"\u002F\u003E\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EЕсли всю логику работы GUI вынести в Контроллер, то это нарушало бы сразу несколько принципов:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cul\u003E\r\n\u003Cli\u003Eглавный принцип определяющий качество декомпозиции – \u003Cem\u003EHigh Cohesion + Low Coupling\u003C\u002Fem\u003E, который говорит что «резать» на модули нужно так, чтобы связи, особенно сильные, оставались преимущественно внутри модулей, а не между ними\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Cem\u003EПринцип единственной ответственности (Single responsibility principle)\u003C\u002Fem\u003E. \u003C\u002Fli\u003E\r\n\u003C\u002Ful\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EВторое. Тонкий Вид, рассматриваемый исключительно как набор графических элементов, не выполняет никакой функции и поэтому в плане пере-использования мало полезен. Если же мы рассматриваем Вид как полноценный функциональный модуль, решающий довольно общую и востребованную задачу – визуализация и удобное представление данных, то при правильном подходе он становится идеальным кандидатом на пере-использование.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EВ этом смысле разделение пользовательского интерфейса на Вид и Контроллер очень красивый шаг – Контроллер вобрал в себя большую часть зависимостей. Виду от Модели нужны лишь данные для отображения в определенном формате. Соответственно потенциально один и тот же Вид может быть использован для визуализации информации в разных приложениях.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EПоследнее время активно разрабатывается и используется концепция \u003Cstrong\u003EDashboard\u003C\u002Fstrong\u003E-ов (информационных панелей), для которых создаются наборы универсальных виджетов, позволяющих наглядно и удобно визуализировать «все что угодно». В отличие от «тупого вида» такие «\u003Cem\u003Eполноценные блоки визуализации\u003C\u002Fem\u003E» (инкапсулирующие свою логику, настройки и способные работать самостоятельно) очень востребованы и ценны сами по себе. \u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw1560\u002Ffiles\u002Fa69\u002F310\u002F6c2\u002Fa693106c29ed4650bc71ef42d75613a1.png\" alt=\"Dashboard\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Ffiles\u002Fa69\u002F310\u002F6c2\u002Fa693106c29ed4650bc71ef42d75613a1.png\"\u002F\u003E\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EКогда Вид и Контроллер, трактуются как функциональные модули, отвечающие за решение определенных задач, то становится понятно, что для того чтобы инкапсулировать свою логику работы им вовсе нет нужды смешивать ее с графикой. Ведь любой модуль, при необходимости, может быть разделен на подмодули и обладать своей внутренней структурой.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EКак мы выяснили основной Контроллер SmallTalk-80 — MouseMenuController вовсе не являлся «всего лишь обработчиком действий пользователя с мышью и клавиатурой», на самом деле он делал довольно много вещей: \u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Col\u003E\r\n\u003Cli\u003EЗадавал набор и названия команд, доступных пользователю в контексте некоего Вида, \u003C\u002Fli\u003E\r\n\u003Cli\u003EОпределял логику того, как эти команды транслировать в вызовы соответствующих методов Модели \u003C\u002Fli\u003E\r\n\u003Cli\u003EОтображал доступные команды \u003C\u002Fli\u003E\r\n\u003Cli\u003EОбрабатывал низкоуровневые движения мыши и создавал высокоуровневые события, к которым удобно привязывать выполнение команд (Event Driven подход). \u003C\u002Fli\u003E\r\n\u003C\u002Fol\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw1560\u002Ffiles\u002F4e5\u002F12c\u002F027\u002F4e512c027f2643e188b9c98fb273e2cf.png\" alt=\"SamllTalk Controller\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Ffiles\u002F4e5\u002F12c\u002F027\u002F4e512c027f2643e188b9c98fb273e2cf.png\"\u002F\u003E\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EДля таких Контроллеров просто «просилась» MVC архитектура. И в SmallTalk-80 она была использована: \"\u003Cem\u003Epop-up menu are implemented as a special kind of MVC class\u003C\u002Fem\u003E\" (Краснер). \u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EТут важно понимать, что Модель в этом «внутреннем» MVC не имеет никакого отношения к доменной модели, это именно внутренняя вспомогательная модель, описывающая «состояние» самого контроллера (в частности то, какая команда выбрана) и логику изменения этого состояния. \u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EАналогично дело обстоит и с Видом. \u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cblockquote\u003E\u003Cstrong\u003EМифы: То, что Вид это всего лишь «графика», является такой же идеализацией как и то, что Контроллер это «исключительно логика».\u003C\u002Fstrong\u003E\u003C\u002Fblockquote\u003E\u003Cp\u003EВизуализация информации является непростой задачей, для решения которой, как правило, требуются дополнительные данные, характеризующие именно сам процесс отображения. Большинство Видов, используемых в реальных приложениях, это довольно сложные объекты со своим «состоянием» и логикой его изменения. \u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EНапример, Вид редко когда может отобразить всю Модель целиком, обычно он отражает лишь какую-то ее часть и ему необходимо «знать» какая именно «часть Модели» должна быть отражена в данный момент. Многие виды позволяют «выделять» какие-то элементы, а значить им где-то нужно хранить информацию о выделениях. \u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EГде хранились такого рода дополнительные данные и логика их изменения? В принципе ответ очевиден и, если вы помните, Реенскауг ответил на этот вопрос – конечно же в самом Виде. Но! Не в перемешку с графикой, а в отдельном под-модуле\u002Fклассе\u002Fскрипте, то есть в некоторой \u003Cstrong\u003Eвнутренней модели\u003C\u002Fstrong\u003E.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EИ раз есть вспомогательные внутренние модели, то должны быть и специальные Контроллеры, которые этими внутренними моделями управляют. Такие Контроллеры изменяют исключительно состояние самого Вида и не имеют никакого отношения к Контроллеру приложения, изменяющему состояние доменной модели. Положением фрейма, например управлял ScrollController. То есть в общем случае Виды тоже имеют структуру MVC. Но пока отложим вопрос с Контроллерами и сосредоточится на главном — на внутренних моделях.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw1560\u002Ffiles\u002F8dc\u002Fdca\u002F76c\u002F8dcdca76c8584b218561f65456c92af7.png\" alt=\"MVC View\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Ffiles\u002F8dc\u002Fdca\u002F76c\u002F8dcdca76c8584b218561f65456c92af7.png\"\u002F\u003E\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EФаулер такие внутренние модели, являющиеся частью представления называет — \u003Ca href=\"http:\u002F\u002Fmartinfowler.com\u002FeaaDev\u002FPresentationModel.html\"\u003EPresentation Model\u003C\u002Fa\u003E: \u003Cem\u003EPresentation Model pulls the state and behavior of the view out into a model class that is part of the presentation\u003C\u002Fem\u003E.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003E\u003Cstrong\u003EИ вот тут внимание!\u003C\u002Fstrong\u003E В первой части статьи подробно рассказывается о том, как в MVC был «потерян» Фасад и что из-за этого его роль на себе вынуждены брать другие компоненты. Так вот хотя Фаулер и пишет что \"\u003Cem\u003EPresentation Model is not a GUI friendly facade to a specific domain object\u003C\u002Fem\u003E\" на практике PresentationModel, ViewModel, ApplicationModel не только описывают состояние и поведение представления, но одновременно являются еще и \u003Cstrong\u003EФасадами\u003C\u002Fstrong\u003E к доменной модели. \u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EВ примере, который Фаулер подробно разбирает, хорошо видно, что его PresentationModel является именно смесью Фасада и модели представления. Ну а Microsoft прямо пишет: \"\u003Cem\u003EPresentation model class acts as a façade on the model with UI-specific state and behavior, by encapsulating the access to the model and providing a public interface that is easy to consume from the view\u003C\u002Fem\u003E\" (\u003Ca href=\"https:\u002F\u002Fmsdn.microsoft.com\u002Fen-us\u002Flibrary\u002Fff921080.aspx\"\u003EMSDN: Presentation Model\u003C\u002Fa\u003E)\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EБезусловно такой подход противоречит \u003Cem\u003EПринципу единой ответственности\u003C\u002Fem\u003E, но он существует, используется во фреймворках и в принципе работает. Поэтому о нем стоит знать. \u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EВ отличие от него в Java подобного смешения стараются не допускать. В Java Swing «application-data models» и «GUI-state models» разделены гораздо более четко. Все, наверное, читали или слышали что Java Swing компоненты реализованы в виде MVC. И большинство наверняка уверены в том, что M в этой триаде это тот самый интерфейс к доменным данным. И по сути это правильно, почти…\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EДавайте внимательно посмотрим на список \u003Ca href=\"https:\u002F\u002Fdocs.oracle.com\u002Fjavase\u002F7\u002Fdocs\u002Fapi\u002Fjavax\u002Fswing\u002FJList.html\"\u003EJList\u003C\u002Fa\u003E. У него действительно есть модель, обеспечивающая доступ к доменным данным – \u003Ca href=\"https:\u002F\u002Fdocs.oracle.com\u002Fjavase\u002F7\u002Fdocs\u002Fapi\u002Fjavax\u002Fswing\u002FListModel.html\"\u003EListModel\u003C\u002Fa\u003E. Но кроме нее у списка имеется еще одна модель — \u003Ca href=\"https:\u002F\u002Fdocs.oracle.com\u002Fjavase\u002F7\u002Fdocs\u002Fapi\u002Fjavax\u002Fswing\u002FListSelectionModel.html\"\u003EListSelectionModel\u003C\u002Fa\u003E, которая отвечает исключительно за внутреннюю логику выделения элементов списка (item selection). И вот эта модель как раз и является в чистом виде внутренней моделью представления – «GUI-state model»: \u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003E\"\u003Cem\u003EThe models provided by Swing fall into two general categories: GUI-state models and application-data models.\u003C\u002Fem\u003E\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003E\u003Cem\u003EGUI state models are interfaces that define the visual status of a GUI control, such as whether a button is pressed or armed, or which items are selected in a list. GUI-state models typically are relevant only in the context of a graphical user interface (GUI).\u003C\u002Fem\u003E\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003E\u003Cem\u003EAn application-data model is an interface that represents some quantifiable data that has meaning primarily in the context of the application, such as the value of a cell in a table or the items displayed in a list. These data models provide a very powerful programming paradigm for Swing programs that need a clean separation between their application data\u002Flogic and their GUI\u003C\u002Fem\u003E\" (см статью от создателей \u003Ca href=\"http:\u002F\u002Fwww.eecs.yorku.ca\u002Fcourse_archive\u002F2004-05\u002FW\u002F3461\u002FFowlerArticle.pdf\"\u003EA Swing Architecture Overview\u003C\u002Fa\u003E).\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EУ таблицы \u003Ca href=\"http:\u002F\u002Fdocs.oracle.com\u002Fjavase\u002F7\u002Fdocs\u002Fapi\u002Fjavax\u002Fswing\u002FJTable.html?is-external=true\"\u003EJTable\u003C\u002Fa\u003E помимо application-data модели, обеспечивающей доступ к доменным данным – \u003Ca href=\"http:\u002F\u002Fdocs.oracle.com\u002Fjavase\u002F7\u002Fdocs\u002Fapi\u002Fjavax\u002Fswing\u002Ftable\u002FTableModel.html\"\u003ETableModel\u003C\u002Fa\u003E, имеются целых две внутренних GUI-stateмодели — ListSelectionModel и \u003Ca href=\"http:\u002F\u002Fdocs.oracle.com\u002Fjavase\u002F7\u002Fdocs\u002Fapi\u002Fjavax\u002Fswing\u002Ftable\u002FTableColumnModel.html\"\u003ETableColumnModel\u003C\u002Fa\u003E.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EА вот у кнопки \u003Ca href=\"https:\u002F\u002Fdocs.oracle.com\u002Fjavase\u002F7\u002Fdocs\u002Fapi\u002Fjavax\u002Fswing\u002FJButton.html\"\u003EJButton\u003C\u002Fa\u003E имеется лишь GUI-state модель – \u003Ca href=\"https:\u002F\u002Fdocs.oracle.com\u002Fjavase\u002F7\u002Fdocs\u002Fapi\u002Fjavax\u002Fswing\u002FButtonModel.html\"\u003EButtonModel\u003C\u002Fa\u003E. Что в принципе и логично. Кнопка не отображает доменных данных, это в чистом виде Контроллер с внутренней моделью, которая определяет состояние кнопки (нажата\u002Fне нажата). \u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EПри использовании графических компонент нам, в основном, приходится иметь дело с application-data моделями, через которые собственно и осуществляется взаимодействие домена и интерфейса. С GUI-state моделями мы сталкиваемся лишь тогда, когда возникает необходимость изменить дефолтное поведение компонента. Поэтому это нормально и правильно что многие даже не знают о наличие GUI-state моделей. \u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw1560\u002Ffiles\u002Fdc5\u002F6fd\u002F873\u002Fdc56fd8734aa4118ae744044a9773b8d.png\" alt=\"MVC JavaSwing GUI-state models\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Ffiles\u002Fdc5\u002F6fd\u002F873\u002Fdc56fd8734aa4118ae744044a9773b8d.png\"\u002F\u003E\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EВидно, что в таблице некоторые модели отмечены одновременно и как GUI и как data. Особых пояснений не дается, написано что это зависит от контекста использования модели. Я могу высказать по этому поводу лишь предположение. \u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EВсе такого рода промежуточные модели относятся к компонентам, которые являются либо разновидностью скроллбара либо разновидностью переключателя (кнопка с состоянием). Такие компоненты предназначены прежде всего для управления и по сути представляют собой контроллер (в SmallTalk скроллбар и был контроллером — ScrollController) но с некоторым внутренним состоянием. Соответственно у таких компонент имеется лишь GUI-state модель и в дефолтной реализации состояние этих компонент никак не связано с состоянием доменной модели, а зависит лишь от действий пользователя, то есть от того, в какое состояние пользователь этот контрол\u002Fкнопку перевел. \u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EНо при этом \u003Cstrong\u003Eвыглядит\u003C\u002Fstrong\u003E состояние таких контроллеров так, как если бы оно было согласовано с состоянием доменной модели: мы перевели переключатель в состояние «On», в доменную модель передалась соответствующая команда, там что-то включилось… и доменная модель тоже перешла в некое состояние «On». Достигается такая псевдо-согласованность как правило \"сама собой\", автоматически.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EТем не менее возможны ситуации когда может понадобиться настоящее реальное согласование доменной модели и состояния переключателя. В этом случае будет написана реализация ButtonModel, в которой метод isSelected() перестанет зависеть от действий пользователя с кнопкой, а вместо этого будет напрямую отображать состояние домена (некий его флаг). Кнопка при этом становится отчасти видом, а ButtonModel перестает быть внутренней GUI-state и становится application-data\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EВ заключение темы привожу схемы обоих описанных тут подходов чтобы каждый мог выбрать то, что ему больше подходит:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw1560\u002Ffiles\u002F3c7\u002F764\u002Fed8\u002F3c7764ed889e4bde850c6871d7b4db7b.png\" alt=\"MVC PresentationModel\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Ffiles\u002F3c7\u002F764\u002Fed8\u002F3c7764ed889e4bde850c6871d7b4db7b.png\"\u002F\u003E\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EЯ стараюсь первого варианта избегать. Мое ИМХО что подобное смешение хоть и соблазняет своей кажущейся простотой но на практике приводит к тому что PresentationModel превращается в большую \"свалку\". Представьте что есть реальный сложный интерфейс. Если использовать подход (2), то мы этот интерфейс разобьем на ui-модули, и каждый модуль будет инкапсулировать свою логику в виде небольшой внутренней ui-state модели. А вот если использовать подход (1), то логика работы всего этого большого интерфейса будет свалена в кучу вперемешку с логикой фасада в PresentationModel. Пока такая PresentationModel или ApplicationModel создается и управляется автоматически неким фреймворком все хорошо. Но если подобное писать ручками… то мозг начинает ломаться и часто это приводит к тому, что логика представления рано или поздно просачивается через фасад в доменную модель. Даже у такого гуру как Фаулер, в его детском примере это таки произошло (интересно, кто-нибудь еще заметил это место?). В архитектуре, где фасад и GUI-state модели разделены, вероятность такого рода ошибок значительно ниже. \u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Ch2 id=\"obedinennyy-vidkontroller-uproschennyy-mvc\"\u003EОбъединенный ВидКонтроллер. «Упрощенный MVC»\u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EРаз уж мы коснулись Java Swing, то нужно сказать еще об одной его важной особенности – в отличие от SmallTalk-80 где и скроллбар и pop-up меню были реализованы в виде полноценного MVC (с внутренней моделью, внутренним низкоуровневым контроллером и видом) Swing в реализации базовых gui компонент использует «упрощенный MVC», в котором Вид и Контроллер объединены в единый компонент, который одновременно отображает данные и обрабатывает действия пользователя. Обычно он так и называется: объединенный \u003Cem\u003EViewController\u003C\u002Fem\u003E или \u003Cem\u003EUI-object\u003C\u002Fem\u003E, \u003Cem\u003EIU-delegate\u003C\u002Fem\u003E. Вот еще одна статья, где это подробно описывается: \u003Ca href=\"http:\u002F\u002Fwww.javaworld.com\u002Farticle\u002F2076632\u002Fcore-java\u002Fmvc-meets-swing.html\"\u003EMVC meets Swing\u003C\u002Fa\u003E.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw1560\u002Ffiles\u002F860\u002F929\u002F151\u002F8609291517e7408cae14be9dc0461819.png\" alt=\"MVC\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Ffiles\u002F860\u002F929\u002F151\u002F8609291517e7408cae14be9dc0461819.png\"\u002F\u003E\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EСамое интересное и неожиданное заключается в том, что такой «упрощенный MVC» де-факто используется в большинстве GUI библиотек и фреймворках пришедших на смену SmallTalk-80: VisualAge Smalltalk от IBM, Visual SmallTalk, VisualWorks SmallTalk, MacApp… (\u003Ca href=\"https:\u002F\u002Fbooks.google.es\u002Fbooks?id=W8_Une9cbbgC&amp;pg=PA124&amp;lpg=PA124&amp;dq=smalltalk+mvc&amp;source=bl&amp;ots=oQrY1q7oDa&amp;sig=Rkeymilwgxn99K8ZJRCl4s-lqbQ&amp;hl=ru&amp;sa=X&amp;redir_esc=y#v=onepage&amp;q=smalltalk%20mvc&amp;f=false\"\u003ESmalltalk, Objects, and Design\u003C\u002Fa\u003E стр 124-125). \u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EФактически классический вариант MVC, с обязательным разделением Видов и Контроллеров, особенно на низком уровне, только в SmallTalk-80 и был реализован. Почему? Опять таки я могу высказать лишь предположение. \u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EОсновное отличие SmallTalk-80 от всех последующих систем заключалось в том что он работал \u003Cstrong\u003Eбез операционной системы\u003C\u002Fstrong\u003E. Поэтому весь объем низкоуровневой работы по отслеживанию движений мыши а также нажатий клавиш на клавиатуре приходилось выполнять Контроллеру. Контроллер в тех условиях был необходим, фактически он выполнял роль драйвера входящих устройств и кроме ссылок на Модель и Вид обязательно содержал ссылку на «сенсор». Соответсвенно именно эта сторона его деятельности акцентировалась и выходила на первый план. \u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EПосле того, как эту работу взяли на себя операционные системы, низкоуровневая «обработка действий пользователя» в большинстве случаев становится достаточно простой для того чтобы с ней мог справится сам Вид. \u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EИ для простых компонент это оказывается плюсом, потому как разделение функций ввода и вывода хорошо работает для интерфейса в целом или для сложных компонент. А в случае создания базовых ui-компонент, как пишут создатели Swing: \"\u003Cem\u003Ethis split didn't work well in practical terms because the view and controller parts of a component required a tight coupling (for example, it was very difficult to write a generic controller that didn't know specifics about the view)\u003C\u002Fem\u003E\".\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EНа самом деле и в SmallTalk-80 Виды и Контроллеры тоже были \u003Cstrong\u003Eочень тесно связанными\u003C\u002Fstrong\u003E: Контроллер всегда содержал ссылку на Вид, а Вид на Контроллер. Кроме того, соответствующие классы Вида и Контроллера обычно еще и разрабатывались совместно: \"\u003Cem\u003EПоскольку классы вида и контроллера часто разрабатывались совместно, для многих подклассов вида был определен класс контроллера, используемого по умолчанию, и метод для получения его экземпляра – defaultControllerClass. И конкретный контроллер связанный с видом часто создавался автоматически просто как экземпляр такого класса\u003C\u002Fem\u003E\" [\u003Cem\u003EBecause view and controller classes are often designed in consort, a view's controller is often simply initialized to an instance of the corresponding controller class. To support this, the message defaultControllerClass, that returns the class of the appropriate controller, is defined in many of the subclasses of View\u003C\u002Fem\u003E – Glenn Krasner ].\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EЧто еще делал Контроллер? Помимо обработки низкоуровневых действий пользователя и создания высокоуровневых событий, Контроллер также содержал \"логику перевода этих высокоуровневых событий в соответствующие методы Модели\". Но как мы выяснили в первой части статьи, Моделями в SmallTalk-80 являлись не сами доменные объекты а интерфейсы и фасады к ним, причем клиент ориентированные. Такие Модели-фасады изначально формировались (были заточена) под требования клиента, так что команды, которые Контроллер отображал в popup menu, практически всегда однозначно соответствовали методам Модели.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EВот что пишет Краснер: \"\u003Cem\u003EВ конце концов сообщения контроллера почти всегда напрямую передавались модели; это означает что в ответ на выбор пункта меню «aMessage» контроллеру посылалось сообщение aMessage и в результате почти всегда вызывался метод модели, который так и назывался «aMessage».\u003C\u002Fem\u003E\" [\u003Cem\u003EFinally, the controller messages were almost always passed directly on to the model; that is, the method for message aMessage, which was sent to the controller when the menu item aMessage was selected, was almost always implemented as ↑model aMessage\u003C\u002Fem\u003E].\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EВ конце своей статьи Краснер приводит несколько примеров из которых видно, что Контроллеры приложений были «пустыми» и не содержали никакой логики. Их создание сводилось к тому что нужно было указать названия команд, отображаемых в pop-up меню, а затем для каждого названия указать метод модели, который должен был вызываться.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EПо сути это означает, что вся логика находилась в моделях: бизнес-логика – в доменной модели, логика перевода команд пользователя в команды системы – в моделях-фасадах, логика работы самого GUI – в ui-state моделях. От Контроллера требовалось лишь связать вызовы методов этих моделей с соответствующими высокоуровневыми событиями (нажатие кнопки, выбор пункта меню) а это настолько тривиально что и эту функцию тоже легко может выполнить сам Вид. \u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EСледующий важный шаг заключается в том, что в современных GUI библиотеках исчезла и существовавшая в smallTalk-80 классификация самих базовых ui-компонент по типу Вид или Контроллер. Как выяснилось далеко не все графические элементы были Видами: pop-up меню относились к Контроллеру, скроллбар и TextEdit просто были Контроллерами. \u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EСейчас такое разделение не делается и мы имеем «ui-компоненты» или «виджеты», которые изначально проектируются так, чтобы быть универсальными – они одновременно могут отображать информацию и создавать высокоуровневые события, к которым удобно привязывать выполнение команд. И таким образом могут играть роль Вида или Контроллера в зависимости от контекста.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EДело в том, что многие ui-компоненты оказались похожи на ParagraphEditor, о котором писал Стив Барбек – они одновременно могут отображать информацию и позволяют ее изменять, объединяя в себе функции Вида и Контроллера. Такими \u003Cstrong\u003Eинтерактивными\u003C\u002Fstrong\u003E элементами являются текстовые поля, формы, всевозможные переключатели (toggle button, radio button, check box) и аналоги скроллбара...\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw780q1\u002Ffiles\u002F4bc\u002Fb46\u002Fd69\u002F4bcb46d6989b46c5a8cd109d333c92fc.jpg\" alt=\"MVC\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Ffiles\u002F4bc\u002Fb46\u002Fd69\u002F4bcb46d6989b46c5a8cd109d333c92fc.jpg\" data-blurred=\"true\"\u002F\u003E\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EДля таких компонент грань Вид или Контроллер оказывается размытой. Один и тот же элемент (объект) может быть Видом или Контроллером в зависимости от контекста в котором он используется и от того какую \u003Cstrong\u003Eфункцию\u003C\u002Fstrong\u003E он в данный момент выполняет. Список, используемый для отображения и ввода команд, являлся частью Контроллера (popUpMenu), а тот же список используемый для отображения данных – частью Вида (ListView). Аналогично — текстовое поле. \u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EКак напишет Реенскауг в своих более поздних работах: \"\u003Cem\u003EМодель, Вид и Контроллер это на самом деле \u003Cstrong\u003Eроли\u003C\u002Fstrong\u003E, которые могут исполняться объектами\u003C\u002Fem\u003E\" (\u003Cem\u003EModel, View and Controller are actually roles that can be played by the objects\u003C\u002Fem\u003E… – \u003Ca href=\"http:\u002F\u002Fwww.artima.com\u002Farticles\u002Fdci_vision.html\"\u003EThe DCI Architecture: A New Vision of Object-Oriented Programming\u003C\u002Fa\u003E\u003Cem\u003E)\u003C\u002Fem\u003E.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EТо, что в SmallTalk-80 \u003Cstrong\u003Eсами объекты\u003C\u002Fstrong\u003E пытались поделить на Модели, Виды и Контроллеры, вызывало лишь ненужную путаницу, которая в частности проявлялось в том, что TextView для отображения посылал текст своему Контроллеру.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EТак осталось ли что нибудь от Контроллера? На мой взгляд да. То, что команды в систему вводятся \"с помощью мыши и клавиатуры\" это ведь тоже своего рода миф. В действительности Контроллер всегда предоставлял пользователю некие средства (как правило графические) \u003Cstrong\u003Eпомогающие\u003C\u002Fstrong\u003E вводить команды. Сначала это были текстовые редакторы, отображающие нажатые пользователем клавиши, затем pop-up меню, отображающие список доступных команд и дающие возможность вводить их «в один клик». Современные gui-библиотеки предоставляют уже целый арсенал средств — кнопки, переключатели, текстовые и графические меню, слайдеры… И вот эта часть работы Контроллера – поиск все более наглядных, удобных и «интуитивно понятных» средств\u002Fформ для ввода команд и управления системами, продолжает быть актуальной. И каждый раз когда мы разрабатываем интерфейс или ui-компонент мы явно или неявно ее решаем. \u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Ch2 id=\"interfeys-kak-composite\"\u003EИнтерфейс как Composite\u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EЕще одна важная идея, которая безусловно осталась – это понимание того, что интерфейс нужно делить на модули, а не делать единым блоком или страницей. \u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EКак видно из примеров, большинство интерфейсов были составными и включали в себя множество Видов и Контроллеров.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EДля обозначения подобных сложно-составных Интерфейсов Реенскауг в своей второй более поздней работе использует специальный термин \"Tool\" (инструмент пользователя) и у него этой теме посвящен отдельный раздел, который так и называется “\u003Cstrong\u003ETool as a Composite\u003C\u002Fstrong\u003E”.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw1560\u002Ffiles\u002Ff17\u002F9a4\u002F842\u002Ff179a4842aa749de9898f6c3d17f265c.png\" alt=\"Reenskaug MVC\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Ffiles\u002Ff17\u002F9a4\u002F842\u002Ff179a4842aa749de9898f6c3d17f265c.png\"\u002F\u003E\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EНа рисунке в качестве Tool приведен уже знакомый нам интерфейс из первого доклада Реенскауга состоящий из трех блоков (которые Реенскауг называет Editor). И вот что по этому поводу пишет Реенскауг:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cul\u003E\r\n\u003Cli\u003E\u003Cem\u003EThe Model that is responsible for representing state, structure, and behavior of the user’s mental model.\u003C\u002Fem\u003E\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Cem\u003EOne or more Editors that present relevant information in a suitable way and support the editing of this information when applicable.\u003C\u002Fem\u003E\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Cem\u003EA Tool that sets up the Editors and coordinates their operation. (E.g., the selection of a model object that is visible in several Editors).\u003C\u002Fem\u003E\u003C\u002Fli\u003E\r\n\u003C\u002Ful\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003E\u003Cem\u003EComplex Editors may again be subdivided into a View and a Controller.This solution is a composite pattern.\u003C\u002Fem\u003E \u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EКак видите, шаблон \u003Cem\u003EComposite\u003C\u002Fem\u003E у Реенскауга относится ко всему интерфейсу, а вовсе не к Виду. Откуда же взялась идея что \u003Cem\u003EComposite\u003C\u002Fem\u003E в MVC относится исключительно к Виду? \u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EВсе просто – поскольку в SmallTalk-80 с каждым Видом \u003Cstrong\u003Eобязательно\u003C\u002Fstrong\u003E был связан свой Контроллер, то \u003Cstrong\u003Eв явном виде\u003C\u002Fstrong\u003E композиция там действительно задавалась только для Видов, а соответствующая композиция (иерархия) Контроллеров просто «вычислялась»: \"\u003Cem\u003ESince each view is associated with a unique controller, the view\u002FsubView tree induces a parallel controller tree within each topView\u003C\u002Fem\u003E\". Это решение было не особо удачным и приводило к хрупкости системы – стоило какой-нибудь Вид оставить без Контроллера и вся система рушилась. Поэтому в SmallTalk-80 был придуман «костыль» – Контроллер, который назывался «NoController». Этот контроллер ничего не делал и по умолчанию связывался с Видами, которые “исключительно отображали информацию” и не нуждались в контроллере. Его единственное назначение состояло в том, чтобы цепочка контроллеров, соответствующих Видам, не прерывалась. (подробно можно почитать У Стива Барбека в разделе “Communication Between Controllers”).\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EТак что в действительности и в SmallTalk-80 и у Реенскауга пользовательский интерфейс всегда включал в себя не только композицию Видов, но и точно такую же композицию соответствующих им Контроллеров. \u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EИ если уж говорить о шаблоне \u003Cem\u003EComposite\u003C\u002Fem\u003E, то, конечно же, более корректно относить его не к Виду а ко всему пользовательскому интерфейсу, как это сделано у Реенскауга и как это делается в современных GUI библиотеках. Интерфейсы больших приложений делятся на «gui-компоненты» или виджеты, которые в свою очередь могут делиться на более простые компоненты и образовывать древовидную структуру. \u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EКаждый такой gui-компонент является автономным модулем, который одновременно отображает некую информацию и обрабатывает относящиеся к нему действия пользователя, порождая высокоуровневые события к которым удобно привязывать выполнение команд (View+Controller). Также он инкапсулирует свою логику работы как правило в виде внутренней GUI-state модели. То есть по сути представляет собой MVC (или «упрощенный MVC»). И вот такие полноценные gui-компоненты уже действительно можно разрабатывать параллельно и независимо, а также переиспользовать. \u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EСледствием шаблона \u003Cem\u003EComposite\u003C\u002Fem\u003E и того, что каждый gui-компонент может быть реализован в виде небольшого MVC, является некая \u003Cstrong\u003Eиерархичность\u003C\u002Fstrong\u003E или \u003Cstrong\u003Eрекурсивность\u003C\u002Fstrong\u003E MVC. Из-за того что об этом редко пишут, аналоги этой идеи тоже пере-открываются. Вот известная статья на эту тему – \u003Ca href=\"http:\u002F\u002Fwww.javaworld.com\u002Farticle\u002F2076128\u002Fdesign-patterns\u002Fhmvc--the-layered-pattern-for-developing-strong-client-tiers.html?page=2\"\u003EHierarchical model–view–controller\u003C\u002Fa\u003E и интересная дискуссия – \u003Ca href=\"http:\u002F\u002Fc2.com\u002Fcgi\u002Fwiki?RecursiveModelViewController\"\u003ERecursive Model View Controller\u003C\u002Fa\u003E. А вот картинка из статьи:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw1560\u002Ffiles\u002F27a\u002F745\u002F695\u002F27a7456952f64302afb70197c9fd4cf0.gif\" alt=\"Hierarchical model–view–controller\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Ffiles\u002F27a\u002F745\u002F695\u002F27a7456952f64302afb70197c9fd4cf0.gif\"\u002F\u003E\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EНа практике построение интерфейсов из независимых и полноценных ui-компонент активно использует и развивает ebay. Подробно об этом можно почитать в их замечательной статье \u003Ca href=\"http:\u002F\u002Fwww.ebaytechblog.com\u002F2014\u002F10\u002F02\u002Fdont-build-pages-build-modules\u002F\"\u003EDon’t Build Pages, Build Modules\u003C\u002Fa\u003E: \"\u003Cem\u003EКогда дело касается view люди все еще мыслят страницами вместо того чтобы строить UI модули. Мы обнаружили что с ростом сложности страниц их становится экспоненциально сложнее поддерживать. Что мы хотим это разделить страницу на маленькие управляемые части, каждую из которых можно разрабатывать независимо. Мы хотим уйти от идеи непосредственно строить страницы. Вместо этого мы разбиваем страницу на логические UI модули и делаем это рекурсивно до тех пор пока модуль не станет \u003Ca href=\"http:\u002F\u002Faddyosmani.com\u002Ffirst\u002F\"\u003E FIRST\u003C\u002Fa\u003E. Это означает что страница строится из высокоуровневых модулей, которые в свою очередь строятся из подмодулей\u003C\u002Fem\u003E\".\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw1560\u002Ffiles\u002F23b\u002Fc9c\u002Fe6d\u002F23bc9ce6d9014255a5b86fe76cf7aacf.png\" alt=\"MVC\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Ffiles\u002F23b\u002Fc9c\u002Fe6d\u002F23bc9ce6d9014255a5b86fe76cf7aacf.png\"\u002F\u003E\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Ch2 id=\"summiruya\"\u003EСуммируя\u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EЯ вовсе не хочу сказать что «original MVC» единственно правильный. Моя цель состояла лишь в том, чтобы показать, что он был намного сложнее и богаче чем те упрощенные схемки, которые нам обычно преподносятся в качестве MVC. Создавать на их основе реальные приложения это все равно что строить самолет на основе схем из детского конструктора и удивляться что он не летает. С другой стороны, если рассматривать MVC не как схему, а прежде всего, как набор архитектурных идей, то он действительно становится прост, логичен и очень понятен, и буквально выводится из этих идей. \u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EИ когда есть понимание, что же именно делается, с помощью каких «инструментов», ради чего, то тогда MVC перестает быть «догмой» и его можно варьировать в зависимости от потребностей конкретного проекта. Да и термины становятся не так важны. \u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EКогда я слышу или читаю про фронт-контроллер или что \"контроллер это единая точка входа в систему\", то мне понятно что термином Контроллер у этих ребят называется Фасад. И это вовсе не означает что их архитектура неправильная. Наоборот, как минимум хорошо, что у них Фасад вообще есть, ну а дальше нужно смотреть, как он реализован, не оттягивает ли на себя реализацию бизнес логики и тп \u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EКогда говорится, что Контроллер это бизнес-логика, то и это не страшно… Просто принимаешь что в этом случае Контроллером называется доменная модель. Важно не то, как она называется, а то как она реализована и отделена ли от пользовательского интерфейса. \u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EТермин Вид часто используют как синоним термина Пользовательский Интерфейс. Так тоже \"можно\". \u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EДело ведь не в терминах, а в сути. Мне кажется, что корень большинства проблем заключается в том, что как раз о сути MVC мало кто пишет. Вместо этого термины Модель, Вид и Контроллер вырываются из контекста архитектурных идей, им даются какие-то формальные определения, а затем они нередко применяются для обозначения модулей в некачественной декомпозиции, навешивается шаблон \u003Cem\u003EНаблюдатель\u003C\u002Fem\u003E и все это преподносится под «брендом MVC».\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EКак писал Вирт: \"\u003Cem\u003EСамой трудной проектной задачей является нахождение наиболее адекватной декомпозиции системы на иерархически выстроенные модули, с минимизацией функций и дублирования кода\u003C\u002Fem\u003E\". \u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EПоэтому основная мысль, которую мне хотелось донести, заключается в том, что MVC он не про Модель, Вид и Контроллер, не про то как они связаны между собой и не про шаблон \u003Cem\u003EНаблюдатель\u003C\u002Fem\u003E. MVC он про то, как нужно грамотно разбивать систему на функционально осмысленные модули, слабо связанные друг с другом и полезные сами по себе. Модули, которые на самом деле можно разрабатывать и использовать независимо, переиспользовать… Что собственно и является основой любой хорошей архитектуры.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EА Модель, Вид и Контроллер это всего лишь результат \u003Cstrong\u003Eначальной декомпозиции\u003C\u002Fstrong\u003E, предложенной нам талантливыми людьми. Также как паттерны \u003Cem\u003EФасад\u003C\u002Fem\u003E, \u003Cem\u003EНаблюдатель, Компоновщик\u003C\u002Fem\u003E — это просто инструменты, которые ими были использованы для ослабления связанности и уменьшения сложности.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\r\n\u003Cp\u003EСпасибо всем кто «дотянул» до конца. Будем очень признательны за обоснованную критику. Особенно интересно мнение людей близко знакомых со SmallTalk.\u003C\u002Fp\u003E\u003C\u002Fdiv\u003E","tags":[{"titleHtml":"MVC"},{"titleHtml":"архитектура приложений"}],"metadata":{"stylesUrls":[],"scriptUrls":[],"shareImageUrl":"https:\u002F\u002Fhabr.com\u002Fshare\u002Fpublication\u002F322700\u002F69f193b3363819ddd9edb9c4895632c0\u002F","shareImageWidth":1200,"shareImageHeight":630,"vkShareImageUrl":"https:\u002F\u002Fhabr.com\u002Fshare\u002Fpublication\u002F322700\u002F69f193b3363819ddd9edb9c4895632c0\u002F?format=vk","schemaJsonLd":"{\"@context\":\"http:\\\u002F\\\u002Fschema.org\",\"@type\":\"Article\",\"mainEntityOfPage\":{\"@type\":\"WebPage\",\"@id\":\"https:\\\u002F\\\u002Fhabr.com\\\u002Fru\\\u002Fpost\\\u002F322700\\\u002F\"},\"headline\":\"Охота на мифический MVC. Построение пользовательского интерфейса\",\"datePublished\":\"2017-02-27T15:39:31+03:00\",\"dateModified\":\"2017-02-28T07:03:49+03:00\",\"author\":{\"@type\":\"Person\",\"name\":\"cobiot\"},\"publisher\":{\"@type\":\"Organization\",\"name\":\"Habr\",\"logo\":{\"@type\":\"ImageObject\",\"url\":\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fwebt\\\u002Fa_\\\u002Flk\\\u002F9m\\\u002Fa_lk9mjkccjox-zccjrpfolmkmq.png\"}},\"description\":\"Детектив по материалам IT. Часть вторая В этой части я покажу как изначально выглядело деление пользовательского интерфейса и что из себя представляли Вид и Конт...\",\"url\":\"https:\\\u002F\\\u002Fhabr.com\\\u002Fru\\\u002Fpost\\\u002F322700\\\u002F#post-content-body\",\"about\":[\"h_analysis_design\",\"h_refactoring\",\"f_develop\"],\"image\":[\"https:\\\u002F\\\u002Fhabr.com\\\u002Fshare\\\u002Fpublication\\\u002F322700\\\u002F69f193b3363819ddd9edb9c4895632c0\\\u002F\"]}","metaDescription":"Детектив по материалам IT. Часть вторая\r\nВ этой части я покажу как изначально выглядело деление пользовательского интерфейса и что из себя представляли Вид и Контроллер. Попробую рассказать почему в...","mainImageUrl":null,"amp":true,"customTrackerLinks":[]},"polls":[],"commentsEnabled":true,"rulesRemindEnabled":false,"votesEnabled":true,"status":"published","plannedPublishTime":null,"checked":null,"isEditorial":false}},"articlesIds":{},"isLoading":false,"pagesCount":{},"route":{},"reasonsList":null,"view":"cards","lastVisitedRoute":{},"ssrCommentsArticleIds":[""],"karma":{}},"authorContribution":{"authors":{}},"betaTest":{"currentAnnouncement":null,"announcements":{},"announcementCards":null,"announcementComments":{},"announcementCommentThreads":{},"announcementCommentingStatuses":{},"archivedList":[]},"authorStatistics":{"articleRefs":{},"articleIds":{},"pagesCount":{},"route":{},"viewsCount":[],"maxStatsCount":{}},"career":{"seoLandings":[{"title":"Cистемный аналитик","vacanciesCount":415,"itemUrl":"https:\u002F\u002Fcareer.habr.com\u002Fvacancies\u002Fsistemnij_analitik","itemHubs":["uml","prototyping","analysis_design","productpm"]}],"hubs":"analysis_design,refactoring"},"comments":{"articleComments":{},"searchCommentsResults":null,"previewComment":null,"pagesCount":null,"commentAccess":{},"scrollParents":{},"pageArticleComments":{"lastViewedComment":0,"postId":null,"lastCommentTimestamp":"","moderated":[],"moderatedIds":[],"commentRoute":""}},"companies":{"companyRefs":{},"companyIds":{},"companyTopIds":{},"pagesCount":{},"companyProfiles":{},"companiesCategories":[],"companiesCategoriesTotalCount":0,"companiesWidgets":{},"companiesWorkers":{},"companiesFans":{},"route":{},"isLoading":false,"companyWorkersLoading":false,"companyFansLoading":false,"vacancies":{},"workplaceInfo":null},"companyAdmin":{"companyInfo":null,"companyInfoLoading":false,"faqArticles":null,"brandingPreviewImageUrl":null},"companiesContribution":{"hubs":{},"flows":{},"companyRefs":{}},"companyHubsContribution":{"contributionRefs":{"hubRefs":{},"hubIds":{}}},"conversation":{"messages":[],"respondent":null,"isLoadMore":false},"conversations":{"conversations":[],"unreadCount":0,"pagesCount":0,"isLoadMore":false},"desktopState":{"desktopFl":null,"desktopHl":null,"isChecked":false,"isLoginDemanded":false},"docs":{"menu":{},"articles":{},"mainMenu":[],"loading":{"main":false,"dropdown":false,"article":false}},"feature":{"isProbablyVisible":"true"},"flows":{"flows":[{"alias":"develop","id":1,"route":{"name":"FLOW_PAGE","params":{"flowName":"develop"}}},{"alias":"admin","id":6,"route":{"name":"FLOW_PAGE","params":{"flowName":"admin"}}},{"alias":"design","id":2,"route":{"name":"FLOW_PAGE","params":{"flowName":"design"}}},{"alias":"management","id":3,"route":{"name":"FLOW_PAGE","params":{"flowName":"management"}}},{"alias":"marketing","id":4,"route":{"name":"FLOW_PAGE","params":{"flowName":"marketing"}}},{"alias":"popsci","id":7,"route":{"name":"FLOW_PAGE","params":{"flowName":"popsci"}}}]},"global":{"isPwa":false,"device":"desktop","isHabrCom":true},"hubs":{"hubRefs":{},"hubIds":{},"pagesCount":{},"isLoading":false,"route":{}},"hubsBlock":{"hubRefs":{},"hubIds":{}},"i18n":{"fl":"ru","hl":"ru"},"info":{"infoPage":{},"isLoading":true},"location":{"urlStruct":{"protocol":null,"slashes":null,"auth":null,"host":null,"port":null,"hostname":null,"hash":null,"search":null,"query":{},"pathname":null,"path":null,"href":""},"searchQuery":null},"me":{"user":null,"ppgDemanded":false,"karmaResetInfo":{"canReincarnate":null,"wasReincarnated":null,"currentScore":null},"notes":null},"mostReadingList":{"mostReadingListIds":[],"mostReadingListRefs":null,"promoPost":null},"pinnedPost":{"pinnedPost":null},"ppa":{"articles":{},"card":null,"transactions":null,"totalTransactions":null,"isAccessible":null},"projectsBlocks":{"activeBlocks":{}},"promoData":{"isLoading":false,"hasLoaded":false,"featurer":null,"megaposts":null,"promoLinks":null,"promoPosts":null},"pullRefresh":{"shouldRefresh":false},"sandbox":{"articleIds":[],"articleRefs":{},"pagesCount":null,"route":{},"lastVisitedRoute":{},"isLoading":false},"search":{"searchQueryError":null},"settingsOther":{"inputs":{"uiLang":{"errors":[],"ref":null,"value":""},"articlesLangEnglish":{"errors":[],"ref":null,"value":false},"articlesLangRussian":{"errors":[],"ref":null,"value":false},"agreement":{"errors":[],"ref":null,"value":false},"email":{"errors":[],"ref":null,"value":true},"digest":{"errors":[],"ref":null,"value":true}}},"similarList":{"similarListIds":[],"similarListRefs":null},"ssr":{"error":null,"isDataLoaded":false,"isDataLoading":false,"isHydrationFailed":false,"isServer":false},"technotext":{"nominationsList":[]},"userHubsContribution":{"contributionRefs":{"hubRefs":{},"hubIds":{}}},"userInvites":{"availableInvites":0,"usedInvitesIds":[],"usedInvitesRefs":{},"usedInvitesPagesCount":0,"unusedInvitesIds":[],"unusedInvitesRefs":{},"unusedInvitesPagesCount":0},"users":{"authorRefs":{},"authorIds":{},"pagesCount":{},"authorProfiles":{},"userHubs":{},"userInvitations":{},"authorFollowers":{},"authorFollowed":{},"userSpecialization":{},"karmaStats":[],"statistics":null,"isLoading":false,"authorFollowersLoading":false,"authorFollowedLoading":false,"userHubsLoading":false,"userInvitationsLoading":false,"route":{}},"viewport":{"prevScrollY":{},"scrollY":0,"width":0},"tracker":{"items":{},"pagesCache":{},"markedViewedSilently":{},"markedRead":{},"unreadCounters":{"applications":null,"system":null,"mentions":null,"subscribers":null,"posts_and_comments":null},"unviewedCounters":{"applications":null,"system":null,"mentions":null,"subscribers":null,"posts_and_comments":null}}};(function(){var s;(s=document.currentScript||document.scripts[document.scripts.length-1]).parentNode.removeChild(s);}());</script>
<script src="https://assets.habr.com/habr-web/js/chunk-vendors.da6c6b36.js" defer></script><script src="https://assets.habr.com/habr-web/js/app.92df6f6d.js" defer></script>



    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    </script>
  
  <script type="text/javascript" >
    (function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
    m[i].l=1*new Date();k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})
    (window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");

    ym(24049213, "init", {
      defer:true,
      trackLinks:true,
      accurateTrackBounce:true,
      webvisor:false,
    });
  </script>
  <noscript>
    <div>
      <img src="https://mc.yandex.ru/watch/24049213" style="position:absolute; left:-9999px;" alt="" />
    </div>
  </noscript>
  
    <script type="text/javascript">
      window.addEventListener('load', function () {
        setTimeout(() => {
          const img = new Image();
          img.src = 'https://vk.com/rtrg?p=VK-RTRG-421343-57vKE';
        }, 0);
      });
    </script>
  
<script src="https://habr.com/js/ads.js" onload="window['zhY4i4nJ9K'] = true"></script>
</body>
</html>
