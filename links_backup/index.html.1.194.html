<!DOCTYPE html>
<html lang="ru" data-vue-meta="%7B%22lang%22:%7B%22ssr%22:%22ru%22%7D%7D">
<head >
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1.0,viewport-fit=cover">
  <meta name="referrer" content="unsafe-url">
  <title>Размышления о стандартной библиотеке JavaScript. Core.js / Хабр</title>
  <style>
    /* cyrillic-ext */
    @font-face {
      font-family: 'Fira Sans';
      font-style: normal;
      font-weight: 500;
      font-display: swap;
      src: url(https://fonts.gstatic.com/s/firasans/v11/va9B4kDNxMZdWfMOD5VnZKveSxf6TF0.woff2) format('woff2');
      unicode-range: U+0460-052F, U+1C80-1C88, U+20B4, U+2DE0-2DFF, U+A640-A69F, U+FE2E-FE2F;
    }

    /* cyrillic */
    @font-face {
      font-family: 'Fira Sans';
      font-style: normal;
      font-weight: 500;
      font-display: swap;
      src: url(https://fonts.gstatic.com/s/firasans/v11/va9B4kDNxMZdWfMOD5VnZKveQhf6TF0.woff2) format('woff2');
      unicode-range: U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116;
    }

    /* latin-ext */
    @font-face {
      font-family: 'Fira Sans';
      font-style: normal;
      font-weight: 500;
      font-display: swap;
      src: url(https://fonts.gstatic.com/s/firasans/v11/va9B4kDNxMZdWfMOD5VnZKveSBf6TF0.woff2) format('woff2');
      unicode-range: U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;
    }

    /* latin */
    @font-face {
      font-family: 'Fira Sans';
      font-style: normal;
      font-weight: 500;
      font-display: swap;
      src: url(https://fonts.gstatic.com/s/firasans/v11/va9B4kDNxMZdWfMOD5VnZKveRhf6.woff2) format('woff2');
      unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
    }

    /* non-breaking hyphen */
    @font-face {
      font-family: 'Fira Sans';
      font-style: normal;
      font-weight: 500;
      font-display: swap;
      src: url(https://fonts.gstatic.com/l/font?kit=KFOlCnqEu92Fr1MmEU9vBh0_IsHAlmrO6g&skey=ee881451c540fdec&v=v29) format('woff2');
      unicode-range: U+02011;
    }
  </style>
  <link rel="preload" href="https://assets.habr.com/habr-web/css/chunk-vendors.e7843cc0.css" as="style"><link rel="preload" href="https://assets.habr.com/habr-web/js/chunk-vendors.da6c6b36.js" as="script"><link rel="preload" href="https://assets.habr.com/habr-web/css/app.4de4e95a.css" as="style"><link rel="preload" href="https://assets.habr.com/habr-web/js/app.92df6f6d.js" as="script">
  <link rel="stylesheet" href="https://assets.habr.com/habr-web/css/chunk-vendors.e7843cc0.css"><link rel="stylesheet" href="https://assets.habr.com/habr-web/css/app.4de4e95a.css">
  <script>window.i18nFetch = new Promise((res, rej) => {
          const xhr = new XMLHttpRequest();
          xhr.open('GET', '/js/i18n/ru-compiled.2822d469ec31a56409ac330bbcf7fcbf.json');
          xhr.responseType = 'json';
          xhr.onload = function(e) {
            if (this.status === 200) {
              res({ru: xhr.response});
            } else {
              rej(e);
            }
          };
          xhr.send();
        });</script>
  
  <script data-vue-meta="ssr" type="application/ld+json" data-vmid="ldjson-schema">{"@context":"http:\/\/schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/habr.com\/ru\/post\/216997\/"},"headline":"Размышления о стандартной библиотеке JavaScript. Core.js","datePublished":"2014-11-18T14:57:02+03:00","dateModified":"2015-05-05T15:18:05+03:00","author":{"@type":"Person","name":"Денис Пушкарев"},"publisher":{"@type":"Organization","name":"Habr","logo":{"@type":"ImageObject","url":"https:\/\/habrastorage.org\/webt\/a_\/lk\/9m\/a_lk9mjkccjox-zccjrpfolmkmq.png"}},"description":"Один пацан писал все на JavaScript, и клиент, и сервер, говорил что нравится, удобно, читабельно. Потом его в дурку забрали, конечно. &mdash; С просторов интернета К ч...","url":"https:\/\/habr.com\/ru\/post\/216997\/#post-content-body","about":["h_webdev","h_javascript","h_nodejs","f_develop"],"image":["https:\/\/habr.com\/share\/publication\/216997\/1e86b032fadde939287e7beae715f26a\/"]}</script>
  <script src="https://www.googletagservices.com/tag/js/gpt.js" async></script>
  <style>.grecaptcha-badge{visibility: hidden;}</style>
  <meta name="habr-version" content="2.64.0">
  
  <meta data-vue-meta="ssr" property="fb:app_id" content="444736788986613"><meta data-vue-meta="ssr" property="fb:pages" content="472597926099084"><meta data-vue-meta="ssr" name="twitter:card" content="summary_large_image"><meta data-vue-meta="ssr" name="twitter:site" content="@habr_com"><meta data-vue-meta="ssr" property="og:site_name" content="Хабр" data-vmid="og:site_name"><meta data-vue-meta="ssr" property="og:title" content="Размышления о стандартной библиотеке JavaScript. Core.js" data-vmid="og:title"><meta data-vue-meta="ssr" name="twitter:title" content="Размышления о стандартной библиотеке JavaScript. Core.js" data-vmid="twitter:title"><meta data-vue-meta="ssr" name="aiturec:title" content="Размышления о стандартной библиотеке JavaScript. Core.js" data-vmid="aiturec:title"><meta data-vue-meta="ssr" name="description" content="Один пацан писал все на JavaScript, и клиент, и сервер, говорил что нравится, удобно, читабельно. Потом его в дурку забрали, конечно.
— С просторов интернета
К чему это я? Занятная штука —..." data-vmid="description"><meta data-vue-meta="ssr" itemprop="description" content="Один пацан писал все на JavaScript, и клиент, и сервер, говорил что нравится, удобно, читабельно. Потом его в дурку забрали, конечно.
— С просторов интернета
К чему это я? Занятная штука —..." data-vmid="description:itemprop"><meta data-vue-meta="ssr" property="og:description" content="Один пацан писал все на JavaScript, и клиент, и сервер, говорил что нравится, удобно, читабельно. Потом его в дурку забрали, конечно.
— С просторов интернета
К чему это я? Занятная штука —..." data-vmid="og:description"><meta data-vue-meta="ssr" name="twitter:description" content="Один пацан писал все на JavaScript, и клиент, и сервер, говорил что нравится, удобно, читабельно. Потом его в дурку забрали, конечно.
— С просторов интернета
К чему это я? Занятная штука —..." data-vmid="twitter:description"><meta data-vue-meta="ssr" property="aiturec:description" content="Один пацан писал все на JavaScript, и клиент, и сервер, говорил что нравится, удобно, читабельно. Потом его в дурку забрали, конечно.
— С просторов интернета
К чему это я? Занятная штука —..." data-vmid="aiturec:description"><meta data-vue-meta="ssr" itemprop="image" content="https://habr.com/share/publication/216997/1e86b032fadde939287e7beae715f26a/" data-vmid="image:itemprop"><meta data-vue-meta="ssr" property="og:image" content="https://habr.com/share/publication/216997/1e86b032fadde939287e7beae715f26a/" data-vmid="og:image"><meta data-vue-meta="ssr" property="og:image:width" content="1200" data-vmid="og:image:width"><meta data-vue-meta="ssr" property="og:image:height" content="630" data-vmid="og:image:height"><meta data-vue-meta="ssr" property="aiturec:image" content="https://habr.com/share/publication/216997/1e86b032fadde939287e7beae715f26a/" data-vmid="aiturec:image"><meta data-vue-meta="ssr" name="twitter:image" content="https://habr.com/share/publication/216997/1e86b032fadde939287e7beae715f26a/" data-vmid="twitter:image"><meta data-vue-meta="ssr" property="vk:image" content="https://habr.com/share/publication/216997/1e86b032fadde939287e7beae715f26a/?format=vk" data-vmid="vk:image"><meta data-vue-meta="ssr" property="aiturec:item_id" content="216997" data-vmid="aiturec:item_id"><meta data-vue-meta="ssr" property="aiturec:datetime" content="2014-11-18T11:57:02.000Z" data-vmid="aiturec:datetime"><meta data-vue-meta="ssr" content="https://habr.com/ru/post/216997/" property="og:url" data-vmid="og:url"><meta data-vue-meta="ssr" property="og:type" content="article" data-vmid="og:type"><meta data-vue-meta="ssr" property="og:locale" content="ru_RU" data-vmid="og:locale"><meta data-vue-meta="ssr" name="keywords" content="Core.js, ECMAScript 5, ECMAScript 6, ECMAScript 7, Harmony, Strawman, Map, Set, WeakMap, WeakSet, Promise, Symbol, console, setImmediate, Dict, итераторы, iterators, стандартная библиотека, standard library">
  <link data-vue-meta="ssr" href="https://habr.com/ru/rss/post/216997/?fl=ru" type="application/rss+xml" title="" rel="alternate" name="rss"><link data-vue-meta="ssr" href="index.html.1.194.html" rel="canonical" data-vmid="canonical"><link data-vue-meta="ssr" data-vmid="hreflang"><link data-vue-meta="ssr" image_src="image" href="https://habr.com/share/publication/216997/1e86b032fadde939287e7beae715f26a/" data-vmid="image:href">
  <meta name="apple-mobile-web-app-status-bar-style" content="#303b44">
  <meta name="msapplication-TileColor" content="#629FBC">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="mobile-web-app-capable" content="yes">
  <link
    rel="shortcut icon"
    type="image/png"
    sizes="16x16"
    href="https://assets.habr.com/habr-web/img/favicons/favicon-16.png"
  >
  <link
    rel="shortcut icon"
    type="image/png"
    sizes="32x32"
    href="https://assets.habr.com/habr-web/img/favicons/favicon-32.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="76x76"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-76.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="120x120"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-120.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="152x152"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-152.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="180x180"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-180.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="256x256"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-256.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1136x640.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2436x1125.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1792x828.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_828x1792.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1334x750.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1242x2668.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 736px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2208x1242.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1125x2436.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 736px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1242x2208.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2732x2048.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2688x1242.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 834px) and (device-height: 1112px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2224x1668.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_750x1334.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2048x2732.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2388x1668.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 834px) and (device-height: 1112px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1668x2224.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_640x1136.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1668x2388.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2048x1536.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1536x2048.png"
  >
  <link
    rel="mask-icon"
    color="#77a2b6"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-120.svg"
  >
  <link
    crossorigin="use-credentials"
    href="https://habr.com/manifest.webmanifest"
    rel="manifest"
  >
</head>
<body>


<div id="app" data-server-rendered="true" data-async-called="true"><div class="tm-layout__wrapper"><!----> <div></div> <!----> <header class="tm-header"><div class="tm-page-width"><div class="tm-header__container"><!----> <span class="tm-header__logo-wrap"><a href="https://habr.com/ru/" class="tm-header__logo tm-header__logo_ru"><svg height="16" width="16" class="tm-svg-img tm-header__icon"><title>Хабр</title> <use xlink:href="/img/habr-logo-ru.svg#logo"></use></svg></a> <span class="tm-header__beta-sign" style="display:none;">β</span></span> <div class="tm-dropdown tm-header__projects"><div class="tm-dropdown__head"><button class="tm-header__dropdown-toggle"><svg height="16" width="16" class="tm-svg-img tm-header__icon tm-header__icon_dropdown"><title>Открыть список</title> <use xlink:href="/img/megazord-v25.4b679db1.svg#arrow-down"></use></svg></button></div> <!----></div> <a href="https://habr.com/ru/sandbox/start/" class="tm-header__become-author-btn">
            Как стать автором
          </a> <div class="tm-feature tm-header__feature tm-feature_variant-inline"><!----></div> <!----> <!----></div></div></header> <div class="tm-layout"><div class="tm-page-progress-bar"></div> <div data-menu-sticky="true" class="tm-base-layout__header tm-base-layout__header_is-sticky"><div class="tm-page-width"><div class="tm-base-layout__header-wrapper"><div class="tm-main-menu"><div class="tm-main-menu__section"><nav class="tm-main-menu__section-content"><!----> <a href="https://habr.com/ru/flows/all" class="tm-main-menu__item">
        Все потоки
      </a> <a href="https://habr.com/ru/flows/develop/" class="tm-main-menu__item">
          Разработка
        </a><a href="https://habr.com/ru/flows/admin/" class="tm-main-menu__item">
          Администрирование
        </a><a href="https://habr.com/ru/flows/design/" class="tm-main-menu__item">
          Дизайн
        </a><a href="https://habr.com/ru/flows/management/" class="tm-main-menu__item">
          Менеджмент
        </a><a href="https://habr.com/ru/flows/marketing/" class="tm-main-menu__item">
          Маркетинг
        </a><a href="https://habr.com/ru/flows/popsci/" class="tm-main-menu__item">
          Научпоп
        </a></nav></div></div> <div class="tm-header-user-menu tm-base-layout__user-menu"><a href="https://habr.com/ru/search/" class="tm-header-user-menu__item tm-header-user-menu__search"><svg height="24" width="24" class="tm-svg-img tm-header-user-menu__icon tm-header-user-menu__icon_search tm-header-user-menu__icon_dark"><title>Поиск</title> <use xlink:href="/img/megazord-v25.4b679db1.svg#search"></use></svg></a> <!----> <!----> <!----> <div class="tm-header-user-menu__item tm-header-user-menu__user_desktop"><div class="tm-dropdown"><div class="tm-dropdown__head"><svg height="24" width="24" data-test-id="menu-toggle-guest" class="tm-svg-img tm-header-user-menu__icon"><title>Профиль</title> <use xlink:href="/img/megazord-v25.4b679db1.svg#header-user"></use></svg> <!----></div> <!----></div> <!----></div> <!----></div></div></div></div> <!----> <div class="tm-page-width"></div> <main class="tm-layout__container"><div hl="ru" data-async-called="true" class="tm-page"><div class="tm-page-width"><!----> <div class="tm-page__wrapper"><div class="tm-page__main tm-page__main_has-sidebar"><div class="pull-down"><div class="pull-down__header" style="height:0px;"><div class="pull-down__content" style="bottom:10px;"><svg height="24" width="24" class="tm-svg-img pull-down__arrow"><title>Обновить</title> <use xlink:href="/img/megazord-v25.4b679db1.svg#pull-arrow"></use></svg></div></div> <div class="tm-article-presenter"> <div class="tm-article-presenter__body"><div class="tm-misprint-area"><div class="tm-misprint-area__wrapper"><article class="tm-article-presenter__content tm-article-presenter__content_narrow"><div class="tm-article-presenter__header"> <div class="tm-article-snippet tm-article-presenter__snippet"><div class="tm-article-snippet__meta-container"><div class="tm-article-snippet__meta"><span class="tm-user-info tm-article-snippet__author"><a href="https://habr.com/ru/users/rock/" title="rock" class="tm-user-info__userpic"><div class="tm-entity-image"><img alt="" height="24" src="https://habrastorage.org/getpro/habr/avatars/4a0/778/fd6/4a0778fd67c81e90eae402d2ea40d49c.gif" width="24" class="tm-entity-image__pic"></div></a> <span class="tm-user-info__user"><a href="https://habr.com/ru/users/rock/" class="tm-user-info__username">
      rock
    </a> </span></span> <span class="tm-article-snippet__datetime-published"><time datetime="2014-11-18T11:57:02.000Z" title="2014-11-18, 14:57">18  ноября  2014 в 14:57</time></span></div> <!----></div> <h1 lang="ru" class="tm-article-snippet__title tm-article-snippet__title_h1"><span>Размышления о стандартной библиотеке JavaScript. Core.js</span></h1> <div class="tm-article-snippet__hubs"><span class="tm-article-snippet__hubs-item"><a href="https://habr.com/ru/hub/webdev/" class="tm-article-snippet__hubs-item-link"><span>Разработка веб-сайтов</span> <span title="Профильный хаб" class="tm-article-snippet__profiled-hub">*</span></a></span><span class="tm-article-snippet__hubs-item"><a href="https://habr.com/ru/hub/javascript/" class="tm-article-snippet__hubs-item-link"><span>JavaScript</span> <span title="Профильный хаб" class="tm-article-snippet__profiled-hub">*</span></a></span><span class="tm-article-snippet__hubs-item"><a href="https://habr.com/ru/hub/nodejs/" class="tm-article-snippet__hubs-item-link"><span>Node.JS</span> <span title="Профильный хаб" class="tm-article-snippet__profiled-hub">*</span></a></span></div> <!----> <!----> <!----></div></div> <!----> <div data-gallery-root="" lang="ru" class="tm-article-body"><div></div> <div id="post-content-body"><div><div class="article-formatted-body article-formatted-body_version-1"><div xmlns="http://www.w3.org/1999/xhtml"><blockquote>Один пацан писал все на JavaScript, и клиент, и сервер, говорил что нравится, удобно, читабельно. Потом его в дурку забрали, конечно.<br/>
<i><b>— С просторов интернета</b></i></blockquote><br/>
К чему это я? Занятная штука — JavaScript. Основа современного web и на фронтэнде альтернатив как таковых не имеет.<br/>
<br/>
JavaScript это, в том числе, и <a href="http://ru.wikipedia.org/wiki/%D1%F2%E0%ED%E4%E0%F0%F2%ED%E0%FF_%E1%E8%E1%EB%E8%EE%F2%E5%EA%E0">стандартная библиотека</a>, о которой здесь и пойдёт речь. Под стандартной библиотекой я подразумеваю модули, конструкторы, методы, что должны присутствовать на любой платформе, будь то браузер или сервер, без лишних действий со стороны программиста, не включая API, специфичный для платформы. Даже если вы пишите не на JavaScript, а на языке в него компилируемом, скорее всего, вам придется иметь дело с его стандартной библиотекой.<br/>
<br/>
Ванильная стандартная библиотека JavaScript, в целом, неплоха. Это не только стандартная библиотека по спецификации языка ECMA-262 актуальных версий — от 3 до черновика 6. Часть API вынесена в отдельные спецификации, например, API интернационализации ECMA-402. Многие возможности, без которых сложно представить JavaScript, например, <code>setTimeout</code>, относятся к web-стандартам. Консоль не стандартизована вовсе — приходится полагаться на стандарт де-факто.<br/>
<br/>
Вот только не такая уж она и стандартная — везде разная. Есть старые IE, в которых из коробки мы получаем стандартную библиотеку ES3 90-бородатого года даже без <code>Array#forEach, Function#bind, Object.create</code> и консоли, и есть, например, Node.js, на которой многие уже вовсю используют возможности грядущего ES6.<br/>
<br/>
Хочется иметь универсальную, действительно стандартную библиотеку, как на сервере, так и в любом браузере, максимально соответствующую современным стандартам, а также реализующую необходимый функционал, что (пока?) не стандартизован. Статья посвящена библиотеке <b><a href="https://github.com/zloirock/core-js">core.js</a></b> — реализация моих соображений по поводу стандартной библиотеки JavaScript. Кроме того, эта статья еще и шпаргалка по современной стандартизованной стандартной библиотеке JavaScript и заметки о её перспективах.<br/>
<br/>
<h4><b>Содержание, или что получим на выходе:</b></h4><br/>
<ul>
<li><h5><a href="https://habr.com/post/216997/#approach">Подходы</a></h5></li>
<li> <h5><a href="https://habr.com/post/216997/#I">Часть первая: Костыли</a></h5><br/>
 <ul>
<li><a href="https://habr.com/post/216997/#es5">ECMAScript 5</a></li>
<li><a href="https://habr.com/post/216997/#es6">ECMAScript 6</a></li>
<li><a href="https://habr.com/post/216997/#es6-symbol">ECMAScript 6: Символы</a></li>
<li><a href="https://habr.com/post/216997/#es6-collections">ECMAScript 6: Коллекции</a></li>
<li><a href="https://habr.com/post/216997/#es6-iterators">ECMAScript 6: Итераторы</a></li>
<li><a href="https://habr.com/post/216997/#es6-promise">ECMAScript 6: Обещания</a></li>
<li><a href="https://habr.com/post/216997/#array-generics">Mozilla JavaScript: Статические версии методов массива</a></li>
<li><a href="https://habr.com/post/216997/#schedule">Отложенное исполнение: setTimeout, setInterval, setImmediate</a></li>
<li><a href="https://habr.com/post/216997/#console">Консоль</a></li>
</ul><br/>
 </li>
<li> <h5><a href="https://habr.com/post/216997/#II">Часть вторая: Велосипеды</a></h5><br/>
 <ul>
<li><a href="https://habr.com/post/216997/#classify">Классификация данных</a></li>
<li><a href="https://habr.com/post/216997/#dict">Словари</a></li>
<li><a href="https://habr.com/post/216997/#partial-application">Частичное применение</a></li>
<li><a href="https://habr.com/post/216997/#date-format">Форматирование даты</a></li>
<li><a href="https://habr.com/post/216997/#object">Объектное API</a></li>
<li><a href="https://habr.com/post/216997/#array">Массивы</a></li>
<li><a href="https://habr.com/post/216997/#num">Числа</a></li>
<li><a href="https://habr.com/post/216997/#escape">Экранирование спецсимволов</a></li>
</ul><br/>
 </li>
<li><h5><a href="https://habr.com/post/216997/#end">Заключение</a></h5></li>
</ul><a name="habracut"></a><br/>
Предупреждаю, многабукф и первые главы довольно банальны, нет желания читать всё — оглавление выше, листайте до интересующего вас раздела.<br/>
<br/>
<a name="approach"></a><h2><b><a href="index.html.1.194.html#approach">#</a> Подходы</b></h2><hr/><br/>
Основных подхода к созданию библиотек, что можно назвать стандартными, в JavaScript три:<br/>
<br/>
Первый — <b>использование только <a href="http://en.wikipedia.org/wiki/Polyfill">полифилов</a>, только стандартизованного функционала</b>. Железобетонная уверенность в том, что со временем API не сломается. Для работы с такой библиотекой её знание не нужно, нужно только знание соответствующего API языка. Обычно, полифилы ограничены одним стандартом или его частью. Например, <a href="https://github.com/es-shims/es5-shim"><b>es5-shim</b></a> или <a href="https://github.com/paulmillr/es6-shim"><b>es6-shim</b></a>. По этой причине, для обеспечения возможностей, что хотелось бы иметь по умолчанию, приходится подключать несколько полифилов. Их внутренние компоненты часто дублируют друг друга, так что такой набор часто разрастается до сотен килобайт. Да и не все возможности, что хотелось бы иметь, стандартизованы. Возможность конфликтов с другими библиотеками незначительна, но в качестве зависимости при написании библиотеки их использовать я бы не стал.<br/>
<br/>
Второй — <b>набор утилит в собственном пространстве имён</b>. Либо экспорт в модульной системе, либо создание одного глобального объекта. Например, <a href="http://underscorejs.org/"><b>Undescore</b></a> или её форк <a href="https://lodash.com/"><b>LoDash</b></a>. Обычно, довольно компактен, но возможности ограничиваются набором простых утилит. Так как не расширяет нативные объекты и часто присутствует метод <code>noConflict</code>, откатывающий изменения, возможность конфликтов с другими библиотеками минимальна, лучше других упомянутых здесь способов подходит как безопасная зависимость для других библиотек.<br/>
<br/>
Третий — <b>расширение нативних объектов не только стандартизованным функционалом</b>. Например, добавление собственных методов в прототип массива, что обычно удобнее передачи массива в функцию. Сейчас в этой категории рулит <a href="http://sugarjs.com/"><b>Sugar</b></a>, в своё время — <a href="http://mootools.net/"><b>MooTools</b></a> и <a href="http://prototypejs.org/"><b>Prototype</b></a>. Добавляют много полезного функционала, но часто методы почти полностью дублируют друг друга. Здесь бы развернуться полифилам — но из полифилов подобные библиотеки обычно ограничиваются методами прототипа массива, <code>Function#bind</code> и еще несколькими, игнорируя большую часть стандартов. Что же касается конфликтов, то здесь всё совсем плохо. Подобные библиотеки часто расширяют нативные объекты методами с одним именем, но разной сигнатурой. Во избежание конфликтов, при разработке конечного приложения не стоит применять больше одной библиотеки, расширяющей нативные объекты, не считая полифилов, а при написании библиотеки такие зависимости вообще недопустимы.<br/>
<br/>
Вместо одной универсальной стандартной библиотеки, для обеспечения возможностей, которые бы хотелось иметь без лишних заморочек, мы вынуждены тянуть солянку из <i>Undescore / LoDash / Sugar + es5-shim, es6-shim, es6-symbol, setImmediate.js / asap, Moment.js / Intl.js, заглушку консоли</i>… и так далее.<br/>
<br/>
<a name="concept"></a><b><a href="index.html.1.194.html#concept">#</a></b> Попытаемся взять лучшее у каждого из данных подходов. <b>Концепция core.js такова</b>:<br/>
<br/>
<ul>
<li>В стандартной библиотеке должен быть весь необходимый для комфортной работы минимум возможностей, не включающий в себя возможности для работы с API конкретной платформы.</li>
<li>Стандарты — наше всё. Основная часть библиотеки — полифилы. Вот только не весь необходимый функционал стандартизован.</li>
<li>Если функционал, имеющийся в системе, реализован по спецификации или стандарту де-факто, оставляем нативный, но если функционал не стандартизован — во избежание конфликтов в будущем, замещаем принудительно.</li>
<li>Библиотека должна быть компактной и хорошо сжиматься.</li>
<li>Модульность, возможность собрать только необходимый функционал.</li>
<li>Пишите конечное приложение — вы здесь царь и бог и имеете полное право использовать библиотеку, расширяющую нативные объекты. Главное, что бы это делала только одна библиотека.</li>
<li>Пишите библиотеку или npm модуль — использовать библиотеку, расширяющую нативные объекты, нельзя ни в коем случае. Рискуете обречь на конфликты программиста, пишущего конечное приложение. На этот случай есть возможность сборки без их расширения.</li>
</ul><br/>
<a name="example"></a><b><a href="index.html.1.194.html#example">#</a></b> В случае обычной сборки, работа с <b>core.js</b> вполне очевидна:<br/>
<br/>
<pre><code class="javascript">console.log(Array.from(new Set([1, 2, 3, 2, 1]))); // => [1, 2, 3]
console.log('*'.repeat(10));                       // => '**********'
Promise.resolve(32).then(console.log);             // => 32
setImmediate(console.log, 42);                     // => 42
</code></pre><br/>
<a name="example-library"></a><b><a href="index.html.1.194.html#example-library">#</a></b> В случае сборки без расширения нативных объектов, функционал экспортируется либо в глобальный объект <code>core</code>, либо в модульную систему. Например, конструктор <code>Promise</code> доступен как <code>core.Promise</code>, а метод <code>Array.from</code> как <code>core.Array.from</code>. Методы, предназначенные к добавлению в прототип уже существующих, а не добавляемых библиотекой, конструкторов становятся статическими, например, <code>core.String.repeat</code> это статическая версия метода <code>String.prototype.repeat</code>.<br/>
<br/>
<pre><code class="javascript">var log  = core.console.log;
log(core.Array.from(new core.Set([1, 2, 3, 2, 1]))); // => [1, 2, 3]
log(core.String.repeat('*', 10));                    // => '**********'
core.Promise.resolve(32).then(log);                  // => 32
core.setImmediate(log, 42);                          // => 42
</code></pre><br/>
Сборка, содержащая только полифилы, соответственно, только их и добавляет. Собственно, в примере с обычной сборки только полифилы и используются.<br/>
<br/>
<a name="node"></a><b><a href="index.html.1.194.html#node">#</a></b> Установка на Node.js:<br/>
<br/>
<pre><code class="javascript">npm i core-js
</code></pre><br/>
Подключить можно на выбор одну из сборок:<br/>
<br/>
<pre><code class="javascript">// Максимальная сборка:
require('core-js');
// Сборка без расширения нативных объектов:
var core = require('core-js/library');
// Сборка, содержащая только полифилы:
require('core-js/shim');
</code></pre><br/>
<a name="browser-builds"></a><b><a href="index.html.1.194.html#browser-builds">#</a></b> <a href="https://github.com/zloirock/core-js/tree/master/client">Сборки для браузера</a>:<br/>
<br/>
<ul>
<li>Максимальная: <a href="https://raw.githubusercontent.com/zloirock/core-js/master/client/core.js">development</a>, <a href="https://raw.githubusercontent.com/zloirock/core-js/master/client/core.min.js">production</a> (21.8 кб без учёта gzip)</li>
<li>Без расширения нативных объектов: <a href="https://raw.githubusercontent.com/zloirock/core-js/master/client/library.js">development</a>, <a href="https://raw.githubusercontent.com/zloirock/core-js/master/client/library.min.js">production</a> (21.8 кб без учёта gzip)</li>
<li>Только полифилы: <a href="https://raw.githubusercontent.com/zloirock/core-js/master/client/shim.js">development</a>, <a href="https://raw.githubusercontent.com/zloirock/core-js/master/client/shim.min.js">production</a> (16.7 кб без учёта gzip)</li>
</ul><br/>
<a name="custom-builds"></a><b><a href="index.html.1.194.html#custom-builds">#</a></b> Если же вас не устраивает ни одна из этих сборок, можно сделать свою собственную. Например, вам нужны только модуль консоли и простое форматирование даты, притом без расширения нативных объектов. Для этого ставим Node.js, после чего устанавливаем grunt-cli, core-js с необходимыми для сборки зависимостями и собираем:<br/>
<br/>
<pre><code class="javascript">npm i -g grunt-cli
npm i core-js
cd node_modules/core-js &amp;&amp; npm i
grunt build:date,console,library --path=custom uglify
</code></pre><br/>
В итоге, получим файлы <code>custom.js</code>, <code>custom.min.js</code> весом 4.8кб и <code>custom.min.map</code>. Флаг <code>library</code> указывает на сборку без расширения нативных объектов. Посмотреть, к какому модулю относится необходимый функционал, можно <a href="https://github.com/zloirock/core-js#api">здесь</a> (последний столбец).<br/>
<br/>
<a name="I"></a><h1><b><a href="index.html.1.194.html#I">#</a> Часть первая: Костыли</b></h1><hr/>Если кто не понял, под костылями, в контексте статьи, подразумеваются полифилы стандартизованного функционала, имеющиеся в библиотеке. Итак, поехали:<br/>
<br/>
<a name="es5"></a><h2><b><a href="index.html.1.194.html#es5">#</a> ECMAScript 5</b></h2><hr/><br/>
Пожалуй, все знают, что добавляет ECMAScript 5 в стандартную библиотеку. Вымерли почти все браузеры, не поддерживающие ES5. За исключением старых IE. До сих пор, заказчики часто просят поддержку IE8, а в самых упоротых случаях даже IE6. Надеюсь, в ближайшее время ситуация изменится. Самым популярным полифилом ES5 является <a href="https://github.com/es-shims/es5-shim">этот es5-shim</a>, часть возможностей присутствует в Sugar, MooTools, Prototype, но только часть. Так как это далеко не новинка, обойдемся без лишних подробностей — краткое описание и, если нужно, некоторые особенности реализации. Само собой, важно помнить, что если код пишется с поддержкой IE8-, ни о какой работе с дескрипторами не может быть и речи.<br/>
<br/>
<a name="es5-array"></a><h4><b><a href="index.html.1.194.html#es5-array">#</a> Методы массива</b></h4><br/>
<a name="es5-array-proto"></a><b><a href="index.html.1.194.html#es5-array-proto">#</a></b> Начнем с методов прототипа массива. Это всем известные:<br/>
<br/>
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf">Array#indexOf</a> возвращает индекс первого элемента, равного указанному значению, или <code>-1</code>, если значение не найдено.<br/>
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/lastIndexOf">Array#lastIndexOf</a> аналогичен предыдущему, но возвращает индекс последнего элемента.<br/>
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach">Array#forEach</a> вызывает функцию для каждого элемента массива.<br/>
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map">Array#map</a> возвращает новый массив с результатом вызова функции для каждого элемента данного массива.<br/>
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter">Array#filter</a> возвращает новый массив со всеми элементами этого массива, удовлетворяющими условию проверяющей функции.<br/>
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/every">Array#every</a> проверяет, каждый ли элемент в массиве удовлетворяет условию проверяющей функции.<br/>
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some">Array#some</a> проверяет, есть ли хотя бы один элемент массива, удовлетворяющий условию проверяющей функции.<br/>
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce">Array#reduce</a> выполняет свертку массива с применением функции, слева — направо.<br/>
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/ReduceRight">Array#reduceRight</a> выполняет свертку массива с применением функции, справа — налево.<br/>
<br/>
<pre><code class="javascript">[1, 2, 3, 2, 1].indexOf(2);     // => 1
[1, 2, 3, 2, 1].lastIndexOf(2); // => 3
[1, 2, 3].forEach(function(val, key){
  console.log(val);             // => 1, 2, 3
  console.log(key);             // => 0, 1, 2
});
[1, 2, 3].map(function(it){
  return it * it;
});                             // => [1, 4, 9]
[1, 2, 3].filter(function(it){
  return it % 2;
});                             // => [1, 3]
function isNum(it){
  return typeof it == 'number';
}
[1, '2', 3].every(isNum);       // => false
[1, '2', 3].some(isNum);        // => true
function add(a, b){
  return a + b;
}
[1, 2, 3].reduce(add);          // => 6
[1, 2, 3].reduceRight(add, ''); // => '321'
</code></pre><br/>
Данные методы реализуются элементарно, но есть одна особенность. Методы массива — <a href="https://ru.wikipedia.org/wiki/%CE%E1%EE%E1%F9%B8%ED%ED%EE%E5_%EF%F0%EE%E3%F0%E0%EC%EC%E8%F0%EE%E2%E0%ED%E8%E5">дженерики</a> и могут быть вызваны в контексте не только массива, но и любого array-like объекта, подробнее об этом <a href="index.html.1.194.html#array-generics"># будет ниже</a>. Так вот, по спецификации ES5 строки являются array-like объектами, букву строки можно получить по индексу, например, <code>'string'[2] // => 'r'</code>, а в старых IE таковыми они не является. В случае применения данных методов в контексте строк, приводим строки к массиву. Для решения этой же проблемы, при необходимости подменяем в старых IE <code>Array#slice</code> и <code>Array#join</code>.<br/>
<br/>
<pre><code class="javascript">Array.prototype.map.call('123', function(it){
  return it * it;
});                                    // => [1, 4, 9]
Array.prototype.slice.call('qwe', 1);  // => ['w', 'e']
Array.prototype.join.call('qwe', '|'); // => 'q|w|e'
</code></pre><br/>
Ну и не забывайте древнюю истину: <b>никогда не обходите массив циклом <code>for-in</code></b>. Это не только медленно, но и вынуждает, если нужна поддержка IE8-, проверять, является ли ключ собственным — иначе выполните обход не только элементов массива, но и методов его прототипа :)<br/>
<br/>
<a name="es5-is-array"></a><b><a href="index.html.1.194.html#es5-is-array">#</a></b> К этой же категории относится статический метод <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray">Array.isArray</a>. Метод проверяет, является ли объект массивом не по цепочке прототипов, а по внутреннему классу. Полезно, но не универсально. О классификации объектов подробно мы поговорим <a href="index.html.1.194.html#classof"># во второй, велосипедной, части статьи</a>.<br/>
<br/>
<pre><code class="javascript">Array.isArray([1, 2, 3]);                      // => true
Array.isArray(Object.create(Array.prototype)); // => false
</code></pre><br/>
<a name="es5-object"></a><h4><b><a href="index.html.1.194.html#es5-object">#</a> Объектное API</b></h4><br/>
Полная эмуляция всех методов объектного API ECMAScript 5 на базе ECMAScript 3 невозможна, частичная — возможна для многих. ES5 добавляет в объектное API следующие категории методов: работа с прототипом (создание из / получение), получение ключей объекта, работа с дескрипторами.<br/>
<br/>
<a name="es5-create"></a><a href="index.html.1.194.html#es5-create"><b>#</b></a> Метод <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create">Object.create</a> создает объект из прототипа. Передав <code>null</code>, можно создать объект без прототипа, что сделать на базе ECMAScript 3 невозможно. Приходится использовать лютый трэш на базе <code>iframe</code>. Зачем это нам будет раскрыто <a href="index.html.1.194.html#dict"># во второй части</a>. Опционально принимает объект <a href="index.html.1.194.html#es5-desc"># дескрипторов</a>, аналогично <code>Object.defineProperties</code>.<br/>
<br/>
<pre><code class="javascript">function Parent(/*...*/){ /*...*/ }
Parent.prototype = {constructor: Parent /*, ... */}
function Child(/*...*/){
  Parent.call(this /*, ...*/);
  // ...
}
// Было в ES3 (нутрянка всяких inherit и extend'ов):
function Tmp(){}
Tmp.prototype = Parent.prototype;
Child.prototype = new Tmp;
Child.prototype.constructor = Child;
// Стало с ES5:
Child.prototype = Object.create(Parent.prototype, {constructor: {value: Child}});

var dict = Object.create(null);
dict.key = 42;
console.log(dict instanceof Object); // => false
console.log(dict.toString)           // => undefined
console.log(dict.key)                // => 42
</code></pre><br/>
<a name="es5-getPrototypeOf"></a><a href="index.html.1.194.html#es5-getPrototypeOf"><b>#</b></a> Метод <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getPrototypeOf">Object.getPrototypeOf</a> возвращает прототип объекта. В ECMAScript 3 нет гарантированного способа получения прототипа объекта. Если объект содержит свойство <code>constructor</code>, возможно прототипом будет <code>constructor.prototype</code>. Для объектов, созданных через <code>Object.create</code>, добавим <a href="index.html.1.194.html#es6-symbol"># символ</a>, содержащий прототип, и будем игнорировать его при <a href="index.html.1.194.html#es5-keys"># получении ключей</a>. Но на инстансе конструктора, прототип которого был переопределен без указания «правильного» свойства <code>constructor</code>, <code>Object.getPrototypeOf</code> будет работать некорректно.<br/>
<br/>
<pre><code class="javascript">var parent = {foo: 'bar'}
  , child  = Object.create(parent);
console.log(Object.getPrototypeOf(child) === parent);      // => true

function F(){}
console.log(Object.getPrototypeOf(new F) === F.prototype); // => true

F.prototype = {constructor: F /*, ...*/};
console.log(Object.getPrototypeOf(new F) === F.prototype); // => true

F.prototype = {};
console.log(Object.getPrototypeOf(new F) === F.prototype); // В IE8- будет работать некорректно
</code></pre><br/>
<a name="es5-keys"></a><a href="index.html.1.194.html#es5-keys"><b>#</b></a> Метод <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys">Object.keys</a> возвращает массив собственных перечисляемых ключей объекта. <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyNames">Object.getOwnPropertyNames</a> возвращает массив собственных ключей объекта, в т.ч. и неперечисляемых. С <code>Object.keys</code>, вроде, всё просто — перебираем объект через <code>for-in</code> и проверяем, являются ли свойства собственными. Если бы не <a href="https://developer.mozilla.org/en-US/docs/ECMAScript_DontEnum_attribute#JScript_DontEnum_Bug">баг с «неперечисляемыми перечисляемыми» свойствами</a> в IE. Так что приходится проверять наличие таковых свойств отдельно. Аналогично, с дополнительной проверкой по списку имеющихся скрытых свойств, работает и <code>Object.getOwnPropertyNames</code>.<br/>
<br/>
<pre><code class="javascript">console.log(Object.keys({q: 1, w: 2, e: 3}));       // => ['q', 'w', 'e']
console.log(Object.keys([1, 2, 3]));                // => ['0', '1', '2']
console.log(Object.getOwnPropertyNames([1, 2, 3])); // => ['0', '1', '2', 'length']
</code></pre><br/>
<a name="es5-desc"></a><a href="index.html.1.194.html#es5-desc"><b>#</b></a> С дескрипторами всё плохо, ECMAScript 3 их не поддерживает. Задать геттеры / сеттеры нет возможности. Браузеры, где есть <code>Object#__define[GS]etter__</code>, но отсутствует <code>Object.defineProperty</code>, давно вымерли. В старых IE есть возможность создать объект с геттерами / сеттерами через <a href="http://habrahabr.ru/post/75158/">извращения с VBScript</a>, но это отдельная тема. <code>enumerable: false</code> свойства есть, их не задать, но есть возможность проверить является ли оно таковым, через <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/propertyIsEnumerable">Object#propertyIsEnumerable</a>. В IE8 есть методы для работы с дескрипторами, но лучше бы их не было (работают только с DOM объектами). Итого, всё, что мы можем сделать для IE8- — заглушки. Установка значения свойства по <code>value</code> дескриптора в <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty">Object.defineProperty</a> и <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperties">Object.defineProperties</a> да честное получение <code>value</code> и <code>enumerable</code> в <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptor">Object.getOwnPropertyDescriptor</a>.<br/>
<br/>
<a name="es5-freeze"></a><a href="index.html.1.194.html#es5-freeze"><b>#</b></a> А что насчет <code>Object.freeze, Object.preventExtensions, Object.seal</code>? Мало того, что их эмуляция невозможна, можно сделать разве что заглушки, но есть и такая точка зрения:<br/>
<blockquote><b>Object.freeze, Object.preventExtensions, Object.seal, with, eval</b><br/>
Crazy shit that you will probably never need. Stay away from it.<br/>
<i><b><a href="http://nodeguide.com/style.html#object.freeze-object.preventextensions-object.seal-with-eval">— Felix Geisendörfer</a></b></i><br/>
</blockquote>И я с ней полностью согласен, так что обойдемся без них.<br/>
<br/>
<a name="es5-other"></a><h4><b><a href="index.html.1.194.html#es5-other">#</a> Прочее</b></h4><br/>
<a name="es5-bind"></a><a href="index.html.1.194.html#es5-bind"><b>#</b></a> В ECMAScript 5 добавлены привязка контекста и базовые возможности частичного применения через <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind">Function#bind</a>. Метод замечательный, но для раскрытия потенциала частичного применения и привязки контекста в JavaScript одного его мало, подробно тема раскрывается в <a href="index.html.1.194.html#partial-application"># соответствующем разделе</a>.<br/>
<br/>
<pre><code class="javascript">var fn = console.log.bind(console, 42);
fn(43); // => 42 43
</code></pre><br/>
<a name="es5-now"></a><a href="index.html.1.194.html#es5-now"><b>#</b></a> Метод <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/now">Date.now</a> возвращает текущее время в числовом представлении, результат выполнения аналогичен <code>+new Date</code>.<br/>
<br/>
<pre><code class="javascript">Date.now(); // => 1400263401642
</code></pre><br/>
<a name="es5-trim"></a><a href="index.html.1.194.html#es5-trim"><b>#</b></a> Метод <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/Trim">String#trim</a> удаляет пробельные символы из начала и конца строки.<br/>
<br/>
<pre><code class="javascript">'\n   строка   \n'.trim(); // => 'строка'
</code></pre><br/>
Что же касается модуля <code>JSON</code>, то он поддерживается IE8 и, в рамках данной библиотеки, реализовывать его я не вижу смысла. Если он вам понадобится в совсем уж доисторических IE — никто не мешает использовать, например, <a href="https://github.com/douglascrockford/JSON-js">этот</a> полифил.<br/>
<br/>
<a name="es6"></a><h2><b><a href="index.html.1.194.html#es6">#</a> ECMAScript 6</b></h2><hr/><br/>
Спецификация ECMAScript 5 была написана наспех вместо так и не принятой спецификации ECMAScript 4 и мало расширяла принятую ещё в прошлом тысячелетии ECMAScript 3. Сейчас уже почти завершена куда более серьёзно расширяющая язык, в т.ч. и стандартную библиотеку, спецификация ECMAScript 6. Добавление новых фич в неё заморожено, все серьёзные изменения идут в предложения по ECMAScript 7, в последнее время большинство изменений черновика спецификации это исправления ошибок. Так что в нашей стандартной библиотеке будем ориентироваться, в основном, на ES6.<br/>
<br/>
Что с её поддержкой в актуальных движках хорошо видно по <a href="http://kangax.github.io/compat-table/es6/">данной таблице</a>.<br/>
<br/>
<ul>
<li>Лучше всех с её поддержкой у <b>Firefox</b> — уже доступно очень многое.</li>
<li><a name="v8-harmony-mode"></a><a href="index.html.1.194.html#v8-harmony-mode"><b>#</b></a> В <b>v8 (Chrome, Opera, Node.js)</b> тоже доступно довольно многое, но значительная часть возможностей по умолчанию заблокирована, для их активации в браузере необходимо поставить флажок «Включить экспериментальный JavaScript» (парсер съедает ссылку <code>chrome://flags/#enable-javascript-harmony</code>), а Node.js запустить с флажком <code>--harmony</code>. Что-то доступно и без флажка, например, <code>Promise</code>, <code>WeakMap</code> и <code>WeakSet</code>, а начиная с Chrome 38 доступны и <code>Symbol</code>, <code>Map</code>, <code>Set</code>, итераторы. Node.js в этом плане сильно отстаёт, так как, особенно в стабильной ветке, v8 там обновляется редко. Зато её, в отличии от браузера пользователя, вам никто не помешает запустить с флажком.</li>
<li>У <b>IE</b>, как обычно, всё плохо, но в 11ой версии были добавлены коллекции и еще пара возможностей. В ближайшем будущем обещают <a href="http://habrahabr.ru/company/microsoft/blog/243215/">очень многое</a>.</li>
<li>Добавить функционал ES6 попытались и в <b>Safari</b>. Вот только почти всё, что они добавили, не соответствует стандарту и порождает лишние проблемы, так что лучше бы и не добавляли. По <a href="https://esdiscuss.org/topic/safari-8-es6-ish-implementation">ссылке</a> только небольшая часть проблем.</li>
</ul><br/>
Самым популярным полифилом ES6 является <a href="https://github.com/paulmillr/es6-shim/">es6-shim</a> от <a href="https://habrahabr.ru/users/paulmillr/" class="user_link">paulmillr</a>.<br/>
<br/>
Часть стандартной библиотеки ECMAScript 6, например, <code>Proxy</code> (а это одна из самых вкусных возможностей), на базе ECMAScript 5 и уж тем более ECMAScript 3 реализовать невозможно, но большую часть можно реализовать если не полностью, то хотя бы частично и «нечестно».<br/>
<br/>
<a name="preprocessors"></a><h4><b><a href="index.html.1.194.html#preprocessors">#</a> Немного про препроцессоры ECMAScript 6+</b></h4><br/>
Что касается синтаксиса, то, в рамках этой библиотеки, его поддержку мы добавить не можем. Однако на помощь тут приходят препроцессоры, преобразующие синтаксис ECMAScript 6+ в ECMAScript 3 или 5. Их огромное количество, рассмотрим только пару популярных.<br/>
<br/>
Есть такой старый и мощный проект — <b><a href="https://github.com/google/traceur-compiler">Google Traceur</a></b>. Он генерирует нечитаемый код и использует довольно тяжелый runtime, так что от его использования я отказался.<br/>
<br/>
Другой проект мне кажется куда более привлекательным — <b><a href="https://github.com/6to5/6to5">6to5</a></b>. Проект свежий и развивается <b>потрясающе</b> быстро. Он генерирует легко читаемый код и не использует собственный runtime, исключение — runtime <b><a href="http://facebook.github.io/regenerator/">regenerator</a></b>, который он использует для компиляции генераторов. Зато вместо него активно использует стандартную библиотеку ES6 — например, <a href="index.html.1.194.html#es6-iterable-interface"># <code>Symbol.iterator</code></a>. По умолчанию — <a href="https://github.com/paulmillr/es6-shim">es6-shim</a> и <a href="https://github.com/medikoo/es6-symbol">es6-symbol</a>. Их легко заменяет наша библиотека, что делает данный препроцессор идеальной её парой. Преобразует код в ECMAScript 5, но, главным образом, это касается стандартной библиотеки — с заглушками методов вроде <a href="index.html.1.194.html#es5-desc"># <code>Object.defineProperties</code></a> почти всё будет работать и в старых IE.<br/>
<br/>
<b>С использованием препроцессора и полифила стандартной библиотеки, начинать использовать ECMAScript 6 на полную катушку можно уже сейчас.</b> За исключением, разве что, некоторых мелочей.<br/>
<br/>
Набросал совсем <b>простенькую <a href="http://es6.zloirock.ru">песочницу</a></b> с возможностью компиляции ES6 через <b>6to5</b> и подключенной библиотекой <b>core.js</b>, примеры будут со ссылками на неё. Однако, так как наша библиотека никак не привязана к синтаксису ECMAScript 6, большая часть примеров будет с использованием синтаксиса ECMAScript 5.<br/>
<br/>
<hr/><br/>
Ну а теперь перейдём к стандартной библиотеке по ECMAScript 6. Новые конструкторы и концепции мы рассмотрим в отдельных главах, это <a href="index.html.1.194.html#es6-symbol"># символы</a>, <a href="index.html.1.194.html#es6-collections"># коллекции</a>, <a href="index.html.1.194.html#es6-iterators"># итераторы</a> и <a href="index.html.1.194.html#es6-promise"># обещания</a>, остальное рассмотрим здесь.<br/>
<br/>
<a name="es6-object-assign"></a><h4><b><a href="index.html.1.194.html#es6-object-assign">#</a> Object.assign</b></h4><br/>
Этого метода ждали многие. <a href="http://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.assign">Object.assign</a> банально копирует все собственные перечисляемые свойства объекта (объектов) источника в целевой объект. <a href="http://goo.gl/H3zj4b">Пример</a>:<br/>
<br/>
<pre><code class="javascript">var foo = {q: 1, w: 2}
  , bar = {e: 3, r: 4}
  , baz = {t: 5, y: 6};
Object.assign(foo, bar, baz); // => foo = {q: 1, w: 2, e: 3, r: 4, t: 5, y: 6}
</code></pre><br/>
Планировалось также добавить метод <code>Object.mixin</code>, который копировал еще и неперечисляемые свойства, учитывал дескрипторы и переназначал родителя, получаемого через ключевое слово <code>super</code>. Однако, его добавление решили отложить. Его аналог есть в <a href="index.html.1.194.html#object-define"># велосипедной части</a> библиотеки.<br/>
<br/>
<a name="es6-object-is"></a><h4><b><a href="index.html.1.194.html#es6-object-is">#</a> Object.is</b></h4><br/>
Операторы сравнения в JavaScript вообще довольно странно себя ведут. Забудем даже такой оператор, как <code>==</code> с его приведениями, посмотрим на <code>===</code>:<br/>
<br/>
<pre><code class="javascript">NaN === NaN  // => false
0 === -0     // => true, но при этом:
1/0 === 1/-0 // => false
</code></pre><br/>
Как раз для этого случая, в языке есть внутренний алгоритм сравнения <a href="http://es5.javascript.ru/x9.html#x9.12">SameValue</a>. Для него <code>NaN</code> равен <code>NaN</code>, а <code>+0</code> и <code>-0</code> различны. В ECMAScript 6 его хотели вынести наружу как операторы <code>is</code> и <code>isnt</code>, но, похоже, поняв, что операторов сравнения в языке уже и так не мало, да и для обратной совместимости, вынесли как метод <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is">Object.is</a>. <a href="http://goo.gl/XMplwh">Пример</a>:<br/>
<br/>
<pre><code class="javascript">Object.is(NaN, NaN); // => true
Object.is(0, -0);    // => false
Object.is(42, 42);   // => true, аналогично '==='
Object.is(42, '42'); // => false, аналогично '==='
</code></pre><br/>
<a name="same-value-zero"></a><a href="index.html.1.194.html#same-value-zero">#</a> Также в ES6 и далее активно используется другой алгоритм сравнения — <a href="http://people.mozilla.org/~jorendorff/es6-draft.html#sec-samevaluezero">SameValueZero</a>, для которого <code>NaN</code> равен <code>NaN</code>, и, в отличии от предыдущего, <code>-0</code> равен <code>+0</code>. Им обеспечивается уникальность ключа <a href="index.html.1.194.html#es6-collections"># коллекций</a>, он применяется при проверке вхождения элемента в коллекцию через <a href="index.html.1.194.html#array-contains"># <code>Array#includes</code></a>.<br/>
<br/>
<a name="es6-object-setPrototypeOf"></a><h4><b><a href="index.html.1.194.html#es6-object-setPrototypeOf">#</a> Object.setPrototypeOf</b></h4><br/>
В ES6 для установки прототипа существующего объекта появляется метод <code>Object.setPrototypeOf</code>. <a href="http://goo.gl/t4wJ4K">Пример</a>:<br/>
<br/>
<pre><code class="javascript">function Parent(){}
function Child(){}
Object.setPrototypeOf(Child.prototype, Parent.prototype);
new Child instanceof Child;  // => true
new Child instanceof Parent; // => true

function fn(){}
Object.setPrototypeOf(fn, []);
typeof fn == 'function';     // => true 
fn instanceof Array;         // => true

var object = {};
Object.setPrototypeOf(object, null);
object instanceof Object;    // => false
</code></pre><br/>
Странно, что такая, казалось бы, необходимая, учитывая прототипную ориентированность языка, возможность — посмотрите, хотя бы, первый пример — простое и очевидное прототипное наследование, отсутствует в ECMAScript 5. Единственный способ изменить прототип уже существующего объекта без данного метода — нестандартное свойство <code>__proto__</code>. На текущий момент, оно поддерживается всеми актуальными браузерами, кроме IE10-, в текущей реализации — геттер / сеттер в прототипе <code>Object</code>.<br/>
<br/>
Примитивная, без лишних проверок и возврата объекта, версия <code>Object.setPrototypeOf</code> выглядела бы просто — выдернем сеттер <code>__proto__</code> и сделаем из него функцию:<br/>
<br/>
<pre><code class="javascript">var setPrototypeOf = Function.call.bind(Object.getOwnPropertyDescriptor(Object.prototype, '__proto__').set);
</code></pre><br/>
Однако, тут появляется еще одна проблема — в старых, но где-то еще актуальных, версиях v8, сеттер <code>__proto__</code> нельзя использовать как функцию. Для реализации <code>Object.setPrototypeOf</code> в них остается только установка значения по ключу <code>__proto__</code>.<br/>
<br/>
<h5>Так и живем:</h5><br/>
<ul>
<li><b>Для IE10- эмуляция <code>Object.setPrototypeOf</code> отсутствует полностью, так как невозможна.</b></li>
<li>В старых версиях v8 <code>Object.setPrototypeOf</code> не работает, если в цепочке прототипов цели отсутствует <code>Object.prototype</code> или свойство <code>__proto__</code> переопределено через, например, <code>Object.defineProperty</code>.</li>
</ul><br/>
Также, ECMAScript 6 и наша библиотека изменяет логику работы <code>Object#toString</code>. Тема серьёзная, но о ней мы поговорим <a href="index.html.1.194.html#classof"># во второй части статьи</a>.<br/>
<br/>
<a name="es6-array"></a><h4><b><a href="index.html.1.194.html#es6-array">#</a> Методы массива</b></h4><br/>
Статические методы <code>Array.from</code> и <code>Array.of</code> — дженерики, если они запущены в контексте функции, отличной от <code>Array</code>, они создают её инстансы. Если есть желание ознакомиться с этим подробней — хорошо описано в <a href="http://www.2ality.com/2014/05/es6-array-methods.html">этой статье по новым методам массива</a>.<br/>
<br/>
<a name="es6-array-from"></a><a href="index.html.1.194.html#es6-array-from"><b>#</b></a> ECMAScript 6 добавляет очень полезный метод — <code>Array.from</code>. Это универсальное приведение к массиву <a href="index.html.1.194.html#es6-iterators"># итерируемых</a> и array-like объектов. Во большинстве случаев он заменит <code>Array.prototype.slice.call</code> без указания начальной и конечной позиций. Дополнительно, метод принимает опциональный map-коллбэк и контекст его исполнения. В случае передачи итерируемого объекта и без map-коллбэка, результат аналогичен использованию оператора <a href="index.html.1.194.html#es6-spread"># spread</a> в литерале массива — <code>[...iterable]</code>. <a href="http://goo.gl/h1F9dN">Пример</a>:<br/>
<br/>
<pre><code class="javascript">Array.from(new Set([1, 2, 3, 2, 1]));      // => [1, 2, 3]
Array.from({0: 1, 1: 2, 2: 3, length: 3}); // => [1, 2, 3]
Array.from('123', Number);                 // => [1, 2, 3]
Array.from('123', function(it){
  return it * it;
});                                        // => [1, 4, 9]
</code></pre><br/>
<a name="es6-array-of"></a><a href="index.html.1.194.html#es6-array-of"><b>#</b></a> В отличие от предыдущего, метод <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/of">Array.of</a> на текущий момент практически бесполезен. Он нужен, в первую очередь, для подклассов <code>Array</code>, как аналог литерала массива <code>[]</code>. <a href="http://goo.gl/BV1EDC">Пример</a>:<br/>
<br/>
<pre><code class="javascript">Array.of(1);       // => [1]
Array.of(1, 2, 3); // => [1, 2, 3]
</code></pre><br/>
<a name="es6-array-find"></a><a href="index.html.1.194.html#es6-array-find"><b>#</b></a> Методы <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find">Array#find</a> и <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex">Array#findIndex</a> осуществляют поиск по массиву через вызов коллбэка. <a href="http://goo.gl/Gb8ILU">Пример</a>:<br/>
<br/>
<pre><code class="javascript">function isOdd(val){
  return val % 2;
}
[4, 8, 15, 16, 23, 42].find(isOdd);      // => 15
[4, 8, 15, 16, 23, 42].findIndex(isOdd); // => 2
[4, 8, 15, 16, 23, 42].find(isNaN);      // => undefined
[4, 8, 15, 16, 23, 42].findIndex(isNaN); // => -1
</code></pre><br/>
<a name="es6-array-fill"></a><a href="index.html.1.194.html#es6-array-fill"><b>#</b></a> Метод массива <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/fill">Array#fill</a> заполняет массив переданным значением. Опциональные аргументы — стартовая и конечная позиции. <a href="http://goo.gl/34utph">Пример</a>:<br/>
<br/>
<pre><code class="javascript">Array(5).map(function(){
  return 42;
});                // => [undefined × 5], потому как .map пропускает "дырки" в массиве
Array(5).fill(42); // => [42, 42, 42, 42, 42]
</code></pre><br/>
<a name="es6-string"></a><h4><b><a href="index.html.1.194.html#es6-string">#</a> Методы строки</b></h4><br/>
Тут всё просто. <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes">String#includes</a> (до недавнего времени — <code>String#contains</code>, но <a href="index.html.1.194.html#array-contains"># <code>Array#includes</code></a> утянул его за собой, пока доступен и по старому имени) проверяет вхождение подстроки в строку. <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith">String#startsWith</a> и <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith">String#endsWith</a> проверяют, начинается ли или заканчивается ли строка на заданную подстроку. Эти 3 метода принимают дополнительный аргумент — стартовую позицию. <a href="http://goo.gl/B5uMrt">Пример</a>:<br/>
<br/>
<pre><code class="javascript">'foobarbaz'.includes('bar');      // => true
'foobarbaz'.includes('bar', 4);   // => false
'foobarbaz'.startsWith('foo');    // => true
'foobarbaz'.startsWith('bar', 3); // => true
'foobarbaz'.endsWith('baz');      // => true
'foobarbaz'.endsWith('bar', 6);   // => true
</code></pre><br/>
Метод <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/repeat">String#repeat</a> возвращает строку, повторенную заданное число раз. <a href="http://goo.gl/UBdYnv">Пример</a>:<br/>
<br/>
<pre><code class="javascript">'string'.repeat(3); // => 'stringstringstring'
</code></pre><br/>
Библиотека пока не добавляет методы ECMAScript 6 / 7 <a href="https://github.com/lukehoban/es6features#unicode">для лучшей поддержки многобайтовых символов</a> и честный <a href="index.html.1.194.html#es6-iterators"># итератор</a> строки, для строк используется итератор массива. Сейчас их нет только потому, что они лично мне просто не нужны. Было бы неплохо добавить их в ближайшем будущем.<br/>
<br/>
<a name="es6-math"></a><h4><b><a href="index.html.1.194.html#es6-math">#</a> Работа с числами</b></h4><br/>
В ECMAScript 6 добавлено огромное количество математических функций и констант. Обойдемся без их описания и примеров, только ссылки: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/EPSILON">Number.EPSILON</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/parseFloat">Number.parseFloat</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/parseInt">Number.parseInt</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isFinite">Number.isFinite</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isInteger">Number.isInteger</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isNaN">Number.isNaN</a>, <a href="http://www.2ality.com/2013/10/safe-integers.html">Number.MAX_SAFE_INTEGER, Number.MIN_SAFE_INTEGER, Number.isSafeInteger</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/acosh">Math.acosh</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/asinh">Math.asinh</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/atanh">Math.atanh</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/cbrt">Math.cbrt</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/clz32">Math.clz32</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/cosh">Math.cosh</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/expm1">Math.expm1</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/hypot">Math.hypot</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/imul">Math.imul</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/log1p">Math.log1p</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/log10">Math.log10</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/log2">Math.log2</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign">Math.sign</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sinh">Math.sinh</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/tanh">Math.tanh</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/trunc">Math.trunc</a>.<br/>
<br/>
<a name="es6-symbol"></a><h2><b><a href="index.html.1.194.html#es6-symbol">#</a> ECMAScript 6: Символы</b></h2><hr/><br/>
В JavaScript с сокрытием свойств объектов дела обстоят довольно плохо. Приватные данные можно хранить в замыканиях, что вынуждает объявлять методы для работы с ними внутри конструктора, а не в прототипе объекта. Начиная с ECMAScript 5, можно объявлять <code>enumerable: false</code> свойства, что скроет свойства объекта от перечисления в <code>for-in</code> и от <code>Object.keys</code>, но это не обеспечит надежного сокрытия — ключ не уникален, его можно легко подобрать, могут возникнуть конфликты имен и, из-за необходимости использования <code>Object.defineProperty</code> с объектом-дескриптором, это довольно громоздко.<br/>
<br/>
В ECMAScript 6 для упрощения инкапсуляции появляется новый тип данных — <a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Symbol">Symbol</a>, ранее известный как <a href="http://wiki.ecmascript.org/doku.php?id=harmony:private_name_objects">Name</a>. Символы предназначены для использования в качестве уникальных ключей объектов. <a href="http://goo.gl/EUsvAf">Пример</a>:<br/>
<br/>
<pre><code class="javascript">var Person = (function(){
  var NAME = Symbol('name');
  function Person(name){
    this[NAME] = name;
  }
  Person.prototype.getName = function(){
    return this[NAME];
  };
  return Person;
})();

var person = new Person('Вася');
console.log(person.getName());          // => 'Вася'
console.log(person['name']);            // => undefined
console.log(person[Symbol('name')]);    // => undefined, каждый вызов Symbol возвращает уникальный ключ
for(var key in person)console.log(key); // => только 'getName', символы не участвуют в обходе объекта

console.log(typeof Symbol());           // => 'symbol'
</code></pre><br/>
Символы не являются полностью приватными — метод <code>Object.getOwnPropertySymbols</code> возвращает собственные символы объекта, что даёт возможность отладки и низкоуровневых операций вроде клонирования. Хранение по настоящему приватных данных можно реализовать на базе <a href="index.html.1.194.html#es6-weakmap"># WeakMap</a>. Хотя, ИМХО, более удачным решением проблемы было бы добавление полностью приватной версии символов.<br/>
<br/>
На текущий момент символы доступны в v8, начиная с Chrome 38 (в более ранних версиях — <a href="index.html.1.194.html#v8-harmony-mode"># с флажком экспериментальных возможностей</a>) и в ночных сборках Firefox, начиная с 33. Скоро обещают и в IE, так что в самом ближайшем будущем будет доступен во всех основных современных браузерах.<br/>
<br/>
<a name="es6-symbol-polyfill"></a><a href="index.html.1.194.html#es6-symbol-polyfill"><b>#</b></a> Конечно, полноценный полифил символов на базе ES5 невозможен, но базовые возможности — создание уникальных не участвующих в обходе объекта через <code>for-in</code> и не возвращаемых <code>Object.keys</code> ключей — реализуется довольно просто, например, так:<br/>
<br/>
<pre><code class="javascript">window.Symbol || (function(){
  var id = 0;
  window.Symbol = function(description){
    if(this instanceof Symbol)throw new TypeError('Symbol is not a constructor');
    var symbol = Object.create(Symbol.prototype)
      , tag    = 'Symbol(' + description + ')_' + (++id + Math.random()).toString(36);
    symbol.tag = tag;
    Object.defineProperty(Object.prototype, tag, {
      configurable: true,
      set: function(it){
        Object.defineProperty(this, tag, {
          enumerable  : false,
          configurable: true,
          writable    : true,
          value       : it
        });
      }
    });
    return symbol;
  }
  Symbol.prototype.toString = function(){
    return this.tag;
  }
})();
</code></pre><br/>
При вызове <code>Symbol</code> мы генерируем уникальный ключ-строку, например, <code>"Symbol(description)_m.y9oth2pcqaypsyvi"</code>, и по этому ключу в <code>Object.prototype</code> устанавливаем сеттер. При попытке установить значение по строке-ключу, к которой приведется наш «символ», сеттер устанавливает <code>enumerable: false</code> свойство в текущий объект. Однако, у подобных «символов» есть огромное количество минусов, вот только часть:<br/>
<br/>
<ul>
<li>Пишет сеттер в <code>Object.prototype</code>: не стоит особо злоупотреблять, может повлиять на производительность.</li>
<li>Работает на базе дескрипторов: в IE8- работает (за счет <a href="index.html.1.194.html#es5-desc"># заглушки</a> <code>Object.defineProperty</code>), не будет сеттеров в <code>Object.prototype</code>, «символы» будут перечисляемы.</li>
<li>В объектах, не содержащих под собой <code>Object.prototype</code> (например, <code>Object.create(null)</code>), «символы» будут перечисляемы.</li>
<li><code>Symbol() in {}</code> вернет <code>true</code> — нужно проверять наличие символов в объекте иным способом.</li>
<li><code>typeof Symbol()</code> будет равен <code>'object'</code> — средствами JavaScript мы не можем добавить новый тип данных.</li>
<li>Не добавляем <code>Object.getOwnPropertySymbols</code> — лишняя обертка для <code>Object.getOwnPropertyNames</code> плохо скажется на производительности, соответственно, <code>Object.getOwnPropertyNames</code> будет возвращать, в том числе, и «символы».</li>
</ul><br/>
<a name="es6-symbol-pure"></a><a href="index.html.1.194.html#es6-symbol-pure"><b>#</b></a> Если решение настолько сомнительно, что оно тут делает? Если в проекте нужно незначительное количество символов и не планируется их использовать с объектами, не содержащими под собой <code>Object.prototype</code>, данное решение вполне сойдет. Для остальных случаев добавим в библиотеку пару хелперов. <code>Symbol.pure</code>, если доступны нативные символы, возвращающий символ, нет — возвращающий уникальную строку-ключ без добавления сеттера в <code>Object.prototype</code>, и <code>Symbol.set</code>, если доступны нативные символы — просто устанавливающий в объект значение по ключу, нет — устанавливающий значение, используя <code>Object.defineProperty</code> с <code>enumerable: false</code>. Таким примитивным образом, избавляемся от половины описанных выше проблем. Использованный выше пример с использованием данных хелперов вместо вызова <code>Symbol</code> выглядит <a href="http://goo.gl/DmPIbT">так</a>:<br/>
<br/>
<pre><code class="javascript">var Person = function(){
  var NAME = Symbol.pure('name');
  function Person(name){
    Symbol.set(this, NAME, name);
  }
  Person.prototype.getName = function(){
    return this[NAME];
  };
  return Person;
}();
</code></pre><br/>
<a name="es6-reflect-own-keys"></a><a href="index.html.1.194.html#es6-reflect-own-keys"><b>#</b></a> Как уже было отмечено выше, метод <code>Object.getOwnPropertySymbols</code> мы не добавляем. А хочется иметь более или менее универсальный, притом стандартизованный, способ для обхода всех ключей, как строк, так и символов. ECMAScript 6 добавляет <a href="http://people.mozilla.org/~jorendorff/es6-draft.html#sec-reflect-object">модуль <code>Reflect</code></a> — в первую очередь, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy#Handler_API">набор заглушек</a> для <code>Proxy</code>. Так как мы не имеем возможность эмулировать <code>Proxy</code>, модуль <code>Reflect</code> нам особо и не нужен. Однако в нём есть метод <code>Reflect.ownKeys</code>, возвращающий все собственные ключи объекта — как строки, так и символы, т.е. <code>Object.getOwnPropertyNames + Object.getOwnPropertySymbols</code>. Добавим этот метод. <a href="http://goo.gl/fyu6pn">Пример</a>:<br/>
<br/>
<pre><code class="javascript">var O = {a: 1};
Object.defineProperty(O, 'b', {value: 2});
O[Symbol('c')] = 3;
Reflect.ownKeys(O); // => ['a', 'b', Symbol(c)]
</code></pre><br/>
<a name="es6-symbol-registry"></a><a href="index.html.1.194.html#es6-symbol-registry"><b>#</b></a> Также ES6 добавляет такую сомнительную штуку, как глобальный регистр символов. Для работы с ним есть пара методов — <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol/for">Symbol.for</a> и <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol/keyFor">Symbol.keyFor</a>. <code>Symbol.for</code> ищет в регистре и возвращает символ по ключу-строке, не находит — создаёт новый, добавляет в регистр и возвращает его. <code>Symbol.keyFor</code> возвращает строку, которой в регистре соответствует переданный символ. <a href="http://goo.gl/0pdJjX">Пример</a>:<br/>
<br/>
<pre><code class="javascript">var symbol = Symbol.for('key');
symbol === Symbol.for('key'); // true
Symbol.keyFor(symbol);        // 'key'
</code></pre><br/>
Ко всему прочему, библиотека активно использует символы <a href="index.html.1.194.html#es6-iterable-interface"># <code>Symbol.iterator</code></a> и <a href="index.html.1.194.html#classof"># <code>Symbol.toStringTag</code></a>.<br/>
<br/>
<a name="es6-collections"></a><h2><b><a href="index.html.1.194.html#es6-collections">#</a> ECMAScript 6: Коллекции</b></h2><hr/><br/>
В ECMAScript 6 появляются 4 новых вида коллекций: <code>Map, Set, WeakMap</code> и <code>WeakSet</code>. Есть еще <a href="http://habrahabr.ru/post/119694/">типизированные массивы</a>, но пока обойдёмся без них.<br/>
<br/>
<ul>
<li><a href="index.html.1.194.html#es6-collections-overview"># Описание коллекций</a></li>
<li><a href="index.html.1.194.html#es6-collections-support"># Поддержка движками</a></li>
<li><a href="index.html.1.194.html#es6-map-set"># Реализация <code>Map</code> и <code>Set</code></a></li>
<li><a href="index.html.1.194.html#es6-weak"># Реализация слабосвязанных коллекций</a></li>
</ul><br/>
<a name="es6-collections-overview"></a><a href="index.html.1.194.html#es6-collections-overview"><b>#</b></a> Итак, что собой представляют данные коллекции?<br/>
<br/>
<a name="es6-map"></a><a href="index.html.1.194.html#es6-map"><b>#</b></a> <b><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map">Map</a></b> — коллекция ключ — значение, в качестве ключей могут выступать любые сущности JavaScript — как примитивы, так и объекты. Есть возможность обхода — имеют <a href="index.html.1.194.html#es6-iterators"># итераторы</a> и метод <code>.forEach</code>, количество элементов доступно через свойство <code>.size</code>. <a href="http://goo.gl/RDbROF">Пример</a>:<br/>
<br/>
<pre><code class="javascript">var a = [1];

var map = new Map([['a', 1], [42, 2]]);
map.set(a, 3).set(true, 4);

console.log(map.size);        // => 4
console.log(map.has(a));      // => true
console.log(map.has([1]));    // => false
console.log(map.get(a));      // => 3
map.forEach(function(val, key){
  console.log(val);           // => 1, 2, 3, 4
  console.log(key);           // => 'a', 42, [1], true
});
map.delete(a);
console.log(map.size);        // => 3
console.log(map.get(a));      // => undefined
console.log(Array.from(map)); // => [['a', 1], [42, 2], [true, 4]]
</code></pre><br/>
<a name="es6-set"></a><a href="index.html.1.194.html#es6-set"><b>#</b></a> <b><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set">Set</a></b> — коллекция уникальных значений. Как и у <code>Map</code>, есть возможность обхода. <a href="http://goo.gl/7XYya3">Пример</a>:<br/>
<br/>
<pre><code class="javascript">var set = new Set(['a', 'b', 'a', 'c']);
set.add('d').add('b').add('e');
console.log(set.size);        // => 5
console.log(set.has('b'));    // => true
set.forEach(function(it){
  console.log(it);            // => 'a', 'b', 'c', 'd', 'e'
});
set.delete('b');
console.log(set.size);        // => 4
console.log(set.has('b'));    // => false
console.log(Array.from(set)); // => ['a', 'c', 'd', 'e']
</code></pre><br/>
<a name="es6-weakmap"></a><a href="index.html.1.194.html#es6-weakmap"><b>#</b></a> <b><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap">WeakMap</a></b> — коллекция ключ-значение, в качестве ключей могут выступать <b>только объекты</b>. Использует слабую связь — когда объект-ключ удаляется (сборщиком мусора), удаляется и пара ключ-значение из коллекции. Нет возможности обойти — нет итераторов и метода <code>.forEach</code>, нет свойства <code>.size</code>. Это еще один способ хранения приватных данных, более «честный», но и <a href="https://esdiscuss.org/topic/weakmap-better-than-private-symbols-was-direct-proxies-problem#content-8">более ресурсоёмкий</a>, по сравнению с использованием <a href="index.html.1.194.html#es6-symbol"># символов</a>. Если в будущем в JavaScript таки добавят <a href="https://github.com/zenparsing/es-abstract-refs#examples">abstract references</a>, для подобных приватных полей появится удобный синтаксис. <a href="http://goo.gl/wCvuq3">Пример</a>:<br/>
<br/>
<pre><code class="javascript">var a = [1]
  , b = [2]
  , c = [3];

var wmap = new WeakMap([[a, 1], [b, 2]]);
wmap.set(c, 3).set(b, 4);
console.log(wmap.has(a));   // => true
console.log(wmap.has([1])); // => false
console.log(wmap.get(a));   // => 1
wmap.delete(a);
console.log(wmap.get(a));   // => undefined

// Так можно хранить приватные данные
var Person = (function(){
  var names = new WeakMap;
  function Person(name){
    names.set(this, name);
  }
  Person.prototype.getName = function(){
    return names.get(this);
  };
  return Person;
})();

var person = new Person('Вася');
console.log(person.getName());          // => 'Вася'
for(var key in person)console.log(key); // => только 'getName'
</code></pre><br/>
<a name="es6-weakset"></a><a href="index.html.1.194.html#es6-weakset"><b>#</b></a> <b><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakSet">WeakSet</a></b> — ну вы поняли. Появился в черновике спецификации относительно недавно, так что имеет довольно слабую поддержку браузерами. <a href="http://goo.gl/TdFbEx">Пример</a>:<br/>
 <br/>
<pre><code class="javascript">var a = [1]
  , b = [2]
  , c = [3];

var wset = new WeakSet([a, b, a]);
wset.add(c).add(b).add(c);
console.log(wset.has(b));   // => true
console.log(wset.has([2])); // => false
wset.delete(b);
console.log(wset.has(b));   // => false
</code></pre><br/>
Все эти коллекции <b>должны</b> обеспечивать сублинейное время поиска. Уникальность ключа обеспечивается алгоритмом сравнения <a href="index.html.1.194.html#same-value-zero"># SameValueZero</a>.<br/>
<br/>
<a name="es6-collections-support"></a><b><a href="index.html.1.194.html#es6-collections-support">#</a></b> Что с поддержкой этих коллекций у современных движков js? Очень даже неплохо.<br/>
<br/>
<ul>
<li>В <b>Firefox</b> есть полноценные <code>Map, Set</code> и <code>WeakMap</code>. В ночных сборках появился и <code>WeakSet</code>. <code>Map</code> и <code>Set</code> принимают итерируемый объект. <code>Map</code> и <code>Set</code> имеют итераторы и метод <code>.forEach</code>.</li>
<li>В <b>v8</b> — читай <b>Chrome, Opera и Node.js</b>, есть все 4 новых вида коллекций. Начиная с Chrome 38, все они доступны без каких либо манипуляций. Чуть раньше были открыты <code>WeakMap</code> и <code>WeakSet</code>. В более ранних версиях коллекции доступны <a href="index.html.1.194.html#v8-harmony-mode"># с флажком экспериментальных возможностей</a>. До самых последних версий v8 конструкторы не принимали итерируемый объект, а у <code>Map</code> и <code>Set</code> отсутствовали итераторы и метод <code>.forEach</code>, что делало нативные <code>Map</code> и <code>Set</code> чуть менее, чем полностью бесполезными.</li>
<li>В <b>IE11</b> появились те же <code>Map, Set</code> и <code>WeakMap</code>. Конструкторы не принимают итерируемый объект. <code>Map</code> и <code>Set</code> не имеют итераторов, но у них есть метод <code>.forEach</code>.</li>
<li>В <b>Safari</b> всё просто замечательно, лучше бы вообще никак. Есть <code>Map, Set</code> и <code>WeakMap</code>. Инициализация итератором отсутствует. Вроде бы, есть методы, возвращающие итераторы, но, внезапно, у некоторых итераторов отсутствует метод <code>next</code>. Есть <code>forEach</code>, но метод передаёт в коллбэк не 3 аргумента, как должно быть, а только 1 для <code>Set</code> и 2 для <code>Map</code>.</li>
</ul><br/>
Почти во всех текущих реализациях методы коллекций <code>.add</code> и <code>.set</code> не возвращают <code>this</code> — заполнить коллекцию цепочкой этих методов не получится. Но это легко лечится.<br/>
<br/>
Для инициализации коллекции итератором также достаточно обертки для конструктора, которая создаст коллекцию и добавит элементы. Про сами итераторы поговорим в <a href="index.html.1.194.html#es6-iterators"># следующей главе</a>.<br/>
<br/>
Ну а полифилы самих коллекций рассмотрим дальше. Полноценная реализация данных коллекций — быстрых, при этом чистых и без утечек памяти (для WeakMap), на базе ECMAScript 5 невозможна, однако, можно найти разумный компромисс.<br/>
<br/>
<a name="es6-map-set"></a><h4><b><a href="index.html.1.194.html#es6-map-set">#</a> Реализация Map и Set</b></h4><br/>
Что в большинстве полифилов представляют собой реализации <code>Map</code>? В инстансе <code>Map</code> — 2 массива, ключи и значения. При получении элемента, ищем совпадение в массиве ключей и возвращаем элемент из массива значений по полученному индексу. Или, для оптимизации удаления, альтернативный вариант — цепочка объектов-вхождений. Что не так и в том, и в другом случае? Это очень медленно, сложность поиска элемента — O(n), сложность операции uniq — O(n<sup>2</sup>). Чем это нам грозит? Вот небольшой тест:<br/>
<br/>
<pre><code class="javascript">var array = [];
for(var i = 0; i &lt; 100000; i++)array.push([{}, {}]);
array = array.concat(array);
console.time('Map test');
var map = new Map(array);
console.timeEnd('Map test');
console.log('Map size: ' + map.size);
</code></pre><br/>
Создаём массив из 200000 тысяч пар объектов (будущие ключ-значение), 100000 из которых уникальны, после чего создаём из этого массива коллекцию <code>Map</code>.<br/>
<br/>
Испытаем нативный <code>Map</code>, например, в Firefox:<br/>
<br/>
<pre><code class="javascript">Map test: таймер запущен
Map test: 46.25мс
Map size: 100000
</code></pre><br/>
А теперь в нём же <code>Map</code> из <a href="https://github.com/paulmillr/es6-shim">самого популярного</a> полифила ECMAScript 6:<br/>
<br/>
<pre><code class="javascript">Map test: таймер запущен
Map test: 506823.31мс
Map size: 100000
</code></pre><br/>
Примерно 8.5 минут. При попытке добавления каждого нового элемента приходится перебирать до 100000 уже добавленных. Отсюда можно сделать вывод, что данный подход годится только для очень маленьких коллекций.<br/>
<br/>
Сублинейной скорости полифила можно добиться используя хэш-таблицы. В ECMAScript 5 это только <code>Object</code>, принимающий в качестве ключа исключительно строки. В протестированном выше полифиле есть небольшая оптимизация — поисковый индекс для ключа-строки или числа через простую функцию, уменьшающий среднюю сложность поиска элемента коллекции до O(1):<br/>
<br/>
<pre><code class="javascript">function fastKey(key){
  if(typeof key === 'string')return '$' + key;
  else if(typeof key === 'number')return key;
  return null;
};
</code></pre><br/>
Точно так же можно реализовать быстрый доступ и для остальных примитивов. Вот только зачем нужен <code>Map</code>, в качестве ключей которого можно эффективно использовать только примитивы? <code>Object.create(null)</code> с этим <a href="index.html.1.194.html#dict"># вполне справляется</a>.<br/>
<br/>
Просто взять и получить уникальную строку-идентификатор для ключа-объекта не получится. Поэтому придется слегка нарушить правила. Давайте будем добавлять при необходимости объектам-ключам символ с идентификатором. Примерно так:<br/>
<br/>
<pre><code class="javascript">var STOREID = Symbol('storeId')
  , id      = 0;
function fastKey(it){
  // Возвращаем с префиксом 'S' если строка и с префиксом 'P' если другой примитив
  if(it !== Object(it))return (typeof it == 'string' ? 'S' : 'P') + it;
  // Если у объекта отсутствует идентификатор - добавляем
  if(!Object.hasOwnProperty.call(it, STOREID))it[STOREID] = ++id;
  // Возвращаем идентификатор с префиксом 'O'
  return 'O' + it[STOREID];
}
</code></pre><br/>
Реализуем <code>Map</code> не на 2 массивах или цепочке объектов-элементов, а на 2 хэшах <code>Object</code>, так же для ключей и значений. Другого хранилища ключей / значений для обхода коллекции в порядке добавления нам не нужно: во всех движках ключи объектов хранятся в порядке добавления, за исключением ключей-чисел, но так как здесь у всех ключей префикс-буква, таковые отсутствуют. Итого, получаем:<br/>
<br/>
<pre><code>Map test: таймер запущен
Map test: 669.93мс
Map size: 100000
</code></pre><br/>
Конечно, медленнее нативных, но, думаю, вполне сойдет. Да, мы пишем скрытое свойство в ключ-объект — невозможно использовать в качестве ключей <a href="index.html.1.194.html#es5-freeze"># frozen-объекты</a>, но зато получаем приемлемую скорость работы. <code>Set</code> реализуется аналогично, на 1 хэше.<br/>
<br/>
<a name="es6-weak"></a><h4><b><a href="index.html.1.194.html#es6-weak">#</a> Реализация слабосвязанных коллекций</b></h4><br/>
Слабосвязанные коллекции реализуем еще проще. У них нет итераторов, метода <code>.forEach</code>, свойства <code>.size</code>. В случае хранения ключей и значений в объекте коллекции, она уже не будет слабосвязанной — ключи / значения не будут удаляться, получим просто урезанную версию <code>Set</code> и <code>Map</code>. Единственное более или менее разумное решение давно известно — хранить значения на ключе, а в объекте коллекции — только её идентификатор. Так как значения хранятся на ключе, в полифиле теряется полная приватность хранимых данных.<br/>
<br/>
<div class="spoiler"><b class="spoiler_title">Сильно упрощённая их реализация выглядит так:</b><div class="spoiler_text"><pre><code class="javascript">window.WeakMap || (function(){
  var id       = 0
    , has      = Function.call.bind(Object.prototype.hasOwnProperty)
    , WEAKDATA = Symbol('WeakData')
    , ID       = Symbol('ID');
  window.WeakMap = function(){
    if(!(this instanceof WeakMap))throw TypeError();
    this[ID] = id++;
  }
  Object.assign(WeakMap.prototype, {
    'delete': function(key){
      return this.has(key) &amp;&amp; delete key[WEAKDATA][this[ID]];
    },
    has: function(key){
      return key === Object(key) &amp;&amp; has(key, WEAKDATA) &amp;&amp; has(key[WEAKDATA], this[ID]);
    },
    get: function(key){
      if(key === Object(key) &amp;&amp; has(key, WEAKDATA))return key[WEAKDATA][this[ID]];
    },
    set: function(key, value){
      if(key !== Object(key))throw TypeError();
      if(!has(key, WEAKDATA))key[WEAKDATA] = {};
      key[WEAKDATA][this[ID]] = value;
      return this;
    }
  });
})();
</code></pre></div></div><br/>
Давайте убедимся, что при удалении ссылки на ключ он не остаётся в коллекции и, соответственно, память не утекает:<br/>
<br/>
<pre><code class="javascript">// &lt;- тут делаем snapshot 1
var array = [];
for(var i = 0; i &lt; 100000; i++)array[i] = {};
var wm = new WeakMap();
for(var i = 0; i &lt; 100000; i++)wm.set(array[i], {});
// &lt;- тут делаем snapshot 2
array = null;
// &lt;- тут делаем snapshot 3
</code></pre><br/>
<img src="https://habrastorage.org/r/w1560/files/7b2/a07/b54/7b2a07b54f664478a8b7a25be220cbe2.png" data-src="//habrastorage.org/files/7b2/a07/b54/7b2a07b54f664478a8b7a25be220cbe2.png"/><br/>
<br/>
<b>Но в некоторых случаях проблема утечки памяти остаётся.</b> После удаления объекта коллекции, значение останется связанным с ключом, что приведет к утечке памяти до момента удаления объекта, бывшего ключом. Так что по-хорошему систему проектировать стоит так, что бы коллекции <code>WeakMap</code> жили дольше, чем их ключи. Кто-то <a href="https://habr.com/company/uprock/blog/200644/">пытается</a> обойти проблему утечки памяти, но это из разряда эзотерики — <a href="https://habr.com/company/uprock/blog/200644/#comment_6941924">память утекает точно в тех же случаях</a>.<br/>
<br/>
У реализации <code>WeakSet</code> эта проблема остается, но сведена к минимуму — вместо значения, что может быть тяжелым объектом, на ключе хранится только флаг наличия в коллекции.<br/>
<br/>
<a name="es6-iterators"></a><h2><b><a href="index.html.1.194.html#es6-iterators">#</a> ECMAScript 6: Итераторы</b></h2><hr/><br/>
В ECMAScript 6 появился протокол итераторов — универсальный способ обхода коллекций, и не только. Так как к нему относятся и синтаксические конструкции, рассмотрим и их. Но, в первую очередь, это не часть стандартной библиотеки или синтаксиса, а концепция. К протоколу итераторов можно отнести:<br/>
<br/>
<ul>
<li><a href="index.html.1.194.html#es6-iter-interface"># Интерфейс итератора</a></li>
<li><a href="index.html.1.194.html#es6-iterable-interface"># Интерфейс итерируемого объекта, символ <code>Symbol.iterator</code></a></li>
<li><a href="index.html.1.194.html#es6-generators"># Генераторы</a></li>
<li><a href="index.html.1.194.html#es6-for-of"># Цикл <code>for-of</code></a></li>
<li><a href="index.html.1.194.html#es6-native-iterables"># Итераторы инстансов встроенных конструкторов и методы, их возвращающие</a></li>
<li><a href="index.html.1.194.html#es6-use-iter"># Методы и конструкторы, принимающие итерируемые объекты</a></li>
<li><a href="index.html.1.194.html#es6-spread"># Оператор spread</a></li>
<li><a href="index.html.1.194.html#es6-comprehensions"># Array / generator comprehensions</a></li>
</ul><br/>
Так как часть этого — синтаксис, в этой главе также рассмотрим модуль <code>$for</code>, что реализует часть возможностей этих синтаксических конструкций. Если собираетесь использовать библиотеку с <a href="index.html.1.194.html#preprocessors"># препроцессором ES6+</a>, можете спокойно собирать её без данного модуля.<br/>
<br/>
<a name="es6-iter-interface"></a><a href="index.html.1.194.html#es6-iter-interface"><b>#</b></a> <b>Итератор</b> — объект, имеющий метод <code>.next</code>, который должен возвращать объект с полями <code>.done</code> — завершен ли обход итератора, и <code>.value</code> — значение текущего шага. Пример — метод, создающий итератор для положительного числа, позволяющий обойти все целые от 0 до заданного (<a href="http://goo.gl/j9evDY">песочница</a>):<br/>
<br/>
<pre><code class="javascript">function NumberIterator(number){
  var i = 0;
  return {
    next: function(){
      return i &lt; number
        ? {done: false, value: i++}
        : {done: true};
    }
  }
}

var iter = NumberIterator(3);
iter.next(); // => {done: false, value: 0}
iter.next(); // => {done: false, value: 1}
iter.next(); // => {done: false, value: 2}
iter.next(); // => {done: true}
</code></pre><br/>
<a name="es6-iterable-interface"></a><a href="index.html.1.194.html#es6-iterable-interface"><b>#</b></a> <b>Итерируемый объект</b> (Iterable) — объект, у которого по ключу <code>Symbol.iterator</code> содержится метод, возвращающий для него итератор. Соответственно, что бы и итератор был итерируемым, по ключу <code>Symbol.iterator</code> у него должен быть метод, возвращающий <code>this</code>. Для примера, сделаем числа итерируемыми (<a href="http://goo.gl/598H0u">песочница</a>):<br/>
<br/>
<pre><code class="javascript">Number.prototype[Symbol.iterator] = function(){
  return NumberIterator(this);
}

Array.from(10); // => [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
</code></pre><br/>
Обратите внимание на <code>Symbol.iterator</code>. В Firefox поддерживается протокол итераторов, но в нём, в стабильных сборках, пока нет <a href="index.html.1.194.html#es6-symbol"># символов</a> и вместо <code>Symbol.iterator</code> используется строка <code>"@@iterator"</code>. В ночных сборках появились символы и даже <code>Symbol.iterator</code>, но в протоколе итераторов пока продолжает использоваться строка <code>"@@iterator"</code>. Чтобы не сломать протокол итераторов в Firefox, в нем в нашей библиотеке мы будем дублировать методы для получения итератора и по ключу <code>Symbol.iterator</code> (создаём, если отсутствует), и по ключу <code>"@@iterator"</code>. В v8 полноценная поддержка протокола итераторов появилась с Chrome 38.<br/>
<br/>
<a name="es6-generators"></a><a href="index.html.1.194.html#es6-generators"><b>#</b></a> <b>Генератор</b> — функция, выполнение которой можно приостановить. Возвращает объект с расширенным интерфейсом итератора. Подробно их мы рассматривать не будем — синтаксис — смотрите, например, в <a href="http://habrahabr.ru/post/210330/">этой</a> статье. Для препроцессора, пожалуй, самая страшная часть ECMAScript 6. Пример с итерируемыми числами при использовании генератора выглядит совсем просто (<a href="http://goo.gl/L6IE5S">песочница</a>):<br/>
<br/>
<pre><code class="javascript">Number.prototype[Symbol.iterator] = function*(){
  for(var i = 0; i &lt; this;)yield i++;
}

Array.from(10); // => [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
</code></pre><br/>
<a name="es6-for-of"></a><a href="index.html.1.194.html#es6-for-of"><b>#</b></a> <b>Цикл <code>for-of</code></b> предназначен для обхода итерируемых объектов. На нашем примере с итерируемыми числами он работает так (<a href="http://goo.gl/Hcnp3z">песочница</a>):<br/>
<br/>
<pre><code class="javascript">for(var num of 5)console.log(num); // => 0, 1, 2, 3, 4
</code></pre><br/>
<a name="es6-native-iterables"></a><a href="index.html.1.194.html#es6-native-iterables"><b>#</b></a> В ECMAScript 6 искаропки итерируемы <code>String, Array, Map, Set</code> и <code>Arguments</code>. Кроме того, <code>Array, Map</code> и <code>Set</code> имеют методы <code>.keys, .values</code> и <code>.entries</code>, которые возвращают итераторы соответственно по ключам, значениям и паре ключ-значение. <b>Core.js добавляет данные итераторы и методы.</b> Вместе с циклом <code>for-of</code> это выглядит так (<a href="http://goo.gl/ArArLq">песочница</a>):<br/>
<br/>
<pre><code class="javascript">var string = 'abc';

for(var val of string)console.log(val);         // => 'a', 'b', 'c'

var array = ['a', 'b', 'c'];

for(var val of array)console.log(val);          // => 'a', 'b', 'c'. Итератор по умолчанию - .values
for(var val of array.values())console.log(val); // => 'a', 'b', 'c'
for(var key of array.keys())console.log(key);   // => 0, 1, 2
for(var [key, val] of array.entries()){
  console.log(key);                             // => 0, 1, 2
  console.log(val);                             // => 'a', 'b', 'c'
}

var map = new Map([['a', 1], ['b', 2], ['c', 3]]);

for(var [key, val] of map){                     // Итератор по умолчанию - .entries
  console.log(key);                             // => 'a', 'b', 'c'
  console.log(val);                             // => 1, 2, 3
}
for(var val of map.values())console.log(val);   // => 1, 2, 3
for(var key of map.keys())console.log(key);     // => 'a', 'b', 'c'
for(var [key, val] of map.entries()){
  console.log(key);                             // => 'a', 'b', 'c'
  console.log(val);                             // => 1, 2, 3
}

var set = new Set([1, 2, 3, 2, 1]);

for(var val of set)console.log(val);            // => 1, 2, 3. Итератор по умолчанию - .values
for(var val of set.values())console.log(val);   // => 1, 2, 3
for(var key of set.keys())console.log(key);     // => 1, 2, 3. Итератор .keys аналогичен .values
for(var [key, val] of set.entries()){           // У Set в итераторе .entries ключ и значение равны
  console.log(key);                             // => 1, 2, 3
  console.log(val);                             // => 1, 2, 3
}

var list = (function(){return arguments})(1, 2, 3);

for(var val of list)console.log(val);           // => 1, 2, 3
</code></pre><br/>
<ul>
<li>В актуальном Firefox есть все данные итераторы, кроме итератора <code>arguments</code>. Цикл работает, но на базе собственного, устаревшего, протокола.</li>
<li>В v8, цикл <code>for-of</code>, начиная с Chrome 38, работает корректно (не считая деструкции массива) и доступны все данные итераторы, кроме <code>arguments</code>. В старых версиях (с флажком) ожидал итератор, а не итерируемый объект.</li>
<li>В IE, само собой, данный цикл пока не работает и итераторы отсутствуют.</li>
</ul><br/>
<a name="for-of-helper"></a><a href="index.html.1.194.html#for-of-helper"><b>#</b></a> Раз всё так плохо с поддержкой синтаксиса данного цикла, для тех, кто не использует препроцессоры ES6+, добавим в библиотеку хелпер, реализующий функционал, аналогичный <code>for-of</code> (<a href="http://goo.gl/B1QWlf">песочница</a>):<br/>
<br/>
<pre><code class="javascript">$for(new Set([1, 2, 3, 2, 1])).of(function(it){
  console.log(it); // => 1, 2, 3
});

// 2й аргумент $for - флаг entries - в коллбэк передаётся 2 аргумента
$for([1, 2, 3].entries(), true).of(function(key, value){
  console.log(key);   // => 0, 1, 2
  console.log(value); // => 1, 2, 3
});

// 2й аргумент .of - контекст исполнения коллбэка
$for('abc').of(console.log, console); // => 'a', 'b', 'c'

// Можно прервать обход итератора, вернув из коллбэка false
$for([1, 2, 3, 4, 5]).of(function(it){
  console.log(it); // => 1, 2, 3
  if(it == 3)return false;
});
</code></pre><br/>
<a name="iter-helpers"></a><a href="index.html.1.194.html#iter-helpers"><b>#</b></a> Прототип объекта <code>arguments</code> — <code>Object.prototype</code>, так что положить метод для получения его итератора в прототип мы не можем. Также есть вариант сборки <b>core.js</b> как библиотеки, без расширения нативных объектов. По этим причинам, вынесем наружу пару хелперов, для проверки, является ли объект итерируемым и для получения итератора объекта — <code>$for.isIterable(foo)</code>, как аналог <code>Symbol.iterator in foo</code> и <code>$for.getIterator(foo)</code>, как аналог <code>foo[Symbol.iterator]()</code>:<br/>
<br/>
<pre><code class="javascript">var list = (function(){return arguments})(1, 2, 3);

console.log($for.isIterable(list)); // => true
console.log($for.isIterable({}));   // => false

var iter = $for.getIterator(list);
console.log(iter.next());           // => {value: 1, done: false}
console.log(iter.next());           // => {value: 2, done: false}
console.log(iter.next());           // => {value: 3, done: false}
console.log(iter.next());           // => {value: undefined, done: true}
</code></pre><br/>
<a name="es6-use-iter"></a><a href="index.html.1.194.html#es6-use-iter"><b>#</b></a> В ECMAScript 6 итераторы используются для инициализации <a href="index.html.1.194.html#es6-collections"># коллекций</a> <code>Map, Set, WeakMap, WeakSet</code>, массивов <a href="index.html.1.194.html#es6-array-from"># через <code>Array.from</code></a>, их ожидают методы <code>Promise.all, Promise.race</code> для работы с <a href="index.html.1.194.html#es6-promise"># обещаниями</a>.<br/>
<br/>
<a name="es6-spread"></a><a href="index.html.1.194.html#es6-spread"><b>#</b></a> Оператор <a href="http://www.2ality.com/2011/08/spreading.html">spread</a>, применимый при вызове функций, конструкторов и в литерале массива, также ожидает итерируемый объект, но это уже совсем далекая от стандартной библиотеки тема. Есть желание пользоваться уже сейчас — препроцессоры в зубы. <a href="http://goo.gl/sf7BPy">Пример</a>:<br/>
<br/>
<pre><code class="javascript">[...new Set([1, 2, 3, 2, 1])]; // => [1, 2, 3]
console.log(1, ...[2, 3, 4]);  // => 1, 2, 3, 4
var map = new Map([[1, 'a'], [2, 'b']]);
new Array(...map.keys(), 3);   // => [1, 2, 3]
</code></pre><br/>
<a name="es6-comprehensions"></a><a href="index.html.1.194.html#es6-comprehensions"><b>#</b></a> Ко всему прочему, к протоколу итераторов относятся и <a href="http://www.2ality.com/2013/01/comprehensions.html">array / generator comprehensions</a> (<a href="https://ru.wikipedia.org/wiki/%D0%A1%D0%BF%D0%B8%D1%81%D0%BA%D0%BE%D0%B2%D0%BE%D0%B5_%D0%B2%D0%BA%D0%BB%D1%8E%D1%87%D0%B5%D0%BD%D0%B8%D0%B5">абстракция массива / генератора?</a>). Раньше они присутствовали в черновике ECMAScript 6, но отложены до ECMAScript 7, хотя давно поддерживаются в <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Array_comprehensions">Firefox</a>. Это возможность генерации массива или итератора из итерируемого объекта с фильтрацией и преобразованием. Т.е. <b>синтаксис <code>filter</code> и <code>map</code> для любых итерируемух объектов</b>. Примеры, кроме последнего — не поддерживается деструкция массива, работают в <b>FF</b>. В <b>6to5</b> и <b>Traceur</b> работает всё. <a href="http://goo.gl/mz9zv2">Пример</a>:<br/>
<br/>
<pre><code class="javascript">var ar1 = [for(i of [1, 2, 3])i * i];    // => [1, 4, 9]

var set = new Set([1, 2, 3, 2, 1]);
var ar2 = [for(i of set)if(i % 2)i * i]; // => [1, 9]

var iter = (for(i of set)if(i % 2)i * i);
iter.next(); // => {value: 1, done: false}
iter.next(); // => {value: 9, done: false}
iter.next(); // => {value: undefined, done: true}

var map1 = new Map([['a', 1], ['b', 2], ['c', 3]]);
var map2 = new Map((for([k, v] of map1)if(v % 2)[k + k, v * v])); // => Map {aa: 1, cc: 9}
</code></pre><br/>
Как по мне — штука потрясающая. Вот только это тоже синтаксис.<br/>
<br/>
<a name="for"></a><a href="index.html.1.194.html#for"><b>#</b></a> Для тех, кто не намерен пользоваться препроцессором ES6, добавим подобное, совсем уж велосипед, в рамках модуля <code>$for</code>. Вызов <code>$for</code> возвращает итератор, расширенный методами <code>of</code>, о котором выше, <code>filter, map</code> и <code>array</code>. Методы <code>filter</code> и <code>map</code> возвращают итератор, что, соответственно, фильтрует или преобразует значения предыдущего итератора. Этот итератор расширен теми же методами, что и итератор <code>$for</code>. Метод <code>array</code> преобразует текущий итератор в массиву, он принимает опциональный map-коллбэк. У всех этих методов второй, опциональный, аргумент — контекст исполнения. Если <code>$for</code> принимает флаг <code>entries</code>, все коллбэки цепочки запускаются с парой аргументов.<br/>
<br/>
<a href="http://goo.gl/JHecXL">Пример</a>:<br/>
<br/>
<pre><code class="javascript">var ar1 = $for([1, 2, 3]).array(function(v){
  return v * v;
}); // => [1, 4, 9]

var set = new Set([1, 2, 3, 2, 1]);
var ar1 = $for(set).filter(function(v){
  return v % 2;
}).array(function(v){
  return v * v;
}); // => [1, 9]

var iter = $for(set).filter(function(v){
  return v % 2;
}).map(function(v){
  return v * v;
});
iter.next(); // => {value: 1, done: false}
iter.next(); // => {value: 9, done: false}
iter.next(); // => {value: undefined, done: true}

var map1 = new Map([['a', 1], ['b', 2], ['c', 3]]);
var map2 = new Map($for(map1, true).filter(function(k, v){
  return v % 2;
}).map(function(k, v){
  return [k + k, v * v];
})); // => Map {aa: 1, cc: 9}
</code></pre><br/>
С литералом функции из ES5 выходит довольно громоздко, но со стрелочными функциями будет почти так же, как и с использованием синтаксиса comprehensions.<br/>
<br/>
Можно было бы добавить и другие операций над итераторами в модуль <code>$for</code>, что дало бы универсальный и ленивый (таков протокол итераторов) способ обхода и преобразования итерируемых объектов. Но отложим это на будущее. А может и к чёрту.<br/>
<br/>
Библиотека добавляет еще пару итераторов (<a href="index.html.1.194.html#dict-iter"># раз</a>, <a href="index.html.1.194.html#num-iter"># два</a>), конструктор <a href="index.html.1.194.html#dict-module"># <code>Dict</code></a> ожидает итерируемый объект, но не будем в эту главу перетаскивать совсем уж все велосипеды, связанные с итераторами.<br/>
<br/>
<a name="es6-promise"></a><h2><b><a href="index.html.1.194.html#es6-promise">#</a> ECMAScript 6: Обещания</b></h2><hr/><br/>
Асинхронность и JavaScript для многих уже практически синонимы. Вот только про асинхронность в стандарте ECMAScript 5 нет вообще ничего. Даже такие базовые методы, как <code>setTimeout</code> и <code>setInterval</code>, обеспечиваются web-стандартами W3C и WHATWG, <a href="index.html.1.194.html#timeout-interval"># о них поговорим чуть дальше</a>. Разве что функции как объекты первого класса — удобная передача коллбэков. Это порождает <a href="http://callbackhell.com/">коллбэк-ад</a>. Один из способов упрощения параллельного и последовательного исполнения асинхронных функций — библиотеки вроде <a href="https://github.com/caolan/async">async.js</a>.<br/>
<br/>
Другой подход к упрощению асинхронного программирования — шаблон Promise (Обещание). С помощью объекта-обещания, что может вернуть асинхронная функция, можно подписаться на её результат. Методы, с помощью которых можно подписаться на результат, возвращают новые обещания, что помогает лучше структурировать код, выстраивая обещания в цепочки. Также обещания решают проблему обработки ошибок: в асинхронном коде <code>try-catch</code> не работает, приходится передавать ошибки аргументами коллбэка, что иногда еще больше запутывает код. В конце цепочки обещаний можно подписаться на любую ошибку, что может в ней возникнуть — как брошенную методом <code>reject</code>, так и через <code>throw</code>.<br/>
<br/>
Популярны такие библиотеки обещаний, как <a href="https://github.com/kriskowal/q">Q</a> или <a href="https://github.com/tildeio/rsvp.js">RSVP</a>. Со временем появился стандарт <a href="http://promisesaplus.com/">Promises/A+</a>, согласно которому все обещания разрешаются асинхронно, а на результат можно подписаться при помощи метода <code>.then</code> (первый аргумент — функция, что выполнится при успешном завершении, второй — при возникновении ошибки).<br/>
<br/>
И вот, дабы окончательно стандартизовать работу с асинхронным кодом, в ECMAScript 6 была <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise">добавлена реализация обещаний</a>, совместимая со стандартом Promises/A+ и с минимальным, но покрывающим большую часть потребностей, функционалом. Особо их расписывать не буду, подробно ознакомиться с ними можно <a href="http://www.html5rocks.com/en/tutorials/es6/promises/">здесь</a> (<a href="http://habrahabr.ru/post/209662/">перевод, но слегка устарел</a>), <a href="http://www.2ality.com/2014/10/es6-promises-api.html">здесь</a> или <a href="http://habrahabr.ru/post/242767/">здесь</a>. ES6 Promise уже доступны в v8 и Firefox, есть полифилы — <a href="https://github.com/jakearchibald/es6-promise">es6-promise</a> и <a href="https://github.com/getify/native-promise-only">native-promise-only</a>.<br/>
<br/>
<a name="es6-promise-constructor"></a><a href="index.html.1.194.html#es6-promise-constructor"><b>#</b></a> Реализация обещаний из ECMAScript 6 представляет из себя конструктор <code>Promise</code>, принимающий функцию, в которую передается 2 коллбэка — первый разрешает обещание, второй завершает с ошибкой. Кроме <code>then</code>, обещания ES6 содержат метод <code>catch</code> — сокращение для <code>then</code> с пропущенным первым аргументом, с помощью него можно подписаться на ошибку. <a href="http://goo.gl/z3bXC8">Пример</a>:<br/>
<br/>
<pre><code class="javascript">var log = console.log.bind(console);
function sleepRandom(time){
  return new Promise(function(resolve, reject){
    // resolve разрешает обещание успешно, reject - с ошибкой
    // разрешим обещание через заданное время
    setTimeout(resolve, time * 1e3, 0 | Math.random() * 1e3);
  });
}

log('Поехали');                // => Поехали
sleepRandom(5).then(function(result){
  log(result);                 // => 869, через 5 сек.
  return sleepRandom(10);
}).then(function(result){
  log(result);                 // => 202, через 10 сек. 
}).then(function(){
  log('Сразу после прошлого'); // => Сразу после прошлого
  throw Error('Ашыпка!');
}).then(function(){
  log('не будет выведено - ошибка');
}).catch(log);                 // => Error: 'Ашыпка!'
</code></pre><br/>
Так как мне было лень полностью адаптировать свой движок обещаний под стандарт, ядро обещаний <b>core.js</b> базируется на библиотеке native-promise-only, от кода которой мало что осталось. Для обеспечения асинхронности используется <code>process.nextTick</code> и способы из полифила <a href="index.html.1.194.html#immediate"># setImmediate</a>.<br/>
<br/>
<a name="es6-promise-resolve-reject"></a><a href="index.html.1.194.html#es6-promise-resolve-reject"><b>#</b></a> Пара хелперов <code>Promise.resolve</code> и <code>Promise.reject</code> возвращают завершенное, соответственно, успешно или с ошибкой обещание с переданным им значением. Если <code>Promise.resolve</code> принимает обещание — его и возвращает. Также его можно использовать для преобразования других thenable (например, jQuery Deferred) в обещания, в старой версии стандарта для этого был отдельный метод — <code>Promise.cast</code>. <a href="http://goo.gl/vr8TN3">Пример</a>:<br/>
<br/>
<pre><code class="javascript">Promise.resolve(42).then(log); // => 42
Promise.reject(42).catch(log); // => 42

Promise.resolve($.getJSON('/data.json')); // => ES6 promise
</code></pre><br/>
<a name="es6-promise-all"></a><a href="index.html.1.194.html#es6-promise-all"><b>#</b></a> Хелпер <code>Promise.all</code> возвращает обещание, которое разрешится, когда разрешатся все обещания из переданной ему <a href="index.html.1.194.html#es6-iterators"># итерируемой</a> коллекции (в v8 сейчас работает только с массивами, исправлять в рамках библиотеки пока не стал — не вижу особого смысла использовать его с чем-то ещё). Элементы коллекции, не являющиеся обещаниями, приводятся к обещаниям через <code>Promise.resolve</code>. <a href="http://goo.gl/62OcTx">Пример</a>:<br/>
<br/>
<pre><code class="javascript">Promise.all([
  'foo',
  sleepRandom(5),
  sleepRandom(15),
  sleepRandom(10)  // через 15 секунд выведет что-то вроде
]).then(log);      // => ['foo', 956, 85, 382]
</code></pre><br/>
<a name="es6-promise-race"></a><a href="index.html.1.194.html#es6-promise-race"><b>#</b></a> Хелпер <code>Promise.race</code> похож на предыдущий, но возвращает обещание, которое разрешится, когда разрешится хотя бы одно обещание из переданной ему коллекции. По моему скромному мнению, в отличие от <code>Promise.all</code>, чуть менее, чем полностью, бесполезен. Разве что с его помощью становится чуть проще повесить ограничение на время разрешения обещания. <a href="http://goo.gl/L8ovkJ">Пример</a>:<br/>
<br/>
<pre><code class="javascript">function timeLimit(promise, time){
  return Promise.race([promise, new Promise(function(resolve, reject){
    setTimeout(reject, time * 1e3, Error('Await > ' + time + ' sec'));
  })]);
}

timeLimit(sleepRandom(5), 10).then(log);   // => через 5 секунд получили результат 853
timeLimit(sleepRandom(15), 10).catch(log); // Error: Await > 10 sec
</code></pre><br/>
<a name="async-await"></a><a href="index.html.1.194.html#async-await"><b>#</b></a> Даже с обещаниями, асинхронному JavaScript есть еще куда стремиться в плане удобства, потому к добавлению в ECMAScript 7 предложены <a href="https://github.com/lukehoban/ecmascript-asyncawait">асинхронные функции</a>, расширяющие синтаксис ключевыми словами <code>async / await</code> и базирующиеся на <a href="index.html.1.194.html#es6-generators"># генераторах</a>, обещаниях и генераторах, возвращающих обещания :) Данный синтаксис уже поддерживается и <b>Traceur</b>, и <b>6to5</b>. <a href="http://goo.gl/v5JRT8">Пример</a>:<br/>
<br/>
<pre><code class="javascript">var delay = time => new Promise(resolve => setTimeout(resolve, time));

async function sleepRandom(time){
  await delay(time * 1e3);
  return 0 | Math.random() * 1e3;
}
async function sleepError(time, msg){
  await delay(time * 1e3);
  throw Error(msg);
}

(async () => {
  try {
    log('Поехали');            // => Поехали
    log(await sleepRandom(5)); // => 936, через 5 сек.
    var [a, b, c] = await Promise.all([
      sleepRandom(5),
      sleepRandom(15),
      sleepRandom(10)
    ]);
    log(a, b, c);              // => 210 445 71, через 15 сек.
    await sleepError(5, 'Ашыпка!');
    log('Не будет выведено');
  } catch(e){
    log(e);                    // => Error: 'Ашыпка!', через 5 сек.
  }
})();
</code></pre><br/>
Со временем, обещания изменят значительную часть стандартного асинхронного API JavaScript. Уже <a href="https://fetch.spec.whatwg.org/#fetch-api">стандартизована</a> (<a href="https://github.com/github/fetch">полифил</a>) глобальная функция <code>fetch</code> — простая и удобная обертка над <code>XMLHttpRequest</code>, возвращающая обещание. <a href="https://esdiscuss.org/topic/promise-returning-delay-function">Предлагают</a> добавить, и, думаю, добавят, простую, но часто необходимую, функцию <code>delay</code>, аналогичную функции из предыдущего примера, возвращающую обещание, что разрешится через заданное время — прощай, <code>setTimeout</code>. Пожалуй, <code>delay</code> было бы неплохо добавить и в данную библиотеку.<br/>
<br/>
<a name="array-generics"></a><h2><b><a href="index.html.1.194.html#array-generics">#</a> Mozilla JavaScript: Статические версии методов массива</b></h2><hr/><br/>
Выше мы рассматривали протокол итераторов. Вот только это не единственный стандарт обхода коллекций в JavaScript. Есть куда более простой, быстрый и древний. Это array-like объекты.<br/>
<br/>
Кроме массивов, в JavaScript много сущностей, подобных им, но при этом массивами не являющихся. Эти объекты, как и массивы, содержат длину <code>.length</code> и элементы по ключу [от 0 до <code>.length</code>), которые могут быть пропущены — тогда возникают «дырки». Они не содержат под собой <code>Array.prototype</code>, соответственно не имеют и методов массива. Это объект <code>arguments</code>, строки (формально — IE8+), типизированные массивы (массивы, но не содержат под собой <code>Array.prototype</code>), коллекции элементов DOM, jQuery объекты и т.д.<br/>
<br/>
Почти все методы прототипа массива — дженерики (как сообщает <a href="http://es5.javascript.ru/x15.4.html#x15.4.4.5">перевод спецификации</a> — «нарочито родовые» функции). Они не требуют, что бы объект, из контекста которого они запускались, был массивом. <a href="http://www.2ality.com/2012/02/concat-not-generic.html">Разве что <code>.concat</code> не совсем.</a> Думаю, многим знакомы такие конструкции:<br/>
<br/>
<pre><code class="javascript">Array.prototype.slice.call(arguments, 1);
// или
[].slice.call(arguments, 1);
</code></pre><br/>
Громоздко и невнятно.<br/>
<br/>
ECMAScript 6 добавляет метод <a href="index.html.1.194.html#es6-array-from"># <code>Array.from</code></a>, с его помощью можно привести к массиву итерируемые и array-like объекты.<br/>
<br/>
<pre><code class="javascript">Array.from(arguments).slice(1);
</code></pre><br/>
Вроде удобно, но <a href="http://jsperf.com/array-methods-on-array-like">далеко не дёшево</a> — даже для самой простой операции мы вынуждены приводить весь объект к массиву, притом, в большинстве случаев, через довольно тяжелый протокол итераторов.<br/>
<br/>
В JavaScript от Mozilla, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/New_in_JavaScript/1.6">в версии языка 1.6</a> и, соответственно, в Firefox, еще в 2005 году, вместе с методами массива, позднее вошедшими в ECMAScript 5, были добавлены и <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array#Array_generic_methods">статические версии методов массива</a>. Ни в 5ю, ни в 6ю редакцию ECMAScript они не попали, хоть и присутствуют в ветке разработки <a href="http://wiki.ecmascript.org/doku.php?id=strawman:array_statics">Strawman</a> довольно давно, но я лично надеюсь на их появлении в одной из будущих версий ECMAScript. Добавим в библиотеку и их — реализуются элементарно, а так как они уже имеются в огнелисе — отнесем их в категорию костылей, а не велосипедов.<br/>
<br/>
<pre><code class="javascript">Array.slice(arguments, 1);

Array.join('abcdef', '+'); // => 'a+b+c+d+e+f'

var form = document.getElementsByClassName('form__input');
Array.reduce(form, function(memo, it){
  memo[it.name] = it.value;
  return memo; 
}, {}); // => например, {name: 'Вася', age: '42', sex: 'yes, please'}
</code></pre><br/>
<a name="schedule"></a><h2><b><a href="index.html.1.194.html#schedule">#</a> Отложенное исполнение: setTimeout, setInterval, setImmediate</b></h2><hr/><br/>
<a name="timeout-interval"></a><h4><b><a href="index.html.1.194.html#timeout-interval">#</a> setTimeout, setInterval</b></h4><br/>
Пожалуй, начнем с привычных всем <code>setTimeout</code> и <code>setInterval</code>. Многие не знают, что по стандарту (<a href="http://www.w3.org/TR/html5/webappapis.html#timers">W3C</a>, <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/timers.html#timers">WHATWG</a>) эти функции кроме коллбэка и времени задержки, принимают дополнительные аргументы, с какими запускается переданный коллбэк. Но тут, как обычно, проблема в IE. В IE9- <code>setTimeout</code> и <code>setInterval</code> принимают только 2 аргумента, это лечится оберткой в несколько строчек.<br/>
<br/>
<pre><code class="javascript">// Было:
setTimeout(log.bind(null, 42), 1000);
// Стало:
setTimeout(log, 1000, 42);
</code></pre><br/>
<a name="immediate"></a><h4><b><a href="index.html.1.194.html#immediate">#</a> setImmediate</b></h4><br/>
JavaScript однопоточен и иногда это довольно неприятно. Любые длительные тяжелые вычисления на клиенте подвесят пользовательский интерфейс, а на сервере — обработка запросов. В этом случае спасает разбиение тяжелой задачи на лёгкие подзадачи, исполняемые асинхронно, между которыми может проходить ввод / вывод.<br/>
<br/>
Также в JavaScript (пока) не оптимизируется хвостовая рекурсия. Когда функция будет вызвана определённое число раз рекурсивно, будет сгенерирована ошибка <code>RangeError: Maximum call stack size exceeded</code>. Это число, в зависимости от платформы, варьирует от нескольких сотен до нескольких десятков тысяч. Асинхронный рекурсивный вызов спасает от переполнения стека. Правда, рекурсивный вызов обычно легко переписывается в обычный цикл, что предпочтительней. <br/>
<br/>
Для решения подобных проблем можно использовать <code>setTimeout</code> с минимальной задержкой, но получится очень неспешно. Минимальная задержка <code>setTimeout</code> по спецификации — 4 мс, а на некоторых платформах и того больше. Итого, максимум, ~250 рекурсивных вызовов в секунду в современных браузерах и, например, ~64 в IE8. Приходилось, да и приходится, велосипедить, так как есть способы сделать эффективное отложенное исполнение.<br/>
<br/>
Если на Node.js был <code>process.nextTick</code>, то на клиент помощь пришла откуда не ждали. В IE10 Microsoft добавил метод <a href="https://developer.mozilla.org/en-US/docs/Web/API/Window.setImmediate">setImmediate</a>, устанавливающий задачу, выполняемую сразу после того, как отработает ввод / вывод, и предложил его для стандартизации <a href="https://dvcs.w3.org/hg/webperf/raw-file/tip/specs/setImmediate/Overview.html">W3C</a>. Позже он <a href="http://habrahabr.ru/post/172363/">появился и на Node.js</a>. FF и Chromium его добавлять не спешат. Популярен <a href="https://github.com/YuzuJS/setImmediate">такой</a> полифил.<br/>
<br/>
Способов реализации эффективного отложенного исполнения функций огромное количество. Для достижения максимального быстродействия на различных платформах нам придется использовать многие (аналогичны способам из упомянутого выше полифила). Это:<br/>
<br/>
<ul>
<li>Для старых версий Node.js — <code>process.nextTick</code></li>
<li>Для современных браузеров — <code>postMessage</code></li>
<li>Для WebWorker'ов — <code>MessageChannel</code></li>
<li>Для IE8- — <code>script.onreadystatechange</code></li>
<li>И уж если эти способы не помогли — <code>setTimeout</code> с минимальной задержкой</li>
</ul><br/>
<pre><code class="javascript">setImmediate(function(arg1, arg2){
  console.log(arg1, arg2); // => Сообщение будет выведено асинхронно с минимальной задержкой
}, 'Сообщение будет выведено асинхронно', 'с минимальной задержкой');

clearImmediate(setImmediate(function(){
  console.log('Сообщение не будет выведено');
}));
</code></pre><br/>
Кроме <code>setImmediate</code>, существует его более быстрая альтернатива — концепция <code>asap</code> (as soon as possible, <a href="https://github.com/kriskowal/asap">библиотека</a>) — по возможности, создаём microtask, что выполнится до любого ввода / вывода. Добавить такой глобальный метод в стандарт языка <a href="https://github.com/rwaldron/tc39-notes/blob/master/es6/2014-09/sept-25.md#510-globalasap-for-enqueuing-a-microtask">думают и в tc39</a>. Может и его стоит добавить в библиотеку?<br/>
<br/>
<a name="console"></a><h2><b><a href="index.html.1.194.html#console">#</a> Консоль</b></h2><hr/><br/>
<a href="https://developer.mozilla.org/en-US/docs/Web/API/console">Консоль</a> — единственное универсальное средство вывода и отладки как в браузере, так и на сервере. При этом, консоль не является частью спецификации ECMAScript и вообще не стандартизована. Есть заброшенные <a href="https://github.com/DeveloperToolsWG/console-object">наброски спецификации</a>, фактическая реализация на всех платформах различается.<br/>
<br/>
<a name="console-cap"></a><a href="index.html.1.194.html#console-cap"><b>#</b></a> В IE7- консоль отсутствует полностью. У некоторых браузеров «консоль Гейзенберга» — <code>console</code> определена только тогда, когда пользователь за ней наблюдает. Ну и, конечно, не все методы доступны на всех платформах. Свою консоль в стиле <a href="http://getfirebug.com/firebuglite">Firebug Lite</a> мы изобретать не будем, просто сделаем заглушки для методов, дабы можно было их использовать, не проверяя наличия.<br/>
<br/>
<pre><code class="javascript">// Было:
if(window.console &amp;&amp; console.log)console.log(42);
// Стало:
console.log(42);
</code></pre><br/>
<a name="console-bind"></a><a href="index.html.1.194.html#console-bind"><b>#</b></a> В Firefox и Chromium методы консоли должны быть запущены из контекста <code>console</code>, так что если нужно передать их в качестве коллбэка придется привязать — например, <a href="index.html.1.194.html#es5-bind"># <code>console.log.bind(console)</code></a>. В IE, Firebug и на Node.js можно передавать, не привязывая, что гораздо удобней. Соответственно, привяжем методы к объекту <code>console</code>.<br/>
<br/>
<pre><code class="javascript">// Было:
setTimeout(console.log.bind(console, 42), 1000);
[1, 2, 3].forEach(console.log, console);
// Стало:
setTimeout(console.log, 1000, 42);
[1, 2, 3].forEach(console.log);
</code></pre><br/>
Но есть здесь и одна проблема: на некоторых платформах, при вызове методов консоли выводится и строка, откуда был вызван метод. При переопределении методов консоли, этой строкой будет строка в <b>сore.js</b>. Если это для вас критично — можете собрать библиотеку без модуля консоли.<br/>
<br/>
<h4><b>Так как консоль не стандартизована, добавим немного отсебятины:</b></h4><br/>
<a name="console-disable"></a><a href="index.html.1.194.html#console-disable"><b>#</b></a> Возможность выключить вывод в консоль. Конечно, на продакшне вызовы методов консоли лучше не оставлять в коде, удаляя их либо ручками, либо используя <a href="http://www.elijahmanor.com/grunt-away-those-pesky-console-log-statements/">более продвинутые средства</a>, но это удобно и нужно далеко не всегда.<br/>
<br/>
<pre><code class="javascript">console.disable();
console.warn('Консоль отключена, вы не увидите этого сообщения.');
console.enable();
console.warn('Консоль снова включена.');
</code></pre><br/>
Привязка контекста и возможность отключить консоль также присутствует, например, в <a href="http://habrahabr.ru/post/116852/">этой</a> библиотеке от <a href="https://habrahabr.ru/users/theshock/" class="user_link">TheShock</a>.<br/>
<br/>
<a name="II"></a><h1><b><a href="index.html.1.194.html#II">#</a> Часть вторая: Велосипеды</b></h1><hr/><blockquote>Вариантов ноль, вариантов нет.<br/>
Хотелось полмира — хватило на велосипед.<br/>
<i><b>— Петля пристрастия</b></i></blockquote><br/>
Велосипеды, в контексте данной статьи / библиотеки — весь нестандартизованный функционал. Собственно, то, чего, по моему мнению, не хватает стандартной библиотеке языка, даже если она будет реализована согласно всем имеющимся на данный момент стандартам. Сюда же отнесём и то, что предлагают в ES7+, так как это может быть далеко не раз пересмотрено или вообще отклонено.<br/>
<br/>
<a name="classify"></a><h2><b><a href="index.html.1.194.html#classify">#</a> Классификация данных</b></h2><hr/><br/>
<a name="is-object"></a><a href="index.html.1.194.html#is-object"><b>#</b></a> Тут начнем совсем с банальщины. В JavaScript по спецификации ECMAScript 5 есть <a href="http://es5.javascript.ru/x8.html#x8">6 типов данных</a>: <code>Undefined, Null, Boolean, String, Number</code> и <code>Object</code>. ECMAScript 6 добавляет еще один тип данных — <a href="index.html.1.194.html#es6-symbol"># <code>Symbol</code></a>. Для определения типа данных есть оператор <code>typeof</code>. Вот только работает он специфично. Так уж <a href="http://habrahabr.ru/post/200664/">исторически сложилось</a>, что <code>typeof null</code> возвращает <code>'object'</code> и <a href="http://wiki.ecmascript.org/doku.php?id=harmony:typeof_null">попытка исправить</a> это в Harmony успехом не увенчалась. Для типа <code>Object</code> <code>typeof</code> возвращает либо <code>'object'</code>, либо <code>'function'</code>, в зависимости от наличия внутреннего метода <code>[[Call]]</code>. Итого получаем, что оператор <code>typeof</code> возвращает именно тип данных только для примитивов, и то не всех.<br/>
<br/>
Если проверить, является ли переменная <code>null</code> просто, достаточно её с ним сравнить, то с <code>Object</code> придется либо каждый раз писать сотни кода, либо хелпер. Можно, конечно, сделать так — <code>Object(foo) === foo</code>, но данное решение <a href="http://jsperf.com/core-js-isobject">далеко не самое быстрое</a> — приводит примитив к объекту. В ранних черновиках ES6 присутствовал метод <code>Object.isObject</code>, но, видимо, из-за попытки исправить <code>typeof null</code>, был удален. А проверять, является ли переменная объектом, приходится постоянно. Так что <b>добавим хелпер <code>Object.isObject</code></b>, реализованный проще некуда (<a href="http://goo.gl/CIkM2P">песочница</a>):<br/>
<br/>
<pre><code class="javascript">Object.isObject = function(it){
  return it != null &amp;&amp; (typeof it == 'object' || typeof it == 'function');
}
// ...
typeof {};              // => 'object'
typeof isNaN;           // => 'function'
typeof null;            // => 'object'

Object.isObject({});    // => true
Object.isObject(isNaN); // => true
Object.isObject(null);  // => false
</code></pre><br/>
<a name="classof"></a><a href="index.html.1.194.html#classof"><b>#</b></a> А вот с классификацией объектов интересней. Оператор <code>instanceof</code> проверяет цепочку прототипов. Если создать объект из прототипа или установить объекту в качестве прототипа <code>Function.prototype</code>, это его не сделает функцией. Свойство инстанса <code>constructor</code> не может ничего гарантировать, а <code>constructor.name</code> мало того, что теряет всякий смысл при сжатии кода, еще и не поддерживается IE. Помочь с классификацией объекта может внутреннее свойство <code>[[Class]]</code>. Единственный способ выдрать его наружу — хорошо знакомая многим страшная конструкция <code>Object.prototype.toString.call(foo).slice(8, -1)</code>. <a href="http://goo.gl/2pbqnZ">Пример</a>:<br/>
<br/>
<pre><code class="javascript">Object.prototype.toString.call(1).slice(8, -1);   // => 'Number'
Object.prototype.toString.call([]).slice(8, -1);  // => 'Array'
Object.prototype.toString.call(/./).slice(8, -1); // => 'RegExp'
</code></pre><br/>
На базе получения внутреннего класса большинство библиотек добавляет набор утилит по типу <a href="index.html.1.194.html#es5-is-array"># <code>Array.isArray</code></a>: Object.is<i>Type</i> в <a href="http://sugarjs.com/api/Object/isType">Sugar</a>, _.is<i>Type</i> в <a href="http://underscorejs.org/#isArray">Undescore</a> и т.п.<br/>
<br/>
Мы поступим иначе — <b>один универсальный метод <code>Object.classof</code> для классификации данных</b>, похожий на оператор <code>typeof!</code> из <a href="http://livescript.net/#operators-object">LiveScript</a> (<a href="http://goo.gl/BxwFTQ">пример</a>).<br/>
<br/>
Вот только у <code>Object.prototype.toString.call(foo).slice(8, -1)</code> есть пара проблем:<br/>
<ul>
<li>В старых IE, применимо к <code>null, undefined</code> и <code>arguments</code>, данная конструкция возвращает <code>"Object"</code>. Это легко лечится дополнительными проверками.</li>
<li>Что делать с инстансами конструкторов из ECMAScript 6, полифилы которых мы добавили в нашей библиотеке? Так же будут возвращать <code>"Object"</code>. Тут на помощь приходит <a href="http://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.prototype.tostring">измененная логика работы</a> <code>Object#toString</code> в ECMAScript 6.</li>
</ul><br/>
Внезапно, но в ECMAScript 6 вообще отсутствует такое внутреннее свойство объектов, как <code>[[Class]]</code>. <code>Object#toString</code> ES6, через проверку специальных внутренних свойств, возвращает принадлежность переменной к <code>Undefined, Null, Array, String, Arguments, Function, Error, Boolean, Number, Date</code> или <code>RegExp</code>, а у остальных ищет подсказку по <a href="index.html.1.194.html#es6-symbol"># символу</a> <b><code>Symbol.toStringTag</code></b>. Если метод находит подсказку и она не является именем одного из встроенных «классов» — возвращает её, не находит — <code>Object</code>.<br/>
<br/>
Исправим логику работы <code>Object#toString</code>, благо благодаря <a href="index.html.1.194.html#es5-keys"># одному противному, но веселому, багу</a> мы можем сделать это и в IE8-, не сломав при этом <code>for-in</code>. Ну и, конечно, реализуем данный подход в методе <code>Object.classof</code>. В качестве бонуса мы получаем возможность классификации инстансов пользовательских конструкторов. <a href="http://goo.gl/M7qIFd">Пример</a>:<br/>
<br/>
<pre><code class="javascript">var classof = Object.classof;

classof(null);                 // => 'Null'
classof(undefined);            // => 'Undefined'
classof(1);                    // => 'Number'
classof(true);                 // => 'Boolean'
classof('string');             // => 'String'
classof(Symbol());             // => 'Symbol'

classof(new Number(1));        // => 'Number'
classof(new Boolean(true));    // => 'Boolean'
classof(new String('string')); // => 'String'

var fn   = function(){}
  , list = (function(){return arguments})(1, 2, 3);

classof({});                   // => 'Object'
classof(fn);                   // => 'Function'
classof([]);                   // => 'Array'
classof(list);                 // => 'Arguments'
classof(/./);                  // => 'RegExp'
classof(new TypeError);        // => 'Error'

classof(new Set);              // => 'Set'
classof(new Map);              // => 'Map'
classof(new WeakSet);          // => 'WeakSet'
classof(new WeakMap);          // => 'WeakMap'
classof(new Promise(fn));      // => 'Promise'

classof([].values());          // => 'Array Iterator'
classof(new Set().values());   // => 'Set Iterator'
classof(new Map().values());   // => 'Map Iterator'

classof(Math);                 // => 'Math'
classof(JSON);                 // => 'JSON'

function Example(){}
Example.prototype[Symbol.toStringTag] = 'Example';

classof(new Example);          // => 'Example'
</code></pre><br/>
<a name="dict"></a><h2><b><a href="index.html.1.194.html#dict">#</a> Словари</b></h2><hr/><br/>
В JavaScript объекты и словари (ассоциативные массивы) — одно. В этом есть как плюсы — это кажется очень удобным, не зря так распространён основанный на объектной системе JavaScript формат обмена данными <code>JSON</code>, так и минусы.<br/>
<br/>
Для словарей нет разницы между получением элемента по ключу и метода из прототипа, что, при наличии под объектом прототипа (а у объекта, заданного нотацией — фигурными скобками, это <code>Object.prototype</code>), ломает базовые операции над словарем. Для объектов же это ограничения на расширение <code>Object.prototype</code>.<br/>
<br/>
В ECMAScript 6 появился <a href="index.html.1.194.html#es6-map"># уже упомянутый выше</a> новый вид коллекций ключ-значение — <code>Map</code>. Его быстродействие иногда даже выше, чем у объектов (само собой, не касается полифилов). Вот только ИМХО в большинстве случаев их не заменит. У <code>Map</code>, в отличии от словарей-объектов, отсутствует простая запись литералом, доступ к свойствам происходит через методы — не такой лаконичный. <code>Map</code>'ы далеки от любимого всеми <code>JSON</code> и не столь универсальны. Да и обычно в ключах словаря не требуется ничего, кроме строк.<br/>
<br/>
<ul>
<li><a href="index.html.1.194.html#dict-and-object-prototype"># Проблема: <code>Object.prototype</code> и словари</a></li>
<li><a href="index.html.1.194.html#dict-module"># Конструктор <code>Dict</code></a></li>
<li><a href="index.html.1.194.html#dict-safe-crud"># Методы для безопасной работы со словарем, имеющим под собой прототип</a></li>
<li><a href="index.html.1.194.html#dict-methods"># Методы для работы со словарем</a></li>
<li><a href="index.html.1.194.html#dict-iter"># Итерация по словарю</a></li>
<li><a href="index.html.1.194.html#dict-next"># Возможные перспективы</a></li>
</ul><br/>
<a name="dict-and-object-prototype"></a><h4><b><a href="index.html.1.194.html#dict-and-object-prototype">#</a> Проблема: Object.prototype и словари</b></h4><br/>
В <code>Object.prototype</code>, как подсказывает <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/prototype">Mozilla Developer Network</a>, в зависимости от реализации, могут находиться:<br/>
<br/>
<pre><code class="javascript">Object.prototype.constructor();
Object.prototype.hasOwnProperty();
Object.prototype.isPrototypeOf();
Object.prototype.propertyIsEnumerable();
Object.prototype.toLocaleString();
Object.prototype.toString();
Object.prototype.valueOf();
Object.prototype.__proto__;
Object.prototype.__count__;
Object.prototype.__parent__;
Object.prototype.__noSuchMethod__;
Object.prototype.__defineGetter__();
Object.prototype.__defineSetter__();
Object.prototype.__lookupGetter__();
Object.prototype.__lookupSetter__();
Object.prototype.eval();
Object.prototype.toSource();
Object.prototype.unwatch();
Object.prototype.watch();
</code></pre><br/>
Чем это нам может грозить?<br/>
<br/>
Предположим, у нас есть примитивный телефонный справочник, и пользователь имеет доступ к его API:<br/>
<br/>
<pre><code class="javascript">var phone = (function(){
  var db = {
    'Вася': '+7987654',
    'Петя': '+7654321'
  };
  return {
    has: function(name){
      return name in db;
    },
    get: function(name){
      return db[name];
    },
    set: function(name, phone){
      db[name] = phone;
    },
    delete: function(name){
      delete db[name];
    }
  };
})();
</code></pre><br/>
<a href="http://goo.gl/1fJAhL">Получаем</a>:<br/>
<br/>
<pre><code class="javascript">console.log(phone.has('Вася'));     // => true
console.log(phone.get('Вася'));     // => '+7987654'
console.log(phone.has('Дима'));     // => false
console.log(phone.get('Дима'));     // => undefined
console.log(phone.has('toString')); // => true
console.log(phone.get('toString')); // => function toString() { [native code] }
</code></pre><br/>
Свойство, при отсутствии, берется из цепочки прототипов, <code>in</code> аналогично проверяет его наличие. Давайте добавим / заменим <code>in</code> на метод <code>hasOwnProperty</code>, проверяющий наличие свойства в объекте без учета цепочки прототипов. <a href="http://goo.gl/IvQUWE">Получаем</a>:<br/>
<br/>
<pre><code class="javascript">// ...
    has: function(name){
      return db.hasOwnProperty(name);
    },
    get: function(name){
      if(db.hasOwnProperty(name))return db[name];
    },
// ...
console.log(phone.get('Вася'));              // => '+7987654'
phone.set('hasOwnProperty', '+7666666'); // Добавляем нового "абонента"
console.log(phone.get('Вася'));              // TypeError: string is not a function
</code></pre><br/>
Уже довольно серьезно, особенно если этот «телефонный справочник» находится на серверной стороне. Методы прототипа можно перекрыть. Соответственно, нужно использовать метод <code>hasOwnProperty</code>, отвязанный от объекта. Получаем необходимость использования на каждый чих громоздких проверок. <a href="http://goo.gl/FEKzNd">Примерно такой трэш</a>:<br/>
<br/>
<pre><code class="javascript">// ...
    has: function(name){
      return Object.prototype.hasOwnProperty.call(db, name);
    },
    get: function(name){
      if(Object.prototype.hasOwnProperty.call(db, name))return db[name];
    },
// ...
</code></pre><br/>
Для решения данной проблемы в языке пригодился бы <a href="http://wiki.ecmascript.org/doku.php?id=strawman:has_operator">оператор проверки</a>, является ли свойство собственным, похожий на <code>in</code>.<br/>
<br/>
Вы уже решили, что проблемы закончились? <a href="http://goo.gl/yZfzuz">Ничего подобного</a>:<br/>
<br/>
<pre><code class="javascript">phone.set('__proto__', '+7666666'); // Добавляем нового "абонента"
console.log(phone.get('__proto__'));    // => undefined
</code></pre><br/>
В <code>Object.prototype</code> есть еще и «магический» геттер / сеттер <code>__proto__</code>, установка примитива по этому ключу будет игнорироваться, а объекта — повредить, например, при обходе свойств. В старых движках были и другие «магические» свойства. Тут поможет разве что <code>Object.defineProperty</code> (<a href="http://goo.gl/qigN0B">песочникца</a>):<br/>
<br/>
<pre><code class="javascript">// ...
    set: function(name, phone){
      Object.defineProperty(db, name, {
        enumerable  : true,
        configurable: true,
        writable    : true,
        value       : phone
      });
    },
// ...
</code></pre><br/>
Про обход словарей особо говорить не будем — если всё не совсем плохо, словарь не содержит в прототипе перечесляемых свойств, при обходе словаря через <code>for-in</code> можно обойтись без проверки <code>hasOwnProperty</code>. Вот только баг с <a name="es5-keys"></a><a href="index.html.1.194.html#es5-keys"># «неперечисляемыми перечисляемыми» свойствами</a> всё равно делает обход через <code>for-in</code> словарей, под которыми находится <code>Object.prototype</code>, неполноценным в старых IE.<br/>
<br/>
В ECMAScript 5 появился способ создания объекта без прототипа — <code>Object.create(null)</code>, с ним можно использовать реализацию методов, предложенную изначально (<a href="http://goo.gl/gz3ZBZ">песочница</a>):<br/>
<br/>
<pre><code class="javascript">var phone = (function(){
  var db = Object.create(null);
  Object.assign(db, {
    'Вася': '+7987654',
    'Петя': '+7654321'
  });
  return {
    has: function(name){
      return name in db;
    },
    get: function(name){
      return db[name];
    },
    set: function(name, phone){
      db[name] = phone;
    },
    delete: function(name){
      delete db[name];
    }
  };
})();
</code></pre><br/>
Всё замечательно, вот только его создание и инициализация, даже с <code>Object.assign</code>, не особо компактны.<br/>
<br/>
Так как у подобных словарей отсутствует прототип, отсутствуют и методы <code>toString</code> и <code>valueOf</code>. Чем это нам грозит?<br/>
<ul>
<li>Не удастся привести к числу, например <code>+Object.create(null)</code>, или строке, <code>'' + Object.create(null)</code>, — <code>TypeError</code></li>
<li>Соответственно, не удастся сравнить объект алгоритмом абстрактного равенства, например, <code>==</code>, с примитивами — <code>TypeError</code></li>
</ul>Для кого как, а для меня это скорее плюс, чем минус.<br/>
<br/>
<a name="dict-module"></a><h4><b><a href="index.html.1.194.html#dict-module">#</a> Конструктор <code>Dict</code></b></h4><br/>
Итак, создание словаря через <code>Object.create(null)</code> и его заполнение куда более громоздко, чем при создании словаря через <code>{}</code>. Конечно, самым красивым решением было бы добавление в язык <a href="http://wiki.ecmascript.org/doku.php?id=strawman:dicts">литерала словаря</a>, но это, по крайней мере, в ближайшей перспективе, маловероятно. Отсутствует возможность инициализации литералом. Есть запись <code>{__proto__: null, foo: 'bar'}</code>, но поддерживается не везде, <a href="https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#2-unsupported-syntax">на данный момент приводит к деоптимизации кода</a>, да и всё равно довольно громоздкая.<br/>
<br/>
Обсуждалось <a href="https://github.com/rwaldron/tc39-notes/blob/master/es6/2012-11/nov-29.md#collection-apis-review">одно довольно интересное решение</a> — сделать <b>«конструктор» <code>Dict</code> как сокращение <code>Object.create(null)</code></b>. Как оно сейчас поживает и поживает ли вообще, я не в курсе. Но почему бы не взять его, слегка расширив? Заодно получим пространство имен для методов для работы с объектами как словарями. Добавим возможность инициализации итератором <code>entries</code> или объектом без итератора, этакая версия <a href="index.html.1.194.html#es6-array-from"># <code>Array.from</code></a> для словарей.<br/>
<br/>
Так как <code>Dict() instanceof Dict</code> работать не будет и <a href="index.html.1.194.html#classof"># <code>Object.classof(Dict())</code></a> будет возвращать <code>'Object'</code>, добавим для идентификации словарей метод <code>Dict.isDict</code>.<br/>
<br/>
Примерно <a href="http://goo.gl/IuhgSc">вот так</a>:<br/>
<br/>
<pre><code class="javascript">function Dict(props){
  var dict = Object.create(null);
  if(props != null){
    if(Symbol.iterator in props){
      for(var [key, val] of props)dict[key] = val;
    } else Object.assign(dict, props);
  }
  return dict;
}
Dict.prototype = null;
Dict.isDict = function(it){
  return Object.isObject(it) &amp;&amp; Object.getPrototypeOf(it) === null;
}

// ...

var map = new Map([['a', 1], ['b', 2], ['c', 3]]);

Dict();                                            // => {__proto__: null}
Dict({a: 1, b: 2, c: 3});                          // => {__proto__: null, a: 1, b: 2, c: 3}
Dict(map);                                         // => {__proto__: null, a: 1, b: 2, c: 3}
Dict([1, 2, 3].entries());                         // => {__proto__: null, 0: 1, 1: 2, 2: 3}
Dict((for([k, v] of map)if(v % 2)[k + k, v * v])); // => {__proto__: null, aa: 1, cc: 9}

Dict.isDict({});     // => false
Dict.isDict(Dict()); // => true
</code></pre><br/>
<a name="dict-safe-crud"></a><h4><b><a href="index.html.1.194.html#dict-safe-crud">#</a> Методы для безопасной работы со словарем, имеющим под собой прототип</b></h4><br/>
На случай, если всё же придется работать с объектом, имеющим под собой прототип, как со словарем, добавим методы для безопасной работы с собственными свойствами.<br/>
<br/>
<b><code>Dict.has</code></b> — банально, статическая версия <code>hasOwnProperty</code>. В черновиках ECMAScript 6, в модуле <code>Reflect</code> — наборе заглушек для <code>Proxy</code>, до недавнего времени присутствовала статическая версия метода <code>hasOwnProperty</code> — метод <code>Reflect.hasOwn</code>. Однако в последних версиях черновика спецификации данный метод удалили.<br/>
<br/>
<b><code>Dict.get</code></b> — получение значения по ключу с проверкой, является ли свойство собственным. Не является — возвращаем <code>undefined</code>.<br/>
<br/>
<b><code>Dict.set</code></b> — метод для совсем уж параноиков. Позволяет установить свойство словаря, игнорирую сеттеры, такие, как <code>__proto__</code>. Использует <code>defineProperty</code>.<br/>
<br/>
Ну а оператор <code>delete</code> и так работает как надо.<br/>
<br/>
<a href="http://goo.gl/yXHvmR">Пример</a>:<br/>
<br/>
<pre><code class="javascript">var dict = {a: 1, b: 2, c: 3};

console.log(Dict.has(dict, 'a'));         // => true
console.log(Dict.has(dict, 'toString'));  // => false

console.log(Dict.get(dict, 'a'));         // => 1
console.log(Dict.get(dict, 'toString'));  // => undefined

Dict.set(dict, '__proto__', 42);
console.log(Dict.get(dict, '__proto__')); // => 42
</code></pre><br/>
<a name="dict-methods"></a><h4><b><a href="index.html.1.194.html#dict-methods">#</a> Методы для работы со словарем</b></h4><br/>
Методы, добавленные ECMAScript 5 в прототип массива для его обхода (<code>forEach, map, some</code> и т.п.), очень удобны. Их статические аналоги для словарей присутствуют в практически всех фреймворках / библиотеках общего назначения. А вот подвижек с добавлением их в стандарт нет.<br/>
<br/>
Добавим их в рамках нашего модуля <code>Dict</code>. Тут всё просто, методы аналогичны статическим версиям методов массива. Это: <b><code>Dict.forEach, Dict.map, Dict.filter, Dict.some, Dict.every, Dict.find, Dict.findKey, Dict.keyOf, </code><a href="index.html.1.194.html#array-contains"># <code>Dict.includes</code></a><code>, Dict.reduce, </code><a href="index.html.1.194.html#array-turn"># <code>Dict.turn</code></a></b>. <code>Key</code> в названии соответствует <code>index</code> у методов массива. «Правые» версии и опциональный аргумент-индекс (пока?) отсутствуют, так как порядок обхода ключей объектов пока не везде одинаков. Перебираются только собственные перечисляемые элементы объекта. Эти методы — дженерики в том же плане, что и <code>Array.from</code> или <code>Array.of</code>. Например, <code>Dict.map(dict, fn)</code> вернет новый <code>Dict</code>, а <code>Dict.map.call(Object, dict, fn)</code> — новый <code>Object</code>. А в общем, всё примитивно, скучно и как везде (<a href="http://goo.gl/RkjUxu">песочница</a>):<br/>
<br/>
<pre><code class="javascript">var dict = {a: 1, b: 2, c: 3};
Dict.forEach(dict, console.log, console);
// => 1, 'a', {a: 1, b: 2, c: 3}
// => 2, 'b', {a: 1, b: 2, c: 3}
// => 3, 'c', {a: 1, b: 2, c: 3}
Dict.map(dict, function(it){
  return it * it;
}); // => {a: 1, b: 4, c: 9}
Dict.filter(dict, function(it){
  return it % 2;
}); // => {a: 1, c: 3}
Dict.some(dict, function(it){
  return it === 2;
}); // => true
Dict.every(dict, function(it){
  return it === 2;
}); // => false
Dict.find(dict, function(it){
  return it > 2;
}); // => 3
Dict.find(dict, function(it){
  return it > 4;
}); // => undefined
Dict.findKey(dict, function(it){
  return it > 2;
}); // => 'c'
Dict.findKey(dict, function(it){
  return it > 4;
}); // => undefined
Dict.keyOf(dict, 2);    // => 'b'
Dict.keyOf(dict, 4);    // => undefined
Dict.includes(dict, 2); // => true
Dict.includes(dict, 4); // => false
Dict.reduce(dict, function(memo, it){
  return memo + it;
});     // => 6
Dict.reduce(dict, function(memo, it){
  return memo + it;
}, ''); // => '123'
Dict.turn(dict, function(memo, it, key){
  memo[key + key] = it;
});     // => {aa: 1, bb: 2, cc: 3}
Dict.turn(dict, function(memo, it, key){
  it % 2 &amp;&amp; memo.push(key + it);
}, []); // => ['a1', 'c3']
</code></pre><br/>
<a name="chaining"></a><b><a href="index.html.1.194.html#chaining">#</a></b> Что касается цепочек методов, <a href="index.html.1.194.html#dict-and-object-prototype"># по вполне очевидной причине</a>, в рамках модуля <code>Dict</code> их нет, и не предвидятся. Спасением тут могут стать <a href="https://github.com/zenparsing/es-abstract-refs#examples">abstract references</a>. А вот в рамках <a href="index.html.1.194.html#for"># <code>$for</code></a> и <a href="index.html.1.194.html#es6-map"># <code>Map</code></a> вполне возможно и появятся.<br/>
<br/>
<a name="dict-iter"></a><h4><b><a href="index.html.1.194.html#dict-iter">#</a> Итерация по словарю</b></h4><br/>
Близится светлое ES6 будущее с <a href="index.html.1.194.html#es6-iterators"># итераторами</a> и <a href="index.html.1.194.html#es6-for-of"># циклом <code>for-of</code></a>. Вот только объектам как словарям от этого ни тепло, ни холодно — для них в ES6 итераторы не предусмотрены. Соответственно, нет простого способа перебрать их через <code>for-of</code>, инициализировать <a href="index.html.1.194.html#es6-map"># <code>Map</code></a> словарем и т.п. Добавление методов <code>.keys, .values</code> и <code>.entries</code> в <code>Object.prototype</code> маловероятно — там и так достаточно мусора, см. описание предыдущей проблемы. Зато вполне вероятны два других сценария:<br/>
<br/>
Первый — добавление статических методов, возвращающих итератор, в пространство имён <code>Dict</code> — <code>Dict.{keys, values, entries}</code>. Но как уже писал, что с перспективой добавления этого модуля в стандарт мне неизвестно.<br/>
<br/>
Второй — <a href="https://github.com/rwaldron/tc39-notes/blob/master/es6/2014-04/apr-9.md#51-objectentries-objectvalues">добавление методов <code>Object.{values, entries}</code></a>, по типу <code>Object.keys</code>, возвращающих массив, а не итератор, и уже через итератор массива обходить объект.<br/>
<br/>
Что из этого появится — не знаю и гадать боюсь. Для получения массива значения словаря использовать довольно тяжелый протокол итераторов, как и использовать промежуточный массив для итерации по объекту не рационально. Так что, хоть это частично и дублирующий друг друга функционал, реализуем в нашей библиотеке оба набора методов. <a href="http://goo.gl/kKpVv2">Примеры</a>:<br/>
<br/>
<pre><code class="javascript">var dict = {a: 1, b: 2, c: 3};

console.log(Object.values(dict));  // => [1, 2, 3]
console.log(Object.entries(dict)); // => [['a', 1], ['b', 2], ['c', 3]]

for(var key of Dict.keys(dict))console.log(key); // => 'a', 'b', 'c'

for(var [key, val] of Dict.entries(dict)){
  console.log(key); // => 'a', 'b', 'c'
  console.log(val); // => 1, 2, 3
}

$for(Dict.values(dict)).of(console.log); // => 1, 2, 3

new Map(Dict.entries(dict)); // => Map {a: 1, b: 2, c: 3}

new Map((for([k, v] of Dict.entries(dict))if(v % 2)[k + k, v * v])); // =>  Map {aa: 1, cc: 9}
</code></pre><br/>
<a name="dict-next"></a><h4><b><a href="index.html.1.194.html#dict-next">#</a> Возможные перспективы</b></h4><br/>
Можно было бы зайти чуть дальше, сделав <code>Dict</code> не просто сокращением для <code>Object.create(null)</code> с возможностью инициализации итератором и объектом, а полноценным конструктором с прототипом, не содержащим ключей-строк, только <a href="index.html.1.194.html#es6-symbol"># символы</a>. <a href="http://goo.gl/G4yDFL">Примерно так</a>:<br/>
<br/>
<pre><code class="javascript">function Dict(props){
  if(!(this instanceof Dict))return new Dict(props);
  if(props != null){
    if(Symbol.iterator in props){
      for(var [key, val] of props)this[key] = val;
    } else Object.assign(this, props);
  }
}
Dict.prototype = Object.create(null);
Dict.prototype[Symbol.toStringTag] = 'Dict';
Dict.prototype[Symbol.iterator] = function(){
  return Dict.entries(this);
};
</code></pre><br/>
Что бы это нам дало?<br/>
<br/>
<ul>
<li><code>new Dict instanceof Dict</code>.</li>
<li><code>for(var [key, value] of dict){...}, new Map(dict)</code> без необходимости получать итератор через <code>Dict.entries</code>.</li>
<li><a href="index.html.1.194.html#classof"># <code>Object.classof(new Dict)</code></a> возвращал бы <code>'Dict'</code>, а не <code>'Object'</code>.</li>
</ul><br/>
Однако, есть причины, как минимум, отложить внедрение этого подхода до момента, когда IE8- вымрет окончательно, а также Firefox полностью перейдет на протокол итераторов ECMAScript 6. А может и вообще не стоит — рискуем окончательно потерять совместимость со стандартом, когда / если модуль <code>Dict</code> туда попадёт.<br/>
<br/>
<a name="partial-application"></a><h2><b><a href="index.html.1.194.html#partial-application">#</a> Частичное применение</b></h2><hr/><br/>
Пожалуй, одним из самых полезных нововведений в ECMAScript 5 был метод <a href="index.html.1.194.html#es5-bind"># <code>Function#bind</code></a>. Вот только возможности <a href="https://ru.wikipedia.org/wiki/%D0%A7%D0%B0%D1%81%D1%82%D0%B8%D1%87%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%B8%D0%BC%D0%B5%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5">частичного применения</a> данный метод раскрывает далеко не полностью. В этой главе мы рассмотрим такие вещи, как:<br/>
<br/>
<ul>
<li><a href="index.html.1.194.html#part"># Частичное применение без привязки контекста</a></li>
<li><a href="index.html.1.194.html#placeholder"># Частичное применение произвольных аргументов</a></li>
<li><a href="index.html.1.194.html#method-extraction"># Извлечение метода из объекта</a></li>
<li><a href="index.html.1.194.html#only"># Ограничение количества аргументов</a></li>
</ul><br/>
Можно было бы добавить <a href="http://ru.wikipedia.org/wiki/%CA%E0%F0%F0%E8%F0%EE%E2%E0%ED%E8%E5">каррирование</a>, но в JavaScript именно каррирование, а не частичное применение, требуется достаточно редко. Как и «правые» версии методов. Добавлю <a href="http://benalman.com/news/2012/09/partial-application-in-javascript/">ссылку</a> на годную (и так, пожалуй, хорошо известную) статью по теме.<br/>
<br/>
<a name="part"></a><h4><b><a href="index.html.1.194.html#part">#</a> Частичное применение без привязки контекста</b></h4><br/>
<code>Function#bind</code> совмещает в себе частичное применение и привязку контекста <code>this</code>. Последнее нужно далеко не всегда, и в этом случае привязываемый <code>this</code> не только «лишний» аргумент, что нужно писать. Если контекст, в котором должна запускаться частично применённая функция, заранее неизвестен, метод <code>Function#bind</code> неприменим. Например, если это метод прототипа (<a href="http://goo.gl/uj6s6f">песочница</a>):<br/>
<br/>
<pre><code class="javascript">Array.prototype.compact = [].filter.bind(Array.prototype, function(val){
  return val != null;
});

[0, null, 1, undefined, 2].compact(); // => [] - метод запускается в контексте Array.prototype, а не данного массива

// Придется частично применять вручную:
Array.prototype.compact = function(){
  return this.filter(function(val){
    return val != null;
  });
};

[0, null, 1, undefined, 2].compact(); // => [0, 1, 2];
</code></pre><br/>
Добавим метод частичного применения без привязки <code>this</code> — <code>Function#part</code> (<a href="http://goo.gl/l2UY0d">песочница</a>):<br/>
<br/>
<pre><code class="javascript">Array.prototype.compact = [].filter.part(function(val){
  return val != null;
});

[0, null, 1, undefined, 2].compact(); // => [0, 1, 2];

var fn = console.log.part(1, 2);
fn(3, 4); // => 1, 2, 3, 4
</code></pre><br/>
<a name="placeholder"></a><h4><b><a href="index.html.1.194.html#placeholder">#</a> Частичное применение произвольных аргументов</b></h4><br/>
Часто при частичном применении нужно передать произвольные аргументы — не, например, первые 2, а только второй и четвёртый или второй и третий. Тут <code>Function#bind</code> нам помочь не сможет — придется писать обертку вручную под каждый конкретный случай.<br/>
<br/>
<pre><code class="javascript">function fn1(a, c){
  console.log(a, 2, c, 4);
};
fn1(1, 3); // => 1, 2, 3, 4

function fn2(b, c){
  console.log(1, b, c, 4);
};
fn2(2, 3); // => 1, 2, 3, 4
</code></pre><br/>
Для облегчения подобной задачи добавим плейсхолдер — объект, замещающий аргумент, что будет передан при вызове конечной функции. В качестве ссылки на плейсхолдер так и напрашивается глобальная переменная <code>_</code> (как, например, в <a href="http://livescript.net/#functions-partial">LiveScript</a>, <a href="http://goo.gl/EsYZ69">песочница</a>), однако, эту переменную используют библиотеки Undescore.js (кстати, в ней это тоже плейсхолдер для <code>_.partial</code>) и LoDash как свой неймспейс. Во избежание конфликтов с ними, создаём новый глобальный объект <code>_</code> только если таковой отсутствует, а во время работы используем глобальный объект <code>_</code>, что бы там ни лежало. В случае сборки без расширения нативных объектов, в качестве плейсхолдера используем объект <code>core._</code>. <a href="http://goo.gl/ykMnZf">Пример</a>:<br/>
<br/>
<pre><code class="javascript">var fn1 = console.log.part(_, 2, _, 4);
fn1(1, 3);    // => 1, 2, 3, 4

var fn2 = console.log.part(1, _, _, 4);
fn2(2, 3);    // => 1, 2, 3, 4

fn1(1, 3, 5); // => 1, 2, 3, 4, 5
fn1(1);       // => 1, 2, undefined, 4
</code></pre><br/>
Также добавим метод <code>Function#by</code>, аналогичный <code>Function#bind</code>, но с возможностью использования плейсхолдера для аргументов. Можно было бы обернуть <code>Function#bind</code>, заставив работать с плейсхолдером, но это — нарушение спецификации, да и метод этот и так довольно тормозной почти во всех движках.<br/>
<br/>
<pre><code class="javascript">var fn = console.log.by(console, _, 2, _, 4);
fn(1, 3, 5); // => 1, 2, 3, 4, 5
</code></pre><br/>
<a name="method-extraction"></a><h4><b><a href="index.html.1.194.html#method-extraction">#</a> Извлечение метода из объекта</b></h4><br/>
В большинстве случаев, например, при передаче коллбэка в функцию, метод нам нужно привязать именно к тому объекту, из которого его и получаем. И тут возникает проблема — <code>fn(foo.bar.baz.bind(foo.bar))</code>. Мы вынуждены писать <code>foo.bar</code> 2 раза, это явное нарушение принципа DRY. Надеюсь, в будущем от этой проблемы спасут <a href="https://github.com/zenparsing/es-abstract-refs">abstract references</a>, но предложенная реализация проблему <a href="https://github.com/zenparsing/es-abstract-refs/issues/5">не решает</a>. Пожалуй, самым вкусным и красивым решением было бы добавление в язык оператора доступа с сохранением контекста, аналогичного <a href="http://livescript.net/#property-access"><code>~</code> из LiveScript</a> — <code>fn(foo.bar~baz)</code> (<a href="http://goo.gl/58e0Dp">песочница</a>).<br/>
<br/>
Решений проблемы на базе библиотеки в голову приходит не много — разве что извлечение метода из объекта по ключу. Это либо статический метод, например, <code>_.bindKey</code> из <a href="http://lodash.com/docs#bindKey">LoDash</a> (но с ранним связыванием), однако он тоже довольно громоздкий и еще больше ухудшает читаемость, либо аналогичный по функционалу метод в <code>Object.prototype</code>, например, <code>Object#boundTo</code> из <a href="https://github.com/WebReflection/eddy#objectboundtomethod">Eddy.js</a>.<br/>
<br/>
Как бы это страшно ни звучало, мы добавим метод в <code>Object.prototype</code>. Рисковать, расширяя <code>Object.prototype</code> методом по короткому ключу-строке, мы, по крайней мере, пока, не будем — сложно избежать конфликтов, да и сломаем <code>for-in</code> в IE8-. Ранее в этой главе мы уже использовали глобальную переменную <code>_</code>. Дабы не плодить лишних сущностей и для краткости, применим её и здесь. Заменим у объекта <code>_</code> метод <code>toString</code> (соответственно, если использовать совместно с Undescore.js или LoDash — нужно подключать <b>core.js</b> после них). Он будет возвращать уникальный ключ-строку, аналогично <a href="index.html.1.194.html#es6-symbol-polyfill"># ключу полифила символа</a>. Добавим по этому ключу метод в <code>Object.prototype</code>. За счет использования грязного хака с <a href="index.html.1.194.html#es5-keys"># веселым багом</a>, <b>мы добавляем этот метод и в IE8-, при этом не сломав <code>for-in</code>.</b><br/>
<br/>
Итого, из примера, с которого начали, получим <code>fn(foo.bar[_]('baz'))</code> — далековато от идеала, но хоть от второго упоминания объекта избавились. Возвращаемый метод кэшируется. <a href="http://goo.gl/dQsSTi">Примеры</a>:<br/>
<br/>
<pre><code class="javascript">['foobar', 'foobaz', 'barbaz'].filter(/bar/[_]('test')); // => ['foobar', 'barbaz']

var has = {}.hasOwnProperty[_]('call');

console.log(has({key: 42}, 'foo')); // => false
console.log(has({key: 42}, 'key')); // => true

var array = []
  , push  = array[_]('push');
push(1);
push(2, 3);
console.log(array); // => [1, 2, 3];
</code></pre><br/>
По-хорошему, после отказа от поддержки IE8- библиотекой, метод стоит переименовать, а то страшновато это как-то :) <code>tie, boundTo, bindKey</code> или что-то в этом духе, подобрав наименее конфликтный ключ.<br/>
<br/>
Использование <code>Proxy</code> из ES6 здесь было бы куда симпатичней — обычный доступ к свойству вместо передачи ключа в метод — <code>fn(foo.bar[_].baz)</code>, но без <code>Proxy</code> подобное (геттер, обход объекта и привязка всех методов), серьёзно не теряя при этом в производительности, мы пока себе позволить не можем.<br/>
<br/>
<div class="spoiler"><b class="spoiler_title">Пример с Proxy, работает пока только в ночном огнелисе</b><div class="spoiler_text"><pre><code class="javascript">var _ = Symbol();
Object.defineProperty(Object.prototype, _, {
  get: function(){
    return new Proxy(this, {
      apply: function(){ /* аналогично текущей логике [_] для обратной совместимости */ },
      get: function(context, name){
        return context[name].bind(context);
      }
    });
  }
});

['foobar', 'foobaz', 'barbaz'].filter(/bar/[_].test); // => ['foobar', 'barbaz']

var has = {}.hasOwnProperty[_].call;

console.log(has({key: 42}, 'foo')); // => false
console.log(has({key: 42}, 'key')); // => true

var array = []
  , push  = array[_].push;
push(1);
push(2, 3);
console.log(array); // => [1, 2, 3];
</code></pre></div></div><br/>
<a name="only"></a><h4><b><a href="index.html.1.194.html#only">#</a> Ограничение количества аргументов</b></h4><br/>
Проблема необязательных аргументов рассмотрена в <a href="http://habrahabr.ru/post/114737/">данной статье</a>. Пример в ней — <code>parseInt</code> — довольно невразумительный, никто не мешает приводить строки к числу, например, используя <code>Number</code>, что не ожидает дополнительных аргументов. Дело тут не в их «опасности», а в необходимости писать лишнюю обертку.<br/>
<br/>
Например, мы хотим вывести в консоль все элементы массива, только сами элементы и ничего больше:<br/>
<br/>
<pre><code class="javascript">[1, 2, 3].forEach(console.log);
// => 1 0 [1, 2, 3]
// => 2 1 [1, 2, 3]
// => 3 2 [1, 2, 3]
</code></pre><br/>
Метод <code>.forEach</code>, как и многие другие, передаёт коллбэку необязательные аргументы — индекс и сам массив. А нам они не нужны. Так что каждый раз коллбэк придется оборачивать в еще одну функцию:<br/>
<br/>
<pre><code class="javascript">[1, 2, 3].forEach(function(it){
  console.log(it);
}); // => 1, 2, 3
</code></pre><br/>
В статье, упомянутой выше, для ограничения аргументов функций был предложен метод <code>Function#only</code>. Реализуем его вариант. Первый аргумент — максимальное число аргументов, второй, опциональный — контекст. <a href="http://goo.gl/EflCFz">Пример</a>:<br/>
<br/>
<pre><code class="javascript">[1, 2, 3].forEach(console.log.only(1)); // => 1, 2, 3
</code></pre><br/>
Конечно, если максимальное кол-во аргументов — 1, проще, если они доступны, обойтись стрелочными функциями из ES6 или кофеподобных языков, но если больше — уже проблематично.<br/>
<br/>
<a name="date-format"></a><h2><b><a href="index.html.1.194.html#date-format">#</a> Форматирование даты</b></h2><hr/><br/>
Казалось бы, простая задача — форматирования даты, в JavaScript не такая уж и простая. Что делать, если нам нужно получить строку формата <b>«18.11.2014 06:07:25»</b>? <a href="http://goo.gl/duI0y0">Всё довольно страшно</a>:<br/>
<br/>
<pre><code class="javascript">var date = new Date;
function lz2(it){
  return it > 9 ? it : '0' + it;
}
var format = [date.getDate(), date.getMonth() + 1, date.getFullYear()].map(lz2).join('.') + ' ' +
             [date.getHours(), date.getMinutes(), date.getSeconds()].map(lz2).join(':');
console.log(format); // => '18.11.2014 06:07:25 '
</code></pre><br/>
А что делать, если нужно получить, например, строку формата <b>«Вторник, 18 Ноября 2014 г., 6:07:25»</b>?<br/>
<br/>
В начале статьи был упомянут стандарт интернационализации <b>ECMA402</b>, <a href="http://norbertlindenberg.com/ecmascript/intl.html">спецификация</a>. Стандарт добавляет в JavaScript объект <b>Intl</b>, содержащий средства локализованного форматирования даты, чисел, сравнения строк. На базовом уровне <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl">Intl</a> рассмотрен в <a href="http://habrahabr.ru/post/218481/">этой статье</a>. Ко всему прочему, этот стандарт перегружает методы <code>Date#toLocaleString, Date#toLocaleDateString, Date#toLocaleTimeString</code>, добавляя в них 2 аргумента: локализация и опции формата. Используя их, строку, близкую к упомянутому выше формату, можно получить <a href="http://goo.gl/DHvgqd">так</a>:<br/>
<br/>
<pre><code class="javascript">new Date().toLocaleString('ru-RU', {
  weekday: 'long',
  year:    'numeric',
  month:   'long',
  day:     'numeric',
  hour:    'numeric',
  minute:  '2-digit',
  second:  '2-digit'
}); // => 'вторник, 18 ноября 2014 г., 6:07:25'
</code></pre><br/>
Громоздко, конечно, но лучше уж так, чем никак. Касательно поддержки стандарта — в целом, неплохо. Поддерживается Chrome, Opera, IE11, с недавних пор и Firefox. Но обычно нужна поддержка IE10-, Safari, мобильных платформ и чёрт еще знает чего. На этот случай есть <a href="https://github.com/andyearnshaw/Intl.js">полифил</a>. Но вот незадача — реализация данного функционала будет слишком много весить, даже без учета локалей. По этой причине <b>в core.js и отсутствует полифил ECMA402</b>.<br/>
<br/>
<a name="simple-date-format"></a><h4><b><a href="index.html.1.194.html#simple-date-format">#</a> Добавим простое форматирование даты.</b></h4><br/>
Что значит «простое»? Как часто вам нужна полноценная локализация или какие другие продвинутые средства работы с датой? Мне — не очень, обычно хочется простого удобного форматирования даты строкой формата. Ну а если нужны — никто не мешает подключить <b><a href="http://momentjs.com/">Moment.js</a></b> или полифил <code>Intl</code>. Здесь же весь модуль работы с датой — несколько десятков строк.<br/>
<br/>
Добавляем метод <code>Date#format</code> и его UTC версию <code>Date#formatUTC</code> (<a href="http://goo.gl/NMeGEy">песочница</a>):<br/>
<br/>
<pre><code class="javascript">new Date().format('W, D MM Y г., h:mm:ss', 'ru');    // => 'Вторник, 18 Ноября 2014 г., 6:07:25'
new Date().formatUTC('W, D MM Y г., h:mm:ss', 'ru'); // => 'Вторник, 18 Ноября 2014 г., 0:07:25'
</code></pre><br/>
Ради простоты и легкочитаемости строки формата, не будем заморачиваться экранированием обозначений. Пока доступен их минимум:<br/>
<br/>
<pre><code class="sql">s  | Секунды             | 0-59
ss | Секунды, 2 цифры    | 00-59
m  | Минуты              | 0-59
mm | Минуты, 2 цифры     | 00-59
h  | Часы                | 0-23
hh | Часы, 2 цифры       | 00-23
D  | Дата                | 1-31
DD | Дата, 2 цифры       | 01-31
W  | День недели, строка | Вторник
N  | Месяц               | 1-12
NN | Месяц, 2 цифры      | 01-12
M  | Месяц, строка       | Ноябрь
MM | Месяца, строка      | Ноября
Y  | Год, полный         | 2014
YY | Год, 2 цифры        | 14
</code></pre><br/>
Библиотека уже включает русскую (<code>ru</code>) и английскую (<code>en</code>) локали. Локаль задается либо методом <code>core.locale</code>, либо вторым аргументом методов <code>Date#format</code> и <code>Date#formatUTC</code> (<a href="http://goo.gl/BYG9XY">песочница</a>):<br/>
<br/>
<pre><code class="javascript">new Date().format('W, D MM Y', 'ru'); // => 'Вторник, 18 Ноября 2014'
new Date().format('W, D MM Y');       // => 'Tuesday, 18 November 2014'
core.locale('ru');
new Date().format('W, D MM Y');       // => 'Вторник, 18 Ноября 2014'
</code></pre><br/>
Формат локали представлен ниже. В собственном коде можно ограничиться <code>core.addLocale</code>, но из-за возможности сборки библиотеки без расширения нативных объектов, универсальный модуль-локаль будет выглядеть так:<br/>
<br/>
<pre><code class="javascript">(typeof core != 'undefined' ? core : require('core-js/library')).addLocale('ru', {
  weekdays: 'Воскресенье,Понедельник,Вторник,Среда,Четверг,Пятница,Суббота',
  months: 'Январ:я|ь,Феврал:я|ь,Март:а|,Апрел:я|ь,Ма:я|й,Июн:я|ь,Июл:я|ь,Август:а|,Сентябр:я|ь,Октябр:я|ь,Ноябр:я|ь,Декабр:я|ь'
});
</code></pre><br/>
<a href="http://goo.gl/PVfVLd">Несколько примеров</a>:<br/>
<br/>
<pre><code class="javascript">new Date().format('DD.NN.YY');         // => '18.11.14'
new Date().format('hh:mm:ss');         // => '06:07:25'
new Date().format('DD.NN.Y hh:mm:ss'); // => '18.11.2014 06:07:25'
new Date().format('W, D MM Y года');   // => 'Вторник, 18 Ноября 2014 года'
new Date().format('D MM, h:mm');       // => '18 Ноября, 6:07'
new Date().format('M Y');              // => 'Ноябрь 2014'
</code></pre><br/>
<a name="object"></a><h2><b><a href="index.html.1.194.html#object">#</a> Объектное API</b></h2><hr/><br/>
<a name="object-define"></a><a href="index.html.1.194.html#object-define"><b>#</b></a> <b>Первая проблема</b>: в ECMAScript 5 добавлена возможность объявить геттеры и сеттеры в литерале объекта. А вот добавить геттеры / сеттеры уже существующих объектов можно только с использованием <code>Object.defineProperty</code> / <code>Object.defineProperties</code>, что вынуждает передавать на каждое свойство полный (если не хочется таких дополнительных опций, как неперечисляемость или невозможность переопределить) объект дескриптора, а это громоздко.<br/>
<br/>
Кроме метода <a href="index.html.1.194.html#es6-object-assign"># <code>Object.assign</code></a>, в ECMAScript 6 планировалось добавить метод <code>Object.mixin</code>, который копировал свойства объекта-источника в целевой объект с учетом дескрипторов. Кроме этого, метод должен был переназначать родителя методов объекта-источника, получаемого через ключевое слово <code>super</code>. Однако, его решили переработать и отложили добавление в стандарт.<br/>
<br/>
Добавим метод <code>Object.define</code>, работающий как описанный <code>Object.mixin</code> — копирующий свойства объекта-источника в цель с учетом дескрипторов, но не переопределяющий родителя, за отсутствием ключевого слова <code>super</code> в ECMAScript 5.<br/>
<br/>
<pre><code class="javascript">// Было:
Object.defineProperty(target, 'c', {
  enumerable: true,
  configurable: true,
  get: function(){
    return this.a + this.b;
  }
});

// Стало:
Object.define(target, {
  get c(){
    return this.a + this.b;
  }
});
</code></pre><br/>
<a name="object-make"></a><a href="index.html.1.194.html#object-make"><b>#</b></a> <b>Вторая проблема</b>: в ECMAScript 5 также добавлена возможность создания объекта без использования конструктора, через <code>Object.create</code>. Было бы неплохо добавлять собственные свойства объекта при создании, но вторым аргументом <code>Object.create</code>, как и <code>Object.defineProperties</code>, принимает объект, содержащий объекты дескрипторов свойств, что страшно громоздко.<br/>
<br/>
Добавим метод <code>Object.make</code> — аналог <code>Object.create</code>, вторым аргументом ожидающий не объект дескрипторов, а простой объект, из которого копируются собственные свойства в создаваемый объект с учетом дескрипторов.<br/>
<br/>
<pre><code class="javascript">// Поверхностное копирование объекта с учетом прототипа и дескрипторов:
var copy = Object.make(Object.getPrototypeOf(src), src);

// Пример с наследованием:
function Vector2D(x, y){
  this.x = x;
  this.y = y;
}
Object.define(Vector2D.prototype, {
  get xy(){
    return Math.hypot(this.x, this.y);
  }
});
function Vector3D(x, y, z){
  Vector2D.apply(this, arguments);
  this.z = z;
}
Vector3D.prototype = Object.make(Vector2D.prototype, {
  constructor: Vector3D,
  get xyz(){
    return Math.hypot(this.x, this.y, this.z);
  }
});

var vector = new Vector3D(9, 12, 20);
console.log(vector.xy);  // => 15
console.log(vector.xyz); // => 25
vector.y++;
console.log(vector.xy);  // => 15.811388300841896
console.log(vector.xyz); // => 25.495097567963924
</code></pre><br/>
В ECMAScript 7 предлагают добавить метод <a href="https://gist.github.com/WebReflection/9353781">Object.getOwnPropertyDescriptors</a>, возвращающий, как ясно из его названия, объект, содержащий все дескрипторы собственных свойств объекта. Идеальная пара для создания второго аргумента <code>Object.defineProperties</code> и <code>Object.create</code> и, в некоторой степени, альтернатива нашим <code>Object.make</code> и <code>Object.define</code>. Вот только слишком громоздкая.<br/>
<br/>
<a name="array"></a><h2><b><a href="index.html.1.194.html#array">#</a> Массивы</b></h2><hr/><br/>
<a name="array-contains"></a><a href="index.html.1.194.html#array-contains"><b>#</b></a> Метод <a href="https://github.com/domenic/Array.prototype.includes">Array#includes</a> (до недавнего времени — <code>Array#contains</code>, переименован из-за <a href="https://esdiscuss.org/topic/array-prototype-contains-solutions">бага MooTools</a>, пока доступен и по старому имени) планируется к добавлению в ECMAScript 7. Он банально проверяет вхождение элемента в массив. В отличии от <code>Array#indexOf</code>, использует алгоритм сравнения <a href="index.html.1.194.html#same-value-zero"># SameValueZero</a> и не игнорирует «дырки». Второй, опциональный, аргумент — стартовая позиция. <a href="http://goo.gl/2Gq4ma">Примеры</a>:<br/>
<br/>
<pre><code class="javascript">[1, 2, 3].includes(2);        // => true
[1, 2, 3].includes(4);        // => false
[1, 2, 3].includes(2, 2);     // => false

[NaN].indexOf(NaN);           // => -1
[NaN].includes(NaN);          // => true
Array(1).indexOf(undefined);  // => -1
Array(1).includes(undefined); // => true
</code></pre><br/>
<a name="array-turn"></a><a href="index.html.1.194.html#array-turn"><b>#</b></a> А вот метод <code>Array#turn</code> — плод моей больной фантазии. Хотя, как выяснилось, не уникальный — ему аналогичен метод <code>_.transform</code> из <a href="http://lodash.com/docs#transform">LoDash</a>. Это альтернатива методу <code>Array#reduce</code> для свёртки массива в произвольный объект-аккумулятор (по умолчанию — новый массив) без необходимости возвращать аккумулятор из коллбэка. Сигнатура метода и коллбэка аналогична <code>Array#reduce</code>. Можно прервать обход коллекции, вернув из коллбэка <code>false</code>. <a href="http://goo.gl/r3DbCT">Примеры</a>:<br/>
<br/>
<pre><code class="javascript">// Свёртка в словарь:
[1, 2, 3, 4, 5].reduce(function(memo, it){
  memo['key' + it] = !!(it % 2);
  return memo;
}, {}); // => {key1: true, key2: false, key3: true, key4: false, key5: true}

[1, 2, 3, 4, 5].turn(function(memo, it){
  memo['key' + it] = !!(it % 2);
}, {}); // => {key1: true, key2: false, key3: true, key4: false, key5: true}

// filter + map + slice, делаем лишнюю работу:
[1, 2, 3, 4, 5, 6, 7, 8, 9].map(function(it){
  return it * it;
}).filter(function(it){
  return it % 2;
}).slice(0, 2); // => [1, 9]

[1, 2, 3, 4, 5, 6, 7, 8, 9].turn(function(memo, it){
  it % 2 &amp;&amp; memo.push(it * it);
  if(memo.length == 2)return false;
}); // => [1, 9]
</code></pre><br/>
<a name="num"></a><h2><b><a href="index.html.1.194.html#num">#</a> Числа</b></h2><hr/><br/>
<a name="num-iter"></a><a href="index.html.1.194.html#num-iter"><b>#</b></a> Помните <a href="index.html.1.194.html#es6-iterators"># пример с итерируемыми числами</a> из главы про итераторы? Слишком вкусная и универсальная возможность, что бы отказываться от подобного в стандартной библиотеке. Очень краткий цикл, выполняемый заданное число раз, на базе <code>for-of</code>, простая генерация массива заданной длины через <a href="index.html.1.194.html#es6-array-from"># <code>Array.from</code></a> (а может и <a href="index.html.1.194.html#es6-spread"># spread</a>) и т.д. Так что добавим итератор чисел, хоть и не в такой примитивной реализации. <a href="http://goo.gl/yDD2oM">Примеры</a>:<br/>
<br/>
<pre><code class="javascript">// Классический цикл:
for(var i = 0; i &lt; 3; i++)console.log(i); // => 0, 1, 2

// for-of с итератором числа:
for(var i of 3)console.log(i); // => 0, 1, 2

// При отсутствии for-of, хелпер:
$for(3).of(console.log); // => 0, 1, 2

// Генерация массива заданной длины:
// .map пропускает "дырки" в массиве
Array(10).map(Math.random); // => [undefined × 10]

// ES5 костыль, пара вспомогательных массивов:
Array.apply(undefined, Array(10)).map(Math.random); // => [0.9442228835541755, 0.8101077508181334, ...]

// ES6 костыль, заполняем вспомогательный массив:
Array(10).fill(undefined).map(Math.random); // => [0.5587614295072854, 0.009569905698299408, ...]

// Number Iterator:
Array.from(10, Math.random); // => [0.9817775336559862, 0.02720663254149258, ...]

Array.from(10); // => [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

Array.from(10, function(it){
  return this + it * it;
}, .42); // => [0.42, 1.42, 4.42, 9.42, 16.42, 25.42, 36.42, 49.42, 64.42, 81.42]

// Comprehensions:
[for(i of 10)if(i % 2)i * i]; // => [1, 9, 25, 49, 81]

Dict((for(i of 3)['key' + i, !(i % 2)])); // => {key0: true, key1: false, key2: true}

$for(10).filter(function(i){
  return i % 2;
}).array(function(i){
  return i * i;
});  // => [1, 9, 25, 49, 81]

Dict($for(3).map(function(i){
  return ['key' + i, !(i % 2)];
})); // => {key0: true, key1: false, key2: true}
</code></pre><br/>
<a name="num-math"></a><a href="index.html.1.194.html#num-math"><b>#</b></a> Математические функции в <code>Number.prototype</code> — из разряда приятных мелочей. Точно также как в Sugar и MooTools, вынесем методы из объекта <code>Math</code> в <code>Number.prototype</code>. Тут и говорить особо нечего — контекст становится первым аргументом математической функции. Может и дублирует уже имеющийся, стандартизованный, функционал, но это довольно удобно :)<br/>
<br/>
Отдельной строкой упомянем метод <code>Number#random</code>. Он возвращает случайное число между числом-контекстом и переданным аргументом (по умолчанию — 0).<br/>
<br/>
<a href="http://goo.gl/06bs1k">Примеры</a>:<br/>
<br/>
<pre><code class="javascript">3..pow(3);           // => 27
(-729).abs().sqrt(); // => 27

10..random(20);         // => Случайное число (10, 20), например, 16.818793776910752
10..random(20).floor(); // => Случайное целое [10, 19], например, 16

var array = [1, 2, 3, 4, 5];
array[array.length.random().floor()]; // => Случайный элемент массива, например, 4
</code></pre><br/>
<a name="escape"></a><h2><b><a href="index.html.1.194.html#escape">#</a> Экранирование спецсимволов</b></h2><hr/><br/>
<a name="escape-html"></a><a href="index.html.1.194.html#escape-html"><b>#</b></a> Если я внезапно, под конец статьи, скажу, что JavaScript используется, в первую очередь, для работы с HTML, то великой тайны не открою. Для работы с HTML как на клиенте, так и на сервере нам требуется его экранировать. Кто-то может сказать, что это задача фреймворка или шаблонизатора. Вот только стоит ли для такой примитивной задачи их тянуть? Методы для экранирования HTML есть во всех стандартных библиотеках. В Sugar, Prototype, MooTools это методы <code>escapeHTML</code> и <code>unescapeHTML</code> в прототипе строки. Не будем нарушать данную традицию:<br/>
<br/>
<pre><code class="javascript">'&lt;script>doSomething();&lt;/script>'.escapeHTML(); // => '&amp;lt;script&amp;gt;doSomething();&amp;lt;/script&amp;gt;'
'&amp;lt;script&amp;gt;doSomething();&amp;lt;/script&amp;gt;'.unescapeHTML(); // => '&lt;script>doSomething();&lt;/script>'
</code></pre><br/>
<a name="escape-regexp"></a><a href="index.html.1.194.html#escape-regexp"><b>#</b></a> Часто возникает необходимость создать регулярное выражение из пользовательских данных, а для корректной / безопасной работы нужно экранировать и их. Методы для этого есть в Sugar, Prototype, MooTools, где-то как статический метод <code>RegExp</code>, где-то метод <code>String.prototype</code>. Давно <a href="http://esdiscuss.org/topic/regexp-escape">обсуждается</a> добавление такого метода в ECMAScript. Надеюсь, мы дождемся этого, а пока реализуем <a href="https://gist.github.com/kangax/9698100">предложенный вариант</a> в нашей библиотеке:<br/>
<br/>
<pre><code class="javascript">RegExp.escape('Привет -[]{}()*+?.,\\^$|'); // => 'Привет \-\[\]\{\}\(\)\*\+\?\.\,\\\^\$\|'
</code></pre><br/>
<a name="end"></a><h2><b><a href="index.html.1.194.html#end">#</a> Заключение</b></h2><hr/><br/>
Ну вот как-то так.<br/>
<br/>
Предвижу появление в комментариях всем известной картинки xkcd про стандарты, вот только почти всё в библиотеке максимально соответствует имеющимся, а альтернатив её, кроме солянки далеко не из пары библиотек и весом в сотни килобайт, я не вижу.<br/>
<br/>
Что касается планов на будущее библиотеки, они, в основном, раскиданы по тексту статьи. Еще нужно, конечно, оптимизировать производительность и лучше покрыть код тестами — с этим пока особо не заморачивался.<br/>
<br/>
Интересует ваше мнение о том, что я, возможно, пропустил и что можно реализовать лучше.<br/>
<br/>
<b>Да. И еще, раз подобным страдать начал — скучно мне. Ищу интересный проект с достойной з/п.</b></div></div></div> <DIV class="v-portal" style="display:none;"></DIV></div> <!----> <!----></div> <div class="tm-article-presenter__meta"><div class="tm-separated-list tm-article-presenter__meta-list"><span class="tm-separated-list__title">Теги:</span> <ul class="tm-separated-list__list"><li class="tm-separated-list__item"><a href="https://habr.com/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5BCore.js%5D" class="tm-tags-list__link">Core.js</a></li><li class="tm-separated-list__item"><a href="https://habr.com/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5BECMAScript%205%5D" class="tm-tags-list__link">ECMAScript 5</a></li><li class="tm-separated-list__item"><a href="https://habr.com/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5BECMAScript%206%5D" class="tm-tags-list__link">ECMAScript 6</a></li><li class="tm-separated-list__item"><a href="https://habr.com/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5BECMAScript%207%5D" class="tm-tags-list__link">ECMAScript 7</a></li><li class="tm-separated-list__item"><a href="https://habr.com/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5BHarmony%5D" class="tm-tags-list__link">Harmony</a></li><li class="tm-separated-list__item"><a href="https://habr.com/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5BStrawman%5D" class="tm-tags-list__link">Strawman</a></li><li class="tm-separated-list__item"><a href="https://habr.com/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5BMap%5D" class="tm-tags-list__link">Map</a></li><li class="tm-separated-list__item"><a href="https://habr.com/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5BSet%5D" class="tm-tags-list__link">Set</a></li><li class="tm-separated-list__item"><a href="https://habr.com/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5BWeakMap%5D" class="tm-tags-list__link">WeakMap</a></li><li class="tm-separated-list__item"><a href="https://habr.com/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5BWeakSet%5D" class="tm-tags-list__link">WeakSet</a></li><li class="tm-separated-list__item"><a href="https://habr.com/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5BPromise%5D" class="tm-tags-list__link">Promise</a></li><li class="tm-separated-list__item"><a href="https://habr.com/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5BSymbol%5D" class="tm-tags-list__link">Symbol</a></li><li class="tm-separated-list__item"><a href="https://habr.com/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5Bconsole%5D" class="tm-tags-list__link">console</a></li><li class="tm-separated-list__item"><a href="https://habr.com/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5BsetImmediate%5D" class="tm-tags-list__link">setImmediate</a></li><li class="tm-separated-list__item"><a href="https://habr.com/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5BDict%5D" class="tm-tags-list__link">Dict</a></li><li class="tm-separated-list__item"><a href="https://habr.com/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5B%D0%B8%D1%82%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80%D1%8B%5D" class="tm-tags-list__link">итераторы</a></li><li class="tm-separated-list__item"><a href="https://habr.com/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5Biterators%5D" class="tm-tags-list__link">iterators</a></li><li class="tm-separated-list__item"><a href="https://habr.com/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5B%D1%81%D1%82%D0%B0%D0%BD%D0%B4%D0%B0%D1%80%D1%82%D0%BD%D0%B0%D1%8F%20%D0%B1%D0%B8%D0%B1%D0%BB%D0%B8%D0%BE%D1%82%D0%B5%D0%BA%D0%B0%5D" class="tm-tags-list__link">стандартная библиотека</a></li><li class="tm-separated-list__item"><a href="https://habr.com/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5Bstandard%20library%5D" class="tm-tags-list__link">standard library</a></li></ul></div> <div class="tm-separated-list tm-article-presenter__meta-list"><span class="tm-separated-list__title">Хабы:</span> <ul class="tm-separated-list__list"><li class="tm-separated-list__item"><a href="https://habr.com/ru/hub/webdev/" class="tm-hubs-list__link">
    Разработка веб-сайтов
  </a></li><li class="tm-separated-list__item"><a href="https://habr.com/ru/hub/javascript/" class="tm-hubs-list__link">
    JavaScript
  </a></li><li class="tm-separated-list__item"><a href="https://habr.com/ru/hub/nodejs/" class="tm-hubs-list__link">
    Node.JS
  </a></li></ul></div></div></article></div> <!----></div> <div class="tm-article-sticky-panel"><div class="tm-data-icons tm-article-sticky-panel__icons"><div class="tm-article-rating tm-data-icons__item"><div class="tm-votes-meter tm-article-rating__votes-switcher"><svg height="24" width="24" class="tm-svg-img tm-votes-meter__icon tm-votes-meter__icon_appearance-article"><title>Всего голосов 87: ↑82 и ↓5</title> <use xlink:href="/img/megazord-v25.4b679db1.svg#counter-rating"></use></svg> <span title="Всего голосов 87: ↑82 и ↓5" class="tm-votes-meter__value tm-votes-meter__value_positive tm-votes-meter__value_appearance-article tm-votes-meter__value_rating">+77</span></div> <DIV class="v-portal" style="display:none;"></DIV></div> <!----> <span title="Количество просмотров" class="tm-icon-counter tm-data-icons__item"><svg height="24" width="24" class="tm-svg-img tm-icon-counter__icon"><title>Просмотры</title> <use xlink:href="/img/megazord-v25.4b679db1.svg#counter-views"></use></svg> <span class="tm-icon-counter__value">93K</span></span> <button title="Добавить в закладки" type="button" class="bookmarks-button tm-data-icons__item"><span title="Добавить в закладки" class="tm-svg-icon__wrapper bookmarks-button__icon"><svg height="24" width="24" class="tm-svg-img tm-svg-icon"><title>Добавить в закладки</title> <use xlink:href="/img/megazord-v25.4b679db1.svg#counter-favorite"></use></svg></span> <span title="Количество пользователей, добавивших публикацию в закладки" class="bookmarks-button__counter">
    617
  </span></button> <!----> <div title="Поделиться" class="tm-sharing tm-data-icons__item"><button type="button" class="tm-sharing__button"><svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" class="tm-sharing__icon"><path fill="currentColor" d="M13.8 13.8V18l7.2-6.6L13.8 5v3.9C5 8.9 3 18.6 3 18.6c2.5-4.4 6-4.8 10.8-4.8z"></path></svg></button> <DIV class="v-portal" style="display:none;"></DIV></div> <DIV class="v-portal" style="display:none;"></DIV></div> </div></div> <DIV class="v-portal" style="display:none;"></DIV> <div class="tm-article-presenter__footer"><div class="tm-article-blocks"><!----> <section class="tm-block tm-block_spacing-bottom"><!----> <div class="tm-block__body tm-block__body_variant-balanced"><div class="tm-article-author"> <div class="tm-user-card tm-article-author__user-card tm-user-card_variant-article"><div class="tm-user-card__info-container"><div class="tm-user-card__header"><div class="tm-user-card__header-data"><a href="https://habr.com/ru/users/rock/" class="tm-user-card__userpic tm-user-card__userpic_size-40"><div class="tm-entity-image"><img alt="" src="https://habrastorage.org/getpro/habr/avatars/4a0/778/fd6/4a0778fd67c81e90eae402d2ea40d49c.gif" class="tm-entity-image__pic"></div></a> <div class="tm-user-card__meta"><div title=" 102 голоса " class="tm-karma tm-user-card__karma"><div class="tm-karma__votes tm-karma__votes_positive">
    62
  </div> <div class="tm-karma__text">
    Карма
  </div></div> <div title="Рейтинг пользователя" class="tm-rating tm-user-card__rating"><div class="tm-rating__header"> <div class="tm-rating__counter">0</div></div> <div class="tm-rating__text">
    Рейтинг
  </div></div></div></div></div> <div class="tm-user-card__info tm-user-card__info_variant-article"><div class="tm-user-card__title tm-user-card__title_variant-article"><span class="tm-user-card__name tm-user-card__name_variant-article">Денис Пушкарев</span> <a href="https://habr.com/ru/users/rock/" class="tm-user-card__nickname tm-user-card__nickname_variant-article">
          @rock
        </a> <!----></div> <p class="tm-user-card__short-info tm-user-card__short-info_variant-article">JS</p></div></div> <div class="tm-user-card__buttons tm-user-card__buttons_variant-article"><!----> <!----> <!----> <!----> <!----></div></div> <!----></div> <DIV class="v-portal" style="display:none;"></DIV></div> <!----></section> <div class="tm-article-blocks__comments"><div class="tm-article-page-comments"><div class="tm-article-comments-counter-link tm-article-comments-counter-button"><a href="https://habr.com/ru/post/216997/comments/" class="tm-article-comments-counter-link__link tm-article-comments-counter-link__link_button-style"><svg height="24" width="24" class="tm-svg-img tm-article-comments-counter-link__icon tm-article-comments-counter-link__icon_contrasted"><title>Комментарии</title> <use xlink:href="/img/megazord-v25.4b679db1.svg#counter-comments"></use></svg> <span class="tm-article-comments-counter-link__value tm-article-comments-counter-link__value_contrasted">
       Комментарии 40 
    </span></a> <!----></div></div></div> <div class="tm-ad-banner__container tm-page-article__banner"><!----> <div id="articleBottomBanner2308" class="tm-ad-banner"></div></div> <!----> <!----> <!----> <!----> </div></div></div></div></div> <div class="tm-page__sidebar"><div class="tm-layout-sidebar"><div class="tm-layout-sidebar__ads tm-layout-sidebar__ads_initial"><div class="tm-ad-banner__container tm-layout-sidebar__banner"><!----> <div id="sidebarBanner2309" class="tm-ad-banner"></div></div></div> <div class="tm-sexy-sidebar tm-sexy-sidebar_initial" style="margin-top:0px;"><!----> <section data-async-called="true" class="tm-block tm-block_spacing-bottom"><header class="tm-block__header"><h2 class="tm-block__title">Работа</h2> <!----></header> <div class="tm-block__body"><div class="tm-vacancies-block__item"><a href="https://career.habr.com/vacancies/programmist_javascript" target="_blank" class="tm-vacancies-block__vacancy-title">
        JavaScript разработчик
      </a> <div class="tm-vacancies-block__vacancies-count">
        554
    вакансии
      </div></div><div class="tm-vacancies-block__item"><a href="https://career.habr.com/vacancies/nodejs_razrabotchik" target="_blank" class="tm-vacancies-block__vacancy-title">
        Node.js разработчик
      </a> <div class="tm-vacancies-block__vacancies-count">
        185
    вакансий
      </div></div><div class="tm-vacancies-block__item"><a href="https://career.habr.com/vacancies/react_razrabotchik" target="_blank" class="tm-vacancies-block__vacancy-title">
        React разработчик
      </a> <div class="tm-vacancies-block__vacancies-count">
        276
    вакансий
      </div></div></div> <footer class="tm-block__footer"><a href="https://career.habr.com/catalog" class="tm-block-extralink">
      Все вакансии
    </a></footer></section></div></div></div></div></div></div></main> <!----></div> <div class="tm-footer-menu"><div class="tm-page-width"><div class="tm-footer-menu__container"><div class="tm-footer-menu__block"><h3 class="tm-footer-menu__block-title">
          Ваш аккаунт
        </h3> <div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><li class="tm-footer-menu__list-item"><a href="https://habr.com/kek/v1/auth/habrahabr/?back=/ru/post/216997/&amp;hl=ru" rel="nofollow" target="_self">
                Войти
              </a></li><li class="tm-footer-menu__list-item"><a href="https://habr.com/kek/v1/auth/habrahabr-register/?back=/ru/post/216997/&amp;hl=ru" rel="nofollow" target="_self">
                Регистрация
              </a></li></ul></div></div><div class="tm-footer-menu__block"><h3 class="tm-footer-menu__block-title">
          Разделы
        </h3> <div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><li class="tm-footer-menu__list-item"><a href="https://habr.com/ru/" class="footer-menu__item-link router-link-active">
                Публикации
              </a></li><li class="tm-footer-menu__list-item"><a href="https://habr.com/ru/news/" class="footer-menu__item-link">
                Новости
              </a></li><li class="tm-footer-menu__list-item"><a href="https://habr.com/ru/hubs/" class="footer-menu__item-link">
                Хабы
              </a></li><li class="tm-footer-menu__list-item"><a href="https://habr.com/ru/companies/" class="footer-menu__item-link">
                Компании
              </a></li><li class="tm-footer-menu__list-item"><a href="https://habr.com/ru/users/" class="footer-menu__item-link">
                Авторы
              </a></li><li class="tm-footer-menu__list-item"><a href="https://habr.com/ru/sandbox/" class="footer-menu__item-link">
                Песочница
              </a></li></ul></div></div><div class="tm-footer-menu__block"><h3 class="tm-footer-menu__block-title">
          Информация
        </h3> <div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><li class="tm-footer-menu__list-item"><a href="https://habr.com/ru/docs/help/" class="footer-menu__item-link">
                Устройство сайта
              </a></li><li class="tm-footer-menu__list-item"><a href="https://habr.com/ru/docs/authors/codex/" class="footer-menu__item-link">
                Для авторов
              </a></li><li class="tm-footer-menu__list-item"><a href="https://habr.com/ru/docs/companies/corpblogs/" class="footer-menu__item-link">
                Для компаний
              </a></li><li class="tm-footer-menu__list-item"><a href="https://habr.com/ru/docs/docs/transparency/" class="footer-menu__item-link">
                Документы
              </a></li><li class="tm-footer-menu__list-item"><a href="https://account.habr.com/info/agreement" target="_blank">
                Соглашение
              </a></li><li class="tm-footer-menu__list-item"><a href="https://account.habr.com/info/confidential/" target="_blank">
                Конфиденциальность
              </a></li></ul></div></div><div class="tm-footer-menu__block"><h3 class="tm-footer-menu__block-title">
          Услуги
        </h3> <div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><li class="tm-footer-menu__list-item"><a href="https://docs.google.com/presentation/d/e/2PACX-1vQLwRfQmXibiUlWaRg-BAc38s7oM3lJiaPju7qmdJsp8ysIvZ_G-Npem0njJLMozE2bPHMpDqiI5hhy/pub?start=false&amp;loop=false&amp;delayms=60000&amp;slide=id.g91a03369cd_4_297" target="_blank">
                Реклама
              </a></li><li class="tm-footer-menu__list-item"><a href="https://habrastorage.org/storage/stuff/habr/service_price.pdf" target="_blank">
                Тарифы
              </a></li><li class="tm-footer-menu__list-item"><a href="https://docs.google.com/presentation/d/e/2PACX-1vQJJds8-Di7BQSP_guHxICN7woVYoN5NP_22ra-BIo4bqnTT9FR6fB-Ku2P0AoRpX0Ds-LRkDeAoD8F/pub?start=false&amp;loop=false&amp;delayms=60000" target="_blank">
                Контент
              </a></li><li class="tm-footer-menu__list-item"><a href="https://tmtm.timepad.ru/" target="_blank">
                Семинары
              </a></li><li class="tm-footer-menu__list-item"><a href="https://habr.com/ru/megaprojects/" class="footer-menu__item-link">
                Мегапроекты
              </a></li></ul></div></div></div></div></div> <div class="tm-footer"><div class="tm-page-width"><div class="tm-footer__container"><!----> <div class="tm-footer__social"><a href="https://www.facebook.com/habrahabr.ru" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Facebook</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-facebook"></use></svg></a><a href="https://twitter.com/habr_com" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Twitter</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-twitter"></use></svg></a><a href="https://vk.com/habr" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>VK</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-vkontakte"></use></svg></a><a href="https://telegram.me/habr_com" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Telegram</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-telegram"></use></svg></a><a href="https://www.youtube.com/channel/UCd_sTwKqVrweTt4oAKY5y4w" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Youtube</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-youtube"></use></svg></a><a href="https://zen.yandex.ru/habr" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Яндекс Дзен</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-zen"></use></svg></a></div> <DIV class="v-portal" style="display:none;"></DIV> <button class="tm-footer__link"><!---->
        Настройка языка
      </button> <a href="https://habr.com/ru/about" class="tm-footer__link">
        О сайте
      </a> <a href="https://habr.com/ru/feedback/" class="tm-footer__link">
        Техническая поддержка
      </a> <!----> <a href="https://habr.com/berserk-mode-nope" class="tm-footer__link">
        Вернуться на старую версию
      </a> <div class="tm-footer-copyright"><span class="tm-copyright"><span class="tm-copyright__years">© 2006–2022 </span> <span class="tm-copyright__name">«<a href="https://company.habr.com/" rel="noopener" target="_blank" class="tm-copyright__link">Habr</a>»</span></span></div></div></div></div> <!----> <!----></div> <div class="vue-portal-target"></div></div>
<script>window.__INITIAL_STATE__={"adblock":{"hasAcceptableAdsFilter":false,"hasAdblock":false},"articlesList":{"articlesList":{"216997":{"id":"216997","timePublished":"2014-11-18T11:57:02+00:00","isCorporative":false,"lang":"ru","titleHtml":"Размышления о стандартной библиотеке JavaScript. Core.js","leadData":{"textHtml":"\u003Cblockquote\u003EОдин пацан писал все на JavaScript, и клиент, и сервер, говорил что нравится, удобно, читабельно. Потом его в дурку забрали, конечно.\u003Cbr\u002F\u003E\r\n\u003Ci\u003E\u003Cb\u003E— С просторов интернета\u003C\u002Fb\u003E\u003C\u002Fi\u003E\u003C\u002Fblockquote\u003E\u003Cbr\u002F\u003E\r\nК чему это я? Занятная штука — JavaScript. Основа современного web и на фронтэнде альтернатив как таковых не имеет.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nJavaScript это, в том числе, и \u003Ca href=\"http:\u002F\u002Fru.wikipedia.org\u002Fwiki\u002F%D1%F2%E0%ED%E4%E0%F0%F2%ED%E0%FF_%E1%E8%E1%EB%E8%EE%F2%E5%EA%E0\"\u003Eстандартная библиотека\u003C\u002Fa\u003E, о которой здесь и пойдёт речь. Под стандартной библиотекой я подразумеваю модули, конструкторы, методы, что должны присутствовать на любой платформе, будь то браузер или сервер, без лишних действий со стороны программиста, не включая API, специфичный для платформы. Даже если вы пишите не на JavaScript, а на языке в него компилируемом, скорее всего, вам придется иметь дело с его стандартной библиотекой.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nВанильная стандартная библиотека JavaScript, в целом, неплоха. Это не только стандартная библиотека по спецификации языка ECMA-262 актуальных версий — от 3 до черновика 6. Часть API вынесена в отдельные спецификации, например, API интернационализации ECMA-402. Многие возможности, без которых сложно представить JavaScript, например, \u003Ccode\u003EsetTimeout\u003C\u002Fcode\u003E, относятся к web-стандартам. Консоль не стандартизована вовсе — приходится полагаться на стандарт де-факто.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nВот только не такая уж она и стандартная — везде разная. Есть старые IE, в которых из коробки мы получаем стандартную библиотеку ES3 90-бородатого года даже без \u003Ccode\u003EArray#forEach, Function#bind, Object.create\u003C\u002Fcode\u003E и консоли, и есть, например, Node.js, на которой многие уже вовсю используют возможности грядущего ES6.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nХочется иметь универсальную, действительно стандартную библиотеку, как на сервере, так и в любом браузере, максимально соответствующую современным стандартам, а также реализующую необходимый функционал, что (пока?) не стандартизован. Статья посвящена библиотеке \u003Cb\u003E\u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fzloirock\u002Fcore-js\"\u003Ecore.js\u003C\u002Fa\u003E\u003C\u002Fb\u003E — реализация моих соображений по поводу стандартной библиотеки JavaScript. Кроме того, эта статья еще и шпаргалка по современной стандартизованной стандартной библиотеке JavaScript и заметки о её перспективах.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ch4\u003E\u003Cb\u003EСодержание, или что получим на выходе:\u003C\u002Fb\u003E\u003C\u002Fh4\u003E\u003Cbr\u002F\u003E\r\n\u003Cul\u003E\r\n\u003Cli\u003E\u003Ch5\u003E\u003Ca href=\"\u002Fpost\u002F216997\u002F#approach\"\u003EПодходы\u003C\u002Fa\u003E\u003C\u002Fh5\u003E\u003C\u002Fli\u003E\r\n\u003Cli\u003E \u003Ch5\u003E\u003Ca href=\"\u002Fpost\u002F216997\u002F#I\"\u003EЧасть первая: Костыли\u003C\u002Fa\u003E\u003C\u002Fh5\u003E\u003Cbr\u002F\u003E\r\n \u003Cul\u003E\r\n\u003Cli\u003E\u003Ca href=\"\u002Fpost\u002F216997\u002F#es5\"\u003EECMAScript 5\u003C\u002Fa\u003E\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ca href=\"\u002Fpost\u002F216997\u002F#es6\"\u003EECMAScript 6\u003C\u002Fa\u003E\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ca href=\"\u002Fpost\u002F216997\u002F#es6-symbol\"\u003EECMAScript 6: Символы\u003C\u002Fa\u003E\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ca href=\"\u002Fpost\u002F216997\u002F#es6-collections\"\u003EECMAScript 6: Коллекции\u003C\u002Fa\u003E\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ca href=\"\u002Fpost\u002F216997\u002F#es6-iterators\"\u003EECMAScript 6: Итераторы\u003C\u002Fa\u003E\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ca href=\"\u002Fpost\u002F216997\u002F#es6-promise\"\u003EECMAScript 6: Обещания\u003C\u002Fa\u003E\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ca href=\"\u002Fpost\u002F216997\u002F#array-generics\"\u003EMozilla JavaScript: Статические версии методов массива\u003C\u002Fa\u003E\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ca href=\"\u002Fpost\u002F216997\u002F#schedule\"\u003EОтложенное исполнение: setTimeout, setInterval, setImmediate\u003C\u002Fa\u003E\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ca href=\"\u002Fpost\u002F216997\u002F#console\"\u003EКонсоль\u003C\u002Fa\u003E\u003C\u002Fli\u003E\r\n\u003C\u002Ful\u003E\u003Cbr\u002F\u003E\r\n \u003C\u002Fli\u003E\r\n\u003Cli\u003E \u003Ch5\u003E\u003Ca href=\"\u002Fpost\u002F216997\u002F#II\"\u003EЧасть вторая: Велосипеды\u003C\u002Fa\u003E\u003C\u002Fh5\u003E\u003Cbr\u002F\u003E\r\n \u003Cul\u003E\r\n\u003Cli\u003E\u003Ca href=\"\u002Fpost\u002F216997\u002F#classify\"\u003EКлассификация данных\u003C\u002Fa\u003E\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ca href=\"\u002Fpost\u002F216997\u002F#dict\"\u003EСловари\u003C\u002Fa\u003E\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ca href=\"\u002Fpost\u002F216997\u002F#partial-application\"\u003EЧастичное применение\u003C\u002Fa\u003E\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ca href=\"\u002Fpost\u002F216997\u002F#date-format\"\u003EФорматирование даты\u003C\u002Fa\u003E\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ca href=\"\u002Fpost\u002F216997\u002F#object\"\u003EОбъектное API\u003C\u002Fa\u003E\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ca href=\"\u002Fpost\u002F216997\u002F#array\"\u003EМассивы\u003C\u002Fa\u003E\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ca href=\"\u002Fpost\u002F216997\u002F#num\"\u003EЧисла\u003C\u002Fa\u003E\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ca href=\"\u002Fpost\u002F216997\u002F#escape\"\u003EЭкранирование спецсимволов\u003C\u002Fa\u003E\u003C\u002Fli\u003E\r\n\u003C\u002Ful\u003E\u003Cbr\u002F\u003E\r\n \u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ch5\u003E\u003Ca href=\"\u002Fpost\u002F216997\u002F#end\"\u003EЗаключение\u003C\u002Fa\u003E\u003C\u002Fh5\u003E\u003C\u002Fli\u003E\r\n\u003C\u002Ful\u003E","imageUrl":null,"buttonTextHtml":"Читать дальше &rarr;","image":null},"editorVersion":"1.0","postType":"article","postLabels":[],"author":{"scoreStats":{"score":62,"votesCount":102},"rating":0,"relatedData":null,"contacts":[],"authorContacts":[],"paymentDetails":{"paymentYandexMoney":null,"paymentPayPalMe":null,"paymentWebmoney":null},"id":"75758","alias":"rock","fullname":"Денис Пушкарев","avatarUrl":"\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Favatars\u002F4a0\u002F778\u002Ffd6\u002F4a0778fd67c81e90eae402d2ea40d49c.gif","speciality":"JS"},"statistics":{"commentsCount":40,"favoritesCount":617,"readingCount":92536,"score":77,"votesCount":87},"hubs":[{"relatedData":null,"id":"91","alias":"webdev","type":"collective","title":"Разработка веб-сайтов","titleHtml":"Разработка веб-сайтов","isProfiled":true},{"relatedData":null,"id":"357","alias":"javascript","type":"collective","title":"JavaScript","titleHtml":"JavaScript","isProfiled":true},{"relatedData":null,"id":"17110","alias":"nodejs","type":"collective","title":"Node.JS","titleHtml":"Node.JS","isProfiled":true}],"flows":[{"id":"1","alias":"develop","title":"Разработка"}],"relatedData":null,"textHtml":"\u003Cdiv xmlns=\"http:\u002F\u002Fwww.w3.org\u002F1999\u002Fxhtml\"\u003E\u003Cblockquote\u003EОдин пацан писал все на JavaScript, и клиент, и сервер, говорил что нравится, удобно, читабельно. Потом его в дурку забрали, конечно.\u003Cbr\u002F\u003E\r\n\u003Ci\u003E\u003Cb\u003E— С просторов интернета\u003C\u002Fb\u003E\u003C\u002Fi\u003E\u003C\u002Fblockquote\u003E\u003Cbr\u002F\u003E\r\nК чему это я? Занятная штука — JavaScript. Основа современного web и на фронтэнде альтернатив как таковых не имеет.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nJavaScript это, в том числе, и \u003Ca href=\"http:\u002F\u002Fru.wikipedia.org\u002Fwiki\u002F%D1%F2%E0%ED%E4%E0%F0%F2%ED%E0%FF_%E1%E8%E1%EB%E8%EE%F2%E5%EA%E0\"\u003Eстандартная библиотека\u003C\u002Fa\u003E, о которой здесь и пойдёт речь. Под стандартной библиотекой я подразумеваю модули, конструкторы, методы, что должны присутствовать на любой платформе, будь то браузер или сервер, без лишних действий со стороны программиста, не включая API, специфичный для платформы. Даже если вы пишите не на JavaScript, а на языке в него компилируемом, скорее всего, вам придется иметь дело с его стандартной библиотекой.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nВанильная стандартная библиотека JavaScript, в целом, неплоха. Это не только стандартная библиотека по спецификации языка ECMA-262 актуальных версий — от 3 до черновика 6. Часть API вынесена в отдельные спецификации, например, API интернационализации ECMA-402. Многие возможности, без которых сложно представить JavaScript, например, \u003Ccode\u003EsetTimeout\u003C\u002Fcode\u003E, относятся к web-стандартам. Консоль не стандартизована вовсе — приходится полагаться на стандарт де-факто.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nВот только не такая уж она и стандартная — везде разная. Есть старые IE, в которых из коробки мы получаем стандартную библиотеку ES3 90-бородатого года даже без \u003Ccode\u003EArray#forEach, Function#bind, Object.create\u003C\u002Fcode\u003E и консоли, и есть, например, Node.js, на которой многие уже вовсю используют возможности грядущего ES6.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nХочется иметь универсальную, действительно стандартную библиотеку, как на сервере, так и в любом браузере, максимально соответствующую современным стандартам, а также реализующую необходимый функционал, что (пока?) не стандартизован. Статья посвящена библиотеке \u003Cb\u003E\u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fzloirock\u002Fcore-js\"\u003Ecore.js\u003C\u002Fa\u003E\u003C\u002Fb\u003E — реализация моих соображений по поводу стандартной библиотеки JavaScript. Кроме того, эта статья еще и шпаргалка по современной стандартизованной стандартной библиотеке JavaScript и заметки о её перспективах.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ch4\u003E\u003Cb\u003EСодержание, или что получим на выходе:\u003C\u002Fb\u003E\u003C\u002Fh4\u003E\u003Cbr\u002F\u003E\r\n\u003Cul\u003E\r\n\u003Cli\u003E\u003Ch5\u003E\u003Ca href=\"\u002Fpost\u002F216997\u002F#approach\"\u003EПодходы\u003C\u002Fa\u003E\u003C\u002Fh5\u003E\u003C\u002Fli\u003E\r\n\u003Cli\u003E \u003Ch5\u003E\u003Ca href=\"\u002Fpost\u002F216997\u002F#I\"\u003EЧасть первая: Костыли\u003C\u002Fa\u003E\u003C\u002Fh5\u003E\u003Cbr\u002F\u003E\r\n \u003Cul\u003E\r\n\u003Cli\u003E\u003Ca href=\"\u002Fpost\u002F216997\u002F#es5\"\u003EECMAScript 5\u003C\u002Fa\u003E\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ca href=\"\u002Fpost\u002F216997\u002F#es6\"\u003EECMAScript 6\u003C\u002Fa\u003E\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ca href=\"\u002Fpost\u002F216997\u002F#es6-symbol\"\u003EECMAScript 6: Символы\u003C\u002Fa\u003E\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ca href=\"\u002Fpost\u002F216997\u002F#es6-collections\"\u003EECMAScript 6: Коллекции\u003C\u002Fa\u003E\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ca href=\"\u002Fpost\u002F216997\u002F#es6-iterators\"\u003EECMAScript 6: Итераторы\u003C\u002Fa\u003E\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ca href=\"\u002Fpost\u002F216997\u002F#es6-promise\"\u003EECMAScript 6: Обещания\u003C\u002Fa\u003E\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ca href=\"\u002Fpost\u002F216997\u002F#array-generics\"\u003EMozilla JavaScript: Статические версии методов массива\u003C\u002Fa\u003E\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ca href=\"\u002Fpost\u002F216997\u002F#schedule\"\u003EОтложенное исполнение: setTimeout, setInterval, setImmediate\u003C\u002Fa\u003E\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ca href=\"\u002Fpost\u002F216997\u002F#console\"\u003EКонсоль\u003C\u002Fa\u003E\u003C\u002Fli\u003E\r\n\u003C\u002Ful\u003E\u003Cbr\u002F\u003E\r\n \u003C\u002Fli\u003E\r\n\u003Cli\u003E \u003Ch5\u003E\u003Ca href=\"\u002Fpost\u002F216997\u002F#II\"\u003EЧасть вторая: Велосипеды\u003C\u002Fa\u003E\u003C\u002Fh5\u003E\u003Cbr\u002F\u003E\r\n \u003Cul\u003E\r\n\u003Cli\u003E\u003Ca href=\"\u002Fpost\u002F216997\u002F#classify\"\u003EКлассификация данных\u003C\u002Fa\u003E\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ca href=\"\u002Fpost\u002F216997\u002F#dict\"\u003EСловари\u003C\u002Fa\u003E\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ca href=\"\u002Fpost\u002F216997\u002F#partial-application\"\u003EЧастичное применение\u003C\u002Fa\u003E\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ca href=\"\u002Fpost\u002F216997\u002F#date-format\"\u003EФорматирование даты\u003C\u002Fa\u003E\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ca href=\"\u002Fpost\u002F216997\u002F#object\"\u003EОбъектное API\u003C\u002Fa\u003E\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ca href=\"\u002Fpost\u002F216997\u002F#array\"\u003EМассивы\u003C\u002Fa\u003E\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ca href=\"\u002Fpost\u002F216997\u002F#num\"\u003EЧисла\u003C\u002Fa\u003E\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ca href=\"\u002Fpost\u002F216997\u002F#escape\"\u003EЭкранирование спецсимволов\u003C\u002Fa\u003E\u003C\u002Fli\u003E\r\n\u003C\u002Ful\u003E\u003Cbr\u002F\u003E\r\n \u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ch5\u003E\u003Ca href=\"\u002Fpost\u002F216997\u002F#end\"\u003EЗаключение\u003C\u002Fa\u003E\u003C\u002Fh5\u003E\u003C\u002Fli\u003E\r\n\u003C\u002Ful\u003E\u003Ca name=\"habracut\"\u003E\u003C\u002Fa\u003E\u003Cbr\u002F\u003E\r\nПредупреждаю, многабукф и первые главы довольно банальны, нет желания читать всё — оглавление выше, листайте до интересующего вас раздела.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ca name=\"approach\"\u003E\u003C\u002Fa\u003E\u003Ch2\u003E\u003Cb\u003E\u003Ca href=\"#approach\"\u003E#\u003C\u002Fa\u003E Подходы\u003C\u002Fb\u003E\u003C\u002Fh2\u003E\u003Chr\u002F\u003E\u003Cbr\u002F\u003E\r\nОсновных подхода к созданию библиотек, что можно назвать стандартными, в JavaScript три:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nПервый — \u003Cb\u003Eиспользование только \u003Ca href=\"http:\u002F\u002Fen.wikipedia.org\u002Fwiki\u002FPolyfill\"\u003Eполифилов\u003C\u002Fa\u003E, только стандартизованного функционала\u003C\u002Fb\u003E. Железобетонная уверенность в том, что со временем API не сломается. Для работы с такой библиотекой её знание не нужно, нужно только знание соответствующего API языка. Обычно, полифилы ограничены одним стандартом или его частью. Например, \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fes-shims\u002Fes5-shim\"\u003E\u003Cb\u003Ees5-shim\u003C\u002Fb\u003E\u003C\u002Fa\u003E или \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fpaulmillr\u002Fes6-shim\"\u003E\u003Cb\u003Ees6-shim\u003C\u002Fb\u003E\u003C\u002Fa\u003E. По этой причине, для обеспечения возможностей, что хотелось бы иметь по умолчанию, приходится подключать несколько полифилов. Их внутренние компоненты часто дублируют друг друга, так что такой набор часто разрастается до сотен килобайт. Да и не все возможности, что хотелось бы иметь, стандартизованы. Возможность конфликтов с другими библиотеками незначительна, но в качестве зависимости при написании библиотеки их использовать я бы не стал.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nВторой — \u003Cb\u003Eнабор утилит в собственном пространстве имён\u003C\u002Fb\u003E. Либо экспорт в модульной системе, либо создание одного глобального объекта. Например, \u003Ca href=\"http:\u002F\u002Funderscorejs.org\u002F\"\u003E\u003Cb\u003EUndescore\u003C\u002Fb\u003E\u003C\u002Fa\u003E или её форк \u003Ca href=\"https:\u002F\u002Flodash.com\u002F\"\u003E\u003Cb\u003ELoDash\u003C\u002Fb\u003E\u003C\u002Fa\u003E. Обычно, довольно компактен, но возможности ограничиваются набором простых утилит. Так как не расширяет нативные объекты и часто присутствует метод \u003Ccode\u003EnoConflict\u003C\u002Fcode\u003E, откатывающий изменения, возможность конфликтов с другими библиотеками минимальна, лучше других упомянутых здесь способов подходит как безопасная зависимость для других библиотек.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nТретий — \u003Cb\u003Eрасширение нативних объектов не только стандартизованным функционалом\u003C\u002Fb\u003E. Например, добавление собственных методов в прототип массива, что обычно удобнее передачи массива в функцию. Сейчас в этой категории рулит \u003Ca href=\"http:\u002F\u002Fsugarjs.com\u002F\"\u003E\u003Cb\u003ESugar\u003C\u002Fb\u003E\u003C\u002Fa\u003E, в своё время — \u003Ca href=\"http:\u002F\u002Fmootools.net\u002F\"\u003E\u003Cb\u003EMooTools\u003C\u002Fb\u003E\u003C\u002Fa\u003E и \u003Ca href=\"http:\u002F\u002Fprototypejs.org\u002F\"\u003E\u003Cb\u003EPrototype\u003C\u002Fb\u003E\u003C\u002Fa\u003E. Добавляют много полезного функционала, но часто методы почти полностью дублируют друг друга. Здесь бы развернуться полифилам — но из полифилов подобные библиотеки обычно ограничиваются методами прототипа массива, \u003Ccode\u003EFunction#bind\u003C\u002Fcode\u003E и еще несколькими, игнорируя большую часть стандартов. Что же касается конфликтов, то здесь всё совсем плохо. Подобные библиотеки часто расширяют нативные объекты методами с одним именем, но разной сигнатурой. Во избежание конфликтов, при разработке конечного приложения не стоит применять больше одной библиотеки, расширяющей нативные объекты, не считая полифилов, а при написании библиотеки такие зависимости вообще недопустимы.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nВместо одной универсальной стандартной библиотеки, для обеспечения возможностей, которые бы хотелось иметь без лишних заморочек, мы вынуждены тянуть солянку из \u003Ci\u003EUndescore \u002F LoDash \u002F Sugar + es5-shim, es6-shim, es6-symbol, setImmediate.js \u002F asap, Moment.js \u002F Intl.js, заглушку консоли\u003C\u002Fi\u003E… и так далее.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ca name=\"concept\"\u003E\u003C\u002Fa\u003E\u003Cb\u003E\u003Ca href=\"#concept\"\u003E#\u003C\u002Fa\u003E\u003C\u002Fb\u003E Попытаемся взять лучшее у каждого из данных подходов. \u003Cb\u003EКонцепция core.js такова\u003C\u002Fb\u003E:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cul\u003E\r\n\u003Cli\u003EВ стандартной библиотеке должен быть весь необходимый для комфортной работы минимум возможностей, не включающий в себя возможности для работы с API конкретной платформы.\u003C\u002Fli\u003E\r\n\u003Cli\u003EСтандарты — наше всё. Основная часть библиотеки — полифилы. Вот только не весь необходимый функционал стандартизован.\u003C\u002Fli\u003E\r\n\u003Cli\u003EЕсли функционал, имеющийся в системе, реализован по спецификации или стандарту де-факто, оставляем нативный, но если функционал не стандартизован — во избежание конфликтов в будущем, замещаем принудительно.\u003C\u002Fli\u003E\r\n\u003Cli\u003EБиблиотека должна быть компактной и хорошо сжиматься.\u003C\u002Fli\u003E\r\n\u003Cli\u003EМодульность, возможность собрать только необходимый функционал.\u003C\u002Fli\u003E\r\n\u003Cli\u003EПишите конечное приложение — вы здесь царь и бог и имеете полное право использовать библиотеку, расширяющую нативные объекты. Главное, что бы это делала только одна библиотека.\u003C\u002Fli\u003E\r\n\u003Cli\u003EПишите библиотеку или npm модуль — использовать библиотеку, расширяющую нативные объекты, нельзя ни в коем случае. Рискуете обречь на конфликты программиста, пишущего конечное приложение. На этот случай есть возможность сборки без их расширения.\u003C\u002Fli\u003E\r\n\u003C\u002Ful\u003E\u003Cbr\u002F\u003E\r\n\u003Ca name=\"example\"\u003E\u003C\u002Fa\u003E\u003Cb\u003E\u003Ca href=\"#example\"\u003E#\u003C\u002Fa\u003E\u003C\u002Fb\u003E В случае обычной сборки, работа с \u003Cb\u003Ecore.js\u003C\u002Fb\u003E вполне очевидна:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003Econsole.log(Array.from(new Set([1, 2, 3, 2, 1]))); \u002F\u002F =\u003E [1, 2, 3]\nconsole.log('*'.repeat(10));                       \u002F\u002F =\u003E '**********'\nPromise.resolve(32).then(console.log);             \u002F\u002F =\u003E 32\nsetImmediate(console.log, 42);                     \u002F\u002F =\u003E 42\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Ca name=\"example-library\"\u003E\u003C\u002Fa\u003E\u003Cb\u003E\u003Ca href=\"#example-library\"\u003E#\u003C\u002Fa\u003E\u003C\u002Fb\u003E В случае сборки без расширения нативных объектов, функционал экспортируется либо в глобальный объект \u003Ccode\u003Ecore\u003C\u002Fcode\u003E, либо в модульную систему. Например, конструктор \u003Ccode\u003EPromise\u003C\u002Fcode\u003E доступен как \u003Ccode\u003Ecore.Promise\u003C\u002Fcode\u003E, а метод \u003Ccode\u003EArray.from\u003C\u002Fcode\u003E как \u003Ccode\u003Ecore.Array.from\u003C\u002Fcode\u003E. Методы, предназначенные к добавлению в прототип уже существующих, а не добавляемых библиотекой, конструкторов становятся статическими, например, \u003Ccode\u003Ecore.String.repeat\u003C\u002Fcode\u003E это статическая версия метода \u003Ccode\u003EString.prototype.repeat\u003C\u002Fcode\u003E.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003Evar log  = core.console.log;\nlog(core.Array.from(new core.Set([1, 2, 3, 2, 1]))); \u002F\u002F =\u003E [1, 2, 3]\nlog(core.String.repeat('*', 10));                    \u002F\u002F =\u003E '**********'\ncore.Promise.resolve(32).then(log);                  \u002F\u002F =\u003E 32\ncore.setImmediate(log, 42);                          \u002F\u002F =\u003E 42\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nСборка, содержащая только полифилы, соответственно, только их и добавляет. Собственно, в примере с обычной сборки только полифилы и используются.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ca name=\"node\"\u003E\u003C\u002Fa\u003E\u003Cb\u003E\u003Ca href=\"#node\"\u003E#\u003C\u002Fa\u003E\u003C\u002Fb\u003E Установка на Node.js:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003Enpm i core-js\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nПодключить можно на выбор одну из сборок:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003E\u002F\u002F Максимальная сборка:\nrequire('core-js');\n\u002F\u002F Сборка без расширения нативных объектов:\nvar core = require('core-js\u002Flibrary');\n\u002F\u002F Сборка, содержащая только полифилы:\nrequire('core-js\u002Fshim');\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Ca name=\"browser-builds\"\u003E\u003C\u002Fa\u003E\u003Cb\u003E\u003Ca href=\"#browser-builds\"\u003E#\u003C\u002Fa\u003E\u003C\u002Fb\u003E \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fzloirock\u002Fcore-js\u002Ftree\u002Fmaster\u002Fclient\"\u003EСборки для браузера\u003C\u002Fa\u003E:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cul\u003E\r\n\u003Cli\u003EМаксимальная: \u003Ca href=\"https:\u002F\u002Fraw.githubusercontent.com\u002Fzloirock\u002Fcore-js\u002Fmaster\u002Fclient\u002Fcore.js\"\u003Edevelopment\u003C\u002Fa\u003E, \u003Ca href=\"https:\u002F\u002Fraw.githubusercontent.com\u002Fzloirock\u002Fcore-js\u002Fmaster\u002Fclient\u002Fcore.min.js\"\u003Eproduction\u003C\u002Fa\u003E (21.8 кб без учёта gzip)\u003C\u002Fli\u003E\r\n\u003Cli\u003EБез расширения нативных объектов: \u003Ca href=\"https:\u002F\u002Fraw.githubusercontent.com\u002Fzloirock\u002Fcore-js\u002Fmaster\u002Fclient\u002Flibrary.js\"\u003Edevelopment\u003C\u002Fa\u003E, \u003Ca href=\"https:\u002F\u002Fraw.githubusercontent.com\u002Fzloirock\u002Fcore-js\u002Fmaster\u002Fclient\u002Flibrary.min.js\"\u003Eproduction\u003C\u002Fa\u003E (21.8 кб без учёта gzip)\u003C\u002Fli\u003E\r\n\u003Cli\u003EТолько полифилы: \u003Ca href=\"https:\u002F\u002Fraw.githubusercontent.com\u002Fzloirock\u002Fcore-js\u002Fmaster\u002Fclient\u002Fshim.js\"\u003Edevelopment\u003C\u002Fa\u003E, \u003Ca href=\"https:\u002F\u002Fraw.githubusercontent.com\u002Fzloirock\u002Fcore-js\u002Fmaster\u002Fclient\u002Fshim.min.js\"\u003Eproduction\u003C\u002Fa\u003E (16.7 кб без учёта gzip)\u003C\u002Fli\u003E\r\n\u003C\u002Ful\u003E\u003Cbr\u002F\u003E\r\n\u003Ca name=\"custom-builds\"\u003E\u003C\u002Fa\u003E\u003Cb\u003E\u003Ca href=\"#custom-builds\"\u003E#\u003C\u002Fa\u003E\u003C\u002Fb\u003E Если же вас не устраивает ни одна из этих сборок, можно сделать свою собственную. Например, вам нужны только модуль консоли и простое форматирование даты, притом без расширения нативных объектов. Для этого ставим Node.js, после чего устанавливаем grunt-cli, core-js с необходимыми для сборки зависимостями и собираем:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003Enpm i -g grunt-cli\nnpm i core-js\ncd node_modules\u002Fcore-js &amp;&amp; npm i\ngrunt build:date,console,library --path=custom uglify\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nВ итоге, получим файлы \u003Ccode\u003Ecustom.js\u003C\u002Fcode\u003E, \u003Ccode\u003Ecustom.min.js\u003C\u002Fcode\u003E весом 4.8кб и \u003Ccode\u003Ecustom.min.map\u003C\u002Fcode\u003E. Флаг \u003Ccode\u003Elibrary\u003C\u002Fcode\u003E указывает на сборку без расширения нативных объектов. Посмотреть, к какому модулю относится необходимый функционал, можно \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fzloirock\u002Fcore-js#api\"\u003Eздесь\u003C\u002Fa\u003E (последний столбец).\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ca name=\"I\"\u003E\u003C\u002Fa\u003E\u003Ch1\u003E\u003Cb\u003E\u003Ca href=\"#I\"\u003E#\u003C\u002Fa\u003E Часть первая: Костыли\u003C\u002Fb\u003E\u003C\u002Fh1\u003E\u003Chr\u002F\u003EЕсли кто не понял, под костылями, в контексте статьи, подразумеваются полифилы стандартизованного функционала, имеющиеся в библиотеке. Итак, поехали:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ca name=\"es5\"\u003E\u003C\u002Fa\u003E\u003Ch2\u003E\u003Cb\u003E\u003Ca href=\"#es5\"\u003E#\u003C\u002Fa\u003E ECMAScript 5\u003C\u002Fb\u003E\u003C\u002Fh2\u003E\u003Chr\u002F\u003E\u003Cbr\u002F\u003E\r\nПожалуй, все знают, что добавляет ECMAScript 5 в стандартную библиотеку. Вымерли почти все браузеры, не поддерживающие ES5. За исключением старых IE. До сих пор, заказчики часто просят поддержку IE8, а в самых упоротых случаях даже IE6. Надеюсь, в ближайшее время ситуация изменится. Самым популярным полифилом ES5 является \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fes-shims\u002Fes5-shim\"\u003Eэтот es5-shim\u003C\u002Fa\u003E, часть возможностей присутствует в Sugar, MooTools, Prototype, но только часть. Так как это далеко не новинка, обойдемся без лишних подробностей — краткое описание и, если нужно, некоторые особенности реализации. Само собой, важно помнить, что если код пишется с поддержкой IE8-, ни о какой работе с дескрипторами не может быть и речи.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ca name=\"es5-array\"\u003E\u003C\u002Fa\u003E\u003Ch4\u003E\u003Cb\u003E\u003Ca href=\"#es5-array\"\u003E#\u003C\u002Fa\u003E Методы массива\u003C\u002Fb\u003E\u003C\u002Fh4\u003E\u003Cbr\u002F\u003E\r\n\u003Ca name=\"es5-array-proto\"\u003E\u003C\u002Fa\u003E\u003Cb\u003E\u003Ca href=\"#es5-array-proto\"\u003E#\u003C\u002Fa\u003E\u003C\u002Fb\u003E Начнем с методов прототипа массива. Это всем известные:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ca href=\"https:\u002F\u002Fdeveloper.mozilla.org\u002Fen-US\u002Fdocs\u002FWeb\u002FJavaScript\u002FReference\u002FGlobal_Objects\u002FArray\u002FindexOf\"\u003EArray#indexOf\u003C\u002Fa\u003E возвращает индекс первого элемента, равного указанному значению, или \u003Ccode\u003E-1\u003C\u002Fcode\u003E, если значение не найдено.\u003Cbr\u002F\u003E\r\n\u003Ca href=\"https:\u002F\u002Fdeveloper.mozilla.org\u002Fen-US\u002Fdocs\u002FWeb\u002FJavaScript\u002FReference\u002FGlobal_Objects\u002FArray\u002FlastIndexOf\"\u003EArray#lastIndexOf\u003C\u002Fa\u003E аналогичен предыдущему, но возвращает индекс последнего элемента.\u003Cbr\u002F\u003E\r\n\u003Ca href=\"https:\u002F\u002Fdeveloper.mozilla.org\u002Fen-US\u002Fdocs\u002FWeb\u002FJavaScript\u002FReference\u002FGlobal_Objects\u002FArray\u002FforEach\"\u003EArray#forEach\u003C\u002Fa\u003E вызывает функцию для каждого элемента массива.\u003Cbr\u002F\u003E\r\n\u003Ca href=\"https:\u002F\u002Fdeveloper.mozilla.org\u002Fen-US\u002Fdocs\u002FWeb\u002FJavaScript\u002FReference\u002FGlobal_Objects\u002FArray\u002Fmap\"\u003EArray#map\u003C\u002Fa\u003E возвращает новый массив с результатом вызова функции для каждого элемента данного массива.\u003Cbr\u002F\u003E\r\n\u003Ca href=\"https:\u002F\u002Fdeveloper.mozilla.org\u002Fen-US\u002Fdocs\u002FWeb\u002FJavaScript\u002FReference\u002FGlobal_Objects\u002FArray\u002Ffilter\"\u003EArray#filter\u003C\u002Fa\u003E возвращает новый массив со всеми элементами этого массива, удовлетворяющими условию проверяющей функции.\u003Cbr\u002F\u003E\r\n\u003Ca href=\"https:\u002F\u002Fdeveloper.mozilla.org\u002Fen-US\u002Fdocs\u002FWeb\u002FJavaScript\u002FReference\u002FGlobal_Objects\u002FArray\u002Fevery\"\u003EArray#every\u003C\u002Fa\u003E проверяет, каждый ли элемент в массиве удовлетворяет условию проверяющей функции.\u003Cbr\u002F\u003E\r\n\u003Ca href=\"https:\u002F\u002Fdeveloper.mozilla.org\u002Fen-US\u002Fdocs\u002FWeb\u002FJavaScript\u002FReference\u002FGlobal_Objects\u002FArray\u002Fsome\"\u003EArray#some\u003C\u002Fa\u003E проверяет, есть ли хотя бы один элемент массива, удовлетворяющий условию проверяющей функции.\u003Cbr\u002F\u003E\r\n\u003Ca href=\"https:\u002F\u002Fdeveloper.mozilla.org\u002Fen-US\u002Fdocs\u002FWeb\u002FJavaScript\u002FReference\u002FGlobal_Objects\u002FArray\u002FReduce\"\u003EArray#reduce\u003C\u002Fa\u003E выполняет свертку массива с применением функции, слева — направо.\u003Cbr\u002F\u003E\r\n\u003Ca href=\"https:\u002F\u002Fdeveloper.mozilla.org\u002Fen-US\u002Fdocs\u002FWeb\u002FJavaScript\u002FReference\u002FGlobal_Objects\u002FArray\u002FReduceRight\"\u003EArray#reduceRight\u003C\u002Fa\u003E выполняет свертку массива с применением функции, справа — налево.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003E[1, 2, 3, 2, 1].indexOf(2);     \u002F\u002F =\u003E 1\n[1, 2, 3, 2, 1].lastIndexOf(2); \u002F\u002F =\u003E 3\n[1, 2, 3].forEach(function(val, key){\n  console.log(val);             \u002F\u002F =\u003E 1, 2, 3\n  console.log(key);             \u002F\u002F =\u003E 0, 1, 2\n});\n[1, 2, 3].map(function(it){\n  return it * it;\n});                             \u002F\u002F =\u003E [1, 4, 9]\n[1, 2, 3].filter(function(it){\n  return it % 2;\n});                             \u002F\u002F =\u003E [1, 3]\nfunction isNum(it){\n  return typeof it == 'number';\n}\n[1, '2', 3].every(isNum);       \u002F\u002F =\u003E false\n[1, '2', 3].some(isNum);        \u002F\u002F =\u003E true\nfunction add(a, b){\n  return a + b;\n}\n[1, 2, 3].reduce(add);          \u002F\u002F =\u003E 6\n[1, 2, 3].reduceRight(add, ''); \u002F\u002F =\u003E '321'\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nДанные методы реализуются элементарно, но есть одна особенность. Методы массива — \u003Ca href=\"https:\u002F\u002Fru.wikipedia.org\u002Fwiki\u002F%CE%E1%EE%E1%F9%B8%ED%ED%EE%E5_%EF%F0%EE%E3%F0%E0%EC%EC%E8%F0%EE%E2%E0%ED%E8%E5\"\u003Eдженерики\u003C\u002Fa\u003E и могут быть вызваны в контексте не только массива, но и любого array-like объекта, подробнее об этом \u003Ca href=\"#array-generics\"\u003E# будет ниже\u003C\u002Fa\u003E. Так вот, по спецификации ES5 строки являются array-like объектами, букву строки можно получить по индексу, например, \u003Ccode\u003E'string'[2] \u002F\u002F =\u003E 'r'\u003C\u002Fcode\u003E, а в старых IE таковыми они не является. В случае применения данных методов в контексте строк, приводим строки к массиву. Для решения этой же проблемы, при необходимости подменяем в старых IE \u003Ccode\u003EArray#slice\u003C\u002Fcode\u003E и \u003Ccode\u003EArray#join\u003C\u002Fcode\u003E.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003EArray.prototype.map.call('123', function(it){\n  return it * it;\n});                                    \u002F\u002F =\u003E [1, 4, 9]\nArray.prototype.slice.call('qwe', 1);  \u002F\u002F =\u003E ['w', 'e']\nArray.prototype.join.call('qwe', '|'); \u002F\u002F =\u003E 'q|w|e'\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nНу и не забывайте древнюю истину: \u003Cb\u003Eникогда не обходите массив циклом \u003Ccode\u003Efor-in\u003C\u002Fcode\u003E\u003C\u002Fb\u003E. Это не только медленно, но и вынуждает, если нужна поддержка IE8-, проверять, является ли ключ собственным — иначе выполните обход не только элементов массива, но и методов его прототипа :)\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ca name=\"es5-is-array\"\u003E\u003C\u002Fa\u003E\u003Cb\u003E\u003Ca href=\"#es5-is-array\"\u003E#\u003C\u002Fa\u003E\u003C\u002Fb\u003E К этой же категории относится статический метод \u003Ca href=\"https:\u002F\u002Fdeveloper.mozilla.org\u002Fen-US\u002Fdocs\u002FWeb\u002FJavaScript\u002FReference\u002FGlobal_Objects\u002FArray\u002FisArray\"\u003EArray.isArray\u003C\u002Fa\u003E. Метод проверяет, является ли объект массивом не по цепочке прототипов, а по внутреннему классу. Полезно, но не универсально. О классификации объектов подробно мы поговорим \u003Ca href=\"#classof\"\u003E# во второй, велосипедной, части статьи\u003C\u002Fa\u003E.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003EArray.isArray([1, 2, 3]);                      \u002F\u002F =\u003E true\nArray.isArray(Object.create(Array.prototype)); \u002F\u002F =\u003E false\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Ca name=\"es5-object\"\u003E\u003C\u002Fa\u003E\u003Ch4\u003E\u003Cb\u003E\u003Ca href=\"#es5-object\"\u003E#\u003C\u002Fa\u003E Объектное API\u003C\u002Fb\u003E\u003C\u002Fh4\u003E\u003Cbr\u002F\u003E\r\nПолная эмуляция всех методов объектного API ECMAScript 5 на базе ECMAScript 3 невозможна, частичная — возможна для многих. ES5 добавляет в объектное API следующие категории методов: работа с прототипом (создание из \u002F получение), получение ключей объекта, работа с дескрипторами.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ca name=\"es5-create\"\u003E\u003C\u002Fa\u003E\u003Ca href=\"#es5-create\"\u003E\u003Cb\u003E#\u003C\u002Fb\u003E\u003C\u002Fa\u003E Метод \u003Ca href=\"https:\u002F\u002Fdeveloper.mozilla.org\u002Fen-US\u002Fdocs\u002FWeb\u002FJavaScript\u002FReference\u002FGlobal_Objects\u002FObject\u002Fcreate\"\u003EObject.create\u003C\u002Fa\u003E создает объект из прототипа. Передав \u003Ccode\u003Enull\u003C\u002Fcode\u003E, можно создать объект без прототипа, что сделать на базе ECMAScript 3 невозможно. Приходится использовать лютый трэш на базе \u003Ccode\u003Eiframe\u003C\u002Fcode\u003E. Зачем это нам будет раскрыто \u003Ca href=\"#dict\"\u003E# во второй части\u003C\u002Fa\u003E. Опционально принимает объект \u003Ca href=\"#es5-desc\"\u003E# дескрипторов\u003C\u002Fa\u003E, аналогично \u003Ccode\u003EObject.defineProperties\u003C\u002Fcode\u003E.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003Efunction Parent(\u002F*...*\u002F){ \u002F*...*\u002F }\nParent.prototype = {constructor: Parent \u002F*, ... *\u002F}\nfunction Child(\u002F*...*\u002F){\n  Parent.call(this \u002F*, ...*\u002F);\n  \u002F\u002F ...\n}\n\u002F\u002F Было в ES3 (нутрянка всяких inherit и extend'ов):\nfunction Tmp(){}\nTmp.prototype = Parent.prototype;\nChild.prototype = new Tmp;\nChild.prototype.constructor = Child;\n\u002F\u002F Стало с ES5:\nChild.prototype = Object.create(Parent.prototype, {constructor: {value: Child}});\n\nvar dict = Object.create(null);\ndict.key = 42;\nconsole.log(dict instanceof Object); \u002F\u002F =\u003E false\nconsole.log(dict.toString)           \u002F\u002F =\u003E undefined\nconsole.log(dict.key)                \u002F\u002F =\u003E 42\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Ca name=\"es5-getPrototypeOf\"\u003E\u003C\u002Fa\u003E\u003Ca href=\"#es5-getPrototypeOf\"\u003E\u003Cb\u003E#\u003C\u002Fb\u003E\u003C\u002Fa\u003E Метод \u003Ca href=\"https:\u002F\u002Fdeveloper.mozilla.org\u002Fen-US\u002Fdocs\u002FWeb\u002FJavaScript\u002FReference\u002FGlobal_Objects\u002FObject\u002FgetPrototypeOf\"\u003EObject.getPrototypeOf\u003C\u002Fa\u003E возвращает прототип объекта. В ECMAScript 3 нет гарантированного способа получения прототипа объекта. Если объект содержит свойство \u003Ccode\u003Econstructor\u003C\u002Fcode\u003E, возможно прототипом будет \u003Ccode\u003Econstructor.prototype\u003C\u002Fcode\u003E. Для объектов, созданных через \u003Ccode\u003EObject.create\u003C\u002Fcode\u003E, добавим \u003Ca href=\"#es6-symbol\"\u003E# символ\u003C\u002Fa\u003E, содержащий прототип, и будем игнорировать его при \u003Ca href=\"#es5-keys\"\u003E# получении ключей\u003C\u002Fa\u003E. Но на инстансе конструктора, прототип которого был переопределен без указания «правильного» свойства \u003Ccode\u003Econstructor\u003C\u002Fcode\u003E, \u003Ccode\u003EObject.getPrototypeOf\u003C\u002Fcode\u003E будет работать некорректно.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003Evar parent = {foo: 'bar'}\n  , child  = Object.create(parent);\nconsole.log(Object.getPrototypeOf(child) === parent);      \u002F\u002F =\u003E true\n\nfunction F(){}\nconsole.log(Object.getPrototypeOf(new F) === F.prototype); \u002F\u002F =\u003E true\n\nF.prototype = {constructor: F \u002F*, ...*\u002F};\nconsole.log(Object.getPrototypeOf(new F) === F.prototype); \u002F\u002F =\u003E true\n\nF.prototype = {};\nconsole.log(Object.getPrototypeOf(new F) === F.prototype); \u002F\u002F В IE8- будет работать некорректно\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Ca name=\"es5-keys\"\u003E\u003C\u002Fa\u003E\u003Ca href=\"#es5-keys\"\u003E\u003Cb\u003E#\u003C\u002Fb\u003E\u003C\u002Fa\u003E Метод \u003Ca href=\"https:\u002F\u002Fdeveloper.mozilla.org\u002Fen-US\u002Fdocs\u002FWeb\u002FJavaScript\u002FReference\u002FGlobal_Objects\u002FObject\u002Fkeys\"\u003EObject.keys\u003C\u002Fa\u003E возвращает массив собственных перечисляемых ключей объекта. \u003Ca href=\"https:\u002F\u002Fdeveloper.mozilla.org\u002Fen-US\u002Fdocs\u002FWeb\u002FJavaScript\u002FReference\u002FGlobal_Objects\u002FObject\u002FgetOwnPropertyNames\"\u003EObject.getOwnPropertyNames\u003C\u002Fa\u003E возвращает массив собственных ключей объекта, в т.ч. и неперечисляемых. С \u003Ccode\u003EObject.keys\u003C\u002Fcode\u003E, вроде, всё просто — перебираем объект через \u003Ccode\u003Efor-in\u003C\u002Fcode\u003E и проверяем, являются ли свойства собственными. Если бы не \u003Ca href=\"https:\u002F\u002Fdeveloper.mozilla.org\u002Fen-US\u002Fdocs\u002FECMAScript_DontEnum_attribute#JScript_DontEnum_Bug\"\u003Eбаг с «неперечисляемыми перечисляемыми» свойствами\u003C\u002Fa\u003E в IE. Так что приходится проверять наличие таковых свойств отдельно. Аналогично, с дополнительной проверкой по списку имеющихся скрытых свойств, работает и \u003Ccode\u003EObject.getOwnPropertyNames\u003C\u002Fcode\u003E.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003Econsole.log(Object.keys({q: 1, w: 2, e: 3}));       \u002F\u002F =\u003E ['q', 'w', 'e']\nconsole.log(Object.keys([1, 2, 3]));                \u002F\u002F =\u003E ['0', '1', '2']\nconsole.log(Object.getOwnPropertyNames([1, 2, 3])); \u002F\u002F =\u003E ['0', '1', '2', 'length']\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Ca name=\"es5-desc\"\u003E\u003C\u002Fa\u003E\u003Ca href=\"#es5-desc\"\u003E\u003Cb\u003E#\u003C\u002Fb\u003E\u003C\u002Fa\u003E С дескрипторами всё плохо, ECMAScript 3 их не поддерживает. Задать геттеры \u002F сеттеры нет возможности. Браузеры, где есть \u003Ccode\u003EObject#__define[GS]etter__\u003C\u002Fcode\u003E, но отсутствует \u003Ccode\u003EObject.defineProperty\u003C\u002Fcode\u003E, давно вымерли. В старых IE есть возможность создать объект с геттерами \u002F сеттерами через \u003Ca href=\"http:\u002F\u002Fhabrahabr.ru\u002Fpost\u002F75158\u002F\"\u003Eизвращения с VBScript\u003C\u002Fa\u003E, но это отдельная тема. \u003Ccode\u003Eenumerable: false\u003C\u002Fcode\u003E свойства есть, их не задать, но есть возможность проверить является ли оно таковым, через \u003Ca href=\"https:\u002F\u002Fdeveloper.mozilla.org\u002Fen-US\u002Fdocs\u002FWeb\u002FJavaScript\u002FReference\u002FGlobal_Objects\u002FObject\u002FpropertyIsEnumerable\"\u003EObject#propertyIsEnumerable\u003C\u002Fa\u003E. В IE8 есть методы для работы с дескрипторами, но лучше бы их не было (работают только с DOM объектами). Итого, всё, что мы можем сделать для IE8- — заглушки. Установка значения свойства по \u003Ccode\u003Evalue\u003C\u002Fcode\u003E дескриптора в \u003Ca href=\"https:\u002F\u002Fdeveloper.mozilla.org\u002Fen-US\u002Fdocs\u002FWeb\u002FJavaScript\u002FReference\u002FGlobal_Objects\u002FObject\u002FdefineProperty\"\u003EObject.defineProperty\u003C\u002Fa\u003E и \u003Ca href=\"https:\u002F\u002Fdeveloper.mozilla.org\u002Fen-US\u002Fdocs\u002FWeb\u002FJavaScript\u002FReference\u002FGlobal_Objects\u002FObject\u002FdefineProperties\"\u003EObject.defineProperties\u003C\u002Fa\u003E да честное получение \u003Ccode\u003Evalue\u003C\u002Fcode\u003E и \u003Ccode\u003Eenumerable\u003C\u002Fcode\u003E в \u003Ca href=\"https:\u002F\u002Fdeveloper.mozilla.org\u002Fen-US\u002Fdocs\u002FWeb\u002FJavaScript\u002FReference\u002FGlobal_Objects\u002FObject\u002FgetOwnPropertyDescriptor\"\u003EObject.getOwnPropertyDescriptor\u003C\u002Fa\u003E.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ca name=\"es5-freeze\"\u003E\u003C\u002Fa\u003E\u003Ca href=\"#es5-freeze\"\u003E\u003Cb\u003E#\u003C\u002Fb\u003E\u003C\u002Fa\u003E А что насчет \u003Ccode\u003EObject.freeze, Object.preventExtensions, Object.seal\u003C\u002Fcode\u003E? Мало того, что их эмуляция невозможна, можно сделать разве что заглушки, но есть и такая точка зрения:\u003Cbr\u002F\u003E\r\n\u003Cblockquote\u003E\u003Cb\u003EObject.freeze, Object.preventExtensions, Object.seal, with, eval\u003C\u002Fb\u003E\u003Cbr\u002F\u003E\r\nCrazy shit that you will probably never need. Stay away from it.\u003Cbr\u002F\u003E\r\n\u003Ci\u003E\u003Cb\u003E\u003Ca href=\"http:\u002F\u002Fnodeguide.com\u002Fstyle.html#object.freeze-object.preventextensions-object.seal-with-eval\"\u003E— Felix Geisendörfer\u003C\u002Fa\u003E\u003C\u002Fb\u003E\u003C\u002Fi\u003E\u003Cbr\u002F\u003E\r\n\u003C\u002Fblockquote\u003EИ я с ней полностью согласен, так что обойдемся без них.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ca name=\"es5-other\"\u003E\u003C\u002Fa\u003E\u003Ch4\u003E\u003Cb\u003E\u003Ca href=\"#es5-other\"\u003E#\u003C\u002Fa\u003E Прочее\u003C\u002Fb\u003E\u003C\u002Fh4\u003E\u003Cbr\u002F\u003E\r\n\u003Ca name=\"es5-bind\"\u003E\u003C\u002Fa\u003E\u003Ca href=\"#es5-bind\"\u003E\u003Cb\u003E#\u003C\u002Fb\u003E\u003C\u002Fa\u003E В ECMAScript 5 добавлены привязка контекста и базовые возможности частичного применения через \u003Ca href=\"https:\u002F\u002Fdeveloper.mozilla.org\u002Fen-US\u002Fdocs\u002FWeb\u002FJavaScript\u002FReference\u002FGlobal_Objects\u002FFunction\u002Fbind\"\u003EFunction#bind\u003C\u002Fa\u003E. Метод замечательный, но для раскрытия потенциала частичного применения и привязки контекста в JavaScript одного его мало, подробно тема раскрывается в \u003Ca href=\"#partial-application\"\u003E# соответствующем разделе\u003C\u002Fa\u003E.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003Evar fn = console.log.bind(console, 42);\nfn(43); \u002F\u002F =\u003E 42 43\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Ca name=\"es5-now\"\u003E\u003C\u002Fa\u003E\u003Ca href=\"#es5-now\"\u003E\u003Cb\u003E#\u003C\u002Fb\u003E\u003C\u002Fa\u003E Метод \u003Ca href=\"https:\u002F\u002Fdeveloper.mozilla.org\u002Fen-US\u002Fdocs\u002FWeb\u002FJavaScript\u002FReference\u002FGlobal_Objects\u002FDate\u002Fnow\"\u003EDate.now\u003C\u002Fa\u003E возвращает текущее время в числовом представлении, результат выполнения аналогичен \u003Ccode\u003E+new Date\u003C\u002Fcode\u003E.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003EDate.now(); \u002F\u002F =\u003E 1400263401642\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Ca name=\"es5-trim\"\u003E\u003C\u002Fa\u003E\u003Ca href=\"#es5-trim\"\u003E\u003Cb\u003E#\u003C\u002Fb\u003E\u003C\u002Fa\u003E Метод \u003Ca href=\"https:\u002F\u002Fdeveloper.mozilla.org\u002Fen-US\u002Fdocs\u002FWeb\u002FJavaScript\u002FReference\u002FGlobal_Objects\u002FString\u002FTrim\"\u003EString#trim\u003C\u002Fa\u003E удаляет пробельные символы из начала и конца строки.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003E'\\n   строка   \\n'.trim(); \u002F\u002F =\u003E 'строка'\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nЧто же касается модуля \u003Ccode\u003EJSON\u003C\u002Fcode\u003E, то он поддерживается IE8 и, в рамках данной библиотеки, реализовывать его я не вижу смысла. Если он вам понадобится в совсем уж доисторических IE — никто не мешает использовать, например, \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fdouglascrockford\u002FJSON-js\"\u003Eэтот\u003C\u002Fa\u003E полифил.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ca name=\"es6\"\u003E\u003C\u002Fa\u003E\u003Ch2\u003E\u003Cb\u003E\u003Ca href=\"#es6\"\u003E#\u003C\u002Fa\u003E ECMAScript 6\u003C\u002Fb\u003E\u003C\u002Fh2\u003E\u003Chr\u002F\u003E\u003Cbr\u002F\u003E\r\nСпецификация ECMAScript 5 была написана наспех вместо так и не принятой спецификации ECMAScript 4 и мало расширяла принятую ещё в прошлом тысячелетии ECMAScript 3. Сейчас уже почти завершена куда более серьёзно расширяющая язык, в т.ч. и стандартную библиотеку, спецификация ECMAScript 6. Добавление новых фич в неё заморожено, все серьёзные изменения идут в предложения по ECMAScript 7, в последнее время большинство изменений черновика спецификации это исправления ошибок. Так что в нашей стандартной библиотеке будем ориентироваться, в основном, на ES6.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nЧто с её поддержкой в актуальных движках хорошо видно по \u003Ca href=\"http:\u002F\u002Fkangax.github.io\u002Fcompat-table\u002Fes6\u002F\"\u003Eданной таблице\u003C\u002Fa\u003E.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cul\u003E\r\n\u003Cli\u003EЛучше всех с её поддержкой у \u003Cb\u003EFirefox\u003C\u002Fb\u003E — уже доступно очень многое.\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ca name=\"v8-harmony-mode\"\u003E\u003C\u002Fa\u003E\u003Ca href=\"#v8-harmony-mode\"\u003E\u003Cb\u003E#\u003C\u002Fb\u003E\u003C\u002Fa\u003E В \u003Cb\u003Ev8 (Chrome, Opera, Node.js)\u003C\u002Fb\u003E тоже доступно довольно многое, но значительная часть возможностей по умолчанию заблокирована, для их активации в браузере необходимо поставить флажок «Включить экспериментальный JavaScript» (парсер съедает ссылку \u003Ccode\u003Echrome:\u002F\u002Fflags\u002F#enable-javascript-harmony\u003C\u002Fcode\u003E), а Node.js запустить с флажком \u003Ccode\u003E--harmony\u003C\u002Fcode\u003E. Что-то доступно и без флажка, например, \u003Ccode\u003EPromise\u003C\u002Fcode\u003E, \u003Ccode\u003EWeakMap\u003C\u002Fcode\u003E и \u003Ccode\u003EWeakSet\u003C\u002Fcode\u003E, а начиная с Chrome 38 доступны и \u003Ccode\u003ESymbol\u003C\u002Fcode\u003E, \u003Ccode\u003EMap\u003C\u002Fcode\u003E, \u003Ccode\u003ESet\u003C\u002Fcode\u003E, итераторы. Node.js в этом плане сильно отстаёт, так как, особенно в стабильной ветке, v8 там обновляется редко. Зато её, в отличии от браузера пользователя, вам никто не помешает запустить с флажком.\u003C\u002Fli\u003E\r\n\u003Cli\u003EУ \u003Cb\u003EIE\u003C\u002Fb\u003E, как обычно, всё плохо, но в 11ой версии были добавлены коллекции и еще пара возможностей. В ближайшем будущем обещают \u003Ca href=\"http:\u002F\u002Fhabrahabr.ru\u002Fcompany\u002Fmicrosoft\u002Fblog\u002F243215\u002F\"\u003Eочень многое\u003C\u002Fa\u003E.\u003C\u002Fli\u003E\r\n\u003Cli\u003EДобавить функционал ES6 попытались и в \u003Cb\u003ESafari\u003C\u002Fb\u003E. Вот только почти всё, что они добавили, не соответствует стандарту и порождает лишние проблемы, так что лучше бы и не добавляли. По \u003Ca href=\"https:\u002F\u002Fesdiscuss.org\u002Ftopic\u002Fsafari-8-es6-ish-implementation\"\u003Eссылке\u003C\u002Fa\u003E только небольшая часть проблем.\u003C\u002Fli\u003E\r\n\u003C\u002Ful\u003E\u003Cbr\u002F\u003E\r\nСамым популярным полифилом ES6 является \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fpaulmillr\u002Fes6-shim\u002F\"\u003Ees6-shim\u003C\u002Fa\u003E от \u003Ca href=\"https:\u002F\u002Fhabrahabr.ru\u002Fusers\u002Fpaulmillr\u002F\" class=\"user_link\"\u003Epaulmillr\u003C\u002Fa\u003E.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nЧасть стандартной библиотеки ECMAScript 6, например, \u003Ccode\u003EProxy\u003C\u002Fcode\u003E (а это одна из самых вкусных возможностей), на базе ECMAScript 5 и уж тем более ECMAScript 3 реализовать невозможно, но большую часть можно реализовать если не полностью, то хотя бы частично и «нечестно».\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ca name=\"preprocessors\"\u003E\u003C\u002Fa\u003E\u003Ch4\u003E\u003Cb\u003E\u003Ca href=\"#preprocessors\"\u003E#\u003C\u002Fa\u003E Немного про препроцессоры ECMAScript 6+\u003C\u002Fb\u003E\u003C\u002Fh4\u003E\u003Cbr\u002F\u003E\r\nЧто касается синтаксиса, то, в рамках этой библиотеки, его поддержку мы добавить не можем. Однако на помощь тут приходят препроцессоры, преобразующие синтаксис ECMAScript 6+ в ECMAScript 3 или 5. Их огромное количество, рассмотрим только пару популярных.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nЕсть такой старый и мощный проект — \u003Cb\u003E\u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fgoogle\u002Ftraceur-compiler\"\u003EGoogle Traceur\u003C\u002Fa\u003E\u003C\u002Fb\u003E. Он генерирует нечитаемый код и использует довольно тяжелый runtime, так что от его использования я отказался.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nДругой проект мне кажется куда более привлекательным — \u003Cb\u003E\u003Ca href=\"https:\u002F\u002Fgithub.com\u002F6to5\u002F6to5\"\u003E6to5\u003C\u002Fa\u003E\u003C\u002Fb\u003E. Проект свежий и развивается \u003Cb\u003Eпотрясающе\u003C\u002Fb\u003E быстро. Он генерирует легко читаемый код и не использует собственный runtime, исключение — runtime \u003Cb\u003E\u003Ca href=\"http:\u002F\u002Ffacebook.github.io\u002Fregenerator\u002F\"\u003Eregenerator\u003C\u002Fa\u003E\u003C\u002Fb\u003E, который он использует для компиляции генераторов. Зато вместо него активно использует стандартную библиотеку ES6 — например, \u003Ca href=\"#es6-iterable-interface\"\u003E# \u003Ccode\u003ESymbol.iterator\u003C\u002Fcode\u003E\u003C\u002Fa\u003E. По умолчанию — \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fpaulmillr\u002Fes6-shim\"\u003Ees6-shim\u003C\u002Fa\u003E и \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fmedikoo\u002Fes6-symbol\"\u003Ees6-symbol\u003C\u002Fa\u003E. Их легко заменяет наша библиотека, что делает данный препроцессор идеальной её парой. Преобразует код в ECMAScript 5, но, главным образом, это касается стандартной библиотеки — с заглушками методов вроде \u003Ca href=\"#es5-desc\"\u003E# \u003Ccode\u003EObject.defineProperties\u003C\u002Fcode\u003E\u003C\u002Fa\u003E почти всё будет работать и в старых IE.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cb\u003EС использованием препроцессора и полифила стандартной библиотеки, начинать использовать ECMAScript 6 на полную катушку можно уже сейчас.\u003C\u002Fb\u003E За исключением, разве что, некоторых мелочей.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nНабросал совсем \u003Cb\u003Eпростенькую \u003Ca href=\"http:\u002F\u002Fes6.zloirock.ru\"\u003Eпесочницу\u003C\u002Fa\u003E\u003C\u002Fb\u003E с возможностью компиляции ES6 через \u003Cb\u003E6to5\u003C\u002Fb\u003E и подключенной библиотекой \u003Cb\u003Ecore.js\u003C\u002Fb\u003E, примеры будут со ссылками на неё. Однако, так как наша библиотека никак не привязана к синтаксису ECMAScript 6, большая часть примеров будет с использованием синтаксиса ECMAScript 5.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Chr\u002F\u003E\u003Cbr\u002F\u003E\r\nНу а теперь перейдём к стандартной библиотеке по ECMAScript 6. Новые конструкторы и концепции мы рассмотрим в отдельных главах, это \u003Ca href=\"#es6-symbol\"\u003E# символы\u003C\u002Fa\u003E, \u003Ca href=\"#es6-collections\"\u003E# коллекции\u003C\u002Fa\u003E, \u003Ca href=\"#es6-iterators\"\u003E# итераторы\u003C\u002Fa\u003E и \u003Ca href=\"#es6-promise\"\u003E# обещания\u003C\u002Fa\u003E, остальное рассмотрим здесь.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ca name=\"es6-object-assign\"\u003E\u003C\u002Fa\u003E\u003Ch4\u003E\u003Cb\u003E\u003Ca href=\"#es6-object-assign\"\u003E#\u003C\u002Fa\u003E Object.assign\u003C\u002Fb\u003E\u003C\u002Fh4\u003E\u003Cbr\u002F\u003E\r\nЭтого метода ждали многие. \u003Ca href=\"http:\u002F\u002Fpeople.mozilla.org\u002F~jorendorff\u002Fes6-draft.html#sec-object.assign\"\u003EObject.assign\u003C\u002Fa\u003E банально копирует все собственные перечисляемые свойства объекта (объектов) источника в целевой объект. \u003Ca href=\"http:\u002F\u002Fgoo.gl\u002FH3zj4b\"\u003EПример\u003C\u002Fa\u003E:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003Evar foo = {q: 1, w: 2}\n  , bar = {e: 3, r: 4}\n  , baz = {t: 5, y: 6};\nObject.assign(foo, bar, baz); \u002F\u002F =\u003E foo = {q: 1, w: 2, e: 3, r: 4, t: 5, y: 6}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nПланировалось также добавить метод \u003Ccode\u003EObject.mixin\u003C\u002Fcode\u003E, который копировал еще и неперечисляемые свойства, учитывал дескрипторы и переназначал родителя, получаемого через ключевое слово \u003Ccode\u003Esuper\u003C\u002Fcode\u003E. Однако, его добавление решили отложить. Его аналог есть в \u003Ca href=\"#object-define\"\u003E# велосипедной части\u003C\u002Fa\u003E библиотеки.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ca name=\"es6-object-is\"\u003E\u003C\u002Fa\u003E\u003Ch4\u003E\u003Cb\u003E\u003Ca href=\"#es6-object-is\"\u003E#\u003C\u002Fa\u003E Object.is\u003C\u002Fb\u003E\u003C\u002Fh4\u003E\u003Cbr\u002F\u003E\r\nОператоры сравнения в JavaScript вообще довольно странно себя ведут. Забудем даже такой оператор, как \u003Ccode\u003E==\u003C\u002Fcode\u003E с его приведениями, посмотрим на \u003Ccode\u003E===\u003C\u002Fcode\u003E:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003ENaN === NaN  \u002F\u002F =\u003E false\n0 === -0     \u002F\u002F =\u003E true, но при этом:\n1\u002F0 === 1\u002F-0 \u002F\u002F =\u003E false\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nКак раз для этого случая, в языке есть внутренний алгоритм сравнения \u003Ca href=\"http:\u002F\u002Fes5.javascript.ru\u002Fx9.html#x9.12\"\u003ESameValue\u003C\u002Fa\u003E. Для него \u003Ccode\u003ENaN\u003C\u002Fcode\u003E равен \u003Ccode\u003ENaN\u003C\u002Fcode\u003E, а \u003Ccode\u003E+0\u003C\u002Fcode\u003E и \u003Ccode\u003E-0\u003C\u002Fcode\u003E различны. В ECMAScript 6 его хотели вынести наружу как операторы \u003Ccode\u003Eis\u003C\u002Fcode\u003E и \u003Ccode\u003Eisnt\u003C\u002Fcode\u003E, но, похоже, поняв, что операторов сравнения в языке уже и так не мало, да и для обратной совместимости, вынесли как метод \u003Ca href=\"https:\u002F\u002Fdeveloper.mozilla.org\u002Fen-US\u002Fdocs\u002FWeb\u002FJavaScript\u002FReference\u002FGlobal_Objects\u002FObject\u002Fis\"\u003EObject.is\u003C\u002Fa\u003E. \u003Ca href=\"http:\u002F\u002Fgoo.gl\u002FXMplwh\"\u003EПример\u003C\u002Fa\u003E:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003EObject.is(NaN, NaN); \u002F\u002F =\u003E true\nObject.is(0, -0);    \u002F\u002F =\u003E false\nObject.is(42, 42);   \u002F\u002F =\u003E true, аналогично '==='\nObject.is(42, '42'); \u002F\u002F =\u003E false, аналогично '==='\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Ca name=\"same-value-zero\"\u003E\u003C\u002Fa\u003E\u003Ca href=\"#same-value-zero\"\u003E#\u003C\u002Fa\u003E Также в ES6 и далее активно используется другой алгоритм сравнения — \u003Ca href=\"http:\u002F\u002Fpeople.mozilla.org\u002F~jorendorff\u002Fes6-draft.html#sec-samevaluezero\"\u003ESameValueZero\u003C\u002Fa\u003E, для которого \u003Ccode\u003ENaN\u003C\u002Fcode\u003E равен \u003Ccode\u003ENaN\u003C\u002Fcode\u003E, и, в отличии от предыдущего, \u003Ccode\u003E-0\u003C\u002Fcode\u003E равен \u003Ccode\u003E+0\u003C\u002Fcode\u003E. Им обеспечивается уникальность ключа \u003Ca href=\"#es6-collections\"\u003E# коллекций\u003C\u002Fa\u003E, он применяется при проверке вхождения элемента в коллекцию через \u003Ca href=\"#array-contains\"\u003E# \u003Ccode\u003EArray#includes\u003C\u002Fcode\u003E\u003C\u002Fa\u003E.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ca name=\"es6-object-setPrototypeOf\"\u003E\u003C\u002Fa\u003E\u003Ch4\u003E\u003Cb\u003E\u003Ca href=\"#es6-object-setPrototypeOf\"\u003E#\u003C\u002Fa\u003E Object.setPrototypeOf\u003C\u002Fb\u003E\u003C\u002Fh4\u003E\u003Cbr\u002F\u003E\r\nВ ES6 для установки прототипа существующего объекта появляется метод \u003Ccode\u003EObject.setPrototypeOf\u003C\u002Fcode\u003E. \u003Ca href=\"http:\u002F\u002Fgoo.gl\u002Ft4wJ4K\"\u003EПример\u003C\u002Fa\u003E:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003Efunction Parent(){}\nfunction Child(){}\nObject.setPrototypeOf(Child.prototype, Parent.prototype);\nnew Child instanceof Child;  \u002F\u002F =\u003E true\nnew Child instanceof Parent; \u002F\u002F =\u003E true\n\nfunction fn(){}\nObject.setPrototypeOf(fn, []);\ntypeof fn == 'function';     \u002F\u002F =\u003E true \nfn instanceof Array;         \u002F\u002F =\u003E true\n\nvar object = {};\nObject.setPrototypeOf(object, null);\nobject instanceof Object;    \u002F\u002F =\u003E false\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nСтранно, что такая, казалось бы, необходимая, учитывая прототипную ориентированность языка, возможность — посмотрите, хотя бы, первый пример — простое и очевидное прототипное наследование, отсутствует в ECMAScript 5. Единственный способ изменить прототип уже существующего объекта без данного метода — нестандартное свойство \u003Ccode\u003E__proto__\u003C\u002Fcode\u003E. На текущий момент, оно поддерживается всеми актуальными браузерами, кроме IE10-, в текущей реализации — геттер \u002F сеттер в прототипе \u003Ccode\u003EObject\u003C\u002Fcode\u003E.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nПримитивная, без лишних проверок и возврата объекта, версия \u003Ccode\u003EObject.setPrototypeOf\u003C\u002Fcode\u003E выглядела бы просто — выдернем сеттер \u003Ccode\u003E__proto__\u003C\u002Fcode\u003E и сделаем из него функцию:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003Evar setPrototypeOf = Function.call.bind(Object.getOwnPropertyDescriptor(Object.prototype, '__proto__').set);\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nОднако, тут появляется еще одна проблема — в старых, но где-то еще актуальных, версиях v8, сеттер \u003Ccode\u003E__proto__\u003C\u002Fcode\u003E нельзя использовать как функцию. Для реализации \u003Ccode\u003EObject.setPrototypeOf\u003C\u002Fcode\u003E в них остается только установка значения по ключу \u003Ccode\u003E__proto__\u003C\u002Fcode\u003E.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ch5\u003EТак и живем:\u003C\u002Fh5\u003E\u003Cbr\u002F\u003E\r\n\u003Cul\u003E\r\n\u003Cli\u003E\u003Cb\u003EДля IE10- эмуляция \u003Ccode\u003EObject.setPrototypeOf\u003C\u002Fcode\u003E отсутствует полностью, так как невозможна.\u003C\u002Fb\u003E\u003C\u002Fli\u003E\r\n\u003Cli\u003EВ старых версиях v8 \u003Ccode\u003EObject.setPrototypeOf\u003C\u002Fcode\u003E не работает, если в цепочке прототипов цели отсутствует \u003Ccode\u003EObject.prototype\u003C\u002Fcode\u003E или свойство \u003Ccode\u003E__proto__\u003C\u002Fcode\u003E переопределено через, например, \u003Ccode\u003EObject.defineProperty\u003C\u002Fcode\u003E.\u003C\u002Fli\u003E\r\n\u003C\u002Ful\u003E\u003Cbr\u002F\u003E\r\nТакже, ECMAScript 6 и наша библиотека изменяет логику работы \u003Ccode\u003EObject#toString\u003C\u002Fcode\u003E. Тема серьёзная, но о ней мы поговорим \u003Ca href=\"#classof\"\u003E# во второй части статьи\u003C\u002Fa\u003E.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ca name=\"es6-array\"\u003E\u003C\u002Fa\u003E\u003Ch4\u003E\u003Cb\u003E\u003Ca href=\"#es6-array\"\u003E#\u003C\u002Fa\u003E Методы массива\u003C\u002Fb\u003E\u003C\u002Fh4\u003E\u003Cbr\u002F\u003E\r\nСтатические методы \u003Ccode\u003EArray.from\u003C\u002Fcode\u003E и \u003Ccode\u003EArray.of\u003C\u002Fcode\u003E — дженерики, если они запущены в контексте функции, отличной от \u003Ccode\u003EArray\u003C\u002Fcode\u003E, они создают её инстансы. Если есть желание ознакомиться с этим подробней — хорошо описано в \u003Ca href=\"http:\u002F\u002Fwww.2ality.com\u002F2014\u002F05\u002Fes6-array-methods.html\"\u003Eэтой статье по новым методам массива\u003C\u002Fa\u003E.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ca name=\"es6-array-from\"\u003E\u003C\u002Fa\u003E\u003Ca href=\"#es6-array-from\"\u003E\u003Cb\u003E#\u003C\u002Fb\u003E\u003C\u002Fa\u003E ECMAScript 6 добавляет очень полезный метод — \u003Ccode\u003EArray.from\u003C\u002Fcode\u003E. Это универсальное приведение к массиву \u003Ca href=\"#es6-iterators\"\u003E# итерируемых\u003C\u002Fa\u003E и array-like объектов. Во большинстве случаев он заменит \u003Ccode\u003EArray.prototype.slice.call\u003C\u002Fcode\u003E без указания начальной и конечной позиций. Дополнительно, метод принимает опциональный map-коллбэк и контекст его исполнения. В случае передачи итерируемого объекта и без map-коллбэка, результат аналогичен использованию оператора \u003Ca href=\"#es6-spread\"\u003E# spread\u003C\u002Fa\u003E в литерале массива — \u003Ccode\u003E[...iterable]\u003C\u002Fcode\u003E. \u003Ca href=\"http:\u002F\u002Fgoo.gl\u002Fh1F9dN\"\u003EПример\u003C\u002Fa\u003E:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003EArray.from(new Set([1, 2, 3, 2, 1]));      \u002F\u002F =\u003E [1, 2, 3]\nArray.from({0: 1, 1: 2, 2: 3, length: 3}); \u002F\u002F =\u003E [1, 2, 3]\nArray.from('123', Number);                 \u002F\u002F =\u003E [1, 2, 3]\nArray.from('123', function(it){\n  return it * it;\n});                                        \u002F\u002F =\u003E [1, 4, 9]\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Ca name=\"es6-array-of\"\u003E\u003C\u002Fa\u003E\u003Ca href=\"#es6-array-of\"\u003E\u003Cb\u003E#\u003C\u002Fb\u003E\u003C\u002Fa\u003E В отличие от предыдущего, метод \u003Ca href=\"https:\u002F\u002Fdeveloper.mozilla.org\u002Fen-US\u002Fdocs\u002FWeb\u002FJavaScript\u002FReference\u002FGlobal_Objects\u002FArray\u002Fof\"\u003EArray.of\u003C\u002Fa\u003E на текущий момент практически бесполезен. Он нужен, в первую очередь, для подклассов \u003Ccode\u003EArray\u003C\u002Fcode\u003E, как аналог литерала массива \u003Ccode\u003E[]\u003C\u002Fcode\u003E. \u003Ca href=\"http:\u002F\u002Fgoo.gl\u002FBV1EDC\"\u003EПример\u003C\u002Fa\u003E:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003EArray.of(1);       \u002F\u002F =\u003E [1]\nArray.of(1, 2, 3); \u002F\u002F =\u003E [1, 2, 3]\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Ca name=\"es6-array-find\"\u003E\u003C\u002Fa\u003E\u003Ca href=\"#es6-array-find\"\u003E\u003Cb\u003E#\u003C\u002Fb\u003E\u003C\u002Fa\u003E Методы \u003Ca href=\"https:\u002F\u002Fdeveloper.mozilla.org\u002Fen-US\u002Fdocs\u002FWeb\u002FJavaScript\u002FReference\u002FGlobal_Objects\u002FArray\u002Ffind\"\u003EArray#find\u003C\u002Fa\u003E и \u003Ca href=\"https:\u002F\u002Fdeveloper.mozilla.org\u002Fen-US\u002Fdocs\u002FWeb\u002FJavaScript\u002FReference\u002FGlobal_Objects\u002FArray\u002FfindIndex\"\u003EArray#findIndex\u003C\u002Fa\u003E осуществляют поиск по массиву через вызов коллбэка. \u003Ca href=\"http:\u002F\u002Fgoo.gl\u002FGb8ILU\"\u003EПример\u003C\u002Fa\u003E:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003Efunction isOdd(val){\n  return val % 2;\n}\n[4, 8, 15, 16, 23, 42].find(isOdd);      \u002F\u002F =\u003E 15\n[4, 8, 15, 16, 23, 42].findIndex(isOdd); \u002F\u002F =\u003E 2\n[4, 8, 15, 16, 23, 42].find(isNaN);      \u002F\u002F =\u003E undefined\n[4, 8, 15, 16, 23, 42].findIndex(isNaN); \u002F\u002F =\u003E -1\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Ca name=\"es6-array-fill\"\u003E\u003C\u002Fa\u003E\u003Ca href=\"#es6-array-fill\"\u003E\u003Cb\u003E#\u003C\u002Fb\u003E\u003C\u002Fa\u003E Метод массива \u003Ca href=\"https:\u002F\u002Fdeveloper.mozilla.org\u002Fen-US\u002Fdocs\u002FWeb\u002FJavaScript\u002FReference\u002FGlobal_Objects\u002FArray\u002Ffill\"\u003EArray#fill\u003C\u002Fa\u003E заполняет массив переданным значением. Опциональные аргументы — стартовая и конечная позиции. \u003Ca href=\"http:\u002F\u002Fgoo.gl\u002F34utph\"\u003EПример\u003C\u002Fa\u003E:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003EArray(5).map(function(){\n  return 42;\n});                \u002F\u002F =\u003E [undefined × 5], потому как .map пропускает \"дырки\" в массиве\nArray(5).fill(42); \u002F\u002F =\u003E [42, 42, 42, 42, 42]\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Ca name=\"es6-string\"\u003E\u003C\u002Fa\u003E\u003Ch4\u003E\u003Cb\u003E\u003Ca href=\"#es6-string\"\u003E#\u003C\u002Fa\u003E Методы строки\u003C\u002Fb\u003E\u003C\u002Fh4\u003E\u003Cbr\u002F\u003E\r\nТут всё просто. \u003Ca href=\"https:\u002F\u002Fdeveloper.mozilla.org\u002Fen-US\u002Fdocs\u002FWeb\u002FJavaScript\u002FReference\u002FGlobal_Objects\u002FString\u002Fincludes\"\u003EString#includes\u003C\u002Fa\u003E (до недавнего времени — \u003Ccode\u003EString#contains\u003C\u002Fcode\u003E, но \u003Ca href=\"#array-contains\"\u003E# \u003Ccode\u003EArray#includes\u003C\u002Fcode\u003E\u003C\u002Fa\u003E утянул его за собой, пока доступен и по старому имени) проверяет вхождение подстроки в строку. \u003Ca href=\"https:\u002F\u002Fdeveloper.mozilla.org\u002Fen-US\u002Fdocs\u002FWeb\u002FJavaScript\u002FReference\u002FGlobal_Objects\u002FString\u002FstartsWith\"\u003EString#startsWith\u003C\u002Fa\u003E и \u003Ca href=\"https:\u002F\u002Fdeveloper.mozilla.org\u002Fen-US\u002Fdocs\u002FWeb\u002FJavaScript\u002FReference\u002FGlobal_Objects\u002FString\u002FendsWith\"\u003EString#endsWith\u003C\u002Fa\u003E проверяют, начинается ли или заканчивается ли строка на заданную подстроку. Эти 3 метода принимают дополнительный аргумент — стартовую позицию. \u003Ca href=\"http:\u002F\u002Fgoo.gl\u002FB5uMrt\"\u003EПример\u003C\u002Fa\u003E:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003E'foobarbaz'.includes('bar');      \u002F\u002F =\u003E true\n'foobarbaz'.includes('bar', 4);   \u002F\u002F =\u003E false\n'foobarbaz'.startsWith('foo');    \u002F\u002F =\u003E true\n'foobarbaz'.startsWith('bar', 3); \u002F\u002F =\u003E true\n'foobarbaz'.endsWith('baz');      \u002F\u002F =\u003E true\n'foobarbaz'.endsWith('bar', 6);   \u002F\u002F =\u003E true\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nМетод \u003Ca href=\"https:\u002F\u002Fdeveloper.mozilla.org\u002Fen-US\u002Fdocs\u002FWeb\u002FJavaScript\u002FReference\u002FGlobal_Objects\u002FString\u002Frepeat\"\u003EString#repeat\u003C\u002Fa\u003E возвращает строку, повторенную заданное число раз. \u003Ca href=\"http:\u002F\u002Fgoo.gl\u002FUBdYnv\"\u003EПример\u003C\u002Fa\u003E:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003E'string'.repeat(3); \u002F\u002F =\u003E 'stringstringstring'\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nБиблиотека пока не добавляет методы ECMAScript 6 \u002F 7 \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Flukehoban\u002Fes6features#unicode\"\u003Eдля лучшей поддержки многобайтовых символов\u003C\u002Fa\u003E и честный \u003Ca href=\"#es6-iterators\"\u003E# итератор\u003C\u002Fa\u003E строки, для строк используется итератор массива. Сейчас их нет только потому, что они лично мне просто не нужны. Было бы неплохо добавить их в ближайшем будущем.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ca name=\"es6-math\"\u003E\u003C\u002Fa\u003E\u003Ch4\u003E\u003Cb\u003E\u003Ca href=\"#es6-math\"\u003E#\u003C\u002Fa\u003E Работа с числами\u003C\u002Fb\u003E\u003C\u002Fh4\u003E\u003Cbr\u002F\u003E\r\nВ ECMAScript 6 добавлено огромное количество математических функций и констант. Обойдемся без их описания и примеров, только ссылки: \u003Ca href=\"https:\u002F\u002Fdeveloper.mozilla.org\u002Fen-US\u002Fdocs\u002FWeb\u002FJavaScript\u002FReference\u002FGlobal_Objects\u002FNumber\u002FEPSILON\"\u003ENumber.EPSILON\u003C\u002Fa\u003E, \u003Ca href=\"https:\u002F\u002Fdeveloper.mozilla.org\u002Fen-US\u002Fdocs\u002FWeb\u002FJavaScript\u002FReference\u002FGlobal_Objects\u002FNumber\u002FparseFloat\"\u003ENumber.parseFloat\u003C\u002Fa\u003E, \u003Ca href=\"https:\u002F\u002Fdeveloper.mozilla.org\u002Fen-US\u002Fdocs\u002FWeb\u002FJavaScript\u002FReference\u002FGlobal_Objects\u002FNumber\u002FparseInt\"\u003ENumber.parseInt\u003C\u002Fa\u003E, \u003Ca href=\"https:\u002F\u002Fdeveloper.mozilla.org\u002Fen-US\u002Fdocs\u002FWeb\u002FJavaScript\u002FReference\u002FGlobal_Objects\u002FNumber\u002FisFinite\"\u003ENumber.isFinite\u003C\u002Fa\u003E, \u003Ca href=\"https:\u002F\u002Fdeveloper.mozilla.org\u002Fen-US\u002Fdocs\u002FWeb\u002FJavaScript\u002FReference\u002FGlobal_Objects\u002FNumber\u002FisInteger\"\u003ENumber.isInteger\u003C\u002Fa\u003E, \u003Ca href=\"https:\u002F\u002Fdeveloper.mozilla.org\u002Fen-US\u002Fdocs\u002FWeb\u002FJavaScript\u002FReference\u002FGlobal_Objects\u002FNumber\u002FisNaN\"\u003ENumber.isNaN\u003C\u002Fa\u003E, \u003Ca href=\"http:\u002F\u002Fwww.2ality.com\u002F2013\u002F10\u002Fsafe-integers.html\"\u003ENumber.MAX_SAFE_INTEGER, Number.MIN_SAFE_INTEGER, Number.isSafeInteger\u003C\u002Fa\u003E, \u003Ca href=\"https:\u002F\u002Fdeveloper.mozilla.org\u002Fen-US\u002Fdocs\u002FWeb\u002FJavaScript\u002FReference\u002FGlobal_Objects\u002FMath\u002Facosh\"\u003EMath.acosh\u003C\u002Fa\u003E, \u003Ca href=\"https:\u002F\u002Fdeveloper.mozilla.org\u002Fen-US\u002Fdocs\u002FWeb\u002FJavaScript\u002FReference\u002FGlobal_Objects\u002FMath\u002Fasinh\"\u003EMath.asinh\u003C\u002Fa\u003E, \u003Ca href=\"https:\u002F\u002Fdeveloper.mozilla.org\u002Fen-US\u002Fdocs\u002FWeb\u002FJavaScript\u002FReference\u002FGlobal_Objects\u002FMath\u002Fatanh\"\u003EMath.atanh\u003C\u002Fa\u003E, \u003Ca href=\"https:\u002F\u002Fdeveloper.mozilla.org\u002Fen-US\u002Fdocs\u002FWeb\u002FJavaScript\u002FReference\u002FGlobal_Objects\u002FMath\u002Fcbrt\"\u003EMath.cbrt\u003C\u002Fa\u003E, \u003Ca href=\"https:\u002F\u002Fdeveloper.mozilla.org\u002Fen-US\u002Fdocs\u002FWeb\u002FJavaScript\u002FReference\u002FGlobal_Objects\u002FMath\u002Fclz32\"\u003EMath.clz32\u003C\u002Fa\u003E, \u003Ca href=\"https:\u002F\u002Fdeveloper.mozilla.org\u002Fen-US\u002Fdocs\u002FWeb\u002FJavaScript\u002FReference\u002FGlobal_Objects\u002FMath\u002Fcosh\"\u003EMath.cosh\u003C\u002Fa\u003E, \u003Ca href=\"https:\u002F\u002Fdeveloper.mozilla.org\u002Fen-US\u002Fdocs\u002FWeb\u002FJavaScript\u002FReference\u002FGlobal_Objects\u002FMath\u002Fexpm1\"\u003EMath.expm1\u003C\u002Fa\u003E, \u003Ca href=\"https:\u002F\u002Fdeveloper.mozilla.org\u002Fen-US\u002Fdocs\u002FWeb\u002FJavaScript\u002FReference\u002FGlobal_Objects\u002FMath\u002Fhypot\"\u003EMath.hypot\u003C\u002Fa\u003E, \u003Ca href=\"https:\u002F\u002Fdeveloper.mozilla.org\u002Fen-US\u002Fdocs\u002FWeb\u002FJavaScript\u002FReference\u002FGlobal_Objects\u002FMath\u002Fimul\"\u003EMath.imul\u003C\u002Fa\u003E, \u003Ca href=\"https:\u002F\u002Fdeveloper.mozilla.org\u002Fen-US\u002Fdocs\u002FWeb\u002FJavaScript\u002FReference\u002FGlobal_Objects\u002FMath\u002Flog1p\"\u003EMath.log1p\u003C\u002Fa\u003E, \u003Ca href=\"https:\u002F\u002Fdeveloper.mozilla.org\u002Fen-US\u002Fdocs\u002FWeb\u002FJavaScript\u002FReference\u002FGlobal_Objects\u002FMath\u002Flog10\"\u003EMath.log10\u003C\u002Fa\u003E, \u003Ca href=\"https:\u002F\u002Fdeveloper.mozilla.org\u002Fen-US\u002Fdocs\u002FWeb\u002FJavaScript\u002FReference\u002FGlobal_Objects\u002FMath\u002Flog2\"\u003EMath.log2\u003C\u002Fa\u003E, \u003Ca href=\"https:\u002F\u002Fdeveloper.mozilla.org\u002Fen-US\u002Fdocs\u002FWeb\u002FJavaScript\u002FReference\u002FGlobal_Objects\u002FMath\u002Fsign\"\u003EMath.sign\u003C\u002Fa\u003E, \u003Ca href=\"https:\u002F\u002Fdeveloper.mozilla.org\u002Fen-US\u002Fdocs\u002FWeb\u002FJavaScript\u002FReference\u002FGlobal_Objects\u002FMath\u002Fsinh\"\u003EMath.sinh\u003C\u002Fa\u003E, \u003Ca href=\"https:\u002F\u002Fdeveloper.mozilla.org\u002Fen-US\u002Fdocs\u002FWeb\u002FJavaScript\u002FReference\u002FGlobal_Objects\u002FMath\u002Ftanh\"\u003EMath.tanh\u003C\u002Fa\u003E, \u003Ca href=\"https:\u002F\u002Fdeveloper.mozilla.org\u002Fen-US\u002Fdocs\u002FWeb\u002FJavaScript\u002FReference\u002FGlobal_Objects\u002FMath\u002Ftrunc\"\u003EMath.trunc\u003C\u002Fa\u003E.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ca name=\"es6-symbol\"\u003E\u003C\u002Fa\u003E\u003Ch2\u003E\u003Cb\u003E\u003Ca href=\"#es6-symbol\"\u003E#\u003C\u002Fa\u003E ECMAScript 6: Символы\u003C\u002Fb\u003E\u003C\u002Fh2\u003E\u003Chr\u002F\u003E\u003Cbr\u002F\u003E\r\nВ JavaScript с сокрытием свойств объектов дела обстоят довольно плохо. Приватные данные можно хранить в замыканиях, что вынуждает объявлять методы для работы с ними внутри конструктора, а не в прототипе объекта. Начиная с ECMAScript 5, можно объявлять \u003Ccode\u003Eenumerable: false\u003C\u002Fcode\u003E свойства, что скроет свойства объекта от перечисления в \u003Ccode\u003Efor-in\u003C\u002Fcode\u003E и от \u003Ccode\u003EObject.keys\u003C\u002Fcode\u003E, но это не обеспечит надежного сокрытия — ключ не уникален, его можно легко подобрать, могут возникнуть конфликты имен и, из-за необходимости использования \u003Ccode\u003EObject.defineProperty\u003C\u002Fcode\u003E с объектом-дескриптором, это довольно громоздко.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nВ ECMAScript 6 для упрощения инкапсуляции появляется новый тип данных — \u003Ca href=\"https:\u002F\u002Fdeveloper.mozilla.org\u002Fru\u002Fdocs\u002FWeb\u002FJavaScript\u002FReference\u002FGlobal_Objects\u002FSymbol\"\u003ESymbol\u003C\u002Fa\u003E, ранее известный как \u003Ca href=\"http:\u002F\u002Fwiki.ecmascript.org\u002Fdoku.php?id=harmony:private_name_objects\"\u003EName\u003C\u002Fa\u003E. Символы предназначены для использования в качестве уникальных ключей объектов. \u003Ca href=\"http:\u002F\u002Fgoo.gl\u002FEUsvAf\"\u003EПример\u003C\u002Fa\u003E:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003Evar Person = (function(){\n  var NAME = Symbol('name');\n  function Person(name){\n    this[NAME] = name;\n  }\n  Person.prototype.getName = function(){\n    return this[NAME];\n  };\n  return Person;\n})();\n\nvar person = new Person('Вася');\nconsole.log(person.getName());          \u002F\u002F =\u003E 'Вася'\nconsole.log(person['name']);            \u002F\u002F =\u003E undefined\nconsole.log(person[Symbol('name')]);    \u002F\u002F =\u003E undefined, каждый вызов Symbol возвращает уникальный ключ\nfor(var key in person)console.log(key); \u002F\u002F =\u003E только 'getName', символы не участвуют в обходе объекта\n\nconsole.log(typeof Symbol());           \u002F\u002F =\u003E 'symbol'\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nСимволы не являются полностью приватными — метод \u003Ccode\u003EObject.getOwnPropertySymbols\u003C\u002Fcode\u003E возвращает собственные символы объекта, что даёт возможность отладки и низкоуровневых операций вроде клонирования. Хранение по настоящему приватных данных можно реализовать на базе \u003Ca href=\"#es6-weakmap\"\u003E# WeakMap\u003C\u002Fa\u003E. Хотя, ИМХО, более удачным решением проблемы было бы добавление полностью приватной версии символов.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nНа текущий момент символы доступны в v8, начиная с Chrome 38 (в более ранних версиях — \u003Ca href=\"#v8-harmony-mode\"\u003E# с флажком экспериментальных возможностей\u003C\u002Fa\u003E) и в ночных сборках Firefox, начиная с 33. Скоро обещают и в IE, так что в самом ближайшем будущем будет доступен во всех основных современных браузерах.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ca name=\"es6-symbol-polyfill\"\u003E\u003C\u002Fa\u003E\u003Ca href=\"#es6-symbol-polyfill\"\u003E\u003Cb\u003E#\u003C\u002Fb\u003E\u003C\u002Fa\u003E Конечно, полноценный полифил символов на базе ES5 невозможен, но базовые возможности — создание уникальных не участвующих в обходе объекта через \u003Ccode\u003Efor-in\u003C\u002Fcode\u003E и не возвращаемых \u003Ccode\u003EObject.keys\u003C\u002Fcode\u003E ключей — реализуется довольно просто, например, так:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003Ewindow.Symbol || (function(){\n  var id = 0;\n  window.Symbol = function(description){\n    if(this instanceof Symbol)throw new TypeError('Symbol is not a constructor');\n    var symbol = Object.create(Symbol.prototype)\n      , tag    = 'Symbol(' + description + ')_' + (++id + Math.random()).toString(36);\n    symbol.tag = tag;\n    Object.defineProperty(Object.prototype, tag, {\n      configurable: true,\n      set: function(it){\n        Object.defineProperty(this, tag, {\n          enumerable  : false,\n          configurable: true,\n          writable    : true,\n          value       : it\n        });\n      }\n    });\n    return symbol;\n  }\n  Symbol.prototype.toString = function(){\n    return this.tag;\n  }\n})();\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nПри вызове \u003Ccode\u003ESymbol\u003C\u002Fcode\u003E мы генерируем уникальный ключ-строку, например, \u003Ccode\u003E\"Symbol(description)_m.y9oth2pcqaypsyvi\"\u003C\u002Fcode\u003E, и по этому ключу в \u003Ccode\u003EObject.prototype\u003C\u002Fcode\u003E устанавливаем сеттер. При попытке установить значение по строке-ключу, к которой приведется наш «символ», сеттер устанавливает \u003Ccode\u003Eenumerable: false\u003C\u002Fcode\u003E свойство в текущий объект. Однако, у подобных «символов» есть огромное количество минусов, вот только часть:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cul\u003E\r\n\u003Cli\u003EПишет сеттер в \u003Ccode\u003EObject.prototype\u003C\u002Fcode\u003E: не стоит особо злоупотреблять, может повлиять на производительность.\u003C\u002Fli\u003E\r\n\u003Cli\u003EРаботает на базе дескрипторов: в IE8- работает (за счет \u003Ca href=\"#es5-desc\"\u003E# заглушки\u003C\u002Fa\u003E \u003Ccode\u003EObject.defineProperty\u003C\u002Fcode\u003E), не будет сеттеров в \u003Ccode\u003EObject.prototype\u003C\u002Fcode\u003E, «символы» будут перечисляемы.\u003C\u002Fli\u003E\r\n\u003Cli\u003EВ объектах, не содержащих под собой \u003Ccode\u003EObject.prototype\u003C\u002Fcode\u003E (например, \u003Ccode\u003EObject.create(null)\u003C\u002Fcode\u003E), «символы» будут перечисляемы.\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ccode\u003ESymbol() in {}\u003C\u002Fcode\u003E вернет \u003Ccode\u003Etrue\u003C\u002Fcode\u003E — нужно проверять наличие символов в объекте иным способом.\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ccode\u003Etypeof Symbol()\u003C\u002Fcode\u003E будет равен \u003Ccode\u003E'object'\u003C\u002Fcode\u003E — средствами JavaScript мы не можем добавить новый тип данных.\u003C\u002Fli\u003E\r\n\u003Cli\u003EНе добавляем \u003Ccode\u003EObject.getOwnPropertySymbols\u003C\u002Fcode\u003E — лишняя обертка для \u003Ccode\u003EObject.getOwnPropertyNames\u003C\u002Fcode\u003E плохо скажется на производительности, соответственно, \u003Ccode\u003EObject.getOwnPropertyNames\u003C\u002Fcode\u003E будет возвращать, в том числе, и «символы».\u003C\u002Fli\u003E\r\n\u003C\u002Ful\u003E\u003Cbr\u002F\u003E\r\n\u003Ca name=\"es6-symbol-pure\"\u003E\u003C\u002Fa\u003E\u003Ca href=\"#es6-symbol-pure\"\u003E\u003Cb\u003E#\u003C\u002Fb\u003E\u003C\u002Fa\u003E Если решение настолько сомнительно, что оно тут делает? Если в проекте нужно незначительное количество символов и не планируется их использовать с объектами, не содержащими под собой \u003Ccode\u003EObject.prototype\u003C\u002Fcode\u003E, данное решение вполне сойдет. Для остальных случаев добавим в библиотеку пару хелперов. \u003Ccode\u003ESymbol.pure\u003C\u002Fcode\u003E, если доступны нативные символы, возвращающий символ, нет — возвращающий уникальную строку-ключ без добавления сеттера в \u003Ccode\u003EObject.prototype\u003C\u002Fcode\u003E, и \u003Ccode\u003ESymbol.set\u003C\u002Fcode\u003E, если доступны нативные символы — просто устанавливающий в объект значение по ключу, нет — устанавливающий значение, используя \u003Ccode\u003EObject.defineProperty\u003C\u002Fcode\u003E с \u003Ccode\u003Eenumerable: false\u003C\u002Fcode\u003E. Таким примитивным образом, избавляемся от половины описанных выше проблем. Использованный выше пример с использованием данных хелперов вместо вызова \u003Ccode\u003ESymbol\u003C\u002Fcode\u003E выглядит \u003Ca href=\"http:\u002F\u002Fgoo.gl\u002FDmPIbT\"\u003Eтак\u003C\u002Fa\u003E:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003Evar Person = function(){\n  var NAME = Symbol.pure('name');\n  function Person(name){\n    Symbol.set(this, NAME, name);\n  }\n  Person.prototype.getName = function(){\n    return this[NAME];\n  };\n  return Person;\n}();\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Ca name=\"es6-reflect-own-keys\"\u003E\u003C\u002Fa\u003E\u003Ca href=\"#es6-reflect-own-keys\"\u003E\u003Cb\u003E#\u003C\u002Fb\u003E\u003C\u002Fa\u003E Как уже было отмечено выше, метод \u003Ccode\u003EObject.getOwnPropertySymbols\u003C\u002Fcode\u003E мы не добавляем. А хочется иметь более или менее универсальный, притом стандартизованный, способ для обхода всех ключей, как строк, так и символов. ECMAScript 6 добавляет \u003Ca href=\"http:\u002F\u002Fpeople.mozilla.org\u002F~jorendorff\u002Fes6-draft.html#sec-reflect-object\"\u003Eмодуль \u003Ccode\u003EReflect\u003C\u002Fcode\u003E\u003C\u002Fa\u003E — в первую очередь, \u003Ca href=\"https:\u002F\u002Fdeveloper.mozilla.org\u002Fen-US\u002Fdocs\u002FWeb\u002FJavaScript\u002FReference\u002FGlobal_Objects\u002FProxy#Handler_API\"\u003Eнабор заглушек\u003C\u002Fa\u003E для \u003Ccode\u003EProxy\u003C\u002Fcode\u003E. Так как мы не имеем возможность эмулировать \u003Ccode\u003EProxy\u003C\u002Fcode\u003E, модуль \u003Ccode\u003EReflect\u003C\u002Fcode\u003E нам особо и не нужен. Однако в нём есть метод \u003Ccode\u003EReflect.ownKeys\u003C\u002Fcode\u003E, возвращающий все собственные ключи объекта — как строки, так и символы, т.е. \u003Ccode\u003EObject.getOwnPropertyNames + Object.getOwnPropertySymbols\u003C\u002Fcode\u003E. Добавим этот метод. \u003Ca href=\"http:\u002F\u002Fgoo.gl\u002Ffyu6pn\"\u003EПример\u003C\u002Fa\u003E:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003Evar O = {a: 1};\nObject.defineProperty(O, 'b', {value: 2});\nO[Symbol('c')] = 3;\nReflect.ownKeys(O); \u002F\u002F =\u003E ['a', 'b', Symbol(c)]\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Ca name=\"es6-symbol-registry\"\u003E\u003C\u002Fa\u003E\u003Ca href=\"#es6-symbol-registry\"\u003E\u003Cb\u003E#\u003C\u002Fb\u003E\u003C\u002Fa\u003E Также ES6 добавляет такую сомнительную штуку, как глобальный регистр символов. Для работы с ним есть пара методов — \u003Ca href=\"https:\u002F\u002Fdeveloper.mozilla.org\u002Fen-US\u002Fdocs\u002FWeb\u002FJavaScript\u002FReference\u002FGlobal_Objects\u002FSymbol\u002Ffor\"\u003ESymbol.for\u003C\u002Fa\u003E и \u003Ca href=\"https:\u002F\u002Fdeveloper.mozilla.org\u002Fen-US\u002Fdocs\u002FWeb\u002FJavaScript\u002FReference\u002FGlobal_Objects\u002FSymbol\u002FkeyFor\"\u003ESymbol.keyFor\u003C\u002Fa\u003E. \u003Ccode\u003ESymbol.for\u003C\u002Fcode\u003E ищет в регистре и возвращает символ по ключу-строке, не находит — создаёт новый, добавляет в регистр и возвращает его. \u003Ccode\u003ESymbol.keyFor\u003C\u002Fcode\u003E возвращает строку, которой в регистре соответствует переданный символ. \u003Ca href=\"http:\u002F\u002Fgoo.gl\u002F0pdJjX\"\u003EПример\u003C\u002Fa\u003E:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003Evar symbol = Symbol.for('key');\nsymbol === Symbol.for('key'); \u002F\u002F true\nSymbol.keyFor(symbol);        \u002F\u002F 'key'\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nКо всему прочему, библиотека активно использует символы \u003Ca href=\"#es6-iterable-interface\"\u003E# \u003Ccode\u003ESymbol.iterator\u003C\u002Fcode\u003E\u003C\u002Fa\u003E и \u003Ca href=\"#classof\"\u003E# \u003Ccode\u003ESymbol.toStringTag\u003C\u002Fcode\u003E\u003C\u002Fa\u003E.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ca name=\"es6-collections\"\u003E\u003C\u002Fa\u003E\u003Ch2\u003E\u003Cb\u003E\u003Ca href=\"#es6-collections\"\u003E#\u003C\u002Fa\u003E ECMAScript 6: Коллекции\u003C\u002Fb\u003E\u003C\u002Fh2\u003E\u003Chr\u002F\u003E\u003Cbr\u002F\u003E\r\nВ ECMAScript 6 появляются 4 новых вида коллекций: \u003Ccode\u003EMap, Set, WeakMap\u003C\u002Fcode\u003E и \u003Ccode\u003EWeakSet\u003C\u002Fcode\u003E. Есть еще \u003Ca href=\"http:\u002F\u002Fhabrahabr.ru\u002Fpost\u002F119694\u002F\"\u003Eтипизированные массивы\u003C\u002Fa\u003E, но пока обойдёмся без них.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cul\u003E\r\n\u003Cli\u003E\u003Ca href=\"#es6-collections-overview\"\u003E# Описание коллекций\u003C\u002Fa\u003E\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ca href=\"#es6-collections-support\"\u003E# Поддержка движками\u003C\u002Fa\u003E\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ca href=\"#es6-map-set\"\u003E# Реализация \u003Ccode\u003EMap\u003C\u002Fcode\u003E и \u003Ccode\u003ESet\u003C\u002Fcode\u003E\u003C\u002Fa\u003E\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ca href=\"#es6-weak\"\u003E# Реализация слабосвязанных коллекций\u003C\u002Fa\u003E\u003C\u002Fli\u003E\r\n\u003C\u002Ful\u003E\u003Cbr\u002F\u003E\r\n\u003Ca name=\"es6-collections-overview\"\u003E\u003C\u002Fa\u003E\u003Ca href=\"#es6-collections-overview\"\u003E\u003Cb\u003E#\u003C\u002Fb\u003E\u003C\u002Fa\u003E Итак, что собой представляют данные коллекции?\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ca name=\"es6-map\"\u003E\u003C\u002Fa\u003E\u003Ca href=\"#es6-map\"\u003E\u003Cb\u003E#\u003C\u002Fb\u003E\u003C\u002Fa\u003E \u003Cb\u003E\u003Ca href=\"https:\u002F\u002Fdeveloper.mozilla.org\u002Fen-US\u002Fdocs\u002FWeb\u002FJavaScript\u002FReference\u002FGlobal_Objects\u002FMap\"\u003EMap\u003C\u002Fa\u003E\u003C\u002Fb\u003E — коллекция ключ — значение, в качестве ключей могут выступать любые сущности JavaScript — как примитивы, так и объекты. Есть возможность обхода — имеют \u003Ca href=\"#es6-iterators\"\u003E# итераторы\u003C\u002Fa\u003E и метод \u003Ccode\u003E.forEach\u003C\u002Fcode\u003E, количество элементов доступно через свойство \u003Ccode\u003E.size\u003C\u002Fcode\u003E. \u003Ca href=\"http:\u002F\u002Fgoo.gl\u002FRDbROF\"\u003EПример\u003C\u002Fa\u003E:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003Evar a = [1];\n\nvar map = new Map([['a', 1], [42, 2]]);\nmap.set(a, 3).set(true, 4);\n\nconsole.log(map.size);        \u002F\u002F =\u003E 4\nconsole.log(map.has(a));      \u002F\u002F =\u003E true\nconsole.log(map.has([1]));    \u002F\u002F =\u003E false\nconsole.log(map.get(a));      \u002F\u002F =\u003E 3\nmap.forEach(function(val, key){\n  console.log(val);           \u002F\u002F =\u003E 1, 2, 3, 4\n  console.log(key);           \u002F\u002F =\u003E 'a', 42, [1], true\n});\nmap.delete(a);\nconsole.log(map.size);        \u002F\u002F =\u003E 3\nconsole.log(map.get(a));      \u002F\u002F =\u003E undefined\nconsole.log(Array.from(map)); \u002F\u002F =\u003E [['a', 1], [42, 2], [true, 4]]\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Ca name=\"es6-set\"\u003E\u003C\u002Fa\u003E\u003Ca href=\"#es6-set\"\u003E\u003Cb\u003E#\u003C\u002Fb\u003E\u003C\u002Fa\u003E \u003Cb\u003E\u003Ca href=\"https:\u002F\u002Fdeveloper.mozilla.org\u002Fen-US\u002Fdocs\u002FWeb\u002FJavaScript\u002FReference\u002FGlobal_Objects\u002FSet\"\u003ESet\u003C\u002Fa\u003E\u003C\u002Fb\u003E — коллекция уникальных значений. Как и у \u003Ccode\u003EMap\u003C\u002Fcode\u003E, есть возможность обхода. \u003Ca href=\"http:\u002F\u002Fgoo.gl\u002F7XYya3\"\u003EПример\u003C\u002Fa\u003E:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003Evar set = new Set(['a', 'b', 'a', 'c']);\nset.add('d').add('b').add('e');\nconsole.log(set.size);        \u002F\u002F =\u003E 5\nconsole.log(set.has('b'));    \u002F\u002F =\u003E true\nset.forEach(function(it){\n  console.log(it);            \u002F\u002F =\u003E 'a', 'b', 'c', 'd', 'e'\n});\nset.delete('b');\nconsole.log(set.size);        \u002F\u002F =\u003E 4\nconsole.log(set.has('b'));    \u002F\u002F =\u003E false\nconsole.log(Array.from(set)); \u002F\u002F =\u003E ['a', 'c', 'd', 'e']\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Ca name=\"es6-weakmap\"\u003E\u003C\u002Fa\u003E\u003Ca href=\"#es6-weakmap\"\u003E\u003Cb\u003E#\u003C\u002Fb\u003E\u003C\u002Fa\u003E \u003Cb\u003E\u003Ca href=\"https:\u002F\u002Fdeveloper.mozilla.org\u002Fen-US\u002Fdocs\u002FWeb\u002FJavaScript\u002FReference\u002FGlobal_Objects\u002FWeakMap\"\u003EWeakMap\u003C\u002Fa\u003E\u003C\u002Fb\u003E — коллекция ключ-значение, в качестве ключей могут выступать \u003Cb\u003Eтолько объекты\u003C\u002Fb\u003E. Использует слабую связь — когда объект-ключ удаляется (сборщиком мусора), удаляется и пара ключ-значение из коллекции. Нет возможности обойти — нет итераторов и метода \u003Ccode\u003E.forEach\u003C\u002Fcode\u003E, нет свойства \u003Ccode\u003E.size\u003C\u002Fcode\u003E. Это еще один способ хранения приватных данных, более «честный», но и \u003Ca href=\"https:\u002F\u002Fesdiscuss.org\u002Ftopic\u002Fweakmap-better-than-private-symbols-was-direct-proxies-problem#content-8\"\u003Eболее ресурсоёмкий\u003C\u002Fa\u003E, по сравнению с использованием \u003Ca href=\"#es6-symbol\"\u003E# символов\u003C\u002Fa\u003E. Если в будущем в JavaScript таки добавят \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fzenparsing\u002Fes-abstract-refs#examples\"\u003Eabstract references\u003C\u002Fa\u003E, для подобных приватных полей появится удобный синтаксис. \u003Ca href=\"http:\u002F\u002Fgoo.gl\u002FwCvuq3\"\u003EПример\u003C\u002Fa\u003E:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003Evar a = [1]\n  , b = [2]\n  , c = [3];\n\nvar wmap = new WeakMap([[a, 1], [b, 2]]);\nwmap.set(c, 3).set(b, 4);\nconsole.log(wmap.has(a));   \u002F\u002F =\u003E true\nconsole.log(wmap.has([1])); \u002F\u002F =\u003E false\nconsole.log(wmap.get(a));   \u002F\u002F =\u003E 1\nwmap.delete(a);\nconsole.log(wmap.get(a));   \u002F\u002F =\u003E undefined\n\n\u002F\u002F Так можно хранить приватные данные\nvar Person = (function(){\n  var names = new WeakMap;\n  function Person(name){\n    names.set(this, name);\n  }\n  Person.prototype.getName = function(){\n    return names.get(this);\n  };\n  return Person;\n})();\n\nvar person = new Person('Вася');\nconsole.log(person.getName());          \u002F\u002F =\u003E 'Вася'\nfor(var key in person)console.log(key); \u002F\u002F =\u003E только 'getName'\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Ca name=\"es6-weakset\"\u003E\u003C\u002Fa\u003E\u003Ca href=\"#es6-weakset\"\u003E\u003Cb\u003E#\u003C\u002Fb\u003E\u003C\u002Fa\u003E \u003Cb\u003E\u003Ca href=\"https:\u002F\u002Fdeveloper.mozilla.org\u002Fen-US\u002Fdocs\u002FWeb\u002FJavaScript\u002FReference\u002FGlobal_Objects\u002FWeakSet\"\u003EWeakSet\u003C\u002Fa\u003E\u003C\u002Fb\u003E — ну вы поняли. Появился в черновике спецификации относительно недавно, так что имеет довольно слабую поддержку браузерами. \u003Ca href=\"http:\u002F\u002Fgoo.gl\u002FTdFbEx\"\u003EПример\u003C\u002Fa\u003E:\u003Cbr\u002F\u003E\r\n \u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003Evar a = [1]\n  , b = [2]\n  , c = [3];\n\nvar wset = new WeakSet([a, b, a]);\nwset.add(c).add(b).add(c);\nconsole.log(wset.has(b));   \u002F\u002F =\u003E true\nconsole.log(wset.has([2])); \u002F\u002F =\u003E false\nwset.delete(b);\nconsole.log(wset.has(b));   \u002F\u002F =\u003E false\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nВсе эти коллекции \u003Cb\u003Eдолжны\u003C\u002Fb\u003E обеспечивать сублинейное время поиска. Уникальность ключа обеспечивается алгоритмом сравнения \u003Ca href=\"#same-value-zero\"\u003E# SameValueZero\u003C\u002Fa\u003E.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ca name=\"es6-collections-support\"\u003E\u003C\u002Fa\u003E\u003Cb\u003E\u003Ca href=\"#es6-collections-support\"\u003E#\u003C\u002Fa\u003E\u003C\u002Fb\u003E Что с поддержкой этих коллекций у современных движков js? Очень даже неплохо.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cul\u003E\r\n\u003Cli\u003EВ \u003Cb\u003EFirefox\u003C\u002Fb\u003E есть полноценные \u003Ccode\u003EMap, Set\u003C\u002Fcode\u003E и \u003Ccode\u003EWeakMap\u003C\u002Fcode\u003E. В ночных сборках появился и \u003Ccode\u003EWeakSet\u003C\u002Fcode\u003E. \u003Ccode\u003EMap\u003C\u002Fcode\u003E и \u003Ccode\u003ESet\u003C\u002Fcode\u003E принимают итерируемый объект. \u003Ccode\u003EMap\u003C\u002Fcode\u003E и \u003Ccode\u003ESet\u003C\u002Fcode\u003E имеют итераторы и метод \u003Ccode\u003E.forEach\u003C\u002Fcode\u003E.\u003C\u002Fli\u003E\r\n\u003Cli\u003EВ \u003Cb\u003Ev8\u003C\u002Fb\u003E — читай \u003Cb\u003EChrome, Opera и Node.js\u003C\u002Fb\u003E, есть все 4 новых вида коллекций. Начиная с Chrome 38, все они доступны без каких либо манипуляций. Чуть раньше были открыты \u003Ccode\u003EWeakMap\u003C\u002Fcode\u003E и \u003Ccode\u003EWeakSet\u003C\u002Fcode\u003E. В более ранних версиях коллекции доступны \u003Ca href=\"#v8-harmony-mode\"\u003E# с флажком экспериментальных возможностей\u003C\u002Fa\u003E. До самых последних версий v8 конструкторы не принимали итерируемый объект, а у \u003Ccode\u003EMap\u003C\u002Fcode\u003E и \u003Ccode\u003ESet\u003C\u002Fcode\u003E отсутствовали итераторы и метод \u003Ccode\u003E.forEach\u003C\u002Fcode\u003E, что делало нативные \u003Ccode\u003EMap\u003C\u002Fcode\u003E и \u003Ccode\u003ESet\u003C\u002Fcode\u003E чуть менее, чем полностью бесполезными.\u003C\u002Fli\u003E\r\n\u003Cli\u003EВ \u003Cb\u003EIE11\u003C\u002Fb\u003E появились те же \u003Ccode\u003EMap, Set\u003C\u002Fcode\u003E и \u003Ccode\u003EWeakMap\u003C\u002Fcode\u003E. Конструкторы не принимают итерируемый объект. \u003Ccode\u003EMap\u003C\u002Fcode\u003E и \u003Ccode\u003ESet\u003C\u002Fcode\u003E не имеют итераторов, но у них есть метод \u003Ccode\u003E.forEach\u003C\u002Fcode\u003E.\u003C\u002Fli\u003E\r\n\u003Cli\u003EВ \u003Cb\u003ESafari\u003C\u002Fb\u003E всё просто замечательно, лучше бы вообще никак. Есть \u003Ccode\u003EMap, Set\u003C\u002Fcode\u003E и \u003Ccode\u003EWeakMap\u003C\u002Fcode\u003E. Инициализация итератором отсутствует. Вроде бы, есть методы, возвращающие итераторы, но, внезапно, у некоторых итераторов отсутствует метод \u003Ccode\u003Enext\u003C\u002Fcode\u003E. Есть \u003Ccode\u003EforEach\u003C\u002Fcode\u003E, но метод передаёт в коллбэк не 3 аргумента, как должно быть, а только 1 для \u003Ccode\u003ESet\u003C\u002Fcode\u003E и 2 для \u003Ccode\u003EMap\u003C\u002Fcode\u003E.\u003C\u002Fli\u003E\r\n\u003C\u002Ful\u003E\u003Cbr\u002F\u003E\r\nПочти во всех текущих реализациях методы коллекций \u003Ccode\u003E.add\u003C\u002Fcode\u003E и \u003Ccode\u003E.set\u003C\u002Fcode\u003E не возвращают \u003Ccode\u003Ethis\u003C\u002Fcode\u003E — заполнить коллекцию цепочкой этих методов не получится. Но это легко лечится.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nДля инициализации коллекции итератором также достаточно обертки для конструктора, которая создаст коллекцию и добавит элементы. Про сами итераторы поговорим в \u003Ca href=\"#es6-iterators\"\u003E# следующей главе\u003C\u002Fa\u003E.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nНу а полифилы самих коллекций рассмотрим дальше. Полноценная реализация данных коллекций — быстрых, при этом чистых и без утечек памяти (для WeakMap), на базе ECMAScript 5 невозможна, однако, можно найти разумный компромисс.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ca name=\"es6-map-set\"\u003E\u003C\u002Fa\u003E\u003Ch4\u003E\u003Cb\u003E\u003Ca href=\"#es6-map-set\"\u003E#\u003C\u002Fa\u003E Реализация Map и Set\u003C\u002Fb\u003E\u003C\u002Fh4\u003E\u003Cbr\u002F\u003E\r\nЧто в большинстве полифилов представляют собой реализации \u003Ccode\u003EMap\u003C\u002Fcode\u003E? В инстансе \u003Ccode\u003EMap\u003C\u002Fcode\u003E — 2 массива, ключи и значения. При получении элемента, ищем совпадение в массиве ключей и возвращаем элемент из массива значений по полученному индексу. Или, для оптимизации удаления, альтернативный вариант — цепочка объектов-вхождений. Что не так и в том, и в другом случае? Это очень медленно, сложность поиска элемента — O(n), сложность операции uniq — O(n\u003Csup\u003E2\u003C\u002Fsup\u003E). Чем это нам грозит? Вот небольшой тест:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003Evar array = [];\nfor(var i = 0; i &lt; 100000; i++)array.push([{}, {}]);\narray = array.concat(array);\nconsole.time('Map test');\nvar map = new Map(array);\nconsole.timeEnd('Map test');\nconsole.log('Map size: ' + map.size);\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nСоздаём массив из 200000 тысяч пар объектов (будущие ключ-значение), 100000 из которых уникальны, после чего создаём из этого массива коллекцию \u003Ccode\u003EMap\u003C\u002Fcode\u003E.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nИспытаем нативный \u003Ccode\u003EMap\u003C\u002Fcode\u003E, например, в Firefox:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003EMap test: таймер запущен\nMap test: 46.25мс\nMap size: 100000\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nА теперь в нём же \u003Ccode\u003EMap\u003C\u002Fcode\u003E из \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fpaulmillr\u002Fes6-shim\"\u003Eсамого популярного\u003C\u002Fa\u003E полифила ECMAScript 6:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003EMap test: таймер запущен\nMap test: 506823.31мс\nMap size: 100000\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nПримерно 8.5 минут. При попытке добавления каждого нового элемента приходится перебирать до 100000 уже добавленных. Отсюда можно сделать вывод, что данный подход годится только для очень маленьких коллекций.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nСублинейной скорости полифила можно добиться используя хэш-таблицы. В ECMAScript 5 это только \u003Ccode\u003EObject\u003C\u002Fcode\u003E, принимающий в качестве ключа исключительно строки. В протестированном выше полифиле есть небольшая оптимизация — поисковый индекс для ключа-строки или числа через простую функцию, уменьшающий среднюю сложность поиска элемента коллекции до O(1):\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003Efunction fastKey(key){\n  if(typeof key === 'string')return '$' + key;\n  else if(typeof key === 'number')return key;\n  return null;\n};\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nТочно так же можно реализовать быстрый доступ и для остальных примитивов. Вот только зачем нужен \u003Ccode\u003EMap\u003C\u002Fcode\u003E, в качестве ключей которого можно эффективно использовать только примитивы? \u003Ccode\u003EObject.create(null)\u003C\u002Fcode\u003E с этим \u003Ca href=\"#dict\"\u003E# вполне справляется\u003C\u002Fa\u003E.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nПросто взять и получить уникальную строку-идентификатор для ключа-объекта не получится. Поэтому придется слегка нарушить правила. Давайте будем добавлять при необходимости объектам-ключам символ с идентификатором. Примерно так:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003Evar STOREID = Symbol('storeId')\n  , id      = 0;\nfunction fastKey(it){\n  \u002F\u002F Возвращаем с префиксом 'S' если строка и с префиксом 'P' если другой примитив\n  if(it !== Object(it))return (typeof it == 'string' ? 'S' : 'P') + it;\n  \u002F\u002F Если у объекта отсутствует идентификатор - добавляем\n  if(!Object.hasOwnProperty.call(it, STOREID))it[STOREID] = ++id;\n  \u002F\u002F Возвращаем идентификатор с префиксом 'O'\n  return 'O' + it[STOREID];\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nРеализуем \u003Ccode\u003EMap\u003C\u002Fcode\u003E не на 2 массивах или цепочке объектов-элементов, а на 2 хэшах \u003Ccode\u003EObject\u003C\u002Fcode\u003E, так же для ключей и значений. Другого хранилища ключей \u002F значений для обхода коллекции в порядке добавления нам не нужно: во всех движках ключи объектов хранятся в порядке добавления, за исключением ключей-чисел, но так как здесь у всех ключей префикс-буква, таковые отсутствуют. Итого, получаем:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode\u003EMap test: таймер запущен\nMap test: 669.93мс\nMap size: 100000\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nКонечно, медленнее нативных, но, думаю, вполне сойдет. Да, мы пишем скрытое свойство в ключ-объект — невозможно использовать в качестве ключей \u003Ca href=\"#es5-freeze\"\u003E# frozen-объекты\u003C\u002Fa\u003E, но зато получаем приемлемую скорость работы. \u003Ccode\u003ESet\u003C\u002Fcode\u003E реализуется аналогично, на 1 хэше.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ca name=\"es6-weak\"\u003E\u003C\u002Fa\u003E\u003Ch4\u003E\u003Cb\u003E\u003Ca href=\"#es6-weak\"\u003E#\u003C\u002Fa\u003E Реализация слабосвязанных коллекций\u003C\u002Fb\u003E\u003C\u002Fh4\u003E\u003Cbr\u002F\u003E\r\nСлабосвязанные коллекции реализуем еще проще. У них нет итераторов, метода \u003Ccode\u003E.forEach\u003C\u002Fcode\u003E, свойства \u003Ccode\u003E.size\u003C\u002Fcode\u003E. В случае хранения ключей и значений в объекте коллекции, она уже не будет слабосвязанной — ключи \u002F значения не будут удаляться, получим просто урезанную версию \u003Ccode\u003ESet\u003C\u002Fcode\u003E и \u003Ccode\u003EMap\u003C\u002Fcode\u003E. Единственное более или менее разумное решение давно известно — хранить значения на ключе, а в объекте коллекции — только её идентификатор. Так как значения хранятся на ключе, в полифиле теряется полная приватность хранимых данных.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cdiv class=\"spoiler\"\u003E\u003Cb class=\"spoiler_title\"\u003EСильно упрощённая их реализация выглядит так:\u003C\u002Fb\u003E\u003Cdiv class=\"spoiler_text\"\u003E\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003Ewindow.WeakMap || (function(){\n  var id       = 0\n    , has      = Function.call.bind(Object.prototype.hasOwnProperty)\n    , WEAKDATA = Symbol('WeakData')\n    , ID       = Symbol('ID');\n  window.WeakMap = function(){\n    if(!(this instanceof WeakMap))throw TypeError();\n    this[ID] = id++;\n  }\n  Object.assign(WeakMap.prototype, {\n    'delete': function(key){\n      return this.has(key) &amp;&amp; delete key[WEAKDATA][this[ID]];\n    },\n    has: function(key){\n      return key === Object(key) &amp;&amp; has(key, WEAKDATA) &amp;&amp; has(key[WEAKDATA], this[ID]);\n    },\n    get: function(key){\n      if(key === Object(key) &amp;&amp; has(key, WEAKDATA))return key[WEAKDATA][this[ID]];\n    },\n    set: function(key, value){\n      if(key !== Object(key))throw TypeError();\n      if(!has(key, WEAKDATA))key[WEAKDATA] = {};\n      key[WEAKDATA][this[ID]] = value;\n      return this;\n    }\n  });\n})();\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003C\u002Fdiv\u003E\u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\nДавайте убедимся, что при удалении ссылки на ключ он не остаётся в коллекции и, соответственно, память не утекает:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003E\u002F\u002F &lt;- тут делаем snapshot 1\nvar array = [];\nfor(var i = 0; i &lt; 100000; i++)array[i] = {};\nvar wm = new WeakMap();\nfor(var i = 0; i &lt; 100000; i++)wm.set(array[i], {});\n\u002F\u002F &lt;- тут делаем snapshot 2\narray = null;\n\u002F\u002F &lt;- тут делаем snapshot 3\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cimg src=\"\u002F\u002Fhabrastorage.org\u002Fr\u002Fw1560\u002Ffiles\u002F7b2\u002Fa07\u002Fb54\u002F7b2a07b54f664478a8b7a25be220cbe2.png\" data-src=\"\u002F\u002Fhabrastorage.org\u002Ffiles\u002F7b2\u002Fa07\u002Fb54\u002F7b2a07b54f664478a8b7a25be220cbe2.png\"\u002F\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cb\u003EНо в некоторых случаях проблема утечки памяти остаётся.\u003C\u002Fb\u003E После удаления объекта коллекции, значение останется связанным с ключом, что приведет к утечке памяти до момента удаления объекта, бывшего ключом. Так что по-хорошему систему проектировать стоит так, что бы коллекции \u003Ccode\u003EWeakMap\u003C\u002Fcode\u003E жили дольше, чем их ключи. Кто-то \u003Ca href=\"\u002Fcompany\u002Fuprock\u002Fblog\u002F200644\u002F\"\u003Eпытается\u003C\u002Fa\u003E обойти проблему утечки памяти, но это из разряда эзотерики — \u003Ca href=\"\u002Fcompany\u002Fuprock\u002Fblog\u002F200644\u002F#comment_6941924\"\u003Eпамять утекает точно в тех же случаях\u003C\u002Fa\u003E.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nУ реализации \u003Ccode\u003EWeakSet\u003C\u002Fcode\u003E эта проблема остается, но сведена к минимуму — вместо значения, что может быть тяжелым объектом, на ключе хранится только флаг наличия в коллекции.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ca name=\"es6-iterators\"\u003E\u003C\u002Fa\u003E\u003Ch2\u003E\u003Cb\u003E\u003Ca href=\"#es6-iterators\"\u003E#\u003C\u002Fa\u003E ECMAScript 6: Итераторы\u003C\u002Fb\u003E\u003C\u002Fh2\u003E\u003Chr\u002F\u003E\u003Cbr\u002F\u003E\r\nВ ECMAScript 6 появился протокол итераторов — универсальный способ обхода коллекций, и не только. Так как к нему относятся и синтаксические конструкции, рассмотрим и их. Но, в первую очередь, это не часть стандартной библиотеки или синтаксиса, а концепция. К протоколу итераторов можно отнести:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cul\u003E\r\n\u003Cli\u003E\u003Ca href=\"#es6-iter-interface\"\u003E# Интерфейс итератора\u003C\u002Fa\u003E\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ca href=\"#es6-iterable-interface\"\u003E# Интерфейс итерируемого объекта, символ \u003Ccode\u003ESymbol.iterator\u003C\u002Fcode\u003E\u003C\u002Fa\u003E\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ca href=\"#es6-generators\"\u003E# Генераторы\u003C\u002Fa\u003E\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ca href=\"#es6-for-of\"\u003E# Цикл \u003Ccode\u003Efor-of\u003C\u002Fcode\u003E\u003C\u002Fa\u003E\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ca href=\"#es6-native-iterables\"\u003E# Итераторы инстансов встроенных конструкторов и методы, их возвращающие\u003C\u002Fa\u003E\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ca href=\"#es6-use-iter\"\u003E# Методы и конструкторы, принимающие итерируемые объекты\u003C\u002Fa\u003E\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ca href=\"#es6-spread\"\u003E# Оператор spread\u003C\u002Fa\u003E\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ca href=\"#es6-comprehensions\"\u003E# Array \u002F generator comprehensions\u003C\u002Fa\u003E\u003C\u002Fli\u003E\r\n\u003C\u002Ful\u003E\u003Cbr\u002F\u003E\r\nТак как часть этого — синтаксис, в этой главе также рассмотрим модуль \u003Ccode\u003E$for\u003C\u002Fcode\u003E, что реализует часть возможностей этих синтаксических конструкций. Если собираетесь использовать библиотеку с \u003Ca href=\"#preprocessors\"\u003E# препроцессором ES6+\u003C\u002Fa\u003E, можете спокойно собирать её без данного модуля.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ca name=\"es6-iter-interface\"\u003E\u003C\u002Fa\u003E\u003Ca href=\"#es6-iter-interface\"\u003E\u003Cb\u003E#\u003C\u002Fb\u003E\u003C\u002Fa\u003E \u003Cb\u003EИтератор\u003C\u002Fb\u003E — объект, имеющий метод \u003Ccode\u003E.next\u003C\u002Fcode\u003E, который должен возвращать объект с полями \u003Ccode\u003E.done\u003C\u002Fcode\u003E — завершен ли обход итератора, и \u003Ccode\u003E.value\u003C\u002Fcode\u003E — значение текущего шага. Пример — метод, создающий итератор для положительного числа, позволяющий обойти все целые от 0 до заданного (\u003Ca href=\"http:\u002F\u002Fgoo.gl\u002Fj9evDY\"\u003Eпесочница\u003C\u002Fa\u003E):\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003Efunction NumberIterator(number){\n  var i = 0;\n  return {\n    next: function(){\n      return i &lt; number\n        ? {done: false, value: i++}\n        : {done: true};\n    }\n  }\n}\n\nvar iter = NumberIterator(3);\niter.next(); \u002F\u002F =\u003E {done: false, value: 0}\niter.next(); \u002F\u002F =\u003E {done: false, value: 1}\niter.next(); \u002F\u002F =\u003E {done: false, value: 2}\niter.next(); \u002F\u002F =\u003E {done: true}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Ca name=\"es6-iterable-interface\"\u003E\u003C\u002Fa\u003E\u003Ca href=\"#es6-iterable-interface\"\u003E\u003Cb\u003E#\u003C\u002Fb\u003E\u003C\u002Fa\u003E \u003Cb\u003EИтерируемый объект\u003C\u002Fb\u003E (Iterable) — объект, у которого по ключу \u003Ccode\u003ESymbol.iterator\u003C\u002Fcode\u003E содержится метод, возвращающий для него итератор. Соответственно, что бы и итератор был итерируемым, по ключу \u003Ccode\u003ESymbol.iterator\u003C\u002Fcode\u003E у него должен быть метод, возвращающий \u003Ccode\u003Ethis\u003C\u002Fcode\u003E. Для примера, сделаем числа итерируемыми (\u003Ca href=\"http:\u002F\u002Fgoo.gl\u002F598H0u\"\u003Eпесочница\u003C\u002Fa\u003E):\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003ENumber.prototype[Symbol.iterator] = function(){\n  return NumberIterator(this);\n}\n\nArray.from(10); \u002F\u002F =\u003E [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nОбратите внимание на \u003Ccode\u003ESymbol.iterator\u003C\u002Fcode\u003E. В Firefox поддерживается протокол итераторов, но в нём, в стабильных сборках, пока нет \u003Ca href=\"#es6-symbol\"\u003E# символов\u003C\u002Fa\u003E и вместо \u003Ccode\u003ESymbol.iterator\u003C\u002Fcode\u003E используется строка \u003Ccode\u003E\"@@iterator\"\u003C\u002Fcode\u003E. В ночных сборках появились символы и даже \u003Ccode\u003ESymbol.iterator\u003C\u002Fcode\u003E, но в протоколе итераторов пока продолжает использоваться строка \u003Ccode\u003E\"@@iterator\"\u003C\u002Fcode\u003E. Чтобы не сломать протокол итераторов в Firefox, в нем в нашей библиотеке мы будем дублировать методы для получения итератора и по ключу \u003Ccode\u003ESymbol.iterator\u003C\u002Fcode\u003E (создаём, если отсутствует), и по ключу \u003Ccode\u003E\"@@iterator\"\u003C\u002Fcode\u003E. В v8 полноценная поддержка протокола итераторов появилась с Chrome 38.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ca name=\"es6-generators\"\u003E\u003C\u002Fa\u003E\u003Ca href=\"#es6-generators\"\u003E\u003Cb\u003E#\u003C\u002Fb\u003E\u003C\u002Fa\u003E \u003Cb\u003EГенератор\u003C\u002Fb\u003E — функция, выполнение которой можно приостановить. Возвращает объект с расширенным интерфейсом итератора. Подробно их мы рассматривать не будем — синтаксис — смотрите, например, в \u003Ca href=\"http:\u002F\u002Fhabrahabr.ru\u002Fpost\u002F210330\u002F\"\u003Eэтой\u003C\u002Fa\u003E статье. Для препроцессора, пожалуй, самая страшная часть ECMAScript 6. Пример с итерируемыми числами при использовании генератора выглядит совсем просто (\u003Ca href=\"http:\u002F\u002Fgoo.gl\u002FL6IE5S\"\u003Eпесочница\u003C\u002Fa\u003E):\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003ENumber.prototype[Symbol.iterator] = function*(){\n  for(var i = 0; i &lt; this;)yield i++;\n}\n\nArray.from(10); \u002F\u002F =\u003E [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Ca name=\"es6-for-of\"\u003E\u003C\u002Fa\u003E\u003Ca href=\"#es6-for-of\"\u003E\u003Cb\u003E#\u003C\u002Fb\u003E\u003C\u002Fa\u003E \u003Cb\u003EЦикл \u003Ccode\u003Efor-of\u003C\u002Fcode\u003E\u003C\u002Fb\u003E предназначен для обхода итерируемых объектов. На нашем примере с итерируемыми числами он работает так (\u003Ca href=\"http:\u002F\u002Fgoo.gl\u002FHcnp3z\"\u003Eпесочница\u003C\u002Fa\u003E):\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003Efor(var num of 5)console.log(num); \u002F\u002F =\u003E 0, 1, 2, 3, 4\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Ca name=\"es6-native-iterables\"\u003E\u003C\u002Fa\u003E\u003Ca href=\"#es6-native-iterables\"\u003E\u003Cb\u003E#\u003C\u002Fb\u003E\u003C\u002Fa\u003E В ECMAScript 6 искаропки итерируемы \u003Ccode\u003EString, Array, Map, Set\u003C\u002Fcode\u003E и \u003Ccode\u003EArguments\u003C\u002Fcode\u003E. Кроме того, \u003Ccode\u003EArray, Map\u003C\u002Fcode\u003E и \u003Ccode\u003ESet\u003C\u002Fcode\u003E имеют методы \u003Ccode\u003E.keys, .values\u003C\u002Fcode\u003E и \u003Ccode\u003E.entries\u003C\u002Fcode\u003E, которые возвращают итераторы соответственно по ключам, значениям и паре ключ-значение. \u003Cb\u003ECore.js добавляет данные итераторы и методы.\u003C\u002Fb\u003E Вместе с циклом \u003Ccode\u003Efor-of\u003C\u002Fcode\u003E это выглядит так (\u003Ca href=\"http:\u002F\u002Fgoo.gl\u002FArArLq\"\u003Eпесочница\u003C\u002Fa\u003E):\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003Evar string = 'abc';\n\nfor(var val of string)console.log(val);         \u002F\u002F =\u003E 'a', 'b', 'c'\n\nvar array = ['a', 'b', 'c'];\n\nfor(var val of array)console.log(val);          \u002F\u002F =\u003E 'a', 'b', 'c'. Итератор по умолчанию - .values\nfor(var val of array.values())console.log(val); \u002F\u002F =\u003E 'a', 'b', 'c'\nfor(var key of array.keys())console.log(key);   \u002F\u002F =\u003E 0, 1, 2\nfor(var [key, val] of array.entries()){\n  console.log(key);                             \u002F\u002F =\u003E 0, 1, 2\n  console.log(val);                             \u002F\u002F =\u003E 'a', 'b', 'c'\n}\n\nvar map = new Map([['a', 1], ['b', 2], ['c', 3]]);\n\nfor(var [key, val] of map){                     \u002F\u002F Итератор по умолчанию - .entries\n  console.log(key);                             \u002F\u002F =\u003E 'a', 'b', 'c'\n  console.log(val);                             \u002F\u002F =\u003E 1, 2, 3\n}\nfor(var val of map.values())console.log(val);   \u002F\u002F =\u003E 1, 2, 3\nfor(var key of map.keys())console.log(key);     \u002F\u002F =\u003E 'a', 'b', 'c'\nfor(var [key, val] of map.entries()){\n  console.log(key);                             \u002F\u002F =\u003E 'a', 'b', 'c'\n  console.log(val);                             \u002F\u002F =\u003E 1, 2, 3\n}\n\nvar set = new Set([1, 2, 3, 2, 1]);\n\nfor(var val of set)console.log(val);            \u002F\u002F =\u003E 1, 2, 3. Итератор по умолчанию - .values\nfor(var val of set.values())console.log(val);   \u002F\u002F =\u003E 1, 2, 3\nfor(var key of set.keys())console.log(key);     \u002F\u002F =\u003E 1, 2, 3. Итератор .keys аналогичен .values\nfor(var [key, val] of set.entries()){           \u002F\u002F У Set в итераторе .entries ключ и значение равны\n  console.log(key);                             \u002F\u002F =\u003E 1, 2, 3\n  console.log(val);                             \u002F\u002F =\u003E 1, 2, 3\n}\n\nvar list = (function(){return arguments})(1, 2, 3);\n\nfor(var val of list)console.log(val);           \u002F\u002F =\u003E 1, 2, 3\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Cul\u003E\r\n\u003Cli\u003EВ актуальном Firefox есть все данные итераторы, кроме итератора \u003Ccode\u003Earguments\u003C\u002Fcode\u003E. Цикл работает, но на базе собственного, устаревшего, протокола.\u003C\u002Fli\u003E\r\n\u003Cli\u003EВ v8, цикл \u003Ccode\u003Efor-of\u003C\u002Fcode\u003E, начиная с Chrome 38, работает корректно (не считая деструкции массива) и доступны все данные итераторы, кроме \u003Ccode\u003Earguments\u003C\u002Fcode\u003E. В старых версиях (с флажком) ожидал итератор, а не итерируемый объект.\u003C\u002Fli\u003E\r\n\u003Cli\u003EВ IE, само собой, данный цикл пока не работает и итераторы отсутствуют.\u003C\u002Fli\u003E\r\n\u003C\u002Ful\u003E\u003Cbr\u002F\u003E\r\n\u003Ca name=\"for-of-helper\"\u003E\u003C\u002Fa\u003E\u003Ca href=\"#for-of-helper\"\u003E\u003Cb\u003E#\u003C\u002Fb\u003E\u003C\u002Fa\u003E Раз всё так плохо с поддержкой синтаксиса данного цикла, для тех, кто не использует препроцессоры ES6+, добавим в библиотеку хелпер, реализующий функционал, аналогичный \u003Ccode\u003Efor-of\u003C\u002Fcode\u003E (\u003Ca href=\"http:\u002F\u002Fgoo.gl\u002FB1QWlf\"\u003Eпесочница\u003C\u002Fa\u003E):\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003E$for(new Set([1, 2, 3, 2, 1])).of(function(it){\n  console.log(it); \u002F\u002F =\u003E 1, 2, 3\n});\n\n\u002F\u002F 2й аргумент $for - флаг entries - в коллбэк передаётся 2 аргумента\n$for([1, 2, 3].entries(), true).of(function(key, value){\n  console.log(key);   \u002F\u002F =\u003E 0, 1, 2\n  console.log(value); \u002F\u002F =\u003E 1, 2, 3\n});\n\n\u002F\u002F 2й аргумент .of - контекст исполнения коллбэка\n$for('abc').of(console.log, console); \u002F\u002F =\u003E 'a', 'b', 'c'\n\n\u002F\u002F Можно прервать обход итератора, вернув из коллбэка false\n$for([1, 2, 3, 4, 5]).of(function(it){\n  console.log(it); \u002F\u002F =\u003E 1, 2, 3\n  if(it == 3)return false;\n});\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Ca name=\"iter-helpers\"\u003E\u003C\u002Fa\u003E\u003Ca href=\"#iter-helpers\"\u003E\u003Cb\u003E#\u003C\u002Fb\u003E\u003C\u002Fa\u003E Прототип объекта \u003Ccode\u003Earguments\u003C\u002Fcode\u003E — \u003Ccode\u003EObject.prototype\u003C\u002Fcode\u003E, так что положить метод для получения его итератора в прототип мы не можем. Также есть вариант сборки \u003Cb\u003Ecore.js\u003C\u002Fb\u003E как библиотеки, без расширения нативных объектов. По этим причинам, вынесем наружу пару хелперов, для проверки, является ли объект итерируемым и для получения итератора объекта — \u003Ccode\u003E$for.isIterable(foo)\u003C\u002Fcode\u003E, как аналог \u003Ccode\u003ESymbol.iterator in foo\u003C\u002Fcode\u003E и \u003Ccode\u003E$for.getIterator(foo)\u003C\u002Fcode\u003E, как аналог \u003Ccode\u003Efoo[Symbol.iterator]()\u003C\u002Fcode\u003E:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003Evar list = (function(){return arguments})(1, 2, 3);\n\nconsole.log($for.isIterable(list)); \u002F\u002F =\u003E true\nconsole.log($for.isIterable({}));   \u002F\u002F =\u003E false\n\nvar iter = $for.getIterator(list);\nconsole.log(iter.next());           \u002F\u002F =\u003E {value: 1, done: false}\nconsole.log(iter.next());           \u002F\u002F =\u003E {value: 2, done: false}\nconsole.log(iter.next());           \u002F\u002F =\u003E {value: 3, done: false}\nconsole.log(iter.next());           \u002F\u002F =\u003E {value: undefined, done: true}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Ca name=\"es6-use-iter\"\u003E\u003C\u002Fa\u003E\u003Ca href=\"#es6-use-iter\"\u003E\u003Cb\u003E#\u003C\u002Fb\u003E\u003C\u002Fa\u003E В ECMAScript 6 итераторы используются для инициализации \u003Ca href=\"#es6-collections\"\u003E# коллекций\u003C\u002Fa\u003E \u003Ccode\u003EMap, Set, WeakMap, WeakSet\u003C\u002Fcode\u003E, массивов \u003Ca href=\"#es6-array-from\"\u003E# через \u003Ccode\u003EArray.from\u003C\u002Fcode\u003E\u003C\u002Fa\u003E, их ожидают методы \u003Ccode\u003EPromise.all, Promise.race\u003C\u002Fcode\u003E для работы с \u003Ca href=\"#es6-promise\"\u003E# обещаниями\u003C\u002Fa\u003E.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ca name=\"es6-spread\"\u003E\u003C\u002Fa\u003E\u003Ca href=\"#es6-spread\"\u003E\u003Cb\u003E#\u003C\u002Fb\u003E\u003C\u002Fa\u003E Оператор \u003Ca href=\"http:\u002F\u002Fwww.2ality.com\u002F2011\u002F08\u002Fspreading.html\"\u003Espread\u003C\u002Fa\u003E, применимый при вызове функций, конструкторов и в литерале массива, также ожидает итерируемый объект, но это уже совсем далекая от стандартной библиотеки тема. Есть желание пользоваться уже сейчас — препроцессоры в зубы. \u003Ca href=\"http:\u002F\u002Fgoo.gl\u002Fsf7BPy\"\u003EПример\u003C\u002Fa\u003E:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003E[...new Set([1, 2, 3, 2, 1])]; \u002F\u002F =\u003E [1, 2, 3]\nconsole.log(1, ...[2, 3, 4]);  \u002F\u002F =\u003E 1, 2, 3, 4\nvar map = new Map([[1, 'a'], [2, 'b']]);\nnew Array(...map.keys(), 3);   \u002F\u002F =\u003E [1, 2, 3]\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Ca name=\"es6-comprehensions\"\u003E\u003C\u002Fa\u003E\u003Ca href=\"#es6-comprehensions\"\u003E\u003Cb\u003E#\u003C\u002Fb\u003E\u003C\u002Fa\u003E Ко всему прочему, к протоколу итераторов относятся и \u003Ca href=\"http:\u002F\u002Fwww.2ality.com\u002F2013\u002F01\u002Fcomprehensions.html\"\u003Earray \u002F generator comprehensions\u003C\u002Fa\u003E (\u003Ca href=\"https:\u002F\u002Fru.wikipedia.org\u002Fwiki\u002F%D0%A1%D0%BF%D0%B8%D1%81%D0%BA%D0%BE%D0%B2%D0%BE%D0%B5_%D0%B2%D0%BA%D0%BB%D1%8E%D1%87%D0%B5%D0%BD%D0%B8%D0%B5\"\u003Eабстракция массива \u002F генератора?\u003C\u002Fa\u003E). Раньше они присутствовали в черновике ECMAScript 6, но отложены до ECMAScript 7, хотя давно поддерживаются в \u003Ca href=\"https:\u002F\u002Fdeveloper.mozilla.org\u002Fen-US\u002Fdocs\u002FWeb\u002FJavaScript\u002FReference\u002FOperators\u002FArray_comprehensions\"\u003EFirefox\u003C\u002Fa\u003E. Это возможность генерации массива или итератора из итерируемого объекта с фильтрацией и преобразованием. Т.е. \u003Cb\u003Eсинтаксис \u003Ccode\u003Efilter\u003C\u002Fcode\u003E и \u003Ccode\u003Emap\u003C\u002Fcode\u003E для любых итерируемух объектов\u003C\u002Fb\u003E. Примеры, кроме последнего — не поддерживается деструкция массива, работают в \u003Cb\u003EFF\u003C\u002Fb\u003E. В \u003Cb\u003E6to5\u003C\u002Fb\u003E и \u003Cb\u003ETraceur\u003C\u002Fb\u003E работает всё. \u003Ca href=\"http:\u002F\u002Fgoo.gl\u002Fmz9zv2\"\u003EПример\u003C\u002Fa\u003E:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003Evar ar1 = [for(i of [1, 2, 3])i * i];    \u002F\u002F =\u003E [1, 4, 9]\n\nvar set = new Set([1, 2, 3, 2, 1]);\nvar ar2 = [for(i of set)if(i % 2)i * i]; \u002F\u002F =\u003E [1, 9]\n\nvar iter = (for(i of set)if(i % 2)i * i);\niter.next(); \u002F\u002F =\u003E {value: 1, done: false}\niter.next(); \u002F\u002F =\u003E {value: 9, done: false}\niter.next(); \u002F\u002F =\u003E {value: undefined, done: true}\n\nvar map1 = new Map([['a', 1], ['b', 2], ['c', 3]]);\nvar map2 = new Map((for([k, v] of map1)if(v % 2)[k + k, v * v])); \u002F\u002F =\u003E Map {aa: 1, cc: 9}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nКак по мне — штука потрясающая. Вот только это тоже синтаксис.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ca name=\"for\"\u003E\u003C\u002Fa\u003E\u003Ca href=\"#for\"\u003E\u003Cb\u003E#\u003C\u002Fb\u003E\u003C\u002Fa\u003E Для тех, кто не намерен пользоваться препроцессором ES6, добавим подобное, совсем уж велосипед, в рамках модуля \u003Ccode\u003E$for\u003C\u002Fcode\u003E. Вызов \u003Ccode\u003E$for\u003C\u002Fcode\u003E возвращает итератор, расширенный методами \u003Ccode\u003Eof\u003C\u002Fcode\u003E, о котором выше, \u003Ccode\u003Efilter, map\u003C\u002Fcode\u003E и \u003Ccode\u003Earray\u003C\u002Fcode\u003E. Методы \u003Ccode\u003Efilter\u003C\u002Fcode\u003E и \u003Ccode\u003Emap\u003C\u002Fcode\u003E возвращают итератор, что, соответственно, фильтрует или преобразует значения предыдущего итератора. Этот итератор расширен теми же методами, что и итератор \u003Ccode\u003E$for\u003C\u002Fcode\u003E. Метод \u003Ccode\u003Earray\u003C\u002Fcode\u003E преобразует текущий итератор в массиву, он принимает опциональный map-коллбэк. У всех этих методов второй, опциональный, аргумент — контекст исполнения. Если \u003Ccode\u003E$for\u003C\u002Fcode\u003E принимает флаг \u003Ccode\u003Eentries\u003C\u002Fcode\u003E, все коллбэки цепочки запускаются с парой аргументов.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ca href=\"http:\u002F\u002Fgoo.gl\u002FJHecXL\"\u003EПример\u003C\u002Fa\u003E:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003Evar ar1 = $for([1, 2, 3]).array(function(v){\n  return v * v;\n}); \u002F\u002F =\u003E [1, 4, 9]\n\nvar set = new Set([1, 2, 3, 2, 1]);\nvar ar1 = $for(set).filter(function(v){\n  return v % 2;\n}).array(function(v){\n  return v * v;\n}); \u002F\u002F =\u003E [1, 9]\n\nvar iter = $for(set).filter(function(v){\n  return v % 2;\n}).map(function(v){\n  return v * v;\n});\niter.next(); \u002F\u002F =\u003E {value: 1, done: false}\niter.next(); \u002F\u002F =\u003E {value: 9, done: false}\niter.next(); \u002F\u002F =\u003E {value: undefined, done: true}\n\nvar map1 = new Map([['a', 1], ['b', 2], ['c', 3]]);\nvar map2 = new Map($for(map1, true).filter(function(k, v){\n  return v % 2;\n}).map(function(k, v){\n  return [k + k, v * v];\n})); \u002F\u002F =\u003E Map {aa: 1, cc: 9}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nС литералом функции из ES5 выходит довольно громоздко, но со стрелочными функциями будет почти так же, как и с использованием синтаксиса comprehensions.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nМожно было бы добавить и другие операций над итераторами в модуль \u003Ccode\u003E$for\u003C\u002Fcode\u003E, что дало бы универсальный и ленивый (таков протокол итераторов) способ обхода и преобразования итерируемых объектов. Но отложим это на будущее. А может и к чёрту.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nБиблиотека добавляет еще пару итераторов (\u003Ca href=\"#dict-iter\"\u003E# раз\u003C\u002Fa\u003E, \u003Ca href=\"#num-iter\"\u003E# два\u003C\u002Fa\u003E), конструктор \u003Ca href=\"#dict-module\"\u003E# \u003Ccode\u003EDict\u003C\u002Fcode\u003E\u003C\u002Fa\u003E ожидает итерируемый объект, но не будем в эту главу перетаскивать совсем уж все велосипеды, связанные с итераторами.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ca name=\"es6-promise\"\u003E\u003C\u002Fa\u003E\u003Ch2\u003E\u003Cb\u003E\u003Ca href=\"#es6-promise\"\u003E#\u003C\u002Fa\u003E ECMAScript 6: Обещания\u003C\u002Fb\u003E\u003C\u002Fh2\u003E\u003Chr\u002F\u003E\u003Cbr\u002F\u003E\r\nАсинхронность и JavaScript для многих уже практически синонимы. Вот только про асинхронность в стандарте ECMAScript 5 нет вообще ничего. Даже такие базовые методы, как \u003Ccode\u003EsetTimeout\u003C\u002Fcode\u003E и \u003Ccode\u003EsetInterval\u003C\u002Fcode\u003E, обеспечиваются web-стандартами W3C и WHATWG, \u003Ca href=\"#timeout-interval\"\u003E# о них поговорим чуть дальше\u003C\u002Fa\u003E. Разве что функции как объекты первого класса — удобная передача коллбэков. Это порождает \u003Ca href=\"http:\u002F\u002Fcallbackhell.com\u002F\"\u003Eколлбэк-ад\u003C\u002Fa\u003E. Один из способов упрощения параллельного и последовательного исполнения асинхронных функций — библиотеки вроде \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fcaolan\u002Fasync\"\u003Easync.js\u003C\u002Fa\u003E.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nДругой подход к упрощению асинхронного программирования — шаблон Promise (Обещание). С помощью объекта-обещания, что может вернуть асинхронная функция, можно подписаться на её результат. Методы, с помощью которых можно подписаться на результат, возвращают новые обещания, что помогает лучше структурировать код, выстраивая обещания в цепочки. Также обещания решают проблему обработки ошибок: в асинхронном коде \u003Ccode\u003Etry-catch\u003C\u002Fcode\u003E не работает, приходится передавать ошибки аргументами коллбэка, что иногда еще больше запутывает код. В конце цепочки обещаний можно подписаться на любую ошибку, что может в ней возникнуть — как брошенную методом \u003Ccode\u003Ereject\u003C\u002Fcode\u003E, так и через \u003Ccode\u003Ethrow\u003C\u002Fcode\u003E.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nПопулярны такие библиотеки обещаний, как \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fkriskowal\u002Fq\"\u003EQ\u003C\u002Fa\u003E или \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Ftildeio\u002Frsvp.js\"\u003ERSVP\u003C\u002Fa\u003E. Со временем появился стандарт \u003Ca href=\"http:\u002F\u002Fpromisesaplus.com\u002F\"\u003EPromises\u002FA+\u003C\u002Fa\u003E, согласно которому все обещания разрешаются асинхронно, а на результат можно подписаться при помощи метода \u003Ccode\u003E.then\u003C\u002Fcode\u003E (первый аргумент — функция, что выполнится при успешном завершении, второй — при возникновении ошибки).\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nИ вот, дабы окончательно стандартизовать работу с асинхронным кодом, в ECMAScript 6 была \u003Ca href=\"https:\u002F\u002Fdeveloper.mozilla.org\u002Fen-US\u002Fdocs\u002FWeb\u002FJavaScript\u002FReference\u002FGlobal_Objects\u002FPromise\"\u003Eдобавлена реализация обещаний\u003C\u002Fa\u003E, совместимая со стандартом Promises\u002FA+ и с минимальным, но покрывающим большую часть потребностей, функционалом. Особо их расписывать не буду, подробно ознакомиться с ними можно \u003Ca href=\"http:\u002F\u002Fwww.html5rocks.com\u002Fen\u002Ftutorials\u002Fes6\u002Fpromises\u002F\"\u003Eздесь\u003C\u002Fa\u003E (\u003Ca href=\"http:\u002F\u002Fhabrahabr.ru\u002Fpost\u002F209662\u002F\"\u003Eперевод, но слегка устарел\u003C\u002Fa\u003E), \u003Ca href=\"http:\u002F\u002Fwww.2ality.com\u002F2014\u002F10\u002Fes6-promises-api.html\"\u003Eздесь\u003C\u002Fa\u003E или \u003Ca href=\"http:\u002F\u002Fhabrahabr.ru\u002Fpost\u002F242767\u002F\"\u003Eздесь\u003C\u002Fa\u003E. ES6 Promise уже доступны в v8 и Firefox, есть полифилы — \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fjakearchibald\u002Fes6-promise\"\u003Ees6-promise\u003C\u002Fa\u003E и \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fgetify\u002Fnative-promise-only\"\u003Enative-promise-only\u003C\u002Fa\u003E.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ca name=\"es6-promise-constructor\"\u003E\u003C\u002Fa\u003E\u003Ca href=\"#es6-promise-constructor\"\u003E\u003Cb\u003E#\u003C\u002Fb\u003E\u003C\u002Fa\u003E Реализация обещаний из ECMAScript 6 представляет из себя конструктор \u003Ccode\u003EPromise\u003C\u002Fcode\u003E, принимающий функцию, в которую передается 2 коллбэка — первый разрешает обещание, второй завершает с ошибкой. Кроме \u003Ccode\u003Ethen\u003C\u002Fcode\u003E, обещания ES6 содержат метод \u003Ccode\u003Ecatch\u003C\u002Fcode\u003E — сокращение для \u003Ccode\u003Ethen\u003C\u002Fcode\u003E с пропущенным первым аргументом, с помощью него можно подписаться на ошибку. \u003Ca href=\"http:\u002F\u002Fgoo.gl\u002Fz3bXC8\"\u003EПример\u003C\u002Fa\u003E:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003Evar log = console.log.bind(console);\nfunction sleepRandom(time){\n  return new Promise(function(resolve, reject){\n    \u002F\u002F resolve разрешает обещание успешно, reject - с ошибкой\n    \u002F\u002F разрешим обещание через заданное время\n    setTimeout(resolve, time * 1e3, 0 | Math.random() * 1e3);\n  });\n}\n\nlog('Поехали');                \u002F\u002F =\u003E Поехали\nsleepRandom(5).then(function(result){\n  log(result);                 \u002F\u002F =\u003E 869, через 5 сек.\n  return sleepRandom(10);\n}).then(function(result){\n  log(result);                 \u002F\u002F =\u003E 202, через 10 сек. \n}).then(function(){\n  log('Сразу после прошлого'); \u002F\u002F =\u003E Сразу после прошлого\n  throw Error('Ашыпка!');\n}).then(function(){\n  log('не будет выведено - ошибка');\n}).catch(log);                 \u002F\u002F =\u003E Error: 'Ашыпка!'\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nТак как мне было лень полностью адаптировать свой движок обещаний под стандарт, ядро обещаний \u003Cb\u003Ecore.js\u003C\u002Fb\u003E базируется на библиотеке native-promise-only, от кода которой мало что осталось. Для обеспечения асинхронности используется \u003Ccode\u003Eprocess.nextTick\u003C\u002Fcode\u003E и способы из полифила \u003Ca href=\"#immediate\"\u003E# setImmediate\u003C\u002Fa\u003E.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ca name=\"es6-promise-resolve-reject\"\u003E\u003C\u002Fa\u003E\u003Ca href=\"#es6-promise-resolve-reject\"\u003E\u003Cb\u003E#\u003C\u002Fb\u003E\u003C\u002Fa\u003E Пара хелперов \u003Ccode\u003EPromise.resolve\u003C\u002Fcode\u003E и \u003Ccode\u003EPromise.reject\u003C\u002Fcode\u003E возвращают завершенное, соответственно, успешно или с ошибкой обещание с переданным им значением. Если \u003Ccode\u003EPromise.resolve\u003C\u002Fcode\u003E принимает обещание — его и возвращает. Также его можно использовать для преобразования других thenable (например, jQuery Deferred) в обещания, в старой версии стандарта для этого был отдельный метод — \u003Ccode\u003EPromise.cast\u003C\u002Fcode\u003E. \u003Ca href=\"http:\u002F\u002Fgoo.gl\u002Fvr8TN3\"\u003EПример\u003C\u002Fa\u003E:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003EPromise.resolve(42).then(log); \u002F\u002F =\u003E 42\nPromise.reject(42).catch(log); \u002F\u002F =\u003E 42\n\nPromise.resolve($.getJSON('\u002Fdata.json')); \u002F\u002F =\u003E ES6 promise\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Ca name=\"es6-promise-all\"\u003E\u003C\u002Fa\u003E\u003Ca href=\"#es6-promise-all\"\u003E\u003Cb\u003E#\u003C\u002Fb\u003E\u003C\u002Fa\u003E Хелпер \u003Ccode\u003EPromise.all\u003C\u002Fcode\u003E возвращает обещание, которое разрешится, когда разрешатся все обещания из переданной ему \u003Ca href=\"#es6-iterators\"\u003E# итерируемой\u003C\u002Fa\u003E коллекции (в v8 сейчас работает только с массивами, исправлять в рамках библиотеки пока не стал — не вижу особого смысла использовать его с чем-то ещё). Элементы коллекции, не являющиеся обещаниями, приводятся к обещаниям через \u003Ccode\u003EPromise.resolve\u003C\u002Fcode\u003E. \u003Ca href=\"http:\u002F\u002Fgoo.gl\u002F62OcTx\"\u003EПример\u003C\u002Fa\u003E:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003EPromise.all([\n  'foo',\n  sleepRandom(5),\n  sleepRandom(15),\n  sleepRandom(10)  \u002F\u002F через 15 секунд выведет что-то вроде\n]).then(log);      \u002F\u002F =\u003E ['foo', 956, 85, 382]\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Ca name=\"es6-promise-race\"\u003E\u003C\u002Fa\u003E\u003Ca href=\"#es6-promise-race\"\u003E\u003Cb\u003E#\u003C\u002Fb\u003E\u003C\u002Fa\u003E Хелпер \u003Ccode\u003EPromise.race\u003C\u002Fcode\u003E похож на предыдущий, но возвращает обещание, которое разрешится, когда разрешится хотя бы одно обещание из переданной ему коллекции. По моему скромному мнению, в отличие от \u003Ccode\u003EPromise.all\u003C\u002Fcode\u003E, чуть менее, чем полностью, бесполезен. Разве что с его помощью становится чуть проще повесить ограничение на время разрешения обещания. \u003Ca href=\"http:\u002F\u002Fgoo.gl\u002FL8ovkJ\"\u003EПример\u003C\u002Fa\u003E:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003Efunction timeLimit(promise, time){\n  return Promise.race([promise, new Promise(function(resolve, reject){\n    setTimeout(reject, time * 1e3, Error('Await \u003E ' + time + ' sec'));\n  })]);\n}\n\ntimeLimit(sleepRandom(5), 10).then(log);   \u002F\u002F =\u003E через 5 секунд получили результат 853\ntimeLimit(sleepRandom(15), 10).catch(log); \u002F\u002F Error: Await \u003E 10 sec\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Ca name=\"async-await\"\u003E\u003C\u002Fa\u003E\u003Ca href=\"#async-await\"\u003E\u003Cb\u003E#\u003C\u002Fb\u003E\u003C\u002Fa\u003E Даже с обещаниями, асинхронному JavaScript есть еще куда стремиться в плане удобства, потому к добавлению в ECMAScript 7 предложены \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Flukehoban\u002Fecmascript-asyncawait\"\u003Eасинхронные функции\u003C\u002Fa\u003E, расширяющие синтаксис ключевыми словами \u003Ccode\u003Easync \u002F await\u003C\u002Fcode\u003E и базирующиеся на \u003Ca href=\"#es6-generators\"\u003E# генераторах\u003C\u002Fa\u003E, обещаниях и генераторах, возвращающих обещания :) Данный синтаксис уже поддерживается и \u003Cb\u003ETraceur\u003C\u002Fb\u003E, и \u003Cb\u003E6to5\u003C\u002Fb\u003E. \u003Ca href=\"http:\u002F\u002Fgoo.gl\u002Fv5JRT8\"\u003EПример\u003C\u002Fa\u003E:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003Evar delay = time =\u003E new Promise(resolve =\u003E setTimeout(resolve, time));\n\nasync function sleepRandom(time){\n  await delay(time * 1e3);\n  return 0 | Math.random() * 1e3;\n}\nasync function sleepError(time, msg){\n  await delay(time * 1e3);\n  throw Error(msg);\n}\n\n(async () =\u003E {\n  try {\n    log('Поехали');            \u002F\u002F =\u003E Поехали\n    log(await sleepRandom(5)); \u002F\u002F =\u003E 936, через 5 сек.\n    var [a, b, c] = await Promise.all([\n      sleepRandom(5),\n      sleepRandom(15),\n      sleepRandom(10)\n    ]);\n    log(a, b, c);              \u002F\u002F =\u003E 210 445 71, через 15 сек.\n    await sleepError(5, 'Ашыпка!');\n    log('Не будет выведено');\n  } catch(e){\n    log(e);                    \u002F\u002F =\u003E Error: 'Ашыпка!', через 5 сек.\n  }\n})();\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nСо временем, обещания изменят значительную часть стандартного асинхронного API JavaScript. Уже \u003Ca href=\"https:\u002F\u002Ffetch.spec.whatwg.org\u002F#fetch-api\"\u003Eстандартизована\u003C\u002Fa\u003E (\u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fgithub\u002Ffetch\"\u003Eполифил\u003C\u002Fa\u003E) глобальная функция \u003Ccode\u003Efetch\u003C\u002Fcode\u003E — простая и удобная обертка над \u003Ccode\u003EXMLHttpRequest\u003C\u002Fcode\u003E, возвращающая обещание. \u003Ca href=\"https:\u002F\u002Fesdiscuss.org\u002Ftopic\u002Fpromise-returning-delay-function\"\u003EПредлагают\u003C\u002Fa\u003E добавить, и, думаю, добавят, простую, но часто необходимую, функцию \u003Ccode\u003Edelay\u003C\u002Fcode\u003E, аналогичную функции из предыдущего примера, возвращающую обещание, что разрешится через заданное время — прощай, \u003Ccode\u003EsetTimeout\u003C\u002Fcode\u003E. Пожалуй, \u003Ccode\u003Edelay\u003C\u002Fcode\u003E было бы неплохо добавить и в данную библиотеку.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ca name=\"array-generics\"\u003E\u003C\u002Fa\u003E\u003Ch2\u003E\u003Cb\u003E\u003Ca href=\"#array-generics\"\u003E#\u003C\u002Fa\u003E Mozilla JavaScript: Статические версии методов массива\u003C\u002Fb\u003E\u003C\u002Fh2\u003E\u003Chr\u002F\u003E\u003Cbr\u002F\u003E\r\nВыше мы рассматривали протокол итераторов. Вот только это не единственный стандарт обхода коллекций в JavaScript. Есть куда более простой, быстрый и древний. Это array-like объекты.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nКроме массивов, в JavaScript много сущностей, подобных им, но при этом массивами не являющихся. Эти объекты, как и массивы, содержат длину \u003Ccode\u003E.length\u003C\u002Fcode\u003E и элементы по ключу [от 0 до \u003Ccode\u003E.length\u003C\u002Fcode\u003E), которые могут быть пропущены — тогда возникают «дырки». Они не содержат под собой \u003Ccode\u003EArray.prototype\u003C\u002Fcode\u003E, соответственно не имеют и методов массива. Это объект \u003Ccode\u003Earguments\u003C\u002Fcode\u003E, строки (формально — IE8+), типизированные массивы (массивы, но не содержат под собой \u003Ccode\u003EArray.prototype\u003C\u002Fcode\u003E), коллекции элементов DOM, jQuery объекты и т.д.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nПочти все методы прототипа массива — дженерики (как сообщает \u003Ca href=\"http:\u002F\u002Fes5.javascript.ru\u002Fx15.4.html#x15.4.4.5\"\u003Eперевод спецификации\u003C\u002Fa\u003E — «нарочито родовые» функции). Они не требуют, что бы объект, из контекста которого они запускались, был массивом. \u003Ca href=\"http:\u002F\u002Fwww.2ality.com\u002F2012\u002F02\u002Fconcat-not-generic.html\"\u003EРазве что \u003Ccode\u003E.concat\u003C\u002Fcode\u003E не совсем.\u003C\u002Fa\u003E Думаю, многим знакомы такие конструкции:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003EArray.prototype.slice.call(arguments, 1);\n\u002F\u002F или\n[].slice.call(arguments, 1);\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nГромоздко и невнятно.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nECMAScript 6 добавляет метод \u003Ca href=\"#es6-array-from\"\u003E# \u003Ccode\u003EArray.from\u003C\u002Fcode\u003E\u003C\u002Fa\u003E, с его помощью можно привести к массиву итерируемые и array-like объекты.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003EArray.from(arguments).slice(1);\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nВроде удобно, но \u003Ca href=\"http:\u002F\u002Fjsperf.com\u002Farray-methods-on-array-like\"\u003Eдалеко не дёшево\u003C\u002Fa\u003E — даже для самой простой операции мы вынуждены приводить весь объект к массиву, притом, в большинстве случаев, через довольно тяжелый протокол итераторов.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nВ JavaScript от Mozilla, \u003Ca href=\"https:\u002F\u002Fdeveloper.mozilla.org\u002Fen-US\u002Fdocs\u002FWeb\u002FJavaScript\u002FNew_in_JavaScript\u002F1.6\"\u003Eв версии языка 1.6\u003C\u002Fa\u003E и, соответственно, в Firefox, еще в 2005 году, вместе с методами массива, позднее вошедшими в ECMAScript 5, были добавлены и \u003Ca href=\"https:\u002F\u002Fdeveloper.mozilla.org\u002Fen-US\u002Fdocs\u002FWeb\u002FJavaScript\u002FReference\u002FGlobal_Objects\u002FArray#Array_generic_methods\"\u003Eстатические версии методов массива\u003C\u002Fa\u003E. Ни в 5ю, ни в 6ю редакцию ECMAScript они не попали, хоть и присутствуют в ветке разработки \u003Ca href=\"http:\u002F\u002Fwiki.ecmascript.org\u002Fdoku.php?id=strawman:array_statics\"\u003EStrawman\u003C\u002Fa\u003E довольно давно, но я лично надеюсь на их появлении в одной из будущих версий ECMAScript. Добавим в библиотеку и их — реализуются элементарно, а так как они уже имеются в огнелисе — отнесем их в категорию костылей, а не велосипедов.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003EArray.slice(arguments, 1);\n\nArray.join('abcdef', '+'); \u002F\u002F =\u003E 'a+b+c+d+e+f'\n\nvar form = document.getElementsByClassName('form__input');\nArray.reduce(form, function(memo, it){\n  memo[it.name] = it.value;\n  return memo; \n}, {}); \u002F\u002F =\u003E например, {name: 'Вася', age: '42', sex: 'yes, please'}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Ca name=\"schedule\"\u003E\u003C\u002Fa\u003E\u003Ch2\u003E\u003Cb\u003E\u003Ca href=\"#schedule\"\u003E#\u003C\u002Fa\u003E Отложенное исполнение: setTimeout, setInterval, setImmediate\u003C\u002Fb\u003E\u003C\u002Fh2\u003E\u003Chr\u002F\u003E\u003Cbr\u002F\u003E\r\n\u003Ca name=\"timeout-interval\"\u003E\u003C\u002Fa\u003E\u003Ch4\u003E\u003Cb\u003E\u003Ca href=\"#timeout-interval\"\u003E#\u003C\u002Fa\u003E setTimeout, setInterval\u003C\u002Fb\u003E\u003C\u002Fh4\u003E\u003Cbr\u002F\u003E\r\nПожалуй, начнем с привычных всем \u003Ccode\u003EsetTimeout\u003C\u002Fcode\u003E и \u003Ccode\u003EsetInterval\u003C\u002Fcode\u003E. Многие не знают, что по стандарту (\u003Ca href=\"http:\u002F\u002Fwww.w3.org\u002FTR\u002Fhtml5\u002Fwebappapis.html#timers\"\u003EW3C\u003C\u002Fa\u003E, \u003Ca href=\"http:\u002F\u002Fwww.whatwg.org\u002Fspecs\u002Fweb-apps\u002Fcurrent-work\u002Fmultipage\u002Ftimers.html#timers\"\u003EWHATWG\u003C\u002Fa\u003E) эти функции кроме коллбэка и времени задержки, принимают дополнительные аргументы, с какими запускается переданный коллбэк. Но тут, как обычно, проблема в IE. В IE9- \u003Ccode\u003EsetTimeout\u003C\u002Fcode\u003E и \u003Ccode\u003EsetInterval\u003C\u002Fcode\u003E принимают только 2 аргумента, это лечится оберткой в несколько строчек.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003E\u002F\u002F Было:\nsetTimeout(log.bind(null, 42), 1000);\n\u002F\u002F Стало:\nsetTimeout(log, 1000, 42);\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Ca name=\"immediate\"\u003E\u003C\u002Fa\u003E\u003Ch4\u003E\u003Cb\u003E\u003Ca href=\"#immediate\"\u003E#\u003C\u002Fa\u003E setImmediate\u003C\u002Fb\u003E\u003C\u002Fh4\u003E\u003Cbr\u002F\u003E\r\nJavaScript однопоточен и иногда это довольно неприятно. Любые длительные тяжелые вычисления на клиенте подвесят пользовательский интерфейс, а на сервере — обработка запросов. В этом случае спасает разбиение тяжелой задачи на лёгкие подзадачи, исполняемые асинхронно, между которыми может проходить ввод \u002F вывод.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nТакже в JavaScript (пока) не оптимизируется хвостовая рекурсия. Когда функция будет вызвана определённое число раз рекурсивно, будет сгенерирована ошибка \u003Ccode\u003ERangeError: Maximum call stack size exceeded\u003C\u002Fcode\u003E. Это число, в зависимости от платформы, варьирует от нескольких сотен до нескольких десятков тысяч. Асинхронный рекурсивный вызов спасает от переполнения стека. Правда, рекурсивный вызов обычно легко переписывается в обычный цикл, что предпочтительней. \u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nДля решения подобных проблем можно использовать \u003Ccode\u003EsetTimeout\u003C\u002Fcode\u003E с минимальной задержкой, но получится очень неспешно. Минимальная задержка \u003Ccode\u003EsetTimeout\u003C\u002Fcode\u003E по спецификации — 4 мс, а на некоторых платформах и того больше. Итого, максимум, ~250 рекурсивных вызовов в секунду в современных браузерах и, например, ~64 в IE8. Приходилось, да и приходится, велосипедить, так как есть способы сделать эффективное отложенное исполнение.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nЕсли на Node.js был \u003Ccode\u003Eprocess.nextTick\u003C\u002Fcode\u003E, то на клиент помощь пришла откуда не ждали. В IE10 Microsoft добавил метод \u003Ca href=\"https:\u002F\u002Fdeveloper.mozilla.org\u002Fen-US\u002Fdocs\u002FWeb\u002FAPI\u002FWindow.setImmediate\"\u003EsetImmediate\u003C\u002Fa\u003E, устанавливающий задачу, выполняемую сразу после того, как отработает ввод \u002F вывод, и предложил его для стандартизации \u003Ca href=\"https:\u002F\u002Fdvcs.w3.org\u002Fhg\u002Fwebperf\u002Fraw-file\u002Ftip\u002Fspecs\u002FsetImmediate\u002FOverview.html\"\u003EW3C\u003C\u002Fa\u003E. Позже он \u003Ca href=\"http:\u002F\u002Fhabrahabr.ru\u002Fpost\u002F172363\u002F\"\u003Eпоявился и на Node.js\u003C\u002Fa\u003E. FF и Chromium его добавлять не спешат. Популярен \u003Ca href=\"https:\u002F\u002Fgithub.com\u002FYuzuJS\u002FsetImmediate\"\u003Eтакой\u003C\u002Fa\u003E полифил.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nСпособов реализации эффективного отложенного исполнения функций огромное количество. Для достижения максимального быстродействия на различных платформах нам придется использовать многие (аналогичны способам из упомянутого выше полифила). Это:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cul\u003E\r\n\u003Cli\u003EДля старых версий Node.js — \u003Ccode\u003Eprocess.nextTick\u003C\u002Fcode\u003E\u003C\u002Fli\u003E\r\n\u003Cli\u003EДля современных браузеров — \u003Ccode\u003EpostMessage\u003C\u002Fcode\u003E\u003C\u002Fli\u003E\r\n\u003Cli\u003EДля WebWorker'ов — \u003Ccode\u003EMessageChannel\u003C\u002Fcode\u003E\u003C\u002Fli\u003E\r\n\u003Cli\u003EДля IE8- — \u003Ccode\u003Escript.onreadystatechange\u003C\u002Fcode\u003E\u003C\u002Fli\u003E\r\n\u003Cli\u003EИ уж если эти способы не помогли — \u003Ccode\u003EsetTimeout\u003C\u002Fcode\u003E с минимальной задержкой\u003C\u002Fli\u003E\r\n\u003C\u002Ful\u003E\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003EsetImmediate(function(arg1, arg2){\n  console.log(arg1, arg2); \u002F\u002F =\u003E Сообщение будет выведено асинхронно с минимальной задержкой\n}, 'Сообщение будет выведено асинхронно', 'с минимальной задержкой');\n\nclearImmediate(setImmediate(function(){\n  console.log('Сообщение не будет выведено');\n}));\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nКроме \u003Ccode\u003EsetImmediate\u003C\u002Fcode\u003E, существует его более быстрая альтернатива — концепция \u003Ccode\u003Easap\u003C\u002Fcode\u003E (as soon as possible, \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fkriskowal\u002Fasap\"\u003Eбиблиотека\u003C\u002Fa\u003E) — по возможности, создаём microtask, что выполнится до любого ввода \u002F вывода. Добавить такой глобальный метод в стандарт языка \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Frwaldron\u002Ftc39-notes\u002Fblob\u002Fmaster\u002Fes6\u002F2014-09\u002Fsept-25.md#510-globalasap-for-enqueuing-a-microtask\"\u003Eдумают и в tc39\u003C\u002Fa\u003E. Может и его стоит добавить в библиотеку?\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ca name=\"console\"\u003E\u003C\u002Fa\u003E\u003Ch2\u003E\u003Cb\u003E\u003Ca href=\"#console\"\u003E#\u003C\u002Fa\u003E Консоль\u003C\u002Fb\u003E\u003C\u002Fh2\u003E\u003Chr\u002F\u003E\u003Cbr\u002F\u003E\r\n\u003Ca href=\"https:\u002F\u002Fdeveloper.mozilla.org\u002Fen-US\u002Fdocs\u002FWeb\u002FAPI\u002Fconsole\"\u003EКонсоль\u003C\u002Fa\u003E — единственное универсальное средство вывода и отладки как в браузере, так и на сервере. При этом, консоль не является частью спецификации ECMAScript и вообще не стандартизована. Есть заброшенные \u003Ca href=\"https:\u002F\u002Fgithub.com\u002FDeveloperToolsWG\u002Fconsole-object\"\u003Eнаброски спецификации\u003C\u002Fa\u003E, фактическая реализация на всех платформах различается.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ca name=\"console-cap\"\u003E\u003C\u002Fa\u003E\u003Ca href=\"#console-cap\"\u003E\u003Cb\u003E#\u003C\u002Fb\u003E\u003C\u002Fa\u003E В IE7- консоль отсутствует полностью. У некоторых браузеров «консоль Гейзенберга» — \u003Ccode\u003Econsole\u003C\u002Fcode\u003E определена только тогда, когда пользователь за ней наблюдает. Ну и, конечно, не все методы доступны на всех платформах. Свою консоль в стиле \u003Ca href=\"http:\u002F\u002Fgetfirebug.com\u002Ffirebuglite\"\u003EFirebug Lite\u003C\u002Fa\u003E мы изобретать не будем, просто сделаем заглушки для методов, дабы можно было их использовать, не проверяя наличия.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003E\u002F\u002F Было:\nif(window.console &amp;&amp; console.log)console.log(42);\n\u002F\u002F Стало:\nconsole.log(42);\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Ca name=\"console-bind\"\u003E\u003C\u002Fa\u003E\u003Ca href=\"#console-bind\"\u003E\u003Cb\u003E#\u003C\u002Fb\u003E\u003C\u002Fa\u003E В Firefox и Chromium методы консоли должны быть запущены из контекста \u003Ccode\u003Econsole\u003C\u002Fcode\u003E, так что если нужно передать их в качестве коллбэка придется привязать — например, \u003Ca href=\"#es5-bind\"\u003E# \u003Ccode\u003Econsole.log.bind(console)\u003C\u002Fcode\u003E\u003C\u002Fa\u003E. В IE, Firebug и на Node.js можно передавать, не привязывая, что гораздо удобней. Соответственно, привяжем методы к объекту \u003Ccode\u003Econsole\u003C\u002Fcode\u003E.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003E\u002F\u002F Было:\nsetTimeout(console.log.bind(console, 42), 1000);\n[1, 2, 3].forEach(console.log, console);\n\u002F\u002F Стало:\nsetTimeout(console.log, 1000, 42);\n[1, 2, 3].forEach(console.log);\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nНо есть здесь и одна проблема: на некоторых платформах, при вызове методов консоли выводится и строка, откуда был вызван метод. При переопределении методов консоли, этой строкой будет строка в \u003Cb\u003Eсore.js\u003C\u002Fb\u003E. Если это для вас критично — можете собрать библиотеку без модуля консоли.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ch4\u003E\u003Cb\u003EТак как консоль не стандартизована, добавим немного отсебятины:\u003C\u002Fb\u003E\u003C\u002Fh4\u003E\u003Cbr\u002F\u003E\r\n\u003Ca name=\"console-disable\"\u003E\u003C\u002Fa\u003E\u003Ca href=\"#console-disable\"\u003E\u003Cb\u003E#\u003C\u002Fb\u003E\u003C\u002Fa\u003E Возможность выключить вывод в консоль. Конечно, на продакшне вызовы методов консоли лучше не оставлять в коде, удаляя их либо ручками, либо используя \u003Ca href=\"http:\u002F\u002Fwww.elijahmanor.com\u002Fgrunt-away-those-pesky-console-log-statements\u002F\"\u003Eболее продвинутые средства\u003C\u002Fa\u003E, но это удобно и нужно далеко не всегда.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003Econsole.disable();\nconsole.warn('Консоль отключена, вы не увидите этого сообщения.');\nconsole.enable();\nconsole.warn('Консоль снова включена.');\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nПривязка контекста и возможность отключить консоль также присутствует, например, в \u003Ca href=\"http:\u002F\u002Fhabrahabr.ru\u002Fpost\u002F116852\u002F\"\u003Eэтой\u003C\u002Fa\u003E библиотеке от \u003Ca href=\"https:\u002F\u002Fhabrahabr.ru\u002Fusers\u002Ftheshock\u002F\" class=\"user_link\"\u003ETheShock\u003C\u002Fa\u003E.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ca name=\"II\"\u003E\u003C\u002Fa\u003E\u003Ch1\u003E\u003Cb\u003E\u003Ca href=\"#II\"\u003E#\u003C\u002Fa\u003E Часть вторая: Велосипеды\u003C\u002Fb\u003E\u003C\u002Fh1\u003E\u003Chr\u002F\u003E\u003Cblockquote\u003EВариантов ноль, вариантов нет.\u003Cbr\u002F\u003E\r\nХотелось полмира — хватило на велосипед.\u003Cbr\u002F\u003E\r\n\u003Ci\u003E\u003Cb\u003E— Петля пристрастия\u003C\u002Fb\u003E\u003C\u002Fi\u003E\u003C\u002Fblockquote\u003E\u003Cbr\u002F\u003E\r\nВелосипеды, в контексте данной статьи \u002F библиотеки — весь нестандартизованный функционал. Собственно, то, чего, по моему мнению, не хватает стандартной библиотеке языка, даже если она будет реализована согласно всем имеющимся на данный момент стандартам. Сюда же отнесём и то, что предлагают в ES7+, так как это может быть далеко не раз пересмотрено или вообще отклонено.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ca name=\"classify\"\u003E\u003C\u002Fa\u003E\u003Ch2\u003E\u003Cb\u003E\u003Ca href=\"#classify\"\u003E#\u003C\u002Fa\u003E Классификация данных\u003C\u002Fb\u003E\u003C\u002Fh2\u003E\u003Chr\u002F\u003E\u003Cbr\u002F\u003E\r\n\u003Ca name=\"is-object\"\u003E\u003C\u002Fa\u003E\u003Ca href=\"#is-object\"\u003E\u003Cb\u003E#\u003C\u002Fb\u003E\u003C\u002Fa\u003E Тут начнем совсем с банальщины. В JavaScript по спецификации ECMAScript 5 есть \u003Ca href=\"http:\u002F\u002Fes5.javascript.ru\u002Fx8.html#x8\"\u003E6 типов данных\u003C\u002Fa\u003E: \u003Ccode\u003EUndefined, Null, Boolean, String, Number\u003C\u002Fcode\u003E и \u003Ccode\u003EObject\u003C\u002Fcode\u003E. ECMAScript 6 добавляет еще один тип данных — \u003Ca href=\"#es6-symbol\"\u003E# \u003Ccode\u003ESymbol\u003C\u002Fcode\u003E\u003C\u002Fa\u003E. Для определения типа данных есть оператор \u003Ccode\u003Etypeof\u003C\u002Fcode\u003E. Вот только работает он специфично. Так уж \u003Ca href=\"http:\u002F\u002Fhabrahabr.ru\u002Fpost\u002F200664\u002F\"\u003Eисторически сложилось\u003C\u002Fa\u003E, что \u003Ccode\u003Etypeof null\u003C\u002Fcode\u003E возвращает \u003Ccode\u003E'object'\u003C\u002Fcode\u003E и \u003Ca href=\"http:\u002F\u002Fwiki.ecmascript.org\u002Fdoku.php?id=harmony:typeof_null\"\u003Eпопытка исправить\u003C\u002Fa\u003E это в Harmony успехом не увенчалась. Для типа \u003Ccode\u003EObject\u003C\u002Fcode\u003E \u003Ccode\u003Etypeof\u003C\u002Fcode\u003E возвращает либо \u003Ccode\u003E'object'\u003C\u002Fcode\u003E, либо \u003Ccode\u003E'function'\u003C\u002Fcode\u003E, в зависимости от наличия внутреннего метода \u003Ccode\u003E[[Call]]\u003C\u002Fcode\u003E. Итого получаем, что оператор \u003Ccode\u003Etypeof\u003C\u002Fcode\u003E возвращает именно тип данных только для примитивов, и то не всех.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nЕсли проверить, является ли переменная \u003Ccode\u003Enull\u003C\u002Fcode\u003E просто, достаточно её с ним сравнить, то с \u003Ccode\u003EObject\u003C\u002Fcode\u003E придется либо каждый раз писать сотни кода, либо хелпер. Можно, конечно, сделать так — \u003Ccode\u003EObject(foo) === foo\u003C\u002Fcode\u003E, но данное решение \u003Ca href=\"http:\u002F\u002Fjsperf.com\u002Fcore-js-isobject\"\u003Eдалеко не самое быстрое\u003C\u002Fa\u003E — приводит примитив к объекту. В ранних черновиках ES6 присутствовал метод \u003Ccode\u003EObject.isObject\u003C\u002Fcode\u003E, но, видимо, из-за попытки исправить \u003Ccode\u003Etypeof null\u003C\u002Fcode\u003E, был удален. А проверять, является ли переменная объектом, приходится постоянно. Так что \u003Cb\u003Eдобавим хелпер \u003Ccode\u003EObject.isObject\u003C\u002Fcode\u003E\u003C\u002Fb\u003E, реализованный проще некуда (\u003Ca href=\"http:\u002F\u002Fgoo.gl\u002FCIkM2P\"\u003Eпесочница\u003C\u002Fa\u003E):\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003EObject.isObject = function(it){\n  return it != null &amp;&amp; (typeof it == 'object' || typeof it == 'function');\n}\n\u002F\u002F ...\ntypeof {};              \u002F\u002F =\u003E 'object'\ntypeof isNaN;           \u002F\u002F =\u003E 'function'\ntypeof null;            \u002F\u002F =\u003E 'object'\n\nObject.isObject({});    \u002F\u002F =\u003E true\nObject.isObject(isNaN); \u002F\u002F =\u003E true\nObject.isObject(null);  \u002F\u002F =\u003E false\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Ca name=\"classof\"\u003E\u003C\u002Fa\u003E\u003Ca href=\"#classof\"\u003E\u003Cb\u003E#\u003C\u002Fb\u003E\u003C\u002Fa\u003E А вот с классификацией объектов интересней. Оператор \u003Ccode\u003Einstanceof\u003C\u002Fcode\u003E проверяет цепочку прототипов. Если создать объект из прототипа или установить объекту в качестве прототипа \u003Ccode\u003EFunction.prototype\u003C\u002Fcode\u003E, это его не сделает функцией. Свойство инстанса \u003Ccode\u003Econstructor\u003C\u002Fcode\u003E не может ничего гарантировать, а \u003Ccode\u003Econstructor.name\u003C\u002Fcode\u003E мало того, что теряет всякий смысл при сжатии кода, еще и не поддерживается IE. Помочь с классификацией объекта может внутреннее свойство \u003Ccode\u003E[[Class]]\u003C\u002Fcode\u003E. Единственный способ выдрать его наружу — хорошо знакомая многим страшная конструкция \u003Ccode\u003EObject.prototype.toString.call(foo).slice(8, -1)\u003C\u002Fcode\u003E. \u003Ca href=\"http:\u002F\u002Fgoo.gl\u002F2pbqnZ\"\u003EПример\u003C\u002Fa\u003E:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003EObject.prototype.toString.call(1).slice(8, -1);   \u002F\u002F =\u003E 'Number'\nObject.prototype.toString.call([]).slice(8, -1);  \u002F\u002F =\u003E 'Array'\nObject.prototype.toString.call(\u002F.\u002F).slice(8, -1); \u002F\u002F =\u003E 'RegExp'\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nНа базе получения внутреннего класса большинство библиотек добавляет набор утилит по типу \u003Ca href=\"#es5-is-array\"\u003E# \u003Ccode\u003EArray.isArray\u003C\u002Fcode\u003E\u003C\u002Fa\u003E: Object.is\u003Ci\u003EType\u003C\u002Fi\u003E в \u003Ca href=\"http:\u002F\u002Fsugarjs.com\u002Fapi\u002FObject\u002FisType\"\u003ESugar\u003C\u002Fa\u003E, _.is\u003Ci\u003EType\u003C\u002Fi\u003E в \u003Ca href=\"http:\u002F\u002Funderscorejs.org\u002F#isArray\"\u003EUndescore\u003C\u002Fa\u003E и т.п.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nМы поступим иначе — \u003Cb\u003Eодин универсальный метод \u003Ccode\u003EObject.classof\u003C\u002Fcode\u003E для классификации данных\u003C\u002Fb\u003E, похожий на оператор \u003Ccode\u003Etypeof!\u003C\u002Fcode\u003E из \u003Ca href=\"http:\u002F\u002Flivescript.net\u002F#operators-object\"\u003ELiveScript\u003C\u002Fa\u003E (\u003Ca href=\"http:\u002F\u002Fgoo.gl\u002FBxwFTQ\"\u003Eпример\u003C\u002Fa\u003E).\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nВот только у \u003Ccode\u003EObject.prototype.toString.call(foo).slice(8, -1)\u003C\u002Fcode\u003E есть пара проблем:\u003Cbr\u002F\u003E\r\n\u003Cul\u003E\r\n\u003Cli\u003EВ старых IE, применимо к \u003Ccode\u003Enull, undefined\u003C\u002Fcode\u003E и \u003Ccode\u003Earguments\u003C\u002Fcode\u003E, данная конструкция возвращает \u003Ccode\u003E\"Object\"\u003C\u002Fcode\u003E. Это легко лечится дополнительными проверками.\u003C\u002Fli\u003E\r\n\u003Cli\u003EЧто делать с инстансами конструкторов из ECMAScript 6, полифилы которых мы добавили в нашей библиотеке? Так же будут возвращать \u003Ccode\u003E\"Object\"\u003C\u002Fcode\u003E. Тут на помощь приходит \u003Ca href=\"http:\u002F\u002Fpeople.mozilla.org\u002F~jorendorff\u002Fes6-draft.html#sec-object.prototype.tostring\"\u003Eизмененная логика работы\u003C\u002Fa\u003E \u003Ccode\u003EObject#toString\u003C\u002Fcode\u003E в ECMAScript 6.\u003C\u002Fli\u003E\r\n\u003C\u002Ful\u003E\u003Cbr\u002F\u003E\r\nВнезапно, но в ECMAScript 6 вообще отсутствует такое внутреннее свойство объектов, как \u003Ccode\u003E[[Class]]\u003C\u002Fcode\u003E. \u003Ccode\u003EObject#toString\u003C\u002Fcode\u003E ES6, через проверку специальных внутренних свойств, возвращает принадлежность переменной к \u003Ccode\u003EUndefined, Null, Array, String, Arguments, Function, Error, Boolean, Number, Date\u003C\u002Fcode\u003E или \u003Ccode\u003ERegExp\u003C\u002Fcode\u003E, а у остальных ищет подсказку по \u003Ca href=\"#es6-symbol\"\u003E# символу\u003C\u002Fa\u003E \u003Cb\u003E\u003Ccode\u003ESymbol.toStringTag\u003C\u002Fcode\u003E\u003C\u002Fb\u003E. Если метод находит подсказку и она не является именем одного из встроенных «классов» — возвращает её, не находит — \u003Ccode\u003EObject\u003C\u002Fcode\u003E.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nИсправим логику работы \u003Ccode\u003EObject#toString\u003C\u002Fcode\u003E, благо благодаря \u003Ca href=\"#es5-keys\"\u003E# одному противному, но веселому, багу\u003C\u002Fa\u003E мы можем сделать это и в IE8-, не сломав при этом \u003Ccode\u003Efor-in\u003C\u002Fcode\u003E. Ну и, конечно, реализуем данный подход в методе \u003Ccode\u003EObject.classof\u003C\u002Fcode\u003E. В качестве бонуса мы получаем возможность классификации инстансов пользовательских конструкторов. \u003Ca href=\"http:\u002F\u002Fgoo.gl\u002FM7qIFd\"\u003EПример\u003C\u002Fa\u003E:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003Evar classof = Object.classof;\n\nclassof(null);                 \u002F\u002F =\u003E 'Null'\nclassof(undefined);            \u002F\u002F =\u003E 'Undefined'\nclassof(1);                    \u002F\u002F =\u003E 'Number'\nclassof(true);                 \u002F\u002F =\u003E 'Boolean'\nclassof('string');             \u002F\u002F =\u003E 'String'\nclassof(Symbol());             \u002F\u002F =\u003E 'Symbol'\n\nclassof(new Number(1));        \u002F\u002F =\u003E 'Number'\nclassof(new Boolean(true));    \u002F\u002F =\u003E 'Boolean'\nclassof(new String('string')); \u002F\u002F =\u003E 'String'\n\nvar fn   = function(){}\n  , list = (function(){return arguments})(1, 2, 3);\n\nclassof({});                   \u002F\u002F =\u003E 'Object'\nclassof(fn);                   \u002F\u002F =\u003E 'Function'\nclassof([]);                   \u002F\u002F =\u003E 'Array'\nclassof(list);                 \u002F\u002F =\u003E 'Arguments'\nclassof(\u002F.\u002F);                  \u002F\u002F =\u003E 'RegExp'\nclassof(new TypeError);        \u002F\u002F =\u003E 'Error'\n\nclassof(new Set);              \u002F\u002F =\u003E 'Set'\nclassof(new Map);              \u002F\u002F =\u003E 'Map'\nclassof(new WeakSet);          \u002F\u002F =\u003E 'WeakSet'\nclassof(new WeakMap);          \u002F\u002F =\u003E 'WeakMap'\nclassof(new Promise(fn));      \u002F\u002F =\u003E 'Promise'\n\nclassof([].values());          \u002F\u002F =\u003E 'Array Iterator'\nclassof(new Set().values());   \u002F\u002F =\u003E 'Set Iterator'\nclassof(new Map().values());   \u002F\u002F =\u003E 'Map Iterator'\n\nclassof(Math);                 \u002F\u002F =\u003E 'Math'\nclassof(JSON);                 \u002F\u002F =\u003E 'JSON'\n\nfunction Example(){}\nExample.prototype[Symbol.toStringTag] = 'Example';\n\nclassof(new Example);          \u002F\u002F =\u003E 'Example'\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Ca name=\"dict\"\u003E\u003C\u002Fa\u003E\u003Ch2\u003E\u003Cb\u003E\u003Ca href=\"#dict\"\u003E#\u003C\u002Fa\u003E Словари\u003C\u002Fb\u003E\u003C\u002Fh2\u003E\u003Chr\u002F\u003E\u003Cbr\u002F\u003E\r\nВ JavaScript объекты и словари (ассоциативные массивы) — одно. В этом есть как плюсы — это кажется очень удобным, не зря так распространён основанный на объектной системе JavaScript формат обмена данными \u003Ccode\u003EJSON\u003C\u002Fcode\u003E, так и минусы.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nДля словарей нет разницы между получением элемента по ключу и метода из прототипа, что, при наличии под объектом прототипа (а у объекта, заданного нотацией — фигурными скобками, это \u003Ccode\u003EObject.prototype\u003C\u002Fcode\u003E), ломает базовые операции над словарем. Для объектов же это ограничения на расширение \u003Ccode\u003EObject.prototype\u003C\u002Fcode\u003E.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nВ ECMAScript 6 появился \u003Ca href=\"#es6-map\"\u003E# уже упомянутый выше\u003C\u002Fa\u003E новый вид коллекций ключ-значение — \u003Ccode\u003EMap\u003C\u002Fcode\u003E. Его быстродействие иногда даже выше, чем у объектов (само собой, не касается полифилов). Вот только ИМХО в большинстве случаев их не заменит. У \u003Ccode\u003EMap\u003C\u002Fcode\u003E, в отличии от словарей-объектов, отсутствует простая запись литералом, доступ к свойствам происходит через методы — не такой лаконичный. \u003Ccode\u003EMap\u003C\u002Fcode\u003E'ы далеки от любимого всеми \u003Ccode\u003EJSON\u003C\u002Fcode\u003E и не столь универсальны. Да и обычно в ключах словаря не требуется ничего, кроме строк.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cul\u003E\r\n\u003Cli\u003E\u003Ca href=\"#dict-and-object-prototype\"\u003E# Проблема: \u003Ccode\u003EObject.prototype\u003C\u002Fcode\u003E и словари\u003C\u002Fa\u003E\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ca href=\"#dict-module\"\u003E# Конструктор \u003Ccode\u003EDict\u003C\u002Fcode\u003E\u003C\u002Fa\u003E\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ca href=\"#dict-safe-crud\"\u003E# Методы для безопасной работы со словарем, имеющим под собой прототип\u003C\u002Fa\u003E\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ca href=\"#dict-methods\"\u003E# Методы для работы со словарем\u003C\u002Fa\u003E\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ca href=\"#dict-iter\"\u003E# Итерация по словарю\u003C\u002Fa\u003E\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ca href=\"#dict-next\"\u003E# Возможные перспективы\u003C\u002Fa\u003E\u003C\u002Fli\u003E\r\n\u003C\u002Ful\u003E\u003Cbr\u002F\u003E\r\n\u003Ca name=\"dict-and-object-prototype\"\u003E\u003C\u002Fa\u003E\u003Ch4\u003E\u003Cb\u003E\u003Ca href=\"#dict-and-object-prototype\"\u003E#\u003C\u002Fa\u003E Проблема: Object.prototype и словари\u003C\u002Fb\u003E\u003C\u002Fh4\u003E\u003Cbr\u002F\u003E\r\nВ \u003Ccode\u003EObject.prototype\u003C\u002Fcode\u003E, как подсказывает \u003Ca href=\"https:\u002F\u002Fdeveloper.mozilla.org\u002Fen-US\u002Fdocs\u002FWeb\u002FJavaScript\u002FReference\u002FGlobal_Objects\u002FObject\u002Fprototype\"\u003EMozilla Developer Network\u003C\u002Fa\u003E, в зависимости от реализации, могут находиться:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003EObject.prototype.constructor();\nObject.prototype.hasOwnProperty();\nObject.prototype.isPrototypeOf();\nObject.prototype.propertyIsEnumerable();\nObject.prototype.toLocaleString();\nObject.prototype.toString();\nObject.prototype.valueOf();\nObject.prototype.__proto__;\nObject.prototype.__count__;\nObject.prototype.__parent__;\nObject.prototype.__noSuchMethod__;\nObject.prototype.__defineGetter__();\nObject.prototype.__defineSetter__();\nObject.prototype.__lookupGetter__();\nObject.prototype.__lookupSetter__();\nObject.prototype.eval();\nObject.prototype.toSource();\nObject.prototype.unwatch();\nObject.prototype.watch();\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nЧем это нам может грозить?\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nПредположим, у нас есть примитивный телефонный справочник, и пользователь имеет доступ к его API:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003Evar phone = (function(){\n  var db = {\n    'Вася': '+7987654',\n    'Петя': '+7654321'\n  };\n  return {\n    has: function(name){\n      return name in db;\n    },\n    get: function(name){\n      return db[name];\n    },\n    set: function(name, phone){\n      db[name] = phone;\n    },\n    delete: function(name){\n      delete db[name];\n    }\n  };\n})();\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Ca href=\"http:\u002F\u002Fgoo.gl\u002F1fJAhL\"\u003EПолучаем\u003C\u002Fa\u003E:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003Econsole.log(phone.has('Вася'));     \u002F\u002F =\u003E true\nconsole.log(phone.get('Вася'));     \u002F\u002F =\u003E '+7987654'\nconsole.log(phone.has('Дима'));     \u002F\u002F =\u003E false\nconsole.log(phone.get('Дима'));     \u002F\u002F =\u003E undefined\nconsole.log(phone.has('toString')); \u002F\u002F =\u003E true\nconsole.log(phone.get('toString')); \u002F\u002F =\u003E function toString() { [native code] }\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nСвойство, при отсутствии, берется из цепочки прототипов, \u003Ccode\u003Ein\u003C\u002Fcode\u003E аналогично проверяет его наличие. Давайте добавим \u002F заменим \u003Ccode\u003Ein\u003C\u002Fcode\u003E на метод \u003Ccode\u003EhasOwnProperty\u003C\u002Fcode\u003E, проверяющий наличие свойства в объекте без учета цепочки прототипов. \u003Ca href=\"http:\u002F\u002Fgoo.gl\u002FIvQUWE\"\u003EПолучаем\u003C\u002Fa\u003E:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003E\u002F\u002F ...\n    has: function(name){\n      return db.hasOwnProperty(name);\n    },\n    get: function(name){\n      if(db.hasOwnProperty(name))return db[name];\n    },\n\u002F\u002F ...\nconsole.log(phone.get('Вася'));              \u002F\u002F =\u003E '+7987654'\nphone.set('hasOwnProperty', '+7666666'); \u002F\u002F Добавляем нового \"абонента\"\nconsole.log(phone.get('Вася'));              \u002F\u002F TypeError: string is not a function\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nУже довольно серьезно, особенно если этот «телефонный справочник» находится на серверной стороне. Методы прототипа можно перекрыть. Соответственно, нужно использовать метод \u003Ccode\u003EhasOwnProperty\u003C\u002Fcode\u003E, отвязанный от объекта. Получаем необходимость использования на каждый чих громоздких проверок. \u003Ca href=\"http:\u002F\u002Fgoo.gl\u002FFEKzNd\"\u003EПримерно такой трэш\u003C\u002Fa\u003E:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003E\u002F\u002F ...\n    has: function(name){\n      return Object.prototype.hasOwnProperty.call(db, name);\n    },\n    get: function(name){\n      if(Object.prototype.hasOwnProperty.call(db, name))return db[name];\n    },\n\u002F\u002F ...\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nДля решения данной проблемы в языке пригодился бы \u003Ca href=\"http:\u002F\u002Fwiki.ecmascript.org\u002Fdoku.php?id=strawman:has_operator\"\u003Eоператор проверки\u003C\u002Fa\u003E, является ли свойство собственным, похожий на \u003Ccode\u003Ein\u003C\u002Fcode\u003E.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nВы уже решили, что проблемы закончились? \u003Ca href=\"http:\u002F\u002Fgoo.gl\u002FyZfzuz\"\u003EНичего подобного\u003C\u002Fa\u003E:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003Ephone.set('__proto__', '+7666666'); \u002F\u002F Добавляем нового \"абонента\"\nconsole.log(phone.get('__proto__'));    \u002F\u002F =\u003E undefined\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nВ \u003Ccode\u003EObject.prototype\u003C\u002Fcode\u003E есть еще и «магический» геттер \u002F сеттер \u003Ccode\u003E__proto__\u003C\u002Fcode\u003E, установка примитива по этому ключу будет игнорироваться, а объекта — повредить, например, при обходе свойств. В старых движках были и другие «магические» свойства. Тут поможет разве что \u003Ccode\u003EObject.defineProperty\u003C\u002Fcode\u003E (\u003Ca href=\"http:\u002F\u002Fgoo.gl\u002FqigN0B\"\u003Eпесочникца\u003C\u002Fa\u003E):\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003E\u002F\u002F ...\n    set: function(name, phone){\n      Object.defineProperty(db, name, {\n        enumerable  : true,\n        configurable: true,\n        writable    : true,\n        value       : phone\n      });\n    },\n\u002F\u002F ...\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nПро обход словарей особо говорить не будем — если всё не совсем плохо, словарь не содержит в прототипе перечесляемых свойств, при обходе словаря через \u003Ccode\u003Efor-in\u003C\u002Fcode\u003E можно обойтись без проверки \u003Ccode\u003EhasOwnProperty\u003C\u002Fcode\u003E. Вот только баг с \u003Ca name=\"es5-keys\"\u003E\u003C\u002Fa\u003E\u003Ca href=\"#es5-keys\"\u003E# «неперечисляемыми перечисляемыми» свойствами\u003C\u002Fa\u003E всё равно делает обход через \u003Ccode\u003Efor-in\u003C\u002Fcode\u003E словарей, под которыми находится \u003Ccode\u003EObject.prototype\u003C\u002Fcode\u003E, неполноценным в старых IE.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nВ ECMAScript 5 появился способ создания объекта без прототипа — \u003Ccode\u003EObject.create(null)\u003C\u002Fcode\u003E, с ним можно использовать реализацию методов, предложенную изначально (\u003Ca href=\"http:\u002F\u002Fgoo.gl\u002Fgz3ZBZ\"\u003Eпесочница\u003C\u002Fa\u003E):\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003Evar phone = (function(){\n  var db = Object.create(null);\n  Object.assign(db, {\n    'Вася': '+7987654',\n    'Петя': '+7654321'\n  });\n  return {\n    has: function(name){\n      return name in db;\n    },\n    get: function(name){\n      return db[name];\n    },\n    set: function(name, phone){\n      db[name] = phone;\n    },\n    delete: function(name){\n      delete db[name];\n    }\n  };\n})();\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nВсё замечательно, вот только его создание и инициализация, даже с \u003Ccode\u003EObject.assign\u003C\u002Fcode\u003E, не особо компактны.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nТак как у подобных словарей отсутствует прототип, отсутствуют и методы \u003Ccode\u003EtoString\u003C\u002Fcode\u003E и \u003Ccode\u003EvalueOf\u003C\u002Fcode\u003E. Чем это нам грозит?\u003Cbr\u002F\u003E\r\n\u003Cul\u003E\r\n\u003Cli\u003EНе удастся привести к числу, например \u003Ccode\u003E+Object.create(null)\u003C\u002Fcode\u003E, или строке, \u003Ccode\u003E'' + Object.create(null)\u003C\u002Fcode\u003E, — \u003Ccode\u003ETypeError\u003C\u002Fcode\u003E\u003C\u002Fli\u003E\r\n\u003Cli\u003EСоответственно, не удастся сравнить объект алгоритмом абстрактного равенства, например, \u003Ccode\u003E==\u003C\u002Fcode\u003E, с примитивами — \u003Ccode\u003ETypeError\u003C\u002Fcode\u003E\u003C\u002Fli\u003E\r\n\u003C\u002Ful\u003EДля кого как, а для меня это скорее плюс, чем минус.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ca name=\"dict-module\"\u003E\u003C\u002Fa\u003E\u003Ch4\u003E\u003Cb\u003E\u003Ca href=\"#dict-module\"\u003E#\u003C\u002Fa\u003E Конструктор \u003Ccode\u003EDict\u003C\u002Fcode\u003E\u003C\u002Fb\u003E\u003C\u002Fh4\u003E\u003Cbr\u002F\u003E\r\nИтак, создание словаря через \u003Ccode\u003EObject.create(null)\u003C\u002Fcode\u003E и его заполнение куда более громоздко, чем при создании словаря через \u003Ccode\u003E{}\u003C\u002Fcode\u003E. Конечно, самым красивым решением было бы добавление в язык \u003Ca href=\"http:\u002F\u002Fwiki.ecmascript.org\u002Fdoku.php?id=strawman:dicts\"\u003Eлитерала словаря\u003C\u002Fa\u003E, но это, по крайней мере, в ближайшей перспективе, маловероятно. Отсутствует возможность инициализации литералом. Есть запись \u003Ccode\u003E{__proto__: null, foo: 'bar'}\u003C\u002Fcode\u003E, но поддерживается не везде, \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fpetkaantonov\u002Fbluebird\u002Fwiki\u002FOptimization-killers#2-unsupported-syntax\"\u003Eна данный момент приводит к деоптимизации кода\u003C\u002Fa\u003E, да и всё равно довольно громоздкая.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nОбсуждалось \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Frwaldron\u002Ftc39-notes\u002Fblob\u002Fmaster\u002Fes6\u002F2012-11\u002Fnov-29.md#collection-apis-review\"\u003Eодно довольно интересное решение\u003C\u002Fa\u003E — сделать \u003Cb\u003E«конструктор» \u003Ccode\u003EDict\u003C\u002Fcode\u003E как сокращение \u003Ccode\u003EObject.create(null)\u003C\u002Fcode\u003E\u003C\u002Fb\u003E. Как оно сейчас поживает и поживает ли вообще, я не в курсе. Но почему бы не взять его, слегка расширив? Заодно получим пространство имен для методов для работы с объектами как словарями. Добавим возможность инициализации итератором \u003Ccode\u003Eentries\u003C\u002Fcode\u003E или объектом без итератора, этакая версия \u003Ca href=\"#es6-array-from\"\u003E# \u003Ccode\u003EArray.from\u003C\u002Fcode\u003E\u003C\u002Fa\u003E для словарей.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nТак как \u003Ccode\u003EDict() instanceof Dict\u003C\u002Fcode\u003E работать не будет и \u003Ca href=\"#classof\"\u003E# \u003Ccode\u003EObject.classof(Dict())\u003C\u002Fcode\u003E\u003C\u002Fa\u003E будет возвращать \u003Ccode\u003E'Object'\u003C\u002Fcode\u003E, добавим для идентификации словарей метод \u003Ccode\u003EDict.isDict\u003C\u002Fcode\u003E.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nПримерно \u003Ca href=\"http:\u002F\u002Fgoo.gl\u002FIuhgSc\"\u003Eвот так\u003C\u002Fa\u003E:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003Efunction Dict(props){\n  var dict = Object.create(null);\n  if(props != null){\n    if(Symbol.iterator in props){\n      for(var [key, val] of props)dict[key] = val;\n    } else Object.assign(dict, props);\n  }\n  return dict;\n}\nDict.prototype = null;\nDict.isDict = function(it){\n  return Object.isObject(it) &amp;&amp; Object.getPrototypeOf(it) === null;\n}\n\n\u002F\u002F ...\n\nvar map = new Map([['a', 1], ['b', 2], ['c', 3]]);\n\nDict();                                            \u002F\u002F =\u003E {__proto__: null}\nDict({a: 1, b: 2, c: 3});                          \u002F\u002F =\u003E {__proto__: null, a: 1, b: 2, c: 3}\nDict(map);                                         \u002F\u002F =\u003E {__proto__: null, a: 1, b: 2, c: 3}\nDict([1, 2, 3].entries());                         \u002F\u002F =\u003E {__proto__: null, 0: 1, 1: 2, 2: 3}\nDict((for([k, v] of map)if(v % 2)[k + k, v * v])); \u002F\u002F =\u003E {__proto__: null, aa: 1, cc: 9}\n\nDict.isDict({});     \u002F\u002F =\u003E false\nDict.isDict(Dict()); \u002F\u002F =\u003E true\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Ca name=\"dict-safe-crud\"\u003E\u003C\u002Fa\u003E\u003Ch4\u003E\u003Cb\u003E\u003Ca href=\"#dict-safe-crud\"\u003E#\u003C\u002Fa\u003E Методы для безопасной работы со словарем, имеющим под собой прототип\u003C\u002Fb\u003E\u003C\u002Fh4\u003E\u003Cbr\u002F\u003E\r\nНа случай, если всё же придется работать с объектом, имеющим под собой прототип, как со словарем, добавим методы для безопасной работы с собственными свойствами.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cb\u003E\u003Ccode\u003EDict.has\u003C\u002Fcode\u003E\u003C\u002Fb\u003E — банально, статическая версия \u003Ccode\u003EhasOwnProperty\u003C\u002Fcode\u003E. В черновиках ECMAScript 6, в модуле \u003Ccode\u003EReflect\u003C\u002Fcode\u003E — наборе заглушек для \u003Ccode\u003EProxy\u003C\u002Fcode\u003E, до недавнего времени присутствовала статическая версия метода \u003Ccode\u003EhasOwnProperty\u003C\u002Fcode\u003E — метод \u003Ccode\u003EReflect.hasOwn\u003C\u002Fcode\u003E. Однако в последних версиях черновика спецификации данный метод удалили.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cb\u003E\u003Ccode\u003EDict.get\u003C\u002Fcode\u003E\u003C\u002Fb\u003E — получение значения по ключу с проверкой, является ли свойство собственным. Не является — возвращаем \u003Ccode\u003Eundefined\u003C\u002Fcode\u003E.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cb\u003E\u003Ccode\u003EDict.set\u003C\u002Fcode\u003E\u003C\u002Fb\u003E — метод для совсем уж параноиков. Позволяет установить свойство словаря, игнорирую сеттеры, такие, как \u003Ccode\u003E__proto__\u003C\u002Fcode\u003E. Использует \u003Ccode\u003EdefineProperty\u003C\u002Fcode\u003E.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nНу а оператор \u003Ccode\u003Edelete\u003C\u002Fcode\u003E и так работает как надо.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ca href=\"http:\u002F\u002Fgoo.gl\u002FyXHvmR\"\u003EПример\u003C\u002Fa\u003E:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003Evar dict = {a: 1, b: 2, c: 3};\n\nconsole.log(Dict.has(dict, 'a'));         \u002F\u002F =\u003E true\nconsole.log(Dict.has(dict, 'toString'));  \u002F\u002F =\u003E false\n\nconsole.log(Dict.get(dict, 'a'));         \u002F\u002F =\u003E 1\nconsole.log(Dict.get(dict, 'toString'));  \u002F\u002F =\u003E undefined\n\nDict.set(dict, '__proto__', 42);\nconsole.log(Dict.get(dict, '__proto__')); \u002F\u002F =\u003E 42\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Ca name=\"dict-methods\"\u003E\u003C\u002Fa\u003E\u003Ch4\u003E\u003Cb\u003E\u003Ca href=\"#dict-methods\"\u003E#\u003C\u002Fa\u003E Методы для работы со словарем\u003C\u002Fb\u003E\u003C\u002Fh4\u003E\u003Cbr\u002F\u003E\r\nМетоды, добавленные ECMAScript 5 в прототип массива для его обхода (\u003Ccode\u003EforEach, map, some\u003C\u002Fcode\u003E и т.п.), очень удобны. Их статические аналоги для словарей присутствуют в практически всех фреймворках \u002F библиотеках общего назначения. А вот подвижек с добавлением их в стандарт нет.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nДобавим их в рамках нашего модуля \u003Ccode\u003EDict\u003C\u002Fcode\u003E. Тут всё просто, методы аналогичны статическим версиям методов массива. Это: \u003Cb\u003E\u003Ccode\u003EDict.forEach, Dict.map, Dict.filter, Dict.some, Dict.every, Dict.find, Dict.findKey, Dict.keyOf, \u003C\u002Fcode\u003E\u003Ca href=\"#array-contains\"\u003E# \u003Ccode\u003EDict.includes\u003C\u002Fcode\u003E\u003C\u002Fa\u003E\u003Ccode\u003E, Dict.reduce, \u003C\u002Fcode\u003E\u003Ca href=\"#array-turn\"\u003E# \u003Ccode\u003EDict.turn\u003C\u002Fcode\u003E\u003C\u002Fa\u003E\u003C\u002Fb\u003E. \u003Ccode\u003EKey\u003C\u002Fcode\u003E в названии соответствует \u003Ccode\u003Eindex\u003C\u002Fcode\u003E у методов массива. «Правые» версии и опциональный аргумент-индекс (пока?) отсутствуют, так как порядок обхода ключей объектов пока не везде одинаков. Перебираются только собственные перечисляемые элементы объекта. Эти методы — дженерики в том же плане, что и \u003Ccode\u003EArray.from\u003C\u002Fcode\u003E или \u003Ccode\u003EArray.of\u003C\u002Fcode\u003E. Например, \u003Ccode\u003EDict.map(dict, fn)\u003C\u002Fcode\u003E вернет новый \u003Ccode\u003EDict\u003C\u002Fcode\u003E, а \u003Ccode\u003EDict.map.call(Object, dict, fn)\u003C\u002Fcode\u003E — новый \u003Ccode\u003EObject\u003C\u002Fcode\u003E. А в общем, всё примитивно, скучно и как везде (\u003Ca href=\"http:\u002F\u002Fgoo.gl\u002FRkjUxu\"\u003Eпесочница\u003C\u002Fa\u003E):\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003Evar dict = {a: 1, b: 2, c: 3};\nDict.forEach(dict, console.log, console);\n\u002F\u002F =\u003E 1, 'a', {a: 1, b: 2, c: 3}\n\u002F\u002F =\u003E 2, 'b', {a: 1, b: 2, c: 3}\n\u002F\u002F =\u003E 3, 'c', {a: 1, b: 2, c: 3}\nDict.map(dict, function(it){\n  return it * it;\n}); \u002F\u002F =\u003E {a: 1, b: 4, c: 9}\nDict.filter(dict, function(it){\n  return it % 2;\n}); \u002F\u002F =\u003E {a: 1, c: 3}\nDict.some(dict, function(it){\n  return it === 2;\n}); \u002F\u002F =\u003E true\nDict.every(dict, function(it){\n  return it === 2;\n}); \u002F\u002F =\u003E false\nDict.find(dict, function(it){\n  return it \u003E 2;\n}); \u002F\u002F =\u003E 3\nDict.find(dict, function(it){\n  return it \u003E 4;\n}); \u002F\u002F =\u003E undefined\nDict.findKey(dict, function(it){\n  return it \u003E 2;\n}); \u002F\u002F =\u003E 'c'\nDict.findKey(dict, function(it){\n  return it \u003E 4;\n}); \u002F\u002F =\u003E undefined\nDict.keyOf(dict, 2);    \u002F\u002F =\u003E 'b'\nDict.keyOf(dict, 4);    \u002F\u002F =\u003E undefined\nDict.includes(dict, 2); \u002F\u002F =\u003E true\nDict.includes(dict, 4); \u002F\u002F =\u003E false\nDict.reduce(dict, function(memo, it){\n  return memo + it;\n});     \u002F\u002F =\u003E 6\nDict.reduce(dict, function(memo, it){\n  return memo + it;\n}, ''); \u002F\u002F =\u003E '123'\nDict.turn(dict, function(memo, it, key){\n  memo[key + key] = it;\n});     \u002F\u002F =\u003E {aa: 1, bb: 2, cc: 3}\nDict.turn(dict, function(memo, it, key){\n  it % 2 &amp;&amp; memo.push(key + it);\n}, []); \u002F\u002F =\u003E ['a1', 'c3']\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Ca name=\"chaining\"\u003E\u003C\u002Fa\u003E\u003Cb\u003E\u003Ca href=\"#chaining\"\u003E#\u003C\u002Fa\u003E\u003C\u002Fb\u003E Что касается цепочек методов, \u003Ca href=\"#dict-and-object-prototype\"\u003E# по вполне очевидной причине\u003C\u002Fa\u003E, в рамках модуля \u003Ccode\u003EDict\u003C\u002Fcode\u003E их нет, и не предвидятся. Спасением тут могут стать \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fzenparsing\u002Fes-abstract-refs#examples\"\u003Eabstract references\u003C\u002Fa\u003E. А вот в рамках \u003Ca href=\"#for\"\u003E# \u003Ccode\u003E$for\u003C\u002Fcode\u003E\u003C\u002Fa\u003E и \u003Ca href=\"#es6-map\"\u003E# \u003Ccode\u003EMap\u003C\u002Fcode\u003E\u003C\u002Fa\u003E вполне возможно и появятся.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ca name=\"dict-iter\"\u003E\u003C\u002Fa\u003E\u003Ch4\u003E\u003Cb\u003E\u003Ca href=\"#dict-iter\"\u003E#\u003C\u002Fa\u003E Итерация по словарю\u003C\u002Fb\u003E\u003C\u002Fh4\u003E\u003Cbr\u002F\u003E\r\nБлизится светлое ES6 будущее с \u003Ca href=\"#es6-iterators\"\u003E# итераторами\u003C\u002Fa\u003E и \u003Ca href=\"#es6-for-of\"\u003E# циклом \u003Ccode\u003Efor-of\u003C\u002Fcode\u003E\u003C\u002Fa\u003E. Вот только объектам как словарям от этого ни тепло, ни холодно — для них в ES6 итераторы не предусмотрены. Соответственно, нет простого способа перебрать их через \u003Ccode\u003Efor-of\u003C\u002Fcode\u003E, инициализировать \u003Ca href=\"#es6-map\"\u003E# \u003Ccode\u003EMap\u003C\u002Fcode\u003E\u003C\u002Fa\u003E словарем и т.п. Добавление методов \u003Ccode\u003E.keys, .values\u003C\u002Fcode\u003E и \u003Ccode\u003E.entries\u003C\u002Fcode\u003E в \u003Ccode\u003EObject.prototype\u003C\u002Fcode\u003E маловероятно — там и так достаточно мусора, см. описание предыдущей проблемы. Зато вполне вероятны два других сценария:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nПервый — добавление статических методов, возвращающих итератор, в пространство имён \u003Ccode\u003EDict\u003C\u002Fcode\u003E — \u003Ccode\u003EDict.{keys, values, entries}\u003C\u002Fcode\u003E. Но как уже писал, что с перспективой добавления этого модуля в стандарт мне неизвестно.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nВторой — \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Frwaldron\u002Ftc39-notes\u002Fblob\u002Fmaster\u002Fes6\u002F2014-04\u002Fapr-9.md#51-objectentries-objectvalues\"\u003Eдобавление методов \u003Ccode\u003EObject.{values, entries}\u003C\u002Fcode\u003E\u003C\u002Fa\u003E, по типу \u003Ccode\u003EObject.keys\u003C\u002Fcode\u003E, возвращающих массив, а не итератор, и уже через итератор массива обходить объект.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nЧто из этого появится — не знаю и гадать боюсь. Для получения массива значения словаря использовать довольно тяжелый протокол итераторов, как и использовать промежуточный массив для итерации по объекту не рационально. Так что, хоть это частично и дублирующий друг друга функционал, реализуем в нашей библиотеке оба набора методов. \u003Ca href=\"http:\u002F\u002Fgoo.gl\u002FkKpVv2\"\u003EПримеры\u003C\u002Fa\u003E:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003Evar dict = {a: 1, b: 2, c: 3};\n\nconsole.log(Object.values(dict));  \u002F\u002F =\u003E [1, 2, 3]\nconsole.log(Object.entries(dict)); \u002F\u002F =\u003E [['a', 1], ['b', 2], ['c', 3]]\n\nfor(var key of Dict.keys(dict))console.log(key); \u002F\u002F =\u003E 'a', 'b', 'c'\n\nfor(var [key, val] of Dict.entries(dict)){\n  console.log(key); \u002F\u002F =\u003E 'a', 'b', 'c'\n  console.log(val); \u002F\u002F =\u003E 1, 2, 3\n}\n\n$for(Dict.values(dict)).of(console.log); \u002F\u002F =\u003E 1, 2, 3\n\nnew Map(Dict.entries(dict)); \u002F\u002F =\u003E Map {a: 1, b: 2, c: 3}\n\nnew Map((for([k, v] of Dict.entries(dict))if(v % 2)[k + k, v * v])); \u002F\u002F =\u003E  Map {aa: 1, cc: 9}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Ca name=\"dict-next\"\u003E\u003C\u002Fa\u003E\u003Ch4\u003E\u003Cb\u003E\u003Ca href=\"#dict-next\"\u003E#\u003C\u002Fa\u003E Возможные перспективы\u003C\u002Fb\u003E\u003C\u002Fh4\u003E\u003Cbr\u002F\u003E\r\nМожно было бы зайти чуть дальше, сделав \u003Ccode\u003EDict\u003C\u002Fcode\u003E не просто сокращением для \u003Ccode\u003EObject.create(null)\u003C\u002Fcode\u003E с возможностью инициализации итератором и объектом, а полноценным конструктором с прототипом, не содержащим ключей-строк, только \u003Ca href=\"#es6-symbol\"\u003E# символы\u003C\u002Fa\u003E. \u003Ca href=\"http:\u002F\u002Fgoo.gl\u002FG4yDFL\"\u003EПримерно так\u003C\u002Fa\u003E:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003Efunction Dict(props){\n  if(!(this instanceof Dict))return new Dict(props);\n  if(props != null){\n    if(Symbol.iterator in props){\n      for(var [key, val] of props)this[key] = val;\n    } else Object.assign(this, props);\n  }\n}\nDict.prototype = Object.create(null);\nDict.prototype[Symbol.toStringTag] = 'Dict';\nDict.prototype[Symbol.iterator] = function(){\n  return Dict.entries(this);\n};\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nЧто бы это нам дало?\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cul\u003E\r\n\u003Cli\u003E\u003Ccode\u003Enew Dict instanceof Dict\u003C\u002Fcode\u003E.\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ccode\u003Efor(var [key, value] of dict){...}, new Map(dict)\u003C\u002Fcode\u003E без необходимости получать итератор через \u003Ccode\u003EDict.entries\u003C\u002Fcode\u003E.\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ca href=\"#classof\"\u003E# \u003Ccode\u003EObject.classof(new Dict)\u003C\u002Fcode\u003E\u003C\u002Fa\u003E возвращал бы \u003Ccode\u003E'Dict'\u003C\u002Fcode\u003E, а не \u003Ccode\u003E'Object'\u003C\u002Fcode\u003E.\u003C\u002Fli\u003E\r\n\u003C\u002Ful\u003E\u003Cbr\u002F\u003E\r\nОднако, есть причины, как минимум, отложить внедрение этого подхода до момента, когда IE8- вымрет окончательно, а также Firefox полностью перейдет на протокол итераторов ECMAScript 6. А может и вообще не стоит — рискуем окончательно потерять совместимость со стандартом, когда \u002F если модуль \u003Ccode\u003EDict\u003C\u002Fcode\u003E туда попадёт.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ca name=\"partial-application\"\u003E\u003C\u002Fa\u003E\u003Ch2\u003E\u003Cb\u003E\u003Ca href=\"#partial-application\"\u003E#\u003C\u002Fa\u003E Частичное применение\u003C\u002Fb\u003E\u003C\u002Fh2\u003E\u003Chr\u002F\u003E\u003Cbr\u002F\u003E\r\nПожалуй, одним из самых полезных нововведений в ECMAScript 5 был метод \u003Ca href=\"#es5-bind\"\u003E# \u003Ccode\u003EFunction#bind\u003C\u002Fcode\u003E\u003C\u002Fa\u003E. Вот только возможности \u003Ca href=\"https:\u002F\u002Fru.wikipedia.org\u002Fwiki\u002F%D0%A7%D0%B0%D1%81%D1%82%D0%B8%D1%87%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%B8%D0%BC%D0%B5%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5\"\u003Eчастичного применения\u003C\u002Fa\u003E данный метод раскрывает далеко не полностью. В этой главе мы рассмотрим такие вещи, как:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cul\u003E\r\n\u003Cli\u003E\u003Ca href=\"#part\"\u003E# Частичное применение без привязки контекста\u003C\u002Fa\u003E\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ca href=\"#placeholder\"\u003E# Частичное применение произвольных аргументов\u003C\u002Fa\u003E\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ca href=\"#method-extraction\"\u003E# Извлечение метода из объекта\u003C\u002Fa\u003E\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ca href=\"#only\"\u003E# Ограничение количества аргументов\u003C\u002Fa\u003E\u003C\u002Fli\u003E\r\n\u003C\u002Ful\u003E\u003Cbr\u002F\u003E\r\nМожно было бы добавить \u003Ca href=\"http:\u002F\u002Fru.wikipedia.org\u002Fwiki\u002F%CA%E0%F0%F0%E8%F0%EE%E2%E0%ED%E8%E5\"\u003Eкаррирование\u003C\u002Fa\u003E, но в JavaScript именно каррирование, а не частичное применение, требуется достаточно редко. Как и «правые» версии методов. Добавлю \u003Ca href=\"http:\u002F\u002Fbenalman.com\u002Fnews\u002F2012\u002F09\u002Fpartial-application-in-javascript\u002F\"\u003Eссылку\u003C\u002Fa\u003E на годную (и так, пожалуй, хорошо известную) статью по теме.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ca name=\"part\"\u003E\u003C\u002Fa\u003E\u003Ch4\u003E\u003Cb\u003E\u003Ca href=\"#part\"\u003E#\u003C\u002Fa\u003E Частичное применение без привязки контекста\u003C\u002Fb\u003E\u003C\u002Fh4\u003E\u003Cbr\u002F\u003E\r\n\u003Ccode\u003EFunction#bind\u003C\u002Fcode\u003E совмещает в себе частичное применение и привязку контекста \u003Ccode\u003Ethis\u003C\u002Fcode\u003E. Последнее нужно далеко не всегда, и в этом случае привязываемый \u003Ccode\u003Ethis\u003C\u002Fcode\u003E не только «лишний» аргумент, что нужно писать. Если контекст, в котором должна запускаться частично применённая функция, заранее неизвестен, метод \u003Ccode\u003EFunction#bind\u003C\u002Fcode\u003E неприменим. Например, если это метод прототипа (\u003Ca href=\"http:\u002F\u002Fgoo.gl\u002Fuj6s6f\"\u003Eпесочница\u003C\u002Fa\u003E):\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003EArray.prototype.compact = [].filter.bind(Array.prototype, function(val){\n  return val != null;\n});\n\n[0, null, 1, undefined, 2].compact(); \u002F\u002F =\u003E [] - метод запускается в контексте Array.prototype, а не данного массива\n\n\u002F\u002F Придется частично применять вручную:\nArray.prototype.compact = function(){\n  return this.filter(function(val){\n    return val != null;\n  });\n};\n\n[0, null, 1, undefined, 2].compact(); \u002F\u002F =\u003E [0, 1, 2];\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nДобавим метод частичного применения без привязки \u003Ccode\u003Ethis\u003C\u002Fcode\u003E — \u003Ccode\u003EFunction#part\u003C\u002Fcode\u003E (\u003Ca href=\"http:\u002F\u002Fgoo.gl\u002Fl2UY0d\"\u003Eпесочница\u003C\u002Fa\u003E):\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003EArray.prototype.compact = [].filter.part(function(val){\n  return val != null;\n});\n\n[0, null, 1, undefined, 2].compact(); \u002F\u002F =\u003E [0, 1, 2];\n\nvar fn = console.log.part(1, 2);\nfn(3, 4); \u002F\u002F =\u003E 1, 2, 3, 4\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Ca name=\"placeholder\"\u003E\u003C\u002Fa\u003E\u003Ch4\u003E\u003Cb\u003E\u003Ca href=\"#placeholder\"\u003E#\u003C\u002Fa\u003E Частичное применение произвольных аргументов\u003C\u002Fb\u003E\u003C\u002Fh4\u003E\u003Cbr\u002F\u003E\r\nЧасто при частичном применении нужно передать произвольные аргументы — не, например, первые 2, а только второй и четвёртый или второй и третий. Тут \u003Ccode\u003EFunction#bind\u003C\u002Fcode\u003E нам помочь не сможет — придется писать обертку вручную под каждый конкретный случай.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003Efunction fn1(a, c){\n  console.log(a, 2, c, 4);\n};\nfn1(1, 3); \u002F\u002F =\u003E 1, 2, 3, 4\n\nfunction fn2(b, c){\n  console.log(1, b, c, 4);\n};\nfn2(2, 3); \u002F\u002F =\u003E 1, 2, 3, 4\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nДля облегчения подобной задачи добавим плейсхолдер — объект, замещающий аргумент, что будет передан при вызове конечной функции. В качестве ссылки на плейсхолдер так и напрашивается глобальная переменная \u003Ccode\u003E_\u003C\u002Fcode\u003E (как, например, в \u003Ca href=\"http:\u002F\u002Flivescript.net\u002F#functions-partial\"\u003ELiveScript\u003C\u002Fa\u003E, \u003Ca href=\"http:\u002F\u002Fgoo.gl\u002FEsYZ69\"\u003Eпесочница\u003C\u002Fa\u003E), однако, эту переменную используют библиотеки Undescore.js (кстати, в ней это тоже плейсхолдер для \u003Ccode\u003E_.partial\u003C\u002Fcode\u003E) и LoDash как свой неймспейс. Во избежание конфликтов с ними, создаём новый глобальный объект \u003Ccode\u003E_\u003C\u002Fcode\u003E только если таковой отсутствует, а во время работы используем глобальный объект \u003Ccode\u003E_\u003C\u002Fcode\u003E, что бы там ни лежало. В случае сборки без расширения нативных объектов, в качестве плейсхолдера используем объект \u003Ccode\u003Ecore._\u003C\u002Fcode\u003E. \u003Ca href=\"http:\u002F\u002Fgoo.gl\u002FykMnZf\"\u003EПример\u003C\u002Fa\u003E:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003Evar fn1 = console.log.part(_, 2, _, 4);\nfn1(1, 3);    \u002F\u002F =\u003E 1, 2, 3, 4\n\nvar fn2 = console.log.part(1, _, _, 4);\nfn2(2, 3);    \u002F\u002F =\u003E 1, 2, 3, 4\n\nfn1(1, 3, 5); \u002F\u002F =\u003E 1, 2, 3, 4, 5\nfn1(1);       \u002F\u002F =\u003E 1, 2, undefined, 4\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nТакже добавим метод \u003Ccode\u003EFunction#by\u003C\u002Fcode\u003E, аналогичный \u003Ccode\u003EFunction#bind\u003C\u002Fcode\u003E, но с возможностью использования плейсхолдера для аргументов. Можно было бы обернуть \u003Ccode\u003EFunction#bind\u003C\u002Fcode\u003E, заставив работать с плейсхолдером, но это — нарушение спецификации, да и метод этот и так довольно тормозной почти во всех движках.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003Evar fn = console.log.by(console, _, 2, _, 4);\nfn(1, 3, 5); \u002F\u002F =\u003E 1, 2, 3, 4, 5\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Ca name=\"method-extraction\"\u003E\u003C\u002Fa\u003E\u003Ch4\u003E\u003Cb\u003E\u003Ca href=\"#method-extraction\"\u003E#\u003C\u002Fa\u003E Извлечение метода из объекта\u003C\u002Fb\u003E\u003C\u002Fh4\u003E\u003Cbr\u002F\u003E\r\nВ большинстве случаев, например, при передаче коллбэка в функцию, метод нам нужно привязать именно к тому объекту, из которого его и получаем. И тут возникает проблема — \u003Ccode\u003Efn(foo.bar.baz.bind(foo.bar))\u003C\u002Fcode\u003E. Мы вынуждены писать \u003Ccode\u003Efoo.bar\u003C\u002Fcode\u003E 2 раза, это явное нарушение принципа DRY. Надеюсь, в будущем от этой проблемы спасут \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fzenparsing\u002Fes-abstract-refs\"\u003Eabstract references\u003C\u002Fa\u003E, но предложенная реализация проблему \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fzenparsing\u002Fes-abstract-refs\u002Fissues\u002F5\"\u003Eне решает\u003C\u002Fa\u003E. Пожалуй, самым вкусным и красивым решением было бы добавление в язык оператора доступа с сохранением контекста, аналогичного \u003Ca href=\"http:\u002F\u002Flivescript.net\u002F#property-access\"\u003E\u003Ccode\u003E~\u003C\u002Fcode\u003E из LiveScript\u003C\u002Fa\u003E — \u003Ccode\u003Efn(foo.bar~baz)\u003C\u002Fcode\u003E (\u003Ca href=\"http:\u002F\u002Fgoo.gl\u002F58e0Dp\"\u003Eпесочница\u003C\u002Fa\u003E).\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nРешений проблемы на базе библиотеки в голову приходит не много — разве что извлечение метода из объекта по ключу. Это либо статический метод, например, \u003Ccode\u003E_.bindKey\u003C\u002Fcode\u003E из \u003Ca href=\"http:\u002F\u002Flodash.com\u002Fdocs#bindKey\"\u003ELoDash\u003C\u002Fa\u003E (но с ранним связыванием), однако он тоже довольно громоздкий и еще больше ухудшает читаемость, либо аналогичный по функционалу метод в \u003Ccode\u003EObject.prototype\u003C\u002Fcode\u003E, например, \u003Ccode\u003EObject#boundTo\u003C\u002Fcode\u003E из \u003Ca href=\"https:\u002F\u002Fgithub.com\u002FWebReflection\u002Feddy#objectboundtomethod\"\u003EEddy.js\u003C\u002Fa\u003E.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nКак бы это страшно ни звучало, мы добавим метод в \u003Ccode\u003EObject.prototype\u003C\u002Fcode\u003E. Рисковать, расширяя \u003Ccode\u003EObject.prototype\u003C\u002Fcode\u003E методом по короткому ключу-строке, мы, по крайней мере, пока, не будем — сложно избежать конфликтов, да и сломаем \u003Ccode\u003Efor-in\u003C\u002Fcode\u003E в IE8-. Ранее в этой главе мы уже использовали глобальную переменную \u003Ccode\u003E_\u003C\u002Fcode\u003E. Дабы не плодить лишних сущностей и для краткости, применим её и здесь. Заменим у объекта \u003Ccode\u003E_\u003C\u002Fcode\u003E метод \u003Ccode\u003EtoString\u003C\u002Fcode\u003E (соответственно, если использовать совместно с Undescore.js или LoDash — нужно подключать \u003Cb\u003Ecore.js\u003C\u002Fb\u003E после них). Он будет возвращать уникальный ключ-строку, аналогично \u003Ca href=\"#es6-symbol-polyfill\"\u003E# ключу полифила символа\u003C\u002Fa\u003E. Добавим по этому ключу метод в \u003Ccode\u003EObject.prototype\u003C\u002Fcode\u003E. За счет использования грязного хака с \u003Ca href=\"#es5-keys\"\u003E# веселым багом\u003C\u002Fa\u003E, \u003Cb\u003Eмы добавляем этот метод и в IE8-, при этом не сломав \u003Ccode\u003Efor-in\u003C\u002Fcode\u003E.\u003C\u002Fb\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nИтого, из примера, с которого начали, получим \u003Ccode\u003Efn(foo.bar[_]('baz'))\u003C\u002Fcode\u003E — далековато от идеала, но хоть от второго упоминания объекта избавились. Возвращаемый метод кэшируется. \u003Ca href=\"http:\u002F\u002Fgoo.gl\u002FdQsSTi\"\u003EПримеры\u003C\u002Fa\u003E:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003E['foobar', 'foobaz', 'barbaz'].filter(\u002Fbar\u002F[_]('test')); \u002F\u002F =\u003E ['foobar', 'barbaz']\n\nvar has = {}.hasOwnProperty[_]('call');\n\nconsole.log(has({key: 42}, 'foo')); \u002F\u002F =\u003E false\nconsole.log(has({key: 42}, 'key')); \u002F\u002F =\u003E true\n\nvar array = []\n  , push  = array[_]('push');\npush(1);\npush(2, 3);\nconsole.log(array); \u002F\u002F =\u003E [1, 2, 3];\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nПо-хорошему, после отказа от поддержки IE8- библиотекой, метод стоит переименовать, а то страшновато это как-то :) \u003Ccode\u003Etie, boundTo, bindKey\u003C\u002Fcode\u003E или что-то в этом духе, подобрав наименее конфликтный ключ.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nИспользование \u003Ccode\u003EProxy\u003C\u002Fcode\u003E из ES6 здесь было бы куда симпатичней — обычный доступ к свойству вместо передачи ключа в метод — \u003Ccode\u003Efn(foo.bar[_].baz)\u003C\u002Fcode\u003E, но без \u003Ccode\u003EProxy\u003C\u002Fcode\u003E подобное (геттер, обход объекта и привязка всех методов), серьёзно не теряя при этом в производительности, мы пока себе позволить не можем.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cdiv class=\"spoiler\"\u003E\u003Cb class=\"spoiler_title\"\u003EПример с Proxy, работает пока только в ночном огнелисе\u003C\u002Fb\u003E\u003Cdiv class=\"spoiler_text\"\u003E\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003Evar _ = Symbol();\nObject.defineProperty(Object.prototype, _, {\n  get: function(){\n    return new Proxy(this, {\n      apply: function(){ \u002F* аналогично текущей логике [_] для обратной совместимости *\u002F },\n      get: function(context, name){\n        return context[name].bind(context);\n      }\n    });\n  }\n});\n\n['foobar', 'foobaz', 'barbaz'].filter(\u002Fbar\u002F[_].test); \u002F\u002F =\u003E ['foobar', 'barbaz']\n\nvar has = {}.hasOwnProperty[_].call;\n\nconsole.log(has({key: 42}, 'foo')); \u002F\u002F =\u003E false\nconsole.log(has({key: 42}, 'key')); \u002F\u002F =\u003E true\n\nvar array = []\n  , push  = array[_].push;\npush(1);\npush(2, 3);\nconsole.log(array); \u002F\u002F =\u003E [1, 2, 3];\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003C\u002Fdiv\u003E\u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\n\u003Ca name=\"only\"\u003E\u003C\u002Fa\u003E\u003Ch4\u003E\u003Cb\u003E\u003Ca href=\"#only\"\u003E#\u003C\u002Fa\u003E Ограничение количества аргументов\u003C\u002Fb\u003E\u003C\u002Fh4\u003E\u003Cbr\u002F\u003E\r\nПроблема необязательных аргументов рассмотрена в \u003Ca href=\"http:\u002F\u002Fhabrahabr.ru\u002Fpost\u002F114737\u002F\"\u003Eданной статье\u003C\u002Fa\u003E. Пример в ней — \u003Ccode\u003EparseInt\u003C\u002Fcode\u003E — довольно невразумительный, никто не мешает приводить строки к числу, например, используя \u003Ccode\u003ENumber\u003C\u002Fcode\u003E, что не ожидает дополнительных аргументов. Дело тут не в их «опасности», а в необходимости писать лишнюю обертку.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nНапример, мы хотим вывести в консоль все элементы массива, только сами элементы и ничего больше:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003E[1, 2, 3].forEach(console.log);\n\u002F\u002F =\u003E 1 0 [1, 2, 3]\n\u002F\u002F =\u003E 2 1 [1, 2, 3]\n\u002F\u002F =\u003E 3 2 [1, 2, 3]\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nМетод \u003Ccode\u003E.forEach\u003C\u002Fcode\u003E, как и многие другие, передаёт коллбэку необязательные аргументы — индекс и сам массив. А нам они не нужны. Так что каждый раз коллбэк придется оборачивать в еще одну функцию:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003E[1, 2, 3].forEach(function(it){\n  console.log(it);\n}); \u002F\u002F =\u003E 1, 2, 3\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nВ статье, упомянутой выше, для ограничения аргументов функций был предложен метод \u003Ccode\u003EFunction#only\u003C\u002Fcode\u003E. Реализуем его вариант. Первый аргумент — максимальное число аргументов, второй, опциональный — контекст. \u003Ca href=\"http:\u002F\u002Fgoo.gl\u002FEflCFz\"\u003EПример\u003C\u002Fa\u003E:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003E[1, 2, 3].forEach(console.log.only(1)); \u002F\u002F =\u003E 1, 2, 3\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nКонечно, если максимальное кол-во аргументов — 1, проще, если они доступны, обойтись стрелочными функциями из ES6 или кофеподобных языков, но если больше — уже проблематично.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ca name=\"date-format\"\u003E\u003C\u002Fa\u003E\u003Ch2\u003E\u003Cb\u003E\u003Ca href=\"#date-format\"\u003E#\u003C\u002Fa\u003E Форматирование даты\u003C\u002Fb\u003E\u003C\u002Fh2\u003E\u003Chr\u002F\u003E\u003Cbr\u002F\u003E\r\nКазалось бы, простая задача — форматирования даты, в JavaScript не такая уж и простая. Что делать, если нам нужно получить строку формата \u003Cb\u003E«18.11.2014 06:07:25»\u003C\u002Fb\u003E? \u003Ca href=\"http:\u002F\u002Fgoo.gl\u002FduI0y0\"\u003EВсё довольно страшно\u003C\u002Fa\u003E:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003Evar date = new Date;\nfunction lz2(it){\n  return it \u003E 9 ? it : '0' + it;\n}\nvar format = [date.getDate(), date.getMonth() + 1, date.getFullYear()].map(lz2).join('.') + ' ' +\n             [date.getHours(), date.getMinutes(), date.getSeconds()].map(lz2).join(':');\nconsole.log(format); \u002F\u002F =\u003E '18.11.2014 06:07:25 '\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nА что делать, если нужно получить, например, строку формата \u003Cb\u003E«Вторник, 18 Ноября 2014 г., 6:07:25»\u003C\u002Fb\u003E?\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nВ начале статьи был упомянут стандарт интернационализации \u003Cb\u003EECMA402\u003C\u002Fb\u003E, \u003Ca href=\"http:\u002F\u002Fnorbertlindenberg.com\u002Fecmascript\u002Fintl.html\"\u003Eспецификация\u003C\u002Fa\u003E. Стандарт добавляет в JavaScript объект \u003Cb\u003EIntl\u003C\u002Fb\u003E, содержащий средства локализованного форматирования даты, чисел, сравнения строк. На базовом уровне \u003Ca href=\"https:\u002F\u002Fdeveloper.mozilla.org\u002Fen-US\u002Fdocs\u002FWeb\u002FJavaScript\u002FReference\u002FGlobal_Objects\u002FIntl\"\u003EIntl\u003C\u002Fa\u003E рассмотрен в \u003Ca href=\"http:\u002F\u002Fhabrahabr.ru\u002Fpost\u002F218481\u002F\"\u003Eэтой статье\u003C\u002Fa\u003E. Ко всему прочему, этот стандарт перегружает методы \u003Ccode\u003EDate#toLocaleString, Date#toLocaleDateString, Date#toLocaleTimeString\u003C\u002Fcode\u003E, добавляя в них 2 аргумента: локализация и опции формата. Используя их, строку, близкую к упомянутому выше формату, можно получить \u003Ca href=\"http:\u002F\u002Fgoo.gl\u002FDHvgqd\"\u003Eтак\u003C\u002Fa\u003E:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003Enew Date().toLocaleString('ru-RU', {\n  weekday: 'long',\n  year:    'numeric',\n  month:   'long',\n  day:     'numeric',\n  hour:    'numeric',\n  minute:  '2-digit',\n  second:  '2-digit'\n}); \u002F\u002F =\u003E 'вторник, 18 ноября 2014 г., 6:07:25'\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nГромоздко, конечно, но лучше уж так, чем никак. Касательно поддержки стандарта — в целом, неплохо. Поддерживается Chrome, Opera, IE11, с недавних пор и Firefox. Но обычно нужна поддержка IE10-, Safari, мобильных платформ и чёрт еще знает чего. На этот случай есть \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fandyearnshaw\u002FIntl.js\"\u003Eполифил\u003C\u002Fa\u003E. Но вот незадача — реализация данного функционала будет слишком много весить, даже без учета локалей. По этой причине \u003Cb\u003Eв core.js и отсутствует полифил ECMA402\u003C\u002Fb\u003E.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ca name=\"simple-date-format\"\u003E\u003C\u002Fa\u003E\u003Ch4\u003E\u003Cb\u003E\u003Ca href=\"#simple-date-format\"\u003E#\u003C\u002Fa\u003E Добавим простое форматирование даты.\u003C\u002Fb\u003E\u003C\u002Fh4\u003E\u003Cbr\u002F\u003E\r\nЧто значит «простое»? Как часто вам нужна полноценная локализация или какие другие продвинутые средства работы с датой? Мне — не очень, обычно хочется простого удобного форматирования даты строкой формата. Ну а если нужны — никто не мешает подключить \u003Cb\u003E\u003Ca href=\"http:\u002F\u002Fmomentjs.com\u002F\"\u003EMoment.js\u003C\u002Fa\u003E\u003C\u002Fb\u003E или полифил \u003Ccode\u003EIntl\u003C\u002Fcode\u003E. Здесь же весь модуль работы с датой — несколько десятков строк.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nДобавляем метод \u003Ccode\u003EDate#format\u003C\u002Fcode\u003E и его UTC версию \u003Ccode\u003EDate#formatUTC\u003C\u002Fcode\u003E (\u003Ca href=\"http:\u002F\u002Fgoo.gl\u002FNMeGEy\"\u003Eпесочница\u003C\u002Fa\u003E):\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003Enew Date().format('W, D MM Y г., h:mm:ss', 'ru');    \u002F\u002F =\u003E 'Вторник, 18 Ноября 2014 г., 6:07:25'\nnew Date().formatUTC('W, D MM Y г., h:mm:ss', 'ru'); \u002F\u002F =\u003E 'Вторник, 18 Ноября 2014 г., 0:07:25'\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nРади простоты и легкочитаемости строки формата, не будем заморачиваться экранированием обозначений. Пока доступен их минимум:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"sql\"\u003Es  | Секунды             | 0-59\nss | Секунды, 2 цифры    | 00-59\nm  | Минуты              | 0-59\nmm | Минуты, 2 цифры     | 00-59\nh  | Часы                | 0-23\nhh | Часы, 2 цифры       | 00-23\nD  | Дата                | 1-31\nDD | Дата, 2 цифры       | 01-31\nW  | День недели, строка | Вторник\nN  | Месяц               | 1-12\nNN | Месяц, 2 цифры      | 01-12\nM  | Месяц, строка       | Ноябрь\nMM | Месяца, строка      | Ноября\nY  | Год, полный         | 2014\nYY | Год, 2 цифры        | 14\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nБиблиотека уже включает русскую (\u003Ccode\u003Eru\u003C\u002Fcode\u003E) и английскую (\u003Ccode\u003Een\u003C\u002Fcode\u003E) локали. Локаль задается либо методом \u003Ccode\u003Ecore.locale\u003C\u002Fcode\u003E, либо вторым аргументом методов \u003Ccode\u003EDate#format\u003C\u002Fcode\u003E и \u003Ccode\u003EDate#formatUTC\u003C\u002Fcode\u003E (\u003Ca href=\"http:\u002F\u002Fgoo.gl\u002FBYG9XY\"\u003Eпесочница\u003C\u002Fa\u003E):\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003Enew Date().format('W, D MM Y', 'ru'); \u002F\u002F =\u003E 'Вторник, 18 Ноября 2014'\nnew Date().format('W, D MM Y');       \u002F\u002F =\u003E 'Tuesday, 18 November 2014'\ncore.locale('ru');\nnew Date().format('W, D MM Y');       \u002F\u002F =\u003E 'Вторник, 18 Ноября 2014'\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nФормат локали представлен ниже. В собственном коде можно ограничиться \u003Ccode\u003Ecore.addLocale\u003C\u002Fcode\u003E, но из-за возможности сборки библиотеки без расширения нативных объектов, универсальный модуль-локаль будет выглядеть так:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003E(typeof core != 'undefined' ? core : require('core-js\u002Flibrary')).addLocale('ru', {\n  weekdays: 'Воскресенье,Понедельник,Вторник,Среда,Четверг,Пятница,Суббота',\n  months: 'Январ:я|ь,Феврал:я|ь,Март:а|,Апрел:я|ь,Ма:я|й,Июн:я|ь,Июл:я|ь,Август:а|,Сентябр:я|ь,Октябр:я|ь,Ноябр:я|ь,Декабр:я|ь'\n});\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Ca href=\"http:\u002F\u002Fgoo.gl\u002FPVfVLd\"\u003EНесколько примеров\u003C\u002Fa\u003E:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003Enew Date().format('DD.NN.YY');         \u002F\u002F =\u003E '18.11.14'\nnew Date().format('hh:mm:ss');         \u002F\u002F =\u003E '06:07:25'\nnew Date().format('DD.NN.Y hh:mm:ss'); \u002F\u002F =\u003E '18.11.2014 06:07:25'\nnew Date().format('W, D MM Y года');   \u002F\u002F =\u003E 'Вторник, 18 Ноября 2014 года'\nnew Date().format('D MM, h:mm');       \u002F\u002F =\u003E '18 Ноября, 6:07'\nnew Date().format('M Y');              \u002F\u002F =\u003E 'Ноябрь 2014'\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Ca name=\"object\"\u003E\u003C\u002Fa\u003E\u003Ch2\u003E\u003Cb\u003E\u003Ca href=\"#object\"\u003E#\u003C\u002Fa\u003E Объектное API\u003C\u002Fb\u003E\u003C\u002Fh2\u003E\u003Chr\u002F\u003E\u003Cbr\u002F\u003E\r\n\u003Ca name=\"object-define\"\u003E\u003C\u002Fa\u003E\u003Ca href=\"#object-define\"\u003E\u003Cb\u003E#\u003C\u002Fb\u003E\u003C\u002Fa\u003E \u003Cb\u003EПервая проблема\u003C\u002Fb\u003E: в ECMAScript 5 добавлена возможность объявить геттеры и сеттеры в литерале объекта. А вот добавить геттеры \u002F сеттеры уже существующих объектов можно только с использованием \u003Ccode\u003EObject.defineProperty\u003C\u002Fcode\u003E \u002F \u003Ccode\u003EObject.defineProperties\u003C\u002Fcode\u003E, что вынуждает передавать на каждое свойство полный (если не хочется таких дополнительных опций, как неперечисляемость или невозможность переопределить) объект дескриптора, а это громоздко.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nКроме метода \u003Ca href=\"#es6-object-assign\"\u003E# \u003Ccode\u003EObject.assign\u003C\u002Fcode\u003E\u003C\u002Fa\u003E, в ECMAScript 6 планировалось добавить метод \u003Ccode\u003EObject.mixin\u003C\u002Fcode\u003E, который копировал свойства объекта-источника в целевой объект с учетом дескрипторов. Кроме этого, метод должен был переназначать родителя методов объекта-источника, получаемого через ключевое слово \u003Ccode\u003Esuper\u003C\u002Fcode\u003E. Однако, его решили переработать и отложили добавление в стандарт.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nДобавим метод \u003Ccode\u003EObject.define\u003C\u002Fcode\u003E, работающий как описанный \u003Ccode\u003EObject.mixin\u003C\u002Fcode\u003E — копирующий свойства объекта-источника в цель с учетом дескрипторов, но не переопределяющий родителя, за отсутствием ключевого слова \u003Ccode\u003Esuper\u003C\u002Fcode\u003E в ECMAScript 5.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003E\u002F\u002F Было:\nObject.defineProperty(target, 'c', {\n  enumerable: true,\n  configurable: true,\n  get: function(){\n    return this.a + this.b;\n  }\n});\n\n\u002F\u002F Стало:\nObject.define(target, {\n  get c(){\n    return this.a + this.b;\n  }\n});\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Ca name=\"object-make\"\u003E\u003C\u002Fa\u003E\u003Ca href=\"#object-make\"\u003E\u003Cb\u003E#\u003C\u002Fb\u003E\u003C\u002Fa\u003E \u003Cb\u003EВторая проблема\u003C\u002Fb\u003E: в ECMAScript 5 также добавлена возможность создания объекта без использования конструктора, через \u003Ccode\u003EObject.create\u003C\u002Fcode\u003E. Было бы неплохо добавлять собственные свойства объекта при создании, но вторым аргументом \u003Ccode\u003EObject.create\u003C\u002Fcode\u003E, как и \u003Ccode\u003EObject.defineProperties\u003C\u002Fcode\u003E, принимает объект, содержащий объекты дескрипторов свойств, что страшно громоздко.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nДобавим метод \u003Ccode\u003EObject.make\u003C\u002Fcode\u003E — аналог \u003Ccode\u003EObject.create\u003C\u002Fcode\u003E, вторым аргументом ожидающий не объект дескрипторов, а простой объект, из которого копируются собственные свойства в создаваемый объект с учетом дескрипторов.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003E\u002F\u002F Поверхностное копирование объекта с учетом прототипа и дескрипторов:\nvar copy = Object.make(Object.getPrototypeOf(src), src);\n\n\u002F\u002F Пример с наследованием:\nfunction Vector2D(x, y){\n  this.x = x;\n  this.y = y;\n}\nObject.define(Vector2D.prototype, {\n  get xy(){\n    return Math.hypot(this.x, this.y);\n  }\n});\nfunction Vector3D(x, y, z){\n  Vector2D.apply(this, arguments);\n  this.z = z;\n}\nVector3D.prototype = Object.make(Vector2D.prototype, {\n  constructor: Vector3D,\n  get xyz(){\n    return Math.hypot(this.x, this.y, this.z);\n  }\n});\n\nvar vector = new Vector3D(9, 12, 20);\nconsole.log(vector.xy);  \u002F\u002F =\u003E 15\nconsole.log(vector.xyz); \u002F\u002F =\u003E 25\nvector.y++;\nconsole.log(vector.xy);  \u002F\u002F =\u003E 15.811388300841896\nconsole.log(vector.xyz); \u002F\u002F =\u003E 25.495097567963924\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nВ ECMAScript 7 предлагают добавить метод \u003Ca href=\"https:\u002F\u002Fgist.github.com\u002FWebReflection\u002F9353781\"\u003EObject.getOwnPropertyDescriptors\u003C\u002Fa\u003E, возвращающий, как ясно из его названия, объект, содержащий все дескрипторы собственных свойств объекта. Идеальная пара для создания второго аргумента \u003Ccode\u003EObject.defineProperties\u003C\u002Fcode\u003E и \u003Ccode\u003EObject.create\u003C\u002Fcode\u003E и, в некоторой степени, альтернатива нашим \u003Ccode\u003EObject.make\u003C\u002Fcode\u003E и \u003Ccode\u003EObject.define\u003C\u002Fcode\u003E. Вот только слишком громоздкая.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ca name=\"array\"\u003E\u003C\u002Fa\u003E\u003Ch2\u003E\u003Cb\u003E\u003Ca href=\"#array\"\u003E#\u003C\u002Fa\u003E Массивы\u003C\u002Fb\u003E\u003C\u002Fh2\u003E\u003Chr\u002F\u003E\u003Cbr\u002F\u003E\r\n\u003Ca name=\"array-contains\"\u003E\u003C\u002Fa\u003E\u003Ca href=\"#array-contains\"\u003E\u003Cb\u003E#\u003C\u002Fb\u003E\u003C\u002Fa\u003E Метод \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fdomenic\u002FArray.prototype.includes\"\u003EArray#includes\u003C\u002Fa\u003E (до недавнего времени — \u003Ccode\u003EArray#contains\u003C\u002Fcode\u003E, переименован из-за \u003Ca href=\"https:\u002F\u002Fesdiscuss.org\u002Ftopic\u002Farray-prototype-contains-solutions\"\u003Eбага MooTools\u003C\u002Fa\u003E, пока доступен и по старому имени) планируется к добавлению в ECMAScript 7. Он банально проверяет вхождение элемента в массив. В отличии от \u003Ccode\u003EArray#indexOf\u003C\u002Fcode\u003E, использует алгоритм сравнения \u003Ca href=\"#same-value-zero\"\u003E# SameValueZero\u003C\u002Fa\u003E и не игнорирует «дырки». Второй, опциональный, аргумент — стартовая позиция. \u003Ca href=\"http:\u002F\u002Fgoo.gl\u002F2Gq4ma\"\u003EПримеры\u003C\u002Fa\u003E:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003E[1, 2, 3].includes(2);        \u002F\u002F =\u003E true\n[1, 2, 3].includes(4);        \u002F\u002F =\u003E false\n[1, 2, 3].includes(2, 2);     \u002F\u002F =\u003E false\n\n[NaN].indexOf(NaN);           \u002F\u002F =\u003E -1\n[NaN].includes(NaN);          \u002F\u002F =\u003E true\nArray(1).indexOf(undefined);  \u002F\u002F =\u003E -1\nArray(1).includes(undefined); \u002F\u002F =\u003E true\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Ca name=\"array-turn\"\u003E\u003C\u002Fa\u003E\u003Ca href=\"#array-turn\"\u003E\u003Cb\u003E#\u003C\u002Fb\u003E\u003C\u002Fa\u003E А вот метод \u003Ccode\u003EArray#turn\u003C\u002Fcode\u003E — плод моей больной фантазии. Хотя, как выяснилось, не уникальный — ему аналогичен метод \u003Ccode\u003E_.transform\u003C\u002Fcode\u003E из \u003Ca href=\"http:\u002F\u002Flodash.com\u002Fdocs#transform\"\u003ELoDash\u003C\u002Fa\u003E. Это альтернатива методу \u003Ccode\u003EArray#reduce\u003C\u002Fcode\u003E для свёртки массива в произвольный объект-аккумулятор (по умолчанию — новый массив) без необходимости возвращать аккумулятор из коллбэка. Сигнатура метода и коллбэка аналогична \u003Ccode\u003EArray#reduce\u003C\u002Fcode\u003E. Можно прервать обход коллекции, вернув из коллбэка \u003Ccode\u003Efalse\u003C\u002Fcode\u003E. \u003Ca href=\"http:\u002F\u002Fgoo.gl\u002Fr3DbCT\"\u003EПримеры\u003C\u002Fa\u003E:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003E\u002F\u002F Свёртка в словарь:\n[1, 2, 3, 4, 5].reduce(function(memo, it){\n  memo['key' + it] = !!(it % 2);\n  return memo;\n}, {}); \u002F\u002F =\u003E {key1: true, key2: false, key3: true, key4: false, key5: true}\n\n[1, 2, 3, 4, 5].turn(function(memo, it){\n  memo['key' + it] = !!(it % 2);\n}, {}); \u002F\u002F =\u003E {key1: true, key2: false, key3: true, key4: false, key5: true}\n\n\u002F\u002F filter + map + slice, делаем лишнюю работу:\n[1, 2, 3, 4, 5, 6, 7, 8, 9].map(function(it){\n  return it * it;\n}).filter(function(it){\n  return it % 2;\n}).slice(0, 2); \u002F\u002F =\u003E [1, 9]\n\n[1, 2, 3, 4, 5, 6, 7, 8, 9].turn(function(memo, it){\n  it % 2 &amp;&amp; memo.push(it * it);\n  if(memo.length == 2)return false;\n}); \u002F\u002F =\u003E [1, 9]\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Ca name=\"num\"\u003E\u003C\u002Fa\u003E\u003Ch2\u003E\u003Cb\u003E\u003Ca href=\"#num\"\u003E#\u003C\u002Fa\u003E Числа\u003C\u002Fb\u003E\u003C\u002Fh2\u003E\u003Chr\u002F\u003E\u003Cbr\u002F\u003E\r\n\u003Ca name=\"num-iter\"\u003E\u003C\u002Fa\u003E\u003Ca href=\"#num-iter\"\u003E\u003Cb\u003E#\u003C\u002Fb\u003E\u003C\u002Fa\u003E Помните \u003Ca href=\"#es6-iterators\"\u003E# пример с итерируемыми числами\u003C\u002Fa\u003E из главы про итераторы? Слишком вкусная и универсальная возможность, что бы отказываться от подобного в стандартной библиотеке. Очень краткий цикл, выполняемый заданное число раз, на базе \u003Ccode\u003Efor-of\u003C\u002Fcode\u003E, простая генерация массива заданной длины через \u003Ca href=\"#es6-array-from\"\u003E# \u003Ccode\u003EArray.from\u003C\u002Fcode\u003E\u003C\u002Fa\u003E (а может и \u003Ca href=\"#es6-spread\"\u003E# spread\u003C\u002Fa\u003E) и т.д. Так что добавим итератор чисел, хоть и не в такой примитивной реализации. \u003Ca href=\"http:\u002F\u002Fgoo.gl\u002FyDD2oM\"\u003EПримеры\u003C\u002Fa\u003E:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003E\u002F\u002F Классический цикл:\nfor(var i = 0; i &lt; 3; i++)console.log(i); \u002F\u002F =\u003E 0, 1, 2\n\n\u002F\u002F for-of с итератором числа:\nfor(var i of 3)console.log(i); \u002F\u002F =\u003E 0, 1, 2\n\n\u002F\u002F При отсутствии for-of, хелпер:\n$for(3).of(console.log); \u002F\u002F =\u003E 0, 1, 2\n\n\u002F\u002F Генерация массива заданной длины:\n\u002F\u002F .map пропускает \"дырки\" в массиве\nArray(10).map(Math.random); \u002F\u002F =\u003E [undefined × 10]\n\n\u002F\u002F ES5 костыль, пара вспомогательных массивов:\nArray.apply(undefined, Array(10)).map(Math.random); \u002F\u002F =\u003E [0.9442228835541755, 0.8101077508181334, ...]\n\n\u002F\u002F ES6 костыль, заполняем вспомогательный массив:\nArray(10).fill(undefined).map(Math.random); \u002F\u002F =\u003E [0.5587614295072854, 0.009569905698299408, ...]\n\n\u002F\u002F Number Iterator:\nArray.from(10, Math.random); \u002F\u002F =\u003E [0.9817775336559862, 0.02720663254149258, ...]\n\nArray.from(10); \u002F\u002F =\u003E [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n\nArray.from(10, function(it){\n  return this + it * it;\n}, .42); \u002F\u002F =\u003E [0.42, 1.42, 4.42, 9.42, 16.42, 25.42, 36.42, 49.42, 64.42, 81.42]\n\n\u002F\u002F Comprehensions:\n[for(i of 10)if(i % 2)i * i]; \u002F\u002F =\u003E [1, 9, 25, 49, 81]\n\nDict((for(i of 3)['key' + i, !(i % 2)])); \u002F\u002F =\u003E {key0: true, key1: false, key2: true}\n\n$for(10).filter(function(i){\n  return i % 2;\n}).array(function(i){\n  return i * i;\n});  \u002F\u002F =\u003E [1, 9, 25, 49, 81]\n\nDict($for(3).map(function(i){\n  return ['key' + i, !(i % 2)];\n})); \u002F\u002F =\u003E {key0: true, key1: false, key2: true}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Ca name=\"num-math\"\u003E\u003C\u002Fa\u003E\u003Ca href=\"#num-math\"\u003E\u003Cb\u003E#\u003C\u002Fb\u003E\u003C\u002Fa\u003E Математические функции в \u003Ccode\u003ENumber.prototype\u003C\u002Fcode\u003E — из разряда приятных мелочей. Точно также как в Sugar и MooTools, вынесем методы из объекта \u003Ccode\u003EMath\u003C\u002Fcode\u003E в \u003Ccode\u003ENumber.prototype\u003C\u002Fcode\u003E. Тут и говорить особо нечего — контекст становится первым аргументом математической функции. Может и дублирует уже имеющийся, стандартизованный, функционал, но это довольно удобно :)\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nОтдельной строкой упомянем метод \u003Ccode\u003ENumber#random\u003C\u002Fcode\u003E. Он возвращает случайное число между числом-контекстом и переданным аргументом (по умолчанию — 0).\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ca href=\"http:\u002F\u002Fgoo.gl\u002F06bs1k\"\u003EПримеры\u003C\u002Fa\u003E:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003E3..pow(3);           \u002F\u002F =\u003E 27\n(-729).abs().sqrt(); \u002F\u002F =\u003E 27\n\n10..random(20);         \u002F\u002F =\u003E Случайное число (10, 20), например, 16.818793776910752\n10..random(20).floor(); \u002F\u002F =\u003E Случайное целое [10, 19], например, 16\n\nvar array = [1, 2, 3, 4, 5];\narray[array.length.random().floor()]; \u002F\u002F =\u003E Случайный элемент массива, например, 4\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Ca name=\"escape\"\u003E\u003C\u002Fa\u003E\u003Ch2\u003E\u003Cb\u003E\u003Ca href=\"#escape\"\u003E#\u003C\u002Fa\u003E Экранирование спецсимволов\u003C\u002Fb\u003E\u003C\u002Fh2\u003E\u003Chr\u002F\u003E\u003Cbr\u002F\u003E\r\n\u003Ca name=\"escape-html\"\u003E\u003C\u002Fa\u003E\u003Ca href=\"#escape-html\"\u003E\u003Cb\u003E#\u003C\u002Fb\u003E\u003C\u002Fa\u003E Если я внезапно, под конец статьи, скажу, что JavaScript используется, в первую очередь, для работы с HTML, то великой тайны не открою. Для работы с HTML как на клиенте, так и на сервере нам требуется его экранировать. Кто-то может сказать, что это задача фреймворка или шаблонизатора. Вот только стоит ли для такой примитивной задачи их тянуть? Методы для экранирования HTML есть во всех стандартных библиотеках. В Sugar, Prototype, MooTools это методы \u003Ccode\u003EescapeHTML\u003C\u002Fcode\u003E и \u003Ccode\u003EunescapeHTML\u003C\u002Fcode\u003E в прототипе строки. Не будем нарушать данную традицию:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003E'&lt;script\u003EdoSomething();&lt;\u002Fscript\u003E'.escapeHTML(); \u002F\u002F =\u003E '&amp;lt;script&amp;gt;doSomething();&amp;lt;\u002Fscript&amp;gt;'\n'&amp;lt;script&amp;gt;doSomething();&amp;lt;\u002Fscript&amp;gt;'.unescapeHTML(); \u002F\u002F =\u003E '&lt;script\u003EdoSomething();&lt;\u002Fscript\u003E'\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Ca name=\"escape-regexp\"\u003E\u003C\u002Fa\u003E\u003Ca href=\"#escape-regexp\"\u003E\u003Cb\u003E#\u003C\u002Fb\u003E\u003C\u002Fa\u003E Часто возникает необходимость создать регулярное выражение из пользовательских данных, а для корректной \u002F безопасной работы нужно экранировать и их. Методы для этого есть в Sugar, Prototype, MooTools, где-то как статический метод \u003Ccode\u003ERegExp\u003C\u002Fcode\u003E, где-то метод \u003Ccode\u003EString.prototype\u003C\u002Fcode\u003E. Давно \u003Ca href=\"http:\u002F\u002Fesdiscuss.org\u002Ftopic\u002Fregexp-escape\"\u003Eобсуждается\u003C\u002Fa\u003E добавление такого метода в ECMAScript. Надеюсь, мы дождемся этого, а пока реализуем \u003Ca href=\"https:\u002F\u002Fgist.github.com\u002Fkangax\u002F9698100\"\u003Eпредложенный вариант\u003C\u002Fa\u003E в нашей библиотеке:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"javascript\"\u003ERegExp.escape('Привет -[]{}()*+?.,\\\\^$|'); \u002F\u002F =\u003E 'Привет \\-\\[\\]\\{\\}\\(\\)\\*\\+\\?\\.\\,\\\\\\^\\$\\|'\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\n\u003Ca name=\"end\"\u003E\u003C\u002Fa\u003E\u003Ch2\u003E\u003Cb\u003E\u003Ca href=\"#end\"\u003E#\u003C\u002Fa\u003E Заключение\u003C\u002Fb\u003E\u003C\u002Fh2\u003E\u003Chr\u002F\u003E\u003Cbr\u002F\u003E\r\nНу вот как-то так.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nПредвижу появление в комментариях всем известной картинки xkcd про стандарты, вот только почти всё в библиотеке максимально соответствует имеющимся, а альтернатив её, кроме солянки далеко не из пары библиотек и весом в сотни килобайт, я не вижу.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nЧто касается планов на будущее библиотеки, они, в основном, раскиданы по тексту статьи. Еще нужно, конечно, оптимизировать производительность и лучше покрыть код тестами — с этим пока особо не заморачивался.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nИнтересует ваше мнение о том, что я, возможно, пропустил и что можно реализовать лучше.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cb\u003EДа. И еще, раз подобным страдать начал — скучно мне. Ищу интересный проект с достойной з\u002Fп.\u003C\u002Fb\u003E\u003C\u002Fdiv\u003E","tags":[{"titleHtml":"Core.js"},{"titleHtml":"ECMAScript 5"},{"titleHtml":"ECMAScript 6"},{"titleHtml":"ECMAScript 7"},{"titleHtml":"Harmony"},{"titleHtml":"Strawman"},{"titleHtml":"Map"},{"titleHtml":"Set"},{"titleHtml":"WeakMap"},{"titleHtml":"WeakSet"},{"titleHtml":"Promise"},{"titleHtml":"Symbol"},{"titleHtml":"console"},{"titleHtml":"setImmediate"},{"titleHtml":"Dict"},{"titleHtml":"итераторы"},{"titleHtml":"iterators"},{"titleHtml":"стандартная библиотека"},{"titleHtml":"standard library"}],"metadata":{"stylesUrls":[],"scriptUrls":[],"shareImageUrl":"https:\u002F\u002Fhabr.com\u002Fshare\u002Fpublication\u002F216997\u002F1e86b032fadde939287e7beae715f26a\u002F","shareImageWidth":1200,"shareImageHeight":630,"vkShareImageUrl":"https:\u002F\u002Fhabr.com\u002Fshare\u002Fpublication\u002F216997\u002F1e86b032fadde939287e7beae715f26a\u002F?format=vk","schemaJsonLd":"{\"@context\":\"http:\\\u002F\\\u002Fschema.org\",\"@type\":\"Article\",\"mainEntityOfPage\":{\"@type\":\"WebPage\",\"@id\":\"https:\\\u002F\\\u002Fhabr.com\\\u002Fru\\\u002Fpost\\\u002F216997\\\u002F\"},\"headline\":\"Размышления о стандартной библиотеке JavaScript. Core.js\",\"datePublished\":\"2014-11-18T14:57:02+03:00\",\"dateModified\":\"2015-05-05T15:18:05+03:00\",\"author\":{\"@type\":\"Person\",\"name\":\"Денис Пушкарев\"},\"publisher\":{\"@type\":\"Organization\",\"name\":\"Habr\",\"logo\":{\"@type\":\"ImageObject\",\"url\":\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fwebt\\\u002Fa_\\\u002Flk\\\u002F9m\\\u002Fa_lk9mjkccjox-zccjrpfolmkmq.png\"}},\"description\":\"Один пацан писал все на JavaScript, и клиент, и сервер, говорил что нравится, удобно, читабельно. Потом его в дурку забрали, конечно. &mdash; С просторов интернета К ч...\",\"url\":\"https:\\\u002F\\\u002Fhabr.com\\\u002Fru\\\u002Fpost\\\u002F216997\\\u002F#post-content-body\",\"about\":[\"h_webdev\",\"h_javascript\",\"h_nodejs\",\"f_develop\"],\"image\":[\"https:\\\u002F\\\u002Fhabr.com\\\u002Fshare\\\u002Fpublication\\\u002F216997\\\u002F1e86b032fadde939287e7beae715f26a\\\u002F\"]}","metaDescription":"Один пацан писал все на JavaScript, и клиент, и сервер, говорил что нравится, удобно, читабельно. Потом его в дурку забрали, конечно.\r\n— С просторов интернета\r\nК чему это я? Занятная штука —...","mainImageUrl":null,"amp":false,"customTrackerLinks":[]},"polls":[],"commentsEnabled":true,"rulesRemindEnabled":false,"votesEnabled":true,"status":"published","plannedPublishTime":null,"checked":null,"isEditorial":false}},"articlesIds":{},"isLoading":false,"pagesCount":{},"route":{},"reasonsList":null,"view":"cards","lastVisitedRoute":{},"ssrCommentsArticleIds":[""],"karma":{}},"authorContribution":{"authors":{}},"betaTest":{"currentAnnouncement":null,"announcements":{},"announcementCards":null,"announcementComments":{},"announcementCommentThreads":{},"announcementCommentingStatuses":{},"archivedList":[]},"authorStatistics":{"articleRefs":{},"articleIds":{},"pagesCount":{},"route":{},"viewsCount":[],"maxStatsCount":{}},"career":{"seoLandings":[{"title":"JavaScript разработчик","vacanciesCount":554,"itemUrl":"https:\u002F\u002Fcareer.habr.com\u002Fvacancies\u002Fprogrammist_javascript","itemHubs":["javascript","reactjs","nodejs","typescript","vuejs","angular","sveltejs"]},{"title":"Node.js разработчик","vacanciesCount":185,"itemUrl":"https:\u002F\u002Fcareer.habr.com\u002Fvacancies\u002Fnodejs_razrabotchik","itemHubs":["nodejs"]},{"title":"React разработчик","vacanciesCount":276,"itemUrl":"https:\u002F\u002Fcareer.habr.com\u002Fvacancies\u002Freact_razrabotchik","itemHubs":["javascript","reactjs"]}],"hubs":"webdev,javascript,nodejs"},"comments":{"articleComments":{},"searchCommentsResults":null,"previewComment":null,"pagesCount":null,"commentAccess":{},"scrollParents":{},"pageArticleComments":{"lastViewedComment":0,"postId":null,"lastCommentTimestamp":"","moderated":[],"moderatedIds":[],"commentRoute":""}},"companies":{"companyRefs":{},"companyIds":{},"companyTopIds":{},"pagesCount":{},"companyProfiles":{},"companiesCategories":[],"companiesCategoriesTotalCount":0,"companiesWidgets":{},"companiesWorkers":{},"companiesFans":{},"route":{},"isLoading":false,"companyWorkersLoading":false,"companyFansLoading":false,"vacancies":{},"workplaceInfo":null},"companyAdmin":{"companyInfo":null,"companyInfoLoading":false,"faqArticles":null,"brandingPreviewImageUrl":null},"companiesContribution":{"hubs":{},"flows":{},"companyRefs":{}},"companyHubsContribution":{"contributionRefs":{"hubRefs":{},"hubIds":{}}},"conversation":{"messages":[],"respondent":null,"isLoadMore":false},"conversations":{"conversations":[],"unreadCount":0,"pagesCount":0,"isLoadMore":false},"desktopState":{"desktopFl":null,"desktopHl":null,"isChecked":false,"isLoginDemanded":false},"docs":{"menu":{},"articles":{},"mainMenu":[],"loading":{"main":false,"dropdown":false,"article":false}},"feature":{"isProbablyVisible":"true"},"flows":{"flows":[{"alias":"develop","id":1,"route":{"name":"FLOW_PAGE","params":{"flowName":"develop"}}},{"alias":"admin","id":6,"route":{"name":"FLOW_PAGE","params":{"flowName":"admin"}}},{"alias":"design","id":2,"route":{"name":"FLOW_PAGE","params":{"flowName":"design"}}},{"alias":"management","id":3,"route":{"name":"FLOW_PAGE","params":{"flowName":"management"}}},{"alias":"marketing","id":4,"route":{"name":"FLOW_PAGE","params":{"flowName":"marketing"}}},{"alias":"popsci","id":7,"route":{"name":"FLOW_PAGE","params":{"flowName":"popsci"}}}]},"global":{"isPwa":false,"device":"desktop","isHabrCom":true},"hubs":{"hubRefs":{},"hubIds":{},"pagesCount":{},"isLoading":false,"route":{}},"hubsBlock":{"hubRefs":{},"hubIds":{}},"i18n":{"fl":"ru","hl":"ru"},"info":{"infoPage":{},"isLoading":true},"location":{"urlStruct":{"protocol":null,"slashes":null,"auth":null,"host":null,"port":null,"hostname":null,"hash":null,"search":null,"query":{},"pathname":null,"path":null,"href":""},"searchQuery":null},"me":{"user":null,"ppgDemanded":false,"karmaResetInfo":{"canReincarnate":null,"wasReincarnated":null,"currentScore":null},"notes":null},"mostReadingList":{"mostReadingListIds":[],"mostReadingListRefs":null,"promoPost":null},"pinnedPost":{"pinnedPost":null},"ppa":{"articles":{},"card":null,"transactions":null,"totalTransactions":null,"isAccessible":null},"projectsBlocks":{"activeBlocks":{}},"promoData":{"isLoading":false,"hasLoaded":false,"featurer":null,"megaposts":null,"promoLinks":null,"promoPosts":null},"pullRefresh":{"shouldRefresh":false},"sandbox":{"articleIds":[],"articleRefs":{},"pagesCount":null,"route":{},"lastVisitedRoute":{},"isLoading":false},"search":{"searchQueryError":null},"settingsOther":{"inputs":{"uiLang":{"errors":[],"ref":null,"value":""},"articlesLangEnglish":{"errors":[],"ref":null,"value":false},"articlesLangRussian":{"errors":[],"ref":null,"value":false},"agreement":{"errors":[],"ref":null,"value":false},"email":{"errors":[],"ref":null,"value":true},"digest":{"errors":[],"ref":null,"value":true}}},"similarList":{"similarListIds":[],"similarListRefs":null},"ssr":{"error":null,"isDataLoaded":false,"isDataLoading":false,"isHydrationFailed":false,"isServer":false},"technotext":{"nominationsList":[]},"userHubsContribution":{"contributionRefs":{"hubRefs":{},"hubIds":{}}},"userInvites":{"availableInvites":0,"usedInvitesIds":[],"usedInvitesRefs":{},"usedInvitesPagesCount":0,"unusedInvitesIds":[],"unusedInvitesRefs":{},"unusedInvitesPagesCount":0},"users":{"authorRefs":{},"authorIds":{},"pagesCount":{},"authorProfiles":{},"userHubs":{},"userInvitations":{},"authorFollowers":{},"authorFollowed":{},"userSpecialization":{},"karmaStats":[],"statistics":null,"isLoading":false,"authorFollowersLoading":false,"authorFollowedLoading":false,"userHubsLoading":false,"userInvitationsLoading":false,"route":{}},"viewport":{"prevScrollY":{},"scrollY":0,"width":0},"tracker":{"items":{},"pagesCache":{},"markedViewedSilently":{},"markedRead":{},"unreadCounters":{"applications":null,"system":null,"mentions":null,"subscribers":null,"posts_and_comments":null},"unviewedCounters":{"applications":null,"system":null,"mentions":null,"subscribers":null,"posts_and_comments":null}}};(function(){var s;(s=document.currentScript||document.scripts[document.scripts.length-1]).parentNode.removeChild(s);}());</script>
<script src="https://assets.habr.com/habr-web/js/chunk-vendors.da6c6b36.js" defer></script><script src="https://assets.habr.com/habr-web/js/app.92df6f6d.js" defer></script>



    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    </script>
  
  <script type="text/javascript" >
    (function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
    m[i].l=1*new Date();k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})
    (window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");

    ym(24049213, "init", {
      defer:true,
      trackLinks:true,
      accurateTrackBounce:true,
      webvisor:false,
    });
  </script>
  <noscript>
    <div>
      <img src="https://mc.yandex.ru/watch/24049213" style="position:absolute; left:-9999px;" alt="" />
    </div>
  </noscript>
  
    <script type="text/javascript">
      window.addEventListener('load', function () {
        setTimeout(() => {
          const img = new Image();
          img.src = 'https://vk.com/rtrg?p=VK-RTRG-421343-57vKE';
        }, 0);
      });
    </script>
  
<script src="https://habr.com/js/ads.js" onload="window['zhY4i4nJ9K'] = true"></script>
</body>
</html>
