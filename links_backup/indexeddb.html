<!DOCTYPE html><html lang="ru" data-theme-enabled="1"><head><script>window.currentUser = null;</script><script>window.rateUsdToNative = 98.8745;</script><title itemprop="name">IndexedDB</title><link href="https://learn.javascript.ru/pack/styles.151c2ad2b575d09af8f5.css" rel="stylesheet"><meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=yes, minimum-scale=1.0"><meta name="apple-mobile-web-app-capable" content="yes"><!-- chrome autotranslate is enabled only for "en" main version--><meta name="google" content="notranslate"><script>if (window.devicePixelRatio > 1) document.cookie = 'pixelRatio=' + window.devicePixelRatio + ';path=/;expires=Tue, 19 Jan 2038 03:14:07 GMT';</script><link href="https://fonts.googleapis.com/css?family=Open+Sans:bold,italic,bolditalic" rel="stylesheet"><link rel="apple-touch-icon-precomposed" href="https://learn.javascript.ru/img/favicon/apple-touch-icon-precomposed.png"><link rel="canonical" href="indexeddb.html"><meta name="msapplication-TileColor" content="#222A2C"><meta name="msapplication-TileImage" content="/img/favicon/tileicon.png"><link rel="icon" href="https://learn.javascript.ru/img/favicon/favicon.png"><meta itemprop="image" content="https://learn.javascript.ru/img/site_preview_ru_512x512.png"><meta property="og:title" content="IndexedDB"><meta property="og:image" content="https://learn.javascript.ru/img/site_preview_ru_1200x630.png"><meta property="og:image:type" content="image/png"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="630"><meta property="fb:admins" content="100001562528165"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="IndexedDB"><meta name="twitter:site" content="@iliakan"><meta name="twitter:creator" content="@iliakan"><meta name="twitter:image" content="https://learn.javascript.ru/img/site_preview_ru_512x512.png"><link rel="prev" href="https://learn.javascript.ru/localstorage"><link rel="next" href="https://learn.javascript.ru/animation"><script>window.GA_ID = "UA-2056213-16";</script><script>window.GTM_ID = 'GTM-WD2DZPG'</script><script>window.YANDEX_METRIKA_ID = 17649010;</script><script>window.GoogleAnalyticsObject="ga",window.ga=function(){window.ga.q.push(arguments)},window.ga.q=[],window.ga.l=Date.now(),ga("create",GA_ID,"auto"),window.GTM_ID&&ga("require",GTM_ID),window.currentUser?ga("set","&uid",currentUser.id):ga("set","anonymizeIp",!0),window.addEventListener("error",function(e){var r=(e.filename||e.errorUrl)+": "+(e.lineno||e.errorLine),n=e.stack||e.error&&e.error.stack;ga("send","exception",{exDescription:e.message+" "+r+" "+n,exFatal:!0})});</script><script src="https://www.google-analytics.com/analytics.js" async></script><script>ga('send', 'pageview');</script><script>window.metrika={reachGoal:function(){}},window.yandex_metrika_callbacks=[function(){try{window.metrika=new Ya.Metrika({id:YANDEX_METRIKA_ID,webvisor:!0,clickmap:!0,params:{user:window.currentUser&&window.currentUser.id}}),metrika.trackLinks({delay:150}),window.addEventListener("error",function(r){window.metrika.reachGoal("JSERROR",{src:(r.filename||r.errorUrl)+": "+(r.lineno||r.errorLine),stack:r.stack||r.error&&r.error.stack,message:r.message})})}catch(r){}}];</script><script src="https://mc.yandex.ru/metrika/watch.js" async></script><script>window.RECAPTCHA_ID = "6LfmLAEVAAAAAJMykMnf7aY8nkyTRmYi2ynx51R1";</script><script src="https://learn.javascript.ru/pack/init.f43ee4b37d6f76e4f838.js"></script><script src="https://learn.javascript.ru/pack/head.9546f64faccf13e736f6.js" defer></script><script src="https://cdn.jsdelivr.net/npm/idb@3.0.2/build/idb.min.js"></script><meta property="og:title" content="IndexedDB"><meta property="og:type" content="article"><script src="https://learn.javascript.ru/pack/tutorial.f792acb067a354bc7904.js" defer></script><script src="https://learn.javascript.ru/pack/footer.440ca4f81c63a09affe0.js" defer></script></head><body class="no-icons"><script>window.fontTest();</script><div class="page-wrapper page-wrapper_sidebar_on"><!--[if IE]><div style="color:red;text-align:center">Извините, Internet Explorer не поддерживается, пожалуйста используйте более новый браузер.</div><![endif]--><div class="sitetoolbar sitetoolbar_tutorial"><script>window.langs = [{"code":"ar","name":"Arabic"},{"code":"az","name":"Azerbaijani"},{"code":"bg","name":"Bulgarian"},{"code":"bn","name":"Bengali"},{"code":"bs","name":"Bosnian"},{"code":"ca","name":"Catalan"},{"code":"cs","name":"Czech"},{"code":"da","name":"Danish"},{"code":"de","name":"German"},{"code":"el","name":"Greek"},{"code":"en","name":"English"},{"code":"es","name":"Spanish"},{"code":"fa","name":"Persian (Farsi)"},{"code":"fi","name":"Finnish"},{"code":"fr","name":"French"},{"code":"he","name":"Hebrew"},{"code":"hi","name":"Hindi"},{"code":"hr","name":"Croatian"},{"code":"hu","name":"Hungarian"},{"code":"hy","name":"Armenian"},{"code":"id","name":"Indonesian"},{"code":"it","name":"Italian"},{"code":"ja","name":"Japanese"},{"code":"ka","name":"Georgian"},{"code":"kk","name":"Kazakh"},{"code":"km","name":"Central Khmer"},{"code":"ko","name":"Korean"},{"code":"lt","name":"Lithuanian"},{"code":"me","name":"Montenegrin"},{"code":"ml","name":"Malayalam"},{"code":"my","name":"Burmese"},{"code":"nl","name":"Dutch"},{"code":"no","name":"Norvegian"},{"code":"pa","name":"Punjabi"},{"code":"pl","name":"Polish"},{"code":"pt","name":"Portuguese"},{"code":"ro","name":"Romanian"},{"code":"ru","name":"Russian"},{"code":"si","name":"Sinhala"},{"code":"sk","name":"Slovak"},{"code":"sl","name":"Slovenian"},{"code":"sq","name":"Albanian"},{"code":"sr","name":"Serbian"},{"code":"ta","name":"Tamil"},{"code":"te","name":"Telugu"},{"code":"test","name":"Test"},{"code":"th","name":"Thai"},{"code":"tk","name":"Turkmen"},{"code":"tr","name":"Turkish"},{"code":"uk","name":"Ukrainian"},{"code":"ur","name":"Urdu"},{"code":"uz","name":"Uzbek"},{"code":"v2","name":"v2"},{"code":"vi","name":"Vietnamese"},{"code":"zh-hant","name":"Chinese Traditional"},{"code":"zh","name":"Chinese"}];</script><script>window.lang = "ru";</script><script>{let t=navigator.languages||[];t=t.map(t=>t.toLowerCase());let o,i,n=[];for(let o of window.langs)for(let i of t)if(i===o.code||i.startsWith(o.code+"-")){n.push(o);break}if(!o&&"ru"!=lang&&"en"!=lang){n.find(t=>"en"==t.code)&&(o=`\n            According to your browser headers, you know English. Please help to <a href="https://github.com/javascript-tutorial/${lang}.javascript.info#readme">translate the tutorial</a>.\n            Thank you!\n          `,i="notify-translate-tutorial-local")}if(o){let t=`<div class="notification notification_top notification_info sitetoolbar__notification" style="display:none" id="${i}">\n          <div class="notification__content">${o}</div>\n          <button class="notification__close" title="Close"></button>\n        </div>`;document.write(t),showTopNotification()}}</script><div class="sitetoolbar__content"><div class="sitetoolbar__lang-switcher"><button class="sitetoolbar__dropdown-button" data-dropdown-toggler>RU</button><div class="sitetoolbar__dropdown-wrap"><div class="sitetoolbar__dropdown-body"><div class="sitetoolbar__lang-switcher-body"><div class="supported-langs supported-langs_toolbar"><div class="supported-langs__container"><ul class="supported-langs__list" style="height:200px"><li class="supported-langs__item"><a class="supported-langs__link" href="https://ar.javascript.info/"><span class="supported-langs__brief">AR</span><span class="supported-langs__title">عربي</span></a></li><li class="supported-langs__item"><a class="supported-langs__link" href="https://javascript.info/indexeddb"><span class="supported-langs__brief">EN</span><span class="supported-langs__title">English</span></a></li><li class="supported-langs__item"><a class="supported-langs__link" href="https://es.javascript.info/indexeddb"><span class="supported-langs__brief">ES</span><span class="supported-langs__title">Español</span></a></li><li class="supported-langs__item"><a class="supported-langs__link" href="https://fr.javascript.info/"><span class="supported-langs__brief">FR</span><span class="supported-langs__title">Français</span></a></li><li class="supported-langs__item"><a class="supported-langs__link" href="https://id.javascript.info/"><span class="supported-langs__brief">ID</span><span class="supported-langs__title">Indonesia</span></a></li><li class="supported-langs__item"><a class="supported-langs__link" href="https://it.javascript.info/"><span class="supported-langs__brief">IT</span><span class="supported-langs__title">Italiano</span></a></li></ul><ul class="supported-langs__list" style="height:200px"><li class="supported-langs__item"><a class="supported-langs__link" href="https://ja.javascript.info/indexeddb"><span class="supported-langs__brief">JA</span><span class="supported-langs__title">日本語</span></a></li><li class="supported-langs__item"><a class="supported-langs__link" href="https://ko.javascript.info/"><span class="supported-langs__brief">KO</span><span class="supported-langs__title">한국어</span></a></li><li class="supported-langs__item supported-langs__item_current"><a class="supported-langs__link" href="indexeddb.html"><span class="supported-langs__brief">RU</span><span class="supported-langs__title">Русский</span></a></li><li class="supported-langs__item"><a class="supported-langs__link" href="https://tr.javascript.info/indexeddb"><span class="supported-langs__brief">TR</span><span class="supported-langs__title">Türkçe</span></a></li><li class="supported-langs__item"><a class="supported-langs__link" href="https://uk.javascript.info/"><span class="supported-langs__brief">UK</span><span class="supported-langs__title">Українська</span></a></li><li class="supported-langs__item"><a class="supported-langs__link" href="https://zh.javascript.info/indexeddb"><span class="supported-langs__brief">ZH</span><span class="supported-langs__title">简体中文</span></a></li></ul></div><div class="supported-langs__text">Мы хотим сделать этот проект с открытым исходным кодом доступным для людей во всем мире. Пожалуйста, <a href="https://github.com/javascript-tutorial/translate" rel="noopener noreferrer" target="_blank">помогите нам перевести</a> это руководство на свой язык</div></div></div></div></div></div><div class="sitetoolbar__logo-wrap"><a class="sitetoolbar__link sitetoolbar__link_logo" href="https://learn.javascript.ru/"><img class="sitetoolbar__logo sitetoolbar__logo_normal" src="https://learn.javascript.ru/img/sitetoolbar__logo_ru.svg" width="171" alt="" role="presentation"/><img class="sitetoolbar__logo sitetoolbar__logo_normal sitetoolbar__logo_dark" src="https://learn.javascript.ru/img/sitetoolbar__logo_ru-white.svg" width="171" alt="" role="presentation"/><img class="sitetoolbar__logo sitetoolbar__logo_small" src="https://learn.javascript.ru/img/sitetoolbar__logo_small_ru.svg" width="80" alt="" role="presentation"/><img class="sitetoolbar__logo sitetoolbar__logo_small sitetoolbar__logo_dark" src="https://learn.javascript.ru/img/sitetoolbar__logo_small_ru-white.svg" width="80" alt="" role="presentation"/><script>Array.prototype.forEach.call(document.querySelectorAll("img.sitetoolbar__logo"),function(e){let t=document.createElement("object");t.type="image/svg+xml",t.className=e.className,t.style.cssText="left:0;top:0;position:absolute",t.onload=function(){t.onload=null,e.style.visibility="hidden"},t.data=e.src,e.parentNode.insertBefore(t,e)});</script></a></div><div class="sitetoolbar__nav-toggle-wrap"><button class="sitetoolbar__nav-toggle" type="button"></button></div><nav class="sitetoolbar__sections"><ul class="sitetoolbar__sections-list"><li class="sitetoolbar__section sitetoolbar__section_current"><a class="sitetoolbar__link" href="https://learn.javascript.ru/">Учебник</a></li><li class="sitetoolbar__section"><a class="sitetoolbar__link" href="https://learn.javascript.ru/courses">Курсы</a></li><li class="sitetoolbar__section"><a class="sitetoolbar__link" href="https://javascript.ru/forum/">Форум</a></li><li class="sitetoolbar__section"><a class="sitetoolbar__link" href="https://learn.javascript.ru/quiz">Тесты знаний</a></li><li class="sitetoolbar__section sitetoolbar__section_dropdown"><button class="sitetoolbar__dropdown-button" data-dropdown-toggler>Скринкасты</button><div class="sitetoolbar__dropdown-wrap"><div class="sitetoolbar__dropdown-body"><ul class="sitetoolbar__dropdown-items"><li class="sitetoolbar__dropdown-item"><a class="sitetoolbar__secondary-link sitetoolbar__dropdown-link" href="https://learn.javascript.ru/screencast/nodejs">Node.js</a></li><li class="sitetoolbar__dropdown-item"><a class="sitetoolbar__secondary-link sitetoolbar__dropdown-link" href="https://learn.javascript.ru/screencast/webpack">Webpack</a></li><li class="sitetoolbar__dropdown-item"><a class="sitetoolbar__secondary-link sitetoolbar__dropdown-link" href="https://learn.javascript.ru/screencast/gulp">Gulp</a></li><li class="sitetoolbar__dropdown-item"><a class="sitetoolbar__secondary-link sitetoolbar__dropdown-link" href="https://learn.javascript.ru/screencast/react">React.js</a></li><li class="sitetoolbar__dropdown-item"><a class="sitetoolbar__secondary-link sitetoolbar__dropdown-link" href="https://learn.javascript.ru/screencast/angular">Angular</a></li><li class="sitetoolbar__dropdown-item"><a class="sitetoolbar__secondary-link sitetoolbar__dropdown-link" href="https://youtu.be/W4hoc24K93E?list=PLDyvV36pndZFHXjXuwA_NywNrVQO0aQqb">Git: курс</a></li><li class="sitetoolbar__dropdown-item"><a class="sitetoolbar__secondary-link sitetoolbar__dropdown-link" href="https://youtu.be/lHacJuru1bc?list=PLDyvV36pndZEB7kWWocU4QSn-G78LoaEE">Git: разное</a></li></ul></div></div></li></ul></nav><div class="sitetoolbar__book-wrap"><a class="buy-book-button" href="https://learn.javascript.ru/ebook"><span class="buy-book-button__extra-text">Купить</span>EPUB/PDF</a></div><div class="sitetoolbar__login-wrap"><button class="sitetoolbar__login sitetoolbar__login_unready" data-action-login></button></div><div class="sitetoolbar__theme-switcher"><div class="theme-changer"><label class="theme-changer__label" for="theme-changer-input" data-tooltip="Сменить тему оформления"><input class="theme-changer__input" type="checkbox" id="theme-changer-input" data-theme-changer="data-theme-changer"/><span class="theme-changer__icon theme-changer__icon_light-theme"></span><span class="theme-changer__icon theme-changer__icon_dark-theme"></span></label></div></div><div class="sitetoolbar__search-wrap"><div class="sitetoolbar__search-content"><button class="sitetoolbar__search-toggle" type="button"></button><form class="sitetoolbar__search" method="GET" action="https://learn.javascript.ru/search"><div class="sitetoolbar__search-input"><div class="text-input"><input class="text-input__control" name="query" placeholder="Искать на Javascript.ru" required="required" type="text"/></div><button class="sitetoolbar__find" type="submit">Найти</button></div></form></div></div></div><div class="tablet-menu"><div class="tablet-menu__line"><div class="tablet-menu__content"><select class="tablet-menu__nav input-select input-select input-select_small" onchange="if(this.value) window.location.href=this.value"><option value="/" selected>Учебник</option><option value="/courses">Курсы</option><option value="https://javascript.ru/forum/">Форум</option><option value="/quiz">Тесты знаний</option></select></div></div><div class="tablet-menu__line"><div class="tablet-menu__content"><form class="tablet-menu-search" action="https://learn.javascript.ru/search/"><input class="tablet-menu-search__input" type="search" name="query" placeholder="Поиск в учебнике" required="required"/><button class="tablet-menu-search__button" type="submit" name="type" value="articles">Поиск</button></form></div></div><div class="tablet-menu__line"><div class="tablet-menu__content"><a class="map" href="https://learn.javascript.ru/tutorial/map" data-action="tutorial-map"><span class="map__text">Карта учебника</span></a></div></div><div class="tablet-menu__line"><div class="tablet-menu__content"><div class="theme-changer theme-changer_tablet-menu theme-changer_has-label"><label class="theme-changer__label" for="theme-changer-input-tablet" data-tooltip="Сменить тему оформления"><input class="theme-changer__input" type="checkbox" id="theme-changer-input-tablet" data-theme-changer="data-theme-changer"/><span class="theme-changer__icon theme-changer__icon_light-theme"></span><span class="theme-changer__icon theme-changer__icon_dark-theme"></span><span class="theme-changer__label-text theme-changer__label-text_light-theme">Светлая тема</span><span class="theme-changer__label-text theme-changer__label-text_dark-theme">Тёмная тема</span></label></div></div></div><div class="tablet-menu__line"><div class="tablet-menu__content"><div class="share-icons"><span class="share-icons__title">Поделиться</span><a class="share share_tw" href="https://twitter.com/share?url=https%3A%2F%2Flearn.javascript.ru%2Findexeddb" rel="nofollow"></a><a class="share share_fb" href="https://www.facebook.com/sharer/sharer.php?s=100&amp;p%5Burl%5D=https%3A%2F%2Flearn.javascript.ru%2Findexeddb" rel="nofollow"></a><a class="share share_vk" href="https://vkontakte.ru/share.php?url=https%3A%2F%2Flearn.javascript.ru%2Findexeddb" rel="nofollow"></a></div></div></div><div class="tablet-menu__line"><div class="tablet-menu__content"><select class="tablet-menu__nav input-select input-select input-select_small" onchange="if(this.value) window.location.href=this.value"><option value="https://ar.javascript.info/">عربي</option><option value="https://javascript.info/indexeddb">English</option><option value="https://es.javascript.info/indexeddb">Español</option><option value="https://fr.javascript.info/">Français</option><option value="https://id.javascript.info/">Indonesia</option><option value="https://it.javascript.info/">Italiano</option><option value="https://ja.javascript.info/indexeddb">日本語</option><option value="https://ko.javascript.info/">한국어</option><option value="https://learn.javascript.ru/indexeddb" selected>Русский</option><option value="https://tr.javascript.info/indexeddb">Türkçe</option><option value="https://uk.javascript.info/">Українська</option><option value="https://zh.javascript.info/indexeddb">简体中文</option></select></div></div></div><progress class="tutorial-progress" data-sticky value="3" max="3" data-tooltip="Урок 3 из 3"></progress></div><div class="page page_sidebar_on page_inner_padding"><script>if(localStorage.noSidebar){document.querySelector(".page").classList.remove("page_sidebar_on");let e=document.querySelector(".page-wrapper");e&&e.classList.remove("page-wrapper_sidebar_on")}setTimeout(function(){document.querySelector(".page").classList.add("page_sidebar-animation-on")});</script><div class="page__inner"><main class="main main_width-limit"><header class="main__header"><div class="main__header-inner"><div class="main__header-group"><ol class="breadcrumbs"><li class="breadcrumbs__item breadcrumbs__item_home"><a class="breadcrumbs__link" href="https://learn.javascript.ru/"><span class="breadcrumbs__hidden-text">Учебник</span></a></li><li class="breadcrumbs__item" id="breadcrumb-1"><a class="breadcrumbs__link" href="https://learn.javascript.ru/data-storage"><span>Хранение данных в браузере</span></a></li><script type="application/ld+json">{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Учебник","item":"https://learn.javascript.ru/"},{"@type":"ListItem","position":2,"name":"Хранение данных в браузере","item":"https://learn.javascript.ru/data-storage"}]}</script></ol><div class="updated-at" data-tooltip="Последнее обновление: 14-го декабря 2021"><div class="updated-at__content">14-го декабря 2021</div></div></div><h1 class="main__header-title">IndexedDB</h1></div></header><div class="content"><article class="formatted" itemscope itemtype="http://schema.org/TechArticle"><meta itemprop="name" content="IndexedDB"><div itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="email" content="iliakan@gmail.com"><meta itemprop="name" content="Ilya Kantor"></div><div itemprop="articleBody"><p>IndexedDB – это встроенная база данных, более мощная, чем <code>localStorage</code>.</p>
<ul>
<li>Хранилище ключей/значений: доступны несколько типов ключей, а значения могут быть (почти) любыми.</li>
<li>Поддерживает транзакции для надёжности.</li>
<li>Поддерживает запросы в диапазоне ключей и индексы.</li>
<li>Позволяет хранить больше данных, чем <code>localStorage</code>.</li>
</ul>
<p>Для традиционных клиент-серверных приложений эта мощность обычно чрезмерна. IndexedDB предназначена для оффлайн приложений, можно совмещать с ServiceWorkers и другими технологиями.</p>
<p>Интерфейс для IndexedDB, описанный в спецификации <a href="https://www.w3.org/TR/IndexedDB">https://www.w3.org/TR/IndexedDB</a>, основан на событиях.</p>
<p>Мы также можем использовать <code>async/await</code> с помощью обёртки, которая основана на промисах, например <a href="https://github.com/jakearchibald/idb">https://github.com/jakearchibald/idb</a>. Это очень удобно, но обёртка не идеальна, она не может полностью заменить события. Поэтому мы начнём с событий, а затем, когда разберёмся в IndexedDB, рассмотрим и обёртку.</p>
<h2><a class="main__anchor" name="otkryt-bazu-dannyh" href="indexeddb.html#otkryt-bazu-dannyh">Открыть базу данных</a></h2><p>Для начала работы с IndexedDB нужно открыть базу данных.</p>
<p>Синтаксис:</p>
<div id="pbyncpds1v" data-trusted="1" class="code-example">
      <div class="codebox code-example__codebox">
        
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code>let openRequest = indexedDB.open(name, version);</code></pre>
        </div>
      </div>
      
      </div><ul>
<li><code>name</code> – название базы данных, строка.</li>
<li><code>version</code> – версия базы данных, положительное целое число, по умолчанию <code>1</code> (объясняется ниже).</li>
</ul>
<p>У нас может быть множество баз данных с различными именами, но все они существуют в контексте текущего источника (домен/протокол/порт). Разные сайты не могут получить доступ к базам данных друг друга.</p>
<p>После этого вызова необходимо назначить обработчик событий для объекта <code>openRequest</code>:</p>
<ul>
<li><code>success</code>: база данных готова к работе, готов «объект базы данных» <code>openRequest.result</code>, его следует использовать для дальнейших вызовов.</li>
<li><code>error</code>: не удалось открыть базу данных.</li>
<li><code>upgradeneeded</code>: база открыта, но её схема устарела (см. ниже).</li>
</ul>
<p><strong>IndexedDB имеет встроенный механизм «версионирования схемы», который отсутствует в серверных базах данных.</strong></p>
<p>В отличие от серверных баз данных, IndexedDB работает на стороне клиента, в браузере, и у нас нет прямого доступа к данным. Но когда мы публикуем новую версию нашего приложения,  возможно, нам понадобится обновить базу данных.</p>
<p>Если локальная версия базы данных меньше, чем версия, определённая в <code>open</code>, то сработает специальное событие <code>upgradeneeded</code>, и мы сможем сравнить версии и обновить структуры данных по мере необходимости.</p>
<p>Это событие также сработает, если базы данных ещё не существует, так что в этом обработчике мы можем выполнить инициализацию.</p>
<p>Например, когда мы впервые публикуем наше приложение, мы открываем базу данных с версией <code>1</code> и выполняем инициализацию в обработчике <code>upgradeneeded</code>:</p>
<div id="efgh8hr2ax" data-trusted="1" class="code-example" data-highlight="[{&quot;start&quot;:0,&quot;cols&quot;:[{&quot;start&quot;:42,&quot;end&quot;:43}]}]">
      <div class="codebox code-example__codebox">
        
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code>let openRequest = indexedDB.open(&quot;store&quot;, 1);

openRequest.onupgradeneeded = function() {
  // срабатывает, если на клиенте нет базы данных
  // ...выполнить инициализацию...
};

openRequest.onerror = function() {
  console.error(&quot;Error&quot;, openRequest.error);
};

openRequest.onsuccess = function() {
  let db = openRequest.result;
  // продолжить работу с базой данных, используя объект db
};</code></pre>
        </div>
      </div>
      
      </div><p>Когда мы публикуем вторую версию:</p>
<div id="nwlfupu1q1" data-trusted="1" class="code-example" data-highlight="[{&quot;start&quot;:0,&quot;cols&quot;:[{&quot;start&quot;:42,&quot;end&quot;:43}]}]">
      <div class="codebox code-example__codebox">
        
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code>let openRequest = indexedDB.open(&quot;store&quot;, 2);

// проверить существование указанной версии базы данных, обновить по мере необходимости:
openRequest.onupgradeneeded = function() {
  // версия существующей базы данных меньше 2 (или база данных не существует)
  let db = openRequest.result;
  switch(db.version) { // существующая (старая) версия базы данных
    case 0:
      // версия 0 означает, что на клиенте нет базы данных
      // выполнить инициализацию
    case 1:
      // на клиенте версия базы данных 1
      // обновить
  }
};</code></pre>
        </div>
      </div>
      
      </div><p>Таким образом, в <code>openRequest.onupgradeneeded</code> мы обновляем базу данных. Скоро подробно увидим, как это делается. А после того, как этот обработчик завершится без ошибок, сработает <code>openRequest.onsuccess</code>.</p>
<p>После <code>openRequest.onsuccess</code> у нас есть объект базы данных в <code>openRequest.result</code>, который мы будем использовать для дальнейших операций.</p>
<p>Удалить базу данных:</p>
<div id="jl9jyjsm9r" data-trusted="1" class="code-example">
      <div class="codebox code-example__codebox">
        
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code>let deleteRequest = indexedDB.deleteDatabase(name)
// deleteRequest.onsuccess/onerror отслеживает результат</code></pre>
        </div>
      </div>
      
      </div><div class="important important_warn">
            <div class="important__header"><span class="important__type">А что, если открыть предыдущую версию?</span></div>
            <div class="important__content"><p>Что если мы попробуем открыть базу с более низкой версией, чем текущая? Например, на клиенте база версии 3, а мы вызываем <code>open(...2)</code>.</p>
<p>Возникнет ошибка, сработает <code>openRequest.onerror</code>.</p>
<p>Такое может произойти, если посетитель загрузил устаревший код, например, из кеша прокси. Нам следует проверить <code>db.version</code> и предложить ему перезагрузить страницу. А также проверить наши кеширующие заголовки, убедиться, что посетитель никогда не получит устаревший код.</p>
</div></div>
<h3><a class="main__anchor" name="problema-parallelnogo-obnovleniya" href="indexeddb.html#problema-parallelnogo-obnovleniya">Проблема параллельного обновления</a></h3><p>Раз уж мы говорим про версионирование, рассмотрим связанную с этим небольшую проблему.</p>
<p>Допустим, посетитель открыл наш сайт во вкладке браузера, с базой версии 1.</p>
<p>Затем мы выкатили обновление, и тот же посетитель открыл наш сайт в другой вкладке. Так что есть две вкладки, на которых открыт наш сайт, но в одной открыто соединение с базой версии 1, а другая пытается обновить версию базы в обработчике <code>upgradeneeded</code>.</p>
<p>Проблема заключается в том, что база данных всего одна на две вкладки, так как это один и тот же сайт, один источник. И она не может быть одновременно версии 1 и 2. Чтобы обновить на версию 2, все соединения к версии 1 должны быть закрыты.</p>
<p>Чтобы это можно было организовать, при попытке обновления на объекте базы возникает событие <code>versionchange</code>. Нам нужно слушать его и закрыть соединение к базе (а также, возможно, предложить пользователю перезагрузить страницу, чтобы получить обновлённый код).</p>
<p>Если мы его не закроем, то второе, новое соединение будет заблокировано с событием <code>blocked</code> вместо <code>success</code>.</p>
<p>Код, который это делает:</p>
<div id="7yyohdsdrt" data-trusted="1" class="code-example" data-highlight="[{&quot;start&quot;:16,&quot;end&quot;:19},{&quot;start&quot;:8,&quot;end&quot;:11}]">
      <div class="codebox code-example__codebox">
        
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code>let openRequest = indexedDB.open(&quot;store&quot;, 2);

openRequest.onupgradeneeded = ...;
openRequest.onerror = ...;

openRequest.onsuccess = function() {
  let db = openRequest.result;

  db.onversionchange = function() {
    db.close();
    alert(&quot;База данных устарела, пожалуста, перезагрузите страницу.&quot;)
  };

  // ...база данных доступна как объект db...
};

openRequest.onblocked = function() {
  // есть другое соединение к той же базе
  // и оно не было закрыто после срабатывания на нём db.onversionchange
};</code></pre>
        </div>
      </div>
      
      </div><p>Здесь мы делаем две вещи:</p>
<ol>
<li>Добавляем обработчик <code>db.onversionchange</code> после успешного открытия базы, чтобы узнать о попытке параллельного обновления.</li>
<li>Добавляем обработчик <code>openRequest.onblocked</code> для ситуаций, когда старое соединение не было закрыто. Такого не произойдёт, если мы закрываем его в <code>db.onversionchange</code>.</li>
</ol>
<p>Есть и другие варианты. Например, мы можем более «мягко» закрыть соединение в <code>db.onversionchange</code>, предложить пользователю сохранить данные перед этим. Новое обновляющее соединение будет заблокировано сразу после того как обработчик <code>db.onversionchange</code> завершится, не закрыв соединение, и мы можем в новой вкладке попросить посетителя закрыть старые для обновления.</p>
<p>Такой конфликт при обновлении происходит редко, но мы должны как-то его обрабатывать, хотя бы поставить обработчик <code>onblocked</code>, чтобы наш скрипт не «умирал» молча, удивляя посетителя.</p>
<h2><a class="main__anchor" name="hranilische-obektov" href="indexeddb.html#hranilische-obektov">Хранилище объектов</a></h2><p>Чтобы сохранить что-то в IndexedDB, нам нужно <em>хранилище объектов</em>.</p>
<p>Хранилище объектов – это основная концепция IndexedDB. В других базах данных это «таблицы» или «коллекции». Здесь хранятся данные. В базе данных может быть множество хранилищ: одно для пользователей, другое для товаров и так далее.</p>
<p>Несмотря на то, что название – «хранилище объектов», примитивы тоже могут там храниться.</p>
<p><strong>Мы можем хранить почти любое значение, в том числе сложные объекты.</strong></p>
<p>IndexedDB использует <a href="https://www.w3.org/TR/html53/infrastructure.html#section-structuredserializeforstorage">стандартный алгоритм сериализации</a> для клонирования и хранения объекта. Это как <code>JSON.stringify</code>, но более мощный, способный хранить гораздо больше типов данных.</p>
<p>Пример объекта, который нельзя сохранить: объект с циклическими ссылками. Такие объекты не сериализуемы. <code>JSON.stringify</code> также выдаст ошибку при сериализации.</p>
<p><strong>Каждому значению в хранилище должен соответствовать уникальный ключ.</strong></p>
<p>Ключ должен быть одним из следующих типов: number, date, string, binary или array. Это уникальный идентификатор: по ключу мы можем искать/удалять/обновлять значения.</p>
<figure><div class="image" style="width:484px">
      <div class="image__ratio" style="padding-top:55.16528925619835%"></div>
      <object type="image/svg+xml" data="https://learn.javascript.ru/article/indexeddb/indexeddb-structure.svg" width="484" height="267" class="image__image" data-use-theme>
        <img src="https://learn.javascript.ru/article/indexeddb/indexeddb-structure.svg" alt="" width="484" height="267">
      </object>
      </div></figure><p>Как мы видим, можно указать ключ при добавлении значения в хранилище, аналогично <code>localStorage</code>. Но когда мы храним объекты, IndexedDB позволяет установить свойство объекта в качестве ключа, что гораздо удобнее. Или мы можем автоматически сгенерировать ключи.</p>
<p>Но для начала нужно создать хранилище.</p>
<p>Синтаксис для создания хранилища объектов:</p>
<div id="qxt47fzqdi" data-trusted="1" class="code-example">
      <div class="codebox code-example__codebox">
        
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code>db.createObjectStore(name[, keyOptions]);</code></pre>
        </div>
      </div>
      
      </div><p>Обратите внимание, что операция является синхронной, использование <code>await</code> не требуется.</p>
<ul>
<li><code>name</code> – это название хранилища, например <code>&quot;books&quot;</code> для книг,</li>
<li><code>keyOptions</code> – это необязательный объект с одним или двумя свойствами:
<ul>
<li><code>keyPath</code> – путь к свойству объекта, которое IndexedDB будет использовать в качестве ключа, например <code>id</code>.</li>
<li><code>autoIncrement</code> – если <code>true</code>, то ключ будет формироваться автоматически для новых объектов, как постоянно увеличивающееся число.</li>
</ul>
</li>
</ul>
<p>Если при создании хранилища не указать <code>keyOptions</code>, то нам потребуется явно указать ключ позже, при сохранении объекта.</p>
<p>Например, это хранилище объектов использует свойство <code>id</code> как ключ:</p>
<div id="vgrmgu5jp1" data-trusted="1" class="code-example">
      <div class="codebox code-example__codebox">
        
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code>db.createObjectStore('books', {keyPath: 'id'});</code></pre>
        </div>
      </div>
      
      </div><p><strong>Хранилище объектов можно создавать/изменять только при обновлении версии базы данных в обработчике <code>upgradeneeded</code>.</strong></p>
<p>Это техническое ограничение. Вне обработчика мы сможем добавлять/удалять/обновлять данные, но хранилища объектов могут быть созданы/удалены/изменены только во время обновления версии базы данных.</p>
<p>Для обновления версии базы есть два основных подхода:</p>
<ol>
<li>Мы можем реализовать функции обновления по версиям: с 1 на 2, с 2 на 3 и т.д. Потом в <code>upgradeneeded</code> сравнить версии (например, была 2, сейчас 4) и запустить операции обновления для каждой промежуточной версии (2 на 3, затем 3 на 4).</li>
<li>Или мы можем взять список существующих хранилищ объектов, используя <code>db.objectStoreNames</code>. Этот объект является <a href="https://html.spec.whatwg.org/multipage/common-dom-interfaces.html#domstringlist">DOMStringList</a>, в нём есть метод <code>contains(name)</code>, используя который можно проверить существование хранилища. Посмотреть, какие хранилища есть и создать те, которых нет.</li>
</ol>
<p>Для простых баз данных второй подход может быть проще и предпочтительнее.</p>
<p>Вот демонстрация второго способа:</p>
<div id="hibedh17uk" data-trusted="1" class="code-example">
      <div class="codebox code-example__codebox">
        
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code>let openRequest = indexedDB.open(&quot;db&quot;, 2);

// создаём хранилище объектов для books, если ешё не существует
openRequest.onupgradeneeded = function() {
  let db = openRequest.result;
  if (!db.objectStoreNames.contains('books')) { // если хранилище &quot;books&quot; не существует
    db.createObjectStore('books', {keyPath: 'id'}); // создаем хранилище
  }
};</code></pre>
        </div>
      </div>
      
      </div><p>Чтобы удалить хранилище объектов:</p>
<div id="nfppvw6e3f" data-trusted="1" class="code-example">
      <div class="codebox code-example__codebox">
        
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code>db.deleteObjectStore('books')</code></pre>
        </div>
      </div>
      
      </div><h2><a class="main__anchor" name="tranzaktsii" href="indexeddb.html#tranzaktsii">Транзакции</a></h2><p>Термин «транзакция» является общеизвестным, транзакции используются во многих видах баз данных.</p>
<p>Транзакция – это группа операций, которые должны быть или все выполнены, или все не выполнены (всё или ничего).</p>
<p>Например, когда пользователь что-то покупает, нам нужно:</p>
<ol>
<li>Вычесть деньги с его счёта.</li>
<li>Отправить ему покупку.</li>
</ol>
<p>Будет очень плохо, если мы успеем завершить первую операцию, а затем что-то пойдёт не так, например отключат электричество, и мы не сможем завершить вторую операцию. Обе операции должны быть успешно завершены (покупка сделана, отлично!) или необходимо отменить обе операции (в этом случае пользователь сохранит свои деньги и может попытаться купить ещё раз).</p>
<p>Транзакции гарантируют это.</p>
<p><strong>Все операции с данными в IndexedDB могут быть сделаны только внутри транзакций.</strong></p>
<p>Для начала транзакции:</p>
<div id="j5v2gfxs5r" data-trusted="1" class="code-example">
      <div class="codebox code-example__codebox">
        
        <div class="toolbar codebox__toolbar">
          <div class="toolbar__tool">
            <a href="indexeddb.html#" title="выполнить" data-action="run" class="toolbar__button toolbar__button_run"></a>
          </div>
          <div class="toolbar__tool">
            <a href="indexeddb.html#" title="открыть в песочнице" target="_blank" data-action="edit" class="toolbar__button toolbar__button_edit"></a>
          </div>
        </div>
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code>db.transaction(store[, type]);</code></pre>
        </div>
      </div>
      
      </div><ul>
<li><code>store</code> – это название хранилища, к которому транзакция получит доступ, например, <code>&quot;books&quot;</code>. Может быть массивом названий, если нам нужно предоставить доступ к нескольким хранилищам.</li>
<li><code>type</code> – тип транзакции, один из:
<ul>
<li><code>readonly</code> – только чтение, по умолчанию.</li>
<li><code>readwrite</code> – только чтение и запись данных, создание/удаление самих хранилищ объектов недоступно.</li>
</ul>
</li>
</ul>
<p>Есть ещё один тип транзакций: <code>versionchange</code>. Такие транзакции могут делать любые операции, но мы не можем создать их вручную. IndexedDB автоматически создаёт транзакцию типа <code>versionchange</code>, когда открывает базу данных, для обработчика <code>updateneeded</code>. Вот почему это единственное место, где мы можем обновлять структуру базы данных, создавать/удалять хранилища объектов.</p>
<div class="important important_smart">
            <div class="important__header"><span class="important__type">Почему существует несколько типов транзакций?</span></div>
            <div class="important__content"><p>Производительность является причиной, почему транзакции необходимо помечать как <code>readonly</code> или <code>readwrite</code>.</p>
<p>Несколько readonly транзакций могут одновременно работать с одним и тем же хранилищем объектов, а readwrite транзакций – не могут. Транзакции типа readwrite «блокируют» хранилище для записи. Следующая такая транзакция должна дождаться выполнения предыдущей, перед тем как получит доступ к тому же самому хранилищу.</p>
</div></div>
<p>После того, как транзакция будет создана, мы можем добавить элемент в хранилище, вот так:</p>
<div id="78ubawyygr" data-trusted="1" class="code-example" data-highlight="[{&quot;start&quot;:11,&quot;end&quot;:11},{&quot;start&quot;:3,&quot;end&quot;:3}]">
      <div class="codebox code-example__codebox">
        
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code>let transaction = db.transaction(&quot;books&quot;, &quot;readwrite&quot;); // (1)

// получить хранилище объектов для работы с ним
let books = transaction.objectStore(&quot;books&quot;); // (2)

let book = {
  id: 'js',
  price: 10,
  created: new Date()
};

let request = books.add(book); // (3)

request.onsuccess = function() { // (4)
  console.log(&quot;Книга добавлена в хранилище&quot;, request.result);
};

request.onerror = function() {
  console.log(&quot;Ошибка&quot;, request.error);
};</code></pre>
        </div>
      </div>
      
      </div><p>Мы сделали четыре шага:</p>
<ol>
<li>Создать транзакцию и указать все хранилища, к которым необходим доступ, строка <code>(1)</code>.</li>
<li>Получить хранилище объектов, используя <code>transaction.objectStore(name)</code>, строка <code>(2)</code>.</li>
<li>Выполнить запрос на добавление элемента в хранилище объектов <code>books.add(book)</code>, строка <code>(3)</code>.</li>
<li>…Обработать результат запроса <code>(4)</code>, затем мы можем выполнить другие запросы и так далее.</li>
</ol>
<p>Хранилища объектов поддерживают два метода для добавления значений:</p>
<ul>
<li>
<p><strong>put(value, [key])</strong>
Добавляет значение <code>value</code> в хранилище. Ключ <code>key</code> необходимо указать, если при создании хранилища объектов не было указано свойство <code>keyPath</code> или <code>autoIncrement</code>. Если уже есть значение с таким же ключом, то оно будет заменено.</p>
</li>
<li>
<p><strong>add(value, [key])</strong>
То же, что <code>put</code>, но если уже существует значение с таким ключом, то запрос не выполнится, будет сгенерирована ошибка с названием <code>&quot;ConstraintError&quot;</code>.</p>
</li>
</ul>
<p>Аналогично открытию базы, мы отправляем запрос: <code>books.add(book)</code> и после ожидаем события <code>success/error</code>.</p>
<ul>
<li><code>request.result</code> для <code>add</code> является ключом нового объекта.</li>
<li>Ошибка находится в <code>request.error</code> (если есть).</li>
</ul>
<h2><a class="main__anchor" name="avtomaticheskaya-fiksatsiya-tranzaktsiy" href="indexeddb.html#avtomaticheskaya-fiksatsiya-tranzaktsiy">Автоматическая фиксация транзакций</a></h2><p>В примере выше мы запустили транзакцию и выполнили запрос <code>add</code>. Но, как говорилось ранее, транзакция может включать в себя несколько запросов, которые все вместе должны либо успешно завершиться, либо нет. Как нам закончить транзакцию, обозначить, что больше запросов в ней не будет?</p>
<p>Короткий ответ: этого не требуется.</p>
<p>В следующей 3.0 версии спецификации, вероятно, будет возможность вручную завершить транзакцию, но сейчас, в версии 2.0, такой возможности нет.</p>
<p><strong>Когда все запросы завершены и <a href="https://learn.javascript.ru/microtask-queue">очередь микрозадач</a> пуста, тогда транзакция завершится автоматически.</strong></p>
<p>Как правило, это означает, что транзакция автоматически завершается, когда выполнились все её запросы и завершился текущий код.</p>
<p>Таким образом, в приведённом выше примере не требуется никакой специальный вызов, чтобы завершить транзакцию.</p>
<p>Такое автозавершение транзакций имеет важный побочный эффект. Мы не можем вставить асинхронную операцию, такую как <code>fetch</code> или <code>setTimeout</code> в середину транзакции. IndexedDB никак не заставит транзакцию «висеть» и ждать их выполнения.</p>
<p>В приведённом ниже коде в запросе <code>request2</code> в строке с <code>(*)</code> будет ошибка, потому что транзакция уже завершена, больше нельзя выполнить в ней запрос:</p>
<div id="i7wnsxqirh" data-trusted="1" class="code-example" data-highlight="[{&quot;start&quot;:4,&quot;end&quot;:4}]">
      <div class="codebox code-example__codebox">
        
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code>let request1 = books.add(book);

request1.onsuccess = function() {
  fetch('/').then(response =&gt; {
    let request2 = books.add(anotherBook); // (*)
    request2.onerror = function() {
      console.log(request2.error.name); // TransactionInactiveError
    };
  });
};</code></pre>
        </div>
      </div>
      
      </div><p>Всё потому, что <code>fetch</code> является асинхронной операцией, макрозадачей. Транзакции завершаются раньше, чем браузер приступает к выполнению макрозадач.</p>
<p>Авторы спецификации IndexedDB из соображений производительности считают, что транзакции должны завершаться быстро.</p>
<p>В частности, <code>readwrite</code> транзакции «блокируют» хранилища от записи. Таким образом, если одна часть приложения инициирует <code>readwrite</code> транзакцию в хранилище объектов <code>books</code>, то другая часть приложения, которая хочет сделать то же самое, должна ждать: новая транзакция «зависает» до завершения первой. Это может привести к странным задержкам, если транзакции слишком долго выполняются.</p>
<p>Что же делать?</p>
<p>В приведённом выше примере мы могли бы запустить новую транзакцию <code>db.transaction</code> перед новым запросом <code>(*)</code>.</p>
<p>Но ещё лучше выполнять операции вместе, в рамках одной транзакции: отделить транзакции IndexedDB от других асинхронных операций.</p>
<p>Сначала сделаем <code>fetch</code>, подготовим данные, если нужно, затем создадим транзакцию и выполним все запросы к базе данных.</p>
<p>Чтобы поймать момент успешного выполнения, мы можем повесить обработчик на событие <code>transaction.oncomplete</code>:</p>
<div id="m38f93rwtv" data-trusted="1" class="code-example">
      <div class="codebox code-example__codebox">
        
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code>let transaction = db.transaction(&quot;books&quot;, &quot;readwrite&quot;);

// ...выполнить операции...

transaction.oncomplete = function() {
  console.log(&quot;Транзакция выполнена&quot;);
};</code></pre>
        </div>
      </div>
      
      </div><p>Только <code>complete</code> гарантирует, что транзакция сохранена целиком. По отдельности запросы могут выполниться, но при финальной записи что-то может пойти не так (ошибка ввода-вывода, проблема с диском, например).</p>
<p>Чтобы вручную отменить транзакцию, выполните:</p>
<div id="7cz4r61hwg" data-trusted="1" class="code-example">
      <div class="codebox code-example__codebox">
        
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code>transaction.abort();</code></pre>
        </div>
      </div>
      
      </div><p>Это отменит все изменения, сделанные запросами в транзакции, и сгенерирует событие <code>transaction.onabort</code>.</p>
<h2><a class="main__anchor" name="obrabotka-oshibok" href="indexeddb.html#obrabotka-oshibok">Обработка ошибок</a></h2><p>Запросы на запись могут выполниться неудачно.</p>
<p>Мы должны быть готовы к этому, не только из-за возможных ошибок на нашей стороне, но и по причинам, которые не связаны с транзакцией. Например, размер хранилища может быть превышен. И мы должны быть готовы обработать такую ситуацию.</p>
<p><strong>При ошибке в запросе соответствующая транзакция отменяется полностью, включая изменения, сделанные другими её запросами.</strong></p>
<p>Если мы хотим продолжить транзакцию (например, попробовать другой запрос без отмены изменений), это также возможно. Для этого в обработчике <code>request.onerror</code> следует вызвать <code>event.preventDefault()</code>.</p>
<p>В примере ниже новая книга добавляется с тем же ключом (<code>id</code>), что и существующая. Метод <code>store.add</code> генерирует в этом случае ошибку <code>&quot;ConstraintError&quot;</code>. Мы обрабатываем её без отмены транзакции:</p>
<div id="hobqwhs7ez" data-trusted="1" class="code-example">
      <div class="codebox code-example__codebox">
        
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code>let transaction = db.transaction(&quot;books&quot;, &quot;readwrite&quot;);

let book = { id: 'js', price: 10 };

let request = transaction.objectStore(&quot;books&quot;).add(book);

request.onerror = function(event) {
  // ConstraintError возникает при попытке добавить объект с ключом, который уже существует
  if (request.error.name == &quot;ConstraintError&quot;) {
    console.log(&quot;Книга с таким id уже существует&quot;); // обрабатываем ошибку
    event.preventDefault(); // предотвращаем отмену транзакции
    // ...можно попробовать использовать другой ключ...
  } else {
    // неизвестная ошибка
    // транзакция будет отменена
  }
};

transaction.onabort = function() {
  console.log(&quot;Ошибка&quot;, transaction.error);
};</code></pre>
        </div>
      </div>
      
      </div><h3><a class="main__anchor" name="delegirovanie-sobytiy" href="indexeddb.html#delegirovanie-sobytiy">Делегирование событий</a></h3><p>Нужны ли обработчики onerror/onsuccess для каждого запроса? Не всегда. Мы можем использовать делегирование событий.</p>
<p><strong>События IndexedDB всплывают: <code>запрос</code> → <code>транзакция</code> → <code>база данных</code>.</strong></p>
<p>Все события являются DOM-событиями с фазами перехвата и всплытия, но обычно используется только всплытие.</p>
<p>Поэтому мы можем перехватить все ошибки, используя обработчик <code>db.onerror</code>, для оповещения пользователя или других целей:</p>
<div id="86n1dgsvfx" data-trusted="1" class="code-example">
      <div class="codebox code-example__codebox">
        
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code>db.onerror = function(event) {
  let request = event.target; // запрос, в котором произошла ошибка

  console.log(&quot;Ошибка&quot;, request.error);
};</code></pre>
        </div>
      </div>
      
      </div><p>…А если мы полностью обработали ошибку? В этом случае мы не хотим сообщать об этом.</p>
<p>Мы можем остановить всплытие и, следовательно, <code>db.onerror</code>, используя <code>event.stopPropagation()</code> в <code>request.onerror</code>.</p>
<div id="digu44gbrb" data-trusted="1" class="code-example">
      <div class="codebox code-example__codebox">
        
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code>request.onerror = function(event) {
  if (request.error.name == &quot;ConstraintError&quot;) {
    console.log(&quot;Книга с таким id уже существует&quot;); // обрабатываем ошибку
    event.preventDefault(); // предотвращаем отмену транзакции
    event.stopPropagation(); // предотвращаем всплытие ошибки
  } else {
    // ничего не делаем
    // транзакция будет отменена
    // мы можем обработать ошибку в transaction.onabort
  }
};</code></pre>
        </div>
      </div>
      
      </div><h2><a class="main__anchor" name="poisk-po-klyucham" href="indexeddb.html#poisk-po-klyucham">Поиск по ключам</a></h2><p>Есть два основных вида поиска в хранилище объектов:</p>
<ol>
<li>По ключу или по диапазону ключей. То есть: по <code>book.id</code> в хранилище «books».</li>
<li>По полям объекта, например, <code>book.price</code>.</li>
</ol>
<p>Сначала давайте разберёмся с ключами и диапазоном ключей <code>(1)</code>.</p>
<p>Методы поиска поддерживают либо точные ключи, либо так называемые «запросы с диапазоном» – <a href="https://www.w3.org/TR/IndexedDB/#keyrange">IDBKeyRange</a> объекты, которые задают «диапазон ключей».</p>
<p>Диапазоны создаются с помощью следующих вызовов:</p>
<ul>
<li><code>IDBKeyRange.lowerBound(lower, [open])</code> означает: <code>&gt;lower</code> (или <code>≥lower</code>, если <code>open</code> это true)</li>
<li><code>IDBKeyRange.upperBound(upper, [open])</code> означает: <code>&lt;upper</code> (или <code>≤upper</code>, если <code>open</code> это true)</li>
<li><code>IDBKeyRange.bound(lower, upper, [lowerOpen], [upperOpen])</code> означает: между <code>lower</code> и <code>upper</code>, включительно, если соответствующий <code>open</code> равен <code>true</code>.</li>
<li><code>IDBKeyRange.only(key)</code> – диапазон, который состоит только из одного ключа <code>key</code>, редко используется.</li>
</ul>
<p>Все методы поиска принимают аргумент <code>query</code>, который может быть либо точным ключом, либо диапазоном ключей:</p>
<ul>
<li><code>store.get(query)</code> – поиск первого значения по ключу или по диапазону.</li>
<li><code>store.getAll([query], [count])</code> – поиск всех значений, можно ограничить, передав <code>count</code>.</li>
<li><code>store.getKey(query)</code> – поиск первого ключа, который удовлетворяет запросу, обычно передаётся диапазон.</li>
<li><code>store.getAllKeys([query], [count])</code> – поиск всех ключей, которые удовлетворяют запросу, обычно передаётся диапазон, возможно ограничить поиск, передав <code>count</code>.</li>
<li><code>store.count([query])</code> – получить общее количество ключей, которые удовлетворяют запросу, обычно передаётся диапазон.</li>
</ul>
<p>Например, в хранилище у нас есть множество книг. Помните, поле <code>id</code> является ключом, поэтому все эти методы могут искать по ключу <code>id</code>.</p>
<p>Примеры запросов:</p>
<div id="6730s3hlul" data-trusted="1" class="code-example">
      <div class="codebox code-example__codebox">
        
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code>// получить одну книгу
books.get('js')

// получить все книги с 'css' &lt; id &lt; 'html'
books.getAll(IDBKeyRange.bound('css', 'html'))

// получить книги с 'html' &lt;= id
books.getAll(IDBKeyRange.lowerBound('html', true))

// получить все книги
books.getAll()

// получить все ключи: id &gt;= 'js'
books.getAllKeys(IDBKeyRange.lowerBound('js', true))</code></pre>
        </div>
      </div>
      
      </div><div class="important important_smart">
            <div class="important__header"><span class="important__type">Хранилище объектов всегда отсортировано</span></div>
            <div class="important__content"><p>Хранилище объектов внутренне сортирует значения по ключам.</p>
<p>Поэтому запросы, которые возвращают много значений, всегда возвращают их в порядке сортировки по ключу.</p>
</div></div>
<h2><a class="main__anchor" name="poisk-po-indeksirovannomu-polyu" href="indexeddb.html#poisk-po-indeksirovannomu-polyu">Поиск по индексированному полю</a></h2><p>Для поиска по другим полям объекта нам нужно создать дополнительную структуру данных, называемую «индекс» (index).</p>
<p>Индекс является «расширением» к хранилищу, которое отслеживает данное поле объекта. Для каждого значения этого поля хранится список ключей для объектов, которые имеют это значение. Ниже будет более подробная картина.</p>
<p>Синтаксис:</p>
<div id="jdh3h1hjs3" data-trusted="1" class="code-example">
      <div class="codebox code-example__codebox">
        
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code>objectStore.createIndex(name, keyPath, [options]);</code></pre>
        </div>
      </div>
      
      </div><ul>
<li><strong><code>name</code></strong> – название индекса,</li>
<li><strong><code>keyPath</code></strong> – путь к полю объекта, которое индекс должен отслеживать (мы собираемся сделать поиск по этому полю),</li>
<li><strong><code>option</code></strong> – необязательный объект со свойствами:
<ul>
<li><strong><code>unique</code></strong> – если true, тогда в хранилище может быть только один объект с заданным значением в <code>keyPath</code>. Если мы попытаемся добавить дубликат, то индекс сгенерирует ошибку.</li>
<li><strong><code>multiEntry</code></strong> – используется только, если <code>keyPath</code> является массивом. В этом случае, по умолчанию, индекс обрабатывает весь массив как ключ. Но если мы укажем true в <code>multiEntry</code>, тогда индекс будет хранить список объектов хранилища для каждого значения в этом массиве. Таким образом, элементы массива становятся ключами индекса.</li>
</ul>
</li>
</ul>
<p>В нашем примере мы храним книги с ключом <code>id</code>.</p>
<p>Допустим, мы хотим сделать поиск по полю <code>price</code>.</p>
<p>Сначала нам нужно создать индекс. Индексы должны создаваться в <code>upgradeneeded</code>, как и хранилище объектов:</p>
<div id="ufsqnoe0iq" data-trusted="1" class="code-example" data-highlight="[{&quot;start&quot;:3,&quot;end&quot;:3}]">
      <div class="codebox code-example__codebox">
        
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code>openRequest.onupgradeneeded = function() {
  // мы должны создать индекс здесь, в versionchange транзакции
  let books = db.createObjectStore('books', {keyPath: 'id'});
  let index = books.createIndex('price_idx', 'price');
};</code></pre>
        </div>
      </div>
      
      </div><ul>
<li>Индекс будет отслеживать поле <code>price</code>.</li>
<li>Поле price не уникальное, у нас может быть несколько книг с одинаковой ценой, поэтому мы не устанавливаем опцию <code>unique</code>.</li>
<li>Поле price не является массивом, поэтому флаг <code>multiEntry</code> не применим.</li>
</ul>
<p>Представим, что в нашем <code>books</code> есть 4 книги. Вот картинка, которая показывает, что такое «индекс».</p>
<figure><div class="image" style="width:440px">
      <div class="image__ratio" style="padding-top:65.68181818181819%"></div>
      <object type="image/svg+xml" data="https://learn.javascript.ru/article/indexeddb/indexeddb-index.svg" width="440" height="289" class="image__image" data-use-theme>
        <img src="https://learn.javascript.ru/article/indexeddb/indexeddb-index.svg" alt="" width="440" height="289">
      </object>
      </div></figure><p>Как уже говорилось, индекс для каждого значения <code>price</code> (второй аргумент) хранит список ключей, имеющих эту цену.</p>
<p>Индексы автоматически обновляются, нам не нужно об этом заботиться.</p>
<p>Сейчас, когда мы хотим найти объект по цене, мы просто применяем те же методы поиска к индексу:</p>
<div id="x7s21wbbg5" data-trusted="1" class="code-example" data-highlight="[{&quot;start&quot;:4,&quot;end&quot;:4}]">
      <div class="codebox code-example__codebox">
        
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code>let transaction = db.transaction(&quot;books&quot;); // readonly
let books = transaction.objectStore(&quot;books&quot;);
let priceIndex = books.index(&quot;price_idx&quot;);

let request = priceIndex.getAll(10);

request.onsuccess = function() {
  if (request.result !== undefined) {
    console.log(&quot;Книги&quot;, request.result); // массив книг с ценой 10
  } else {
    console.log(&quot;Нет таких книг&quot;);
  }
};</code></pre>
        </div>
      </div>
      
      </div><p>Мы также можем использовать <code>IDBKeyRange</code>, чтобы создать диапазон и найти дешёвые/дорогие книги:</p>
<div id="m0hbq2m583" data-trusted="1" class="code-example">
      <div class="codebox code-example__codebox">
        
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code>// найдём книги, где цена &lt; 5
let request = priceIndex.getAll(IDBKeyRange.upperBound(5));</code></pre>
        </div>
      </div>
      
      </div><p>Индексы внутренне отсортированы по полю отслеживаемого объекта, в нашем случае по <code>price</code>. Поэтому результат поиска будет уже отсортированный по полю <code>price</code>.</p>
<h2><a class="main__anchor" name="udalenie-iz-hranilischa" href="indexeddb.html#udalenie-iz-hranilischa">Удаление из хранилища</a></h2><p>Метод <code>delete</code> удаляет значения по запросу, формат вызова такой же как в <code>getAll</code>:</p>
<ul>
<li><strong><code>delete(query)</code></strong> – производит удаление соответствующих запросу значений.</li>
</ul>
<p>Например:</p>
<div id="szk2y3chkr" data-trusted="1" class="code-example">
      <div class="codebox code-example__codebox">
        
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code>// удалить книгу с id='js'
books.delete('js');</code></pre>
        </div>
      </div>
      
      </div><p>Если нам нужно удалить книги, основываясь на цене или на любом другом поле, сначала нам надо найти ключ в индексе, а затем выполнить <code>delete</code>:</p>
<div id="47f902qls2" data-trusted="1" class="code-example">
      <div class="codebox code-example__codebox">
        
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code>// найдём ключ, где цена = 5
let request = priceIndex.getKey(5);

request.onsuccess = function() {
  let id = request.result;
  let deleteRequest = books.delete(id);
};</code></pre>
        </div>
      </div>
      
      </div><p>Чтобы удалить всё:</p>
<div id="9idsdtecwd" data-trusted="1" class="code-example">
      <div class="codebox code-example__codebox">
        
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code>books.clear(); // очищаем хранилище.</code></pre>
        </div>
      </div>
      
      </div><h2><a class="main__anchor" name="kursory" href="indexeddb.html#kursory">Курсоры</a></h2><p>Такие методы как <code>getAll/getAllKeys</code> возвращают массив ключей/значений.</p>
<p>Но хранилище объектов может быть огромным, больше, чем доступно памяти.</p>
<p>Тогда метод <code>getAll</code> вернёт ошибку при попытке получить все записи в массиве.</p>
<p>Что делать?</p>
<p>Курсоры предоставляют возможности для работы в таких ситуациях.</p>
<p><strong>Объект <em>cursor</em> идёт по хранилищу объектов с заданным запросом (query) и возвращает пары ключ/значение по очереди, а не все сразу. Это позволяет экономить память.</strong></p>
<p>Так как хранилище объектов внутренне отсортировано по ключу, курсор проходит по хранилищу в порядке хранения ключей (по возрастанию по умолчанию).</p>
<p>Синтаксис:</p>
<div id="awlhooj5v" data-trusted="1" class="code-example">
      <div class="codebox code-example__codebox">
        
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code>// как getAll, но с использованием курсора:
let request = store.openCursor([query], [direction]);

// чтобы получить ключи, не значения (как getAllKeys): store.openKeyCursor</code></pre>
        </div>
      </div>
      
      </div><ul>
<li><strong><code>query</code></strong> ключ или диапазон ключей, как для <code>getAll</code>.</li>
<li><strong><code>direction</code></strong> необязательный аргумент, доступные значения:
<ul>
<li><code>&quot;next&quot;</code> – по умолчанию, курсор будет проходить от самого маленького ключа к большему.</li>
<li><code>&quot;prev&quot;</code> – обратный порядок: от самого большого ключа к меньшему.</li>
<li><code>&quot;nextunique&quot;</code>, <code>&quot;prevunique&quot;</code> – то же самое, но курсор пропускает записи с тем же ключом, что уже был (только для курсоров по индексам, например, для нескольких книг с price=5, будет возвращена только первая).</li>
</ul>
</li>
</ul>
<p><strong>Основным отличием курсора является то, что <code>request.onsuccess</code> генерируется многократно: один раз для каждого результата.</strong></p>
<p>Вот пример того, как использовать курсор:</p>
<div id="h2drr4sjrc" data-trusted="1" class="code-example">
      <div class="codebox code-example__codebox">
        
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code>let transaction = db.transaction(&quot;books&quot;);
let books = transaction.objectStore(&quot;books&quot;);

let request = books.openCursor();

// вызывается для каждой найденной курсором книги
request.onsuccess = function() {
  let cursor = request.result;
  if (cursor) {
    let key = cursor.key; // ключ книги (поле id)
    let value = cursor.value; // объект книги
    console.log(key, value);
    cursor.continue();
  } else {
    console.log(&quot;Книг больше нет&quot;);
  }
};</code></pre>
        </div>
      </div>
      
      </div><p>Основные методы курсора:</p>
<ul>
<li><code>advance(count)</code> – продвинуть курсор на <code>count</code> позиций, пропустив значения.</li>
<li><code>continue([key])</code> – продвинуть курсор к следующему значению в диапазоне соответствия (или до позиции сразу после ключа key, если указан).</li>
</ul>
<p>Независимо от того, есть ли ещё значения, соответствующие курсору или нет – вызывается <code>onsuccess</code>, затем в<code>result</code> мы можем получить курсор, указывающий на следующую запись или равный <code>undefined</code>.</p>
<p>В приведённом выше примере курсор был создан для хранилища объектов.</p>
<p>Но мы также можем создать курсор для индексов. Как мы помним, индексы позволяют искать по полю объекта. Курсоры для индексов работают так же, как для хранилищ объектов – они позволяют экономить память, возвращая одно значение в единицу времени.</p>
<p>Для курсоров по индексам <code>cursor.key</code> является ключом индекса (например price), нам следует использовать свойство <code>cursor.primaryKey</code> как ключ объекта:</p>
<div id="6obcp3t5si" data-trusted="1" class="code-example">
      <div class="codebox code-example__codebox">
        
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code>let request = priceIdx.openCursor(IDBKeyRange.upperBound(5));

// вызывается для каждой записи
request.onsuccess = function() {
  let cursor = request.result;
  if (cursor) {
    let key = cursor.primaryKey; // следующий ключ в хранилище объектов (поле id)
    let value = cursor.value; // следующее значение в хранилище объектов (объект &quot;книга&quot;)
    let keyIndex = cursor.key; // следующий ключ индекса (price)
    console.log(key, value);
    cursor.continue();
  } else {
    console.log(&quot;Книг больше нет&quot;);
  }
};</code></pre>
        </div>
      </div>
      
      </div><h2><a class="main__anchor" name="obyortka-dlya-promisov" href="indexeddb.html#obyortka-dlya-promisov">Обёртка для промисов</a></h2><p>Добавлять к каждому запросу <code>onsuccess/onerror</code> немного громоздко. Мы можем сделать нашу жизнь проще, используя делегирование событий, например, установить обработчики на все транзакции, но использовать <code>async/await</code> намного удобнее.</p>
<p>Давайте далее в главе использовать небольшую обёртку над промисами <a href="https://github.com/jakearchibald/idb">https://github.com/jakearchibald/idb</a>. Она создаёт глобальный <code>idb</code> объект с <a href="https://learn.javascript.ru/promisify">промисифицированными</a> IndexedDB методами.</p>
<p>Тогда вместо <code>onsuccess/onerror</code> мы можем писать примерно так:</p>
<div id="f2hb7grpup" data-trusted="1" class="code-example">
      <div class="codebox code-example__codebox">
        
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code>let db = await idb.openDb('store', 1, db =&gt; {
  if (db.oldVersion == 0) {
    // выполняем инициализацию
    db.createObjectStore('books', {keyPath: 'id'});
  }
});

let transaction = db.transaction('books', 'readwrite');
let books = transaction.objectStore('books');

try {
  await books.add(...);
  await books.add(...);

  await transaction.complete;

  console.log('сохранено');
} catch(err) {
  console.log('ошибка', err.message);
}</code></pre>
        </div>
      </div>
      
      </div><p>Теперь у нас красивый «плоский асинхронный» код и, конечно, будет работать <code>try..catch</code>.</p>
<h3><a class="main__anchor" name="obrabotka-oshibok-2" href="indexeddb.html#obrabotka-oshibok-2">Обработка ошибок</a></h3><p>Если мы не перехватим ошибку, то она «вывалится» наружу, вверх по стеку вызовов, до ближайшего внешнего <code>try..catch</code>.</p>
<p>Необработанная ошибка становится событием «unhandled promise rejection» в объекте <code>window</code>.</p>
<p>Мы можем обработать такие ошибки вот так:</p>
<div id="yhyijlvz0m" data-trusted="1" class="code-example">
      <div class="codebox code-example__codebox">
        
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code>window.addEventListener('unhandledrejection', event =&gt; {
  let request = event.target; // объект запроса IndexedDB
  let error = event.reason; //  Необработанный объект ошибки, как request.error
  ...сообщить об ошибке...
});</code></pre>
        </div>
      </div>
      
      </div><h3><a class="main__anchor" name="podvodnyy-kamen-inactive-transaction" href="indexeddb.html#podvodnyy-kamen-inactive-transaction">Подводный камень: «Inactive transaction»</a></h3><p>Как мы уже знаем, транзакции автоматически завершаются, как только браузер завершает работу с текущим кодом и макрозадачу. Поэтому, если мы поместим <em>макрозадачу</em> наподобие <code>fetch</code> в середину транзакции, транзакция не будет ожидать её завершения. Произойдёт автозавершение транзакции. Поэтому при следующем запросе возникнет ошибка.</p>
<p>Для промисифицирующей обёртки и <code>async/await</code> поведение такое же.</p>
<p>Вот пример <code>fetch</code> в середине транзакции:</p>
<div id="5oo3b9qp4i" data-trusted="1" class="code-example">
      <div class="codebox code-example__codebox">
        
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code>let transaction = db.transaction(&quot;inventory&quot;, &quot;readwrite&quot;);
let inventory = transaction.objectStore(&quot;inventory&quot;);

await inventory.add({ id: 'js', price: 10, created: new Date() });

await fetch(...); // (*)

await inventory.add({ id: 'js', price: 10, created: new Date() }); // Ошибка</code></pre>
        </div>
      </div>
      
      </div><p>Следующий <code>inventory.add</code> после <code>fetch</code> <code>(*)</code> не сработает, сгенерируется ошибка «inactive transaction», потому что транзакция уже завершена и закрыта к этому времени.</p>
<p>Решение такое же, как при работе с обычным IndexedDB: либо создать новую транзакцию, либо разделить задачу на части.</p>
<ol>
<li>Подготовить данные и получить всё, что необходимо.</li>
<li>Затем сохранить в базу данных.</li>
</ol>
<h3><a class="main__anchor" name="poluchenie-vstroennyh-obektov" href="indexeddb.html#poluchenie-vstroennyh-obektov">Получение встроенных объектов</a></h3><p>Внутренне обёртка выполняет встроенные IndexedDB запросы, добавляя к ним <code>onerror/onsuccess</code>, и возвращает промисы, которые отклоняются или выполняются с переданным результатом.</p>
<p>Это работает в большинстве случаев. Примеры можно увидеть на странице библиотеки <a href="https://github.com/jakearchibald/idb">https://github.com/jakearchibald/idb</a>.</p>
<p>В некоторых редких случаях, когда нам нужен оригинальный объект <code>request</code>, мы можем получить к нему доступ, используя свойство <code>promise.request</code>:</p>
<div id="us9hsbiz14" data-trusted="1" class="code-example">
      <div class="codebox code-example__codebox">
        
        <div class="codebox__code" data-code="1">
          <pre class="line-numbers language-javascript"><code>let promise = books.add(book); // получаем промис (без await, не ждём результата)

let request = promise.request; // встроенный объект запроса
let transaction = request.transaction; // встроенный объект транзакции

// ...работаем с IndexedDB...

let result = await promise; // если ещё нужно</code></pre>
        </div>
      </div>
      
      </div><h2><a class="main__anchor" name="itogo" href="indexeddb.html#itogo">Итого</a></h2><p>IndexedDB можно рассматривать как «localStorage на стероидах». Это простая база данных типа ключ-значение, достаточно мощная для оффлайн приложений, но простая в использовании.</p>
<p>Лучшим руководством является спецификация, <a href="https://w3c.github.io/IndexedDB">текущая версия 2.0</a>, но также поддерживаются несколько методов из <a href="https://w3c.github.io/IndexedDB/">3.0</a> (не так много отличий) версии.</p>
<p>Использование можно описать в нескольких фразах:</p>
<ol>
<li>Подключить обёртку над промисами, например <a href="https://github.com/jakearchibald/idb">idb</a>.</li>
<li>Открыть базу данных: <code>idb.openDb(name, version, onupgradeneeded)</code>
<ul>
<li>Создание хранилищ объектов и индексов происходит в обработчике <code>onupgradeneeded</code>.</li>
<li>Обновление версии – либо сравнивая номера версий, либо можно проверить что существует, а что нет.</li>
</ul>
</li>
<li>Для запросов:
<ul>
<li>Создать транзакцию <code>db.transaction('books')</code> (можно указать readwrite, если надо).</li>
<li>Получить хранилище объектов <code>transaction.objectStore('books')</code>.</li>
</ul>
</li>
<li>Затем для поиска по ключу вызываем методы непосредственно у хранилища объектов.
<ul>
<li>Для поиска по любому полю объекта создайте индекс.</li>
</ul>
</li>
<li>Если данные не помещаются в памяти, то используйте курсор.</li>
</ol>
<p>Демо-приложение:</p>
<div class="code-tabs"><div class="code-tabs__tools"><div class="code-tabs__scroll-wrap"><button class="code-tabs__scroll-button code-tabs__scroll-button_left" title="&amp;larr;" data-code-tabs-left="data-code-tabs-left"></button></div><div class="code-tabs__switches-wrap"><div class="code-tabs__switches" data-code-tabs-switches="data-code-tabs-switches"><div class="code-tabs__switches-items"><div class="code-tabs__switch">Результат</div><div class="code-tabs__switch code-tabs__switch_current">index.html</div></div></div></div><div class="code-tabs__scroll-wrap"><button class="code-tabs__scroll-button code-tabs__scroll-button_right" title="&amp;rarr;" data-code-tabs-right="data-code-tabs-right"></button></div><div class="code-tabs__buttons"><a class="code-tabs__button code-tabs__button_external" target="_blank" title="открыть в отдельном окне" href="https://learn.javascript.ru/article/indexeddb/books/"></a><a class="code-tabs__button code-tabs__button_edit" target="_blank" title="редактировать в песочнице" href="https://plnkr.co/edit/0wGrQBeGMi3XMFyN?p=preview"></a></div></div><div class="code-tabs__content" data-code-tabs-content="data-code-tabs-content" style="height:200px"><div class="code-tabs__section"><iframe class="code-tabs__result" src="https://learn.javascript.ru/article/indexeddb/books/"></iframe></div><div class="code-tabs__section code-tabs__section_current"><pre class="language-markup line-numbers"><code>&lt;!doctype html&gt;
&lt;script src=&quot;https://cdn.jsdelivr.net/npm/idb@3.0.2/build/idb.min.js&quot;&gt;&lt;/script&gt;

&lt;button onclick=&quot;addBook()&quot;&gt;Добавить книгу&lt;/button&gt;
&lt;button onclick=&quot;clearBooks()&quot;&gt;Очистить хранилище&lt;/button&gt;

&lt;p&gt;Список книг:&lt;/p&gt;

&lt;ul id=&quot;listElem&quot;&gt;&lt;/ul&gt;

&lt;script&gt;
let db;

init();

async function init() {
  db = await idb.openDb('booksDb', 1, db =&gt; {
    db.createObjectStore('books', {keyPath: 'name'});
  });

  list();
}

async function list() {
  let tx = db.transaction('books');
  let bookStore = tx.objectStore('books');

  let books = await bookStore.getAll();

  if (books.length) {
    listElem.innerHTML = books.map(book =&gt; `&lt;li&gt;
        название: ${book.name}, цена: ${book.price}
      &lt;/li&gt;`).join('');
  } else {
    listElem.innerHTML = '&lt;li&gt;Книг пока нет. Пожалуйста, добавьте книги.&lt;/li&gt;'
  }


}

async function clearBooks() {
  let tx = db.transaction('books', 'readwrite');
  await tx.objectStore('books').clear();
  await list();
}

async function addBook() {
  let name = prompt(&quot;Название книги&quot;);
  let price = +prompt(&quot;Цена книги&quot;);

  let tx = db.transaction('books', 'readwrite');

  try {
    await tx.objectStore('books').add({name, price});
    await list();
  } catch(err) {
    if (err.name == 'ConstraintError') {
      alert(&quot;Такая книга уже существует&quot;);
      await addBook();
    } else {
      throw err;
    }
  }
}

window.addEventListener('unhandledrejection', event =&gt; {
  alert(&quot;Ошибка: &quot; + event.reason.message);
});

&lt;/script&gt;</code></pre></div></div></div></div></article></div><div class="page__nav-wrap"><a class="page__nav page__nav_prev" href="https://learn.javascript.ru/localstorage" data-tooltip="LocalStorage, sessionStorage"><span class="page__nav-text"><span class="page__nav-text-shortcut"></span></span><span class="page__nav-text-alternate">Предыдущий урок</span></a><a class="page__nav page__nav_next" href="https://learn.javascript.ru/animation" data-tooltip="Анимация"><span class="page__nav-text"><span class="page__nav-text-shortcut"></span></span><span class="page__nav-text-alternate">Следующий урок</span></a></div><div class="article-tablet-foot tablet-only"><div class="article-tablet-foot__layout"><div class="share-icons"><span class="share-icons__title">Поделиться</span><a class="share share_tw" href="https://twitter.com/share?url=https%3A%2F%2Flearn.javascript.ru%2Findexeddb" rel="nofollow"></a><a class="share share_fb" href="https://www.facebook.com/sharer/sharer.php?s=100&amp;p%5Burl%5D=https%3A%2F%2Flearn.javascript.ru%2Findexeddb" rel="nofollow"></a><a class="share share_vk" href="https://vkontakte.ru/share.php?url=https%3A%2F%2Flearn.javascript.ru%2Findexeddb" rel="nofollow"></a></div><div class="article-tablet-foot__map"><a class="map" href="https://learn.javascript.ru/tutorial/map" data-action="tutorial-map"><span class="map__text">Карта учебника</span></a></div></div></div><div class="banner-bottom"><div class="banner-bottom__text">Проводим <a href="https://learn.javascript.ru/courses">курсы по JavaScript и фреймворкам</a>.</div><button class="banner-bottom__close" data-banner-close="Courses" data-banner-close-message="Эта информация больше не будет выводиться." title="не показывать"></button></div><script>!!1&&"hideBannerCourses"in localStorage||(document.querySelector(".banner-bottom").style.display="flex");</script><div class="comments formatted" id="comments"><div class="comments__header"><h2 class="comments__header-title"><a href="indexeddb.html#comments" name="comments">Комментарии</a></h2><div class="comments__read-before"><span class="comments__read-before-link">перед тем как писать…</span><div class="comments__read-before-popup"><div class="comments__read-before-popup-i"><ul><li>Если вам кажется, что в статье что-то не так - вместо комментария напишите <a href="https://github.com/javascript-tutorial/ru.javascript.info/issues/new">на GitHub</a>.</li><li>Для одной строки кода используйте тег <code>&lt;code&gt;</code>, для нескольких строк кода&nbsp;&mdash; тег <code>&lt;pre&gt;</code>, если больше 10 строк&nbsp;&mdash; ссылку на песочницу (<a href='https://plnkr.co/edit/?p=preview'>plnkr</a>, <a href='http://jsbin.com'>JSBin</a>, <a href='http://codepen.io'>codepen</a>…)</li><li>Если что-то непонятно в статье&nbsp;&mdash; пишите, что именно и с какого места.</li></ul></div></div></div></div><div id="disqus_thread"></div><script>var disqus_config = function() { if (!this.page) this.page = {}; Object.assign(this.page, {"url":"https:\/\/learn.javascript.ru\/indexeddb","identifier":"\/indexeddb"}); };</script><script>var disqus_shortname = "learnjavascriptru";</script><script>var disqus_enabled = true;</script></div></main></div><div class="sidebar page__sidebar sidebar sidebar_sticky-footer"><button class="sidebar__toggle" data-sidebar-toggle></button><a class="map" href="https://learn.javascript.ru/tutorial/map" data-action="tutorial-map" data-tooltip="Карта учебника"></a><div class="sidebar__inner"><div class="sidebar__content"><div class="sidebar__section"><h4 class="sidebar__section-title">Раздел</h4><nav class="sidebar__navigation"><ul class="sidebar__navigation-links"><li class="sidebar__navigation-link"><a class="sidebar__link" href="https://learn.javascript.ru/data-storage">Хранение данных в браузере</a></li></ul></nav></div><div class="sidebar__section"><h4 class="sidebar__section-title">Навигация по уроку</h4><nav class="sidebar__navigation"><ul class="sidebar__navigation-links"><li class="sidebar__navigation-link"><a class="sidebar__link" href="indexeddb.html#otkryt-bazu-dannyh">Открыть базу данных</a></li><li class="sidebar__navigation-link"><a class="sidebar__link" href="indexeddb.html#hranilische-obektov">Хранилище объектов</a></li><li class="sidebar__navigation-link"><a class="sidebar__link" href="indexeddb.html#tranzaktsii">Транзакции</a></li><li class="sidebar__navigation-link"><a class="sidebar__link" href="indexeddb.html#avtomaticheskaya-fiksatsiya-tranzaktsiy">Автоматическая фиксация транзакций</a></li><li class="sidebar__navigation-link"><a class="sidebar__link" href="indexeddb.html#obrabotka-oshibok">Обработка ошибок</a></li><li class="sidebar__navigation-link"><a class="sidebar__link" href="indexeddb.html#poisk-po-klyucham">Поиск по ключам</a></li><li class="sidebar__navigation-link"><a class="sidebar__link" href="indexeddb.html#poisk-po-indeksirovannomu-polyu">Поиск по индексированному полю</a></li><li class="sidebar__navigation-link"><a class="sidebar__link" href="indexeddb.html#udalenie-iz-hranilischa">Удаление из хранилища</a></li><li class="sidebar__navigation-link"><a class="sidebar__link" href="indexeddb.html#kursory">Курсоры</a></li><li class="sidebar__navigation-link"><a class="sidebar__link" href="indexeddb.html#obyortka-dlya-promisov">Обёртка для промисов</a></li><li class="sidebar__navigation-link"><a class="sidebar__link" href="indexeddb.html#itogo">Итого</a></li></ul></nav></div><div class="sidebar__section"><nav class="sidebar__navigation"><ul class="sidebar__navigation-links"><li class="sidebar__navigation-link"><a class="sidebar__link" href="indexeddb.html#comments">Комментарии</a></li></ul></nav></div><div class="sidebar__section"><div class="sidebar__section-title">Поделиться</div><a class="share share_tw sidebar__share" href="https://twitter.com/share?url=https%3A%2F%2Flearn.javascript.ru%2Findexeddb" rel="nofollow"></a><a class="share share_fb sidebar__share" href="https://www.facebook.com/sharer/sharer.php?s=100&amp;p[url]=https%3A%2F%2Flearn.javascript.ru%2Findexeddb" rel="nofollow"></a></div><div class="sidebar__section"><a class="sidebar__link" href="https://github.com/javascript-tutorial/ru.javascript.info/blob/master/6-data-storage/03-indexeddb" rel="nofollow">Редактировать на GitHub</a></div></div></div></div></div></div><div class="page-footer"><ul class="page-footer__list"><li class="page-footer__item page-footer__item_copy">©&nbsp;2007—2022&nbsp; Илья Кантор</li><li class="page-footer__item page-footer__item_about"><a class="page-footer__link" href="https://learn.javascript.ru/about">о проекте</a></li><li class="page-footer__item page-footer__item_contact"><a class="page-footer__link" href="https://learn.javascript.ru/about#contact-us">связаться с нами</a></li><li class="page-footer__item page-footer__item_terms"><a class="page-footer__link" href="https://learn.javascript.ru/terms">пользовательское соглашение</a></li><li class="page-footer__item page-footer__item_privacy"><a class="page-footer__link" href="https://learn.javascript.ru/privacy">политика конфиденциальности</a></li><li class="page-footer__item page-footer__item_slack"><a class="page-footer__slack" href="http://slack.javascript.ru">slack-чат</a></li></ul></div></body></html>