<!DOCTYPE html>
<html lang="ru" data-vue-meta="%7B%22lang%22:%7B%22ssr%22:%22ru%22%7D%7D">
<head >
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1.0,viewport-fit=cover">
  <meta name="referrer" content="unsafe-url">
  <title>Создание архитектуры программы или как проектировать табуретку / Хабр</title>
  <style>
    /* cyrillic-ext */
    @font-face {
      font-family: 'Fira Sans';
      font-style: normal;
      font-weight: 500;
      font-display: swap;
      src: url(https://fonts.gstatic.com/s/firasans/v11/va9B4kDNxMZdWfMOD5VnZKveSxf6TF0.woff2) format('woff2');
      unicode-range: U+0460-052F, U+1C80-1C88, U+20B4, U+2DE0-2DFF, U+A640-A69F, U+FE2E-FE2F;
    }

    /* cyrillic */
    @font-face {
      font-family: 'Fira Sans';
      font-style: normal;
      font-weight: 500;
      font-display: swap;
      src: url(https://fonts.gstatic.com/s/firasans/v11/va9B4kDNxMZdWfMOD5VnZKveQhf6TF0.woff2) format('woff2');
      unicode-range: U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116;
    }

    /* latin-ext */
    @font-face {
      font-family: 'Fira Sans';
      font-style: normal;
      font-weight: 500;
      font-display: swap;
      src: url(https://fonts.gstatic.com/s/firasans/v11/va9B4kDNxMZdWfMOD5VnZKveSBf6TF0.woff2) format('woff2');
      unicode-range: U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;
    }

    /* latin */
    @font-face {
      font-family: 'Fira Sans';
      font-style: normal;
      font-weight: 500;
      font-display: swap;
      src: url(https://fonts.gstatic.com/s/firasans/v11/va9B4kDNxMZdWfMOD5VnZKveRhf6.woff2) format('woff2');
      unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
    }

    /* non-breaking hyphen */
    @font-face {
      font-family: 'Fira Sans';
      font-style: normal;
      font-weight: 500;
      font-display: swap;
      src: url(https://fonts.gstatic.com/l/font?kit=KFOlCnqEu92Fr1MmEU9vBh0_IsHAlmrO6g&skey=ee881451c540fdec&v=v29) format('woff2');
      unicode-range: U+02011;
    }
  </style>
  <link rel="preload" href="https://assets.habr.com/habr-web/css/chunk-vendors.e7843cc0.css" as="style"><link rel="preload" href="https://assets.habr.com/habr-web/js/chunk-vendors.da6c6b36.js" as="script"><link rel="preload" href="https://assets.habr.com/habr-web/css/app.4de4e95a.css" as="style"><link rel="preload" href="https://assets.habr.com/habr-web/js/app.92df6f6d.js" as="script">
  <link rel="stylesheet" href="https://assets.habr.com/habr-web/css/chunk-vendors.e7843cc0.css"><link rel="stylesheet" href="https://assets.habr.com/habr-web/css/app.4de4e95a.css">
  <script>window.i18nFetch = new Promise((res, rej) => {
          const xhr = new XMLHttpRequest();
          xhr.open('GET', '/js/i18n/ru-compiled.2822d469ec31a56409ac330bbcf7fcbf.json');
          xhr.responseType = 'json';
          xhr.onload = function(e) {
            if (this.status === 200) {
              res({ru: xhr.response});
            } else {
              rej(e);
            }
          };
          xhr.send();
        });</script>
  
  <script data-vue-meta="ssr" type="application/ld+json" data-vmid="ldjson-schema">{"@context":"http:\/\/schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/habr.com\/ru\/post\/276593\/"},"headline":"Создание архитектуры программы или как проектировать табуретку","datePublished":"2016-02-04T16:18:04+03:00","dateModified":"2016-02-04T23:37:11+03:00","author":{"@type":"Person","name":"cobiot"},"publisher":{"@type":"Organization","name":"Habr","logo":{"@type":"ImageObject","url":"https:\/\/habrastorage.org\/webt\/a_\/lk\/9m\/a_lk9mjkccjox-zccjrpfolmkmq.png"}},"description":"Взявшись за написание небольшого, но реального и растущего проекта, мы &laquo;на собственной шкуре&raquo; убедились, насколько важно то, чтобы программа не только хорошо раб...","url":"https:\/\/habr.com\/ru\/post\/276593\/#post-content-body","about":["h_webdev","h_analysis_design","h_refactoring","f_develop"],"image":["https:\/\/habr.com\/share\/publication\/276593\/385fbb9492f41423ccf6b6e7ff51609a\/"]}</script>
  <script src="https://www.googletagservices.com/tag/js/gpt.js" async></script>
  <style>.grecaptcha-badge{visibility: hidden;}</style>
  <meta name="habr-version" content="2.64.0">
  
  <meta data-vue-meta="ssr" property="fb:app_id" content="444736788986613"><meta data-vue-meta="ssr" property="fb:pages" content="472597926099084"><meta data-vue-meta="ssr" name="twitter:card" content="summary_large_image"><meta data-vue-meta="ssr" name="twitter:site" content="@habr_com"><meta data-vue-meta="ssr" property="og:site_name" content="Хабр" data-vmid="og:site_name"><meta data-vue-meta="ssr" property="og:title" content="Создание архитектуры программы или как проектировать табуретку" data-vmid="og:title"><meta data-vue-meta="ssr" name="twitter:title" content="Создание архитектуры программы или как проектировать табуретку" data-vmid="twitter:title"><meta data-vue-meta="ssr" name="aiturec:title" content="Создание архитектуры программы или как проектировать табуретку" data-vmid="aiturec:title"><meta data-vue-meta="ssr" name="description" content="Взявшись за написание небольшого, но реального и растущего проекта, мы «на собственной шкуре» убедились, насколько важно то, чтобы программа не только хорошо работала, но и была хорошо организована...." data-vmid="description"><meta data-vue-meta="ssr" itemprop="description" content="Взявшись за написание небольшого, но реального и растущего проекта, мы «на собственной шкуре» убедились, насколько важно то, чтобы программа не только хорошо работала, но и была хорошо организована...." data-vmid="description:itemprop"><meta data-vue-meta="ssr" property="og:description" content="Взявшись за написание небольшого, но реального и растущего проекта, мы «на собственной шкуре» убедились, насколько важно то, чтобы программа не только хорошо работала, но и была хорошо организована...." data-vmid="og:description"><meta data-vue-meta="ssr" name="twitter:description" content="Взявшись за написание небольшого, но реального и растущего проекта, мы «на собственной шкуре» убедились, насколько важно то, чтобы программа не только хорошо работала, но и была хорошо организована...." data-vmid="twitter:description"><meta data-vue-meta="ssr" property="aiturec:description" content="Взявшись за написание небольшого, но реального и растущего проекта, мы «на собственной шкуре» убедились, насколько важно то, чтобы программа не только хорошо работала, но и была хорошо организована...." data-vmid="aiturec:description"><meta data-vue-meta="ssr" itemprop="image" content="https://habr.com/share/publication/276593/385fbb9492f41423ccf6b6e7ff51609a/" data-vmid="image:itemprop"><meta data-vue-meta="ssr" property="og:image" content="https://habr.com/share/publication/276593/385fbb9492f41423ccf6b6e7ff51609a/" data-vmid="og:image"><meta data-vue-meta="ssr" property="og:image:width" content="1200" data-vmid="og:image:width"><meta data-vue-meta="ssr" property="og:image:height" content="630" data-vmid="og:image:height"><meta data-vue-meta="ssr" property="aiturec:image" content="https://habr.com/share/publication/276593/385fbb9492f41423ccf6b6e7ff51609a/" data-vmid="aiturec:image"><meta data-vue-meta="ssr" name="twitter:image" content="https://habr.com/share/publication/276593/385fbb9492f41423ccf6b6e7ff51609a/" data-vmid="twitter:image"><meta data-vue-meta="ssr" property="vk:image" content="https://habr.com/share/publication/276593/385fbb9492f41423ccf6b6e7ff51609a/?format=vk" data-vmid="vk:image"><meta data-vue-meta="ssr" property="aiturec:item_id" content="276593" data-vmid="aiturec:item_id"><meta data-vue-meta="ssr" property="aiturec:datetime" content="2016-02-04T13:18:04.000Z" data-vmid="aiturec:datetime"><meta data-vue-meta="ssr" content="https://habr.com/ru/post/276593/" property="og:url" data-vmid="og:url"><meta data-vue-meta="ssr" property="og:type" content="article" data-vmid="og:type"><meta data-vue-meta="ssr" property="og:locale" content="ru_RU" data-vmid="og:locale"><meta data-vue-meta="ssr" name="keywords" content="архитектура приложений, принципы проектирования">
  <link data-vue-meta="ssr" href="https://habr.com/ru/rss/post/276593/?fl=ru" type="application/rss+xml" title="" rel="alternate" name="rss"><link data-vue-meta="ssr" href="index.html.1.71.html" rel="canonical" data-vmid="canonical"><link data-vue-meta="ssr" data-vmid="hreflang"><link data-vue-meta="ssr" image_src="image" href="https://habr.com/share/publication/276593/385fbb9492f41423ccf6b6e7ff51609a/" data-vmid="image:href"><link data-vue-meta="ssr" rel="amphtml" href="https://habr.com/ru/amp/post/276593/">
  <meta name="apple-mobile-web-app-status-bar-style" content="#303b44">
  <meta name="msapplication-TileColor" content="#629FBC">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="mobile-web-app-capable" content="yes">
  <link
    rel="shortcut icon"
    type="image/png"
    sizes="16x16"
    href="https://assets.habr.com/habr-web/img/favicons/favicon-16.png"
  >
  <link
    rel="shortcut icon"
    type="image/png"
    sizes="32x32"
    href="https://assets.habr.com/habr-web/img/favicons/favicon-32.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="76x76"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-76.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="120x120"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-120.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="152x152"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-152.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="180x180"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-180.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="256x256"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-256.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1136x640.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2436x1125.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1792x828.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_828x1792.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1334x750.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1242x2668.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 736px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2208x1242.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1125x2436.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 736px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1242x2208.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2732x2048.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2688x1242.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 834px) and (device-height: 1112px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2224x1668.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_750x1334.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2048x2732.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2388x1668.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 834px) and (device-height: 1112px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1668x2224.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_640x1136.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1668x2388.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2048x1536.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1536x2048.png"
  >
  <link
    rel="mask-icon"
    color="#77a2b6"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-120.svg"
  >
  <link
    crossorigin="use-credentials"
    href="https://habr.com/manifest.webmanifest"
    rel="manifest"
  >
</head>
<body>


<div id="app" data-server-rendered="true" data-async-called="true"><div class="tm-layout__wrapper"><!----> <div></div> <!----> <header class="tm-header"><div class="tm-page-width"><div class="tm-header__container"><!----> <span class="tm-header__logo-wrap"><a href="https://habr.com/ru/" class="tm-header__logo tm-header__logo_ru"><svg height="16" width="16" class="tm-svg-img tm-header__icon"><title>Хабр</title> <use xlink:href="/img/habr-logo-ru.svg#logo"></use></svg></a> <span class="tm-header__beta-sign" style="display:none;">β</span></span> <div class="tm-dropdown tm-header__projects"><div class="tm-dropdown__head"><button class="tm-header__dropdown-toggle"><svg height="16" width="16" class="tm-svg-img tm-header__icon tm-header__icon_dropdown"><title>Открыть список</title> <use xlink:href="/img/megazord-v25.4b679db1.svg#arrow-down"></use></svg></button></div> <!----></div> <a href="https://habr.com/ru/sandbox/start/" class="tm-header__become-author-btn">
            Как стать автором
          </a> <div class="tm-feature tm-header__feature tm-feature_variant-inline"><!----></div> <!----> <!----></div></div></header> <div class="tm-layout"><div class="tm-page-progress-bar"></div> <div data-menu-sticky="true" class="tm-base-layout__header tm-base-layout__header_is-sticky"><div class="tm-page-width"><div class="tm-base-layout__header-wrapper"><div class="tm-main-menu"><div class="tm-main-menu__section"><nav class="tm-main-menu__section-content"><!----> <a href="https://habr.com/ru/flows/all" class="tm-main-menu__item">
        Все потоки
      </a> <a href="https://habr.com/ru/flows/develop/" class="tm-main-menu__item">
          Разработка
        </a><a href="https://habr.com/ru/flows/admin/" class="tm-main-menu__item">
          Администрирование
        </a><a href="https://habr.com/ru/flows/design/" class="tm-main-menu__item">
          Дизайн
        </a><a href="https://habr.com/ru/flows/management/" class="tm-main-menu__item">
          Менеджмент
        </a><a href="https://habr.com/ru/flows/marketing/" class="tm-main-menu__item">
          Маркетинг
        </a><a href="https://habr.com/ru/flows/popsci/" class="tm-main-menu__item">
          Научпоп
        </a></nav></div></div> <div class="tm-header-user-menu tm-base-layout__user-menu"><a href="https://habr.com/ru/search/" class="tm-header-user-menu__item tm-header-user-menu__search"><svg height="24" width="24" class="tm-svg-img tm-header-user-menu__icon tm-header-user-menu__icon_search tm-header-user-menu__icon_dark"><title>Поиск</title> <use xlink:href="/img/megazord-v25.4b679db1.svg#search"></use></svg></a> <!----> <!----> <!----> <div class="tm-header-user-menu__item tm-header-user-menu__user_desktop"><div class="tm-dropdown"><div class="tm-dropdown__head"><svg height="24" width="24" data-test-id="menu-toggle-guest" class="tm-svg-img tm-header-user-menu__icon"><title>Профиль</title> <use xlink:href="/img/megazord-v25.4b679db1.svg#header-user"></use></svg> <!----></div> <!----></div> <!----></div> <!----></div></div></div></div> <!----> <div class="tm-page-width"></div> <main class="tm-layout__container"><div hl="ru" data-async-called="true" class="tm-page"><div class="tm-page-width"><!----> <div class="tm-page__wrapper"><div class="tm-page__main tm-page__main_has-sidebar"><div class="pull-down"><div class="pull-down__header" style="height:0px;"><div class="pull-down__content" style="bottom:10px;"><svg height="24" width="24" class="tm-svg-img pull-down__arrow"><title>Обновить</title> <use xlink:href="/img/megazord-v25.4b679db1.svg#pull-arrow"></use></svg></div></div> <div class="tm-article-presenter"> <div class="tm-article-presenter__body"><div class="tm-misprint-area"><div class="tm-misprint-area__wrapper"><article class="tm-article-presenter__content tm-article-presenter__content_narrow"><div class="tm-article-presenter__header"> <div class="tm-article-snippet tm-article-presenter__snippet"><div class="tm-article-snippet__meta-container"><div class="tm-article-snippet__meta"><span class="tm-user-info tm-article-snippet__author"><a href="https://habr.com/ru/users/cobiot/" title="cobiot" class="tm-user-info__userpic"><div class="tm-entity-image"><svg height="24" width="24" class="tm-svg-img tm-image-placeholder tm-image-placeholder_blue"><!----> <use xlink:href="/img/megazord-v25.4b679db1.svg#placeholder-user"></use></svg></div></a> <span class="tm-user-info__user"><a href="https://habr.com/ru/users/cobiot/" class="tm-user-info__username">
      cobiot
    </a> </span></span> <span class="tm-article-snippet__datetime-published"><time datetime="2016-02-04T13:18:04.000Z" title="2016-02-04, 16:18">4  февраля  2016 в 16:18</time></span></div> <!----></div> <h1 lang="ru" class="tm-article-snippet__title tm-article-snippet__title_h1"><span>Создание архитектуры программы или как проектировать табуретку</span></h1> <div class="tm-article-snippet__hubs"><span class="tm-article-snippet__hubs-item"><a href="https://habr.com/ru/hub/webdev/" class="tm-article-snippet__hubs-item-link"><span>Разработка веб-сайтов</span> <span title="Профильный хаб" class="tm-article-snippet__profiled-hub">*</span></a></span><span class="tm-article-snippet__hubs-item"><a href="https://habr.com/ru/hub/analysis_design/" class="tm-article-snippet__hubs-item-link"><span>Анализ и проектирование систем</span> <span title="Профильный хаб" class="tm-article-snippet__profiled-hub">*</span></a></span><span class="tm-article-snippet__hubs-item"><a href="https://habr.com/ru/hub/refactoring/" class="tm-article-snippet__hubs-item-link"><span>Проектирование и рефакторинг</span> <span title="Профильный хаб" class="tm-article-snippet__profiled-hub">*</span></a></span></div> <div class="tm-article-snippet__labels"><div class="tm-article-snippet__label tm-article-snippet__label_variant-sandbox"><span>
        Из песочницы
      </span></div></div> <!----> <!----></div></div> <!----> <div data-gallery-root="" lang="ru" class="tm-article-body"><div></div> <div id="post-content-body"><div><div class="article-formatted-body article-formatted-body_version-1"><div xmlns="http://www.w3.org/1999/xhtml">Взявшись за написание небольшого, но реального и растущего проекта, мы «на собственной шкуре» убедились, насколько важно то, чтобы программа не только хорошо работала, но и была хорошо организована. Не верьте, что продуманная архитектура нужна только большим проектам (просто для больших проектов «смертельность» отсутствия архитектуры очевидна). Сложность, как правило, растет гораздо быстрее размеров программы. И если не позаботиться об этом заранее, то довольно быстро наступает момент, когда ты перестаешь ее контролировать. Правильная архитектура экономит очень много сил, времени и денег. А нередко вообще определяет то, выживет ваш проект или нет. И даже если речь идет всего лишь о «построении табуретки» все равно вначале очень полезно ее спроектировать.<br/>
<br/>
К моему удивлению оказалось, что на вроде бы актуальный вопрос: «Как построить хорошую/красивую архитектуру ПО?» — не так легко найти ответ. Не смотря на то, что есть много книг и статей, посвященных и шаблонам проектирования и принципам проектирования, например, принципам SOLID (кратко описаны <a href="http://info.javarush.ru/translation/2013/08/06/%D0%9F%D1%8F%D1%82%D1%8C-%D0%BE%D1%81%D0%BD%D0%BE%D0%B2%D0%BD%D1%8B%D1%85-%D0%BF%D1%80%D0%B8%D0%BD%D1%86%D0%B8%D0%BF%D0%BE%D0%B2-%D0%B4%D0%B8%D0%B7%D0%B0%D0%B9%D0%BD%D0%B0-%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D0%BE%D0%B2-S-O-L-I-D-%D0%B2-Java.html">тут</a>, подробно и с примерами можно посмотреть <a href="http://igor.quatrocode.com/2008/09/solid-top-5.html">тут</a>, <a href="http://blog.byndyu.ru/2009/10/solid.html">тут</a> и <a href="http://sergeyteplyakov.blogspot.com.es/2014/10/solid.html">тут</a>) и тому, как правильно оформлять код, все равно оставалось чувство, что чего-то важного не хватает. Это было похоже на то, как если бы вам дали множество замечательных и полезных инструментов, но забыли главное — объяснить, а как же «проектировать табуретку».<br/>
<br/>
Хотелось разобраться, что вообще в себя включает процесс создания архитектуры программы, какие задачи при этом решаются, какие критерии используются (чтобы правила и принципы перестали быть всего лишь догмами, а стали бы понятны их логика и назначение). Тогда будет понятнее и какие инструменты лучше использовать в том или ином случае.<br/>
<br/>
Данная статья является попыткой ответить на эти вопросы хотя бы в первом приближении.<a name="habracut"></a> Материал собирался для себя, но, может, он окажется полезен кому-то еще. Мне данная работа позволила не только узнать много нового, но и в ином контексте взглянуть на кажущиеся уже почти банальными основные принципы ООП и по настоящему оценить их важность.<br/>
<br/>
Информации оказалось довольно много, поэтому приведены лишь общая идея и краткие описания, дающие начальное представление о теме и понимание, где искать дальше.<br/>
<br/>
<h1>Критерии хорошей архитектуры</h1><br/>
Вообще говоря, не существует общепринятого термина «архитектура программного обеспечения». Тем не менее, когда дело касается практики, то для большинства разработчиков и так понятно какой код является хорошим, а какой плохим. <em>Хорошая архитектура</em> это прежде всего <em>выгодная</em> архитектура, делающая процесс разработки и сопровождения программы более простым и эффективным. Программу с хорошей архитектурой легче расширять и изменять, а также тестировать, отлаживать и понимать. То есть, на самом деле можно сформулировать список вполне разумных и универсальных критериев:<br/>
<br/>
<strong>Эффективность системы</strong>. В первую очередь программа, конечно же, должна решать поставленные задачи и хорошо выполнять свои функции, причем в различных условиях. Сюда можно отнести такие характеристики, как надежность, безопасность, производительность, способность справляться с увеличением нагрузки (масштабируемость) и т.п.<br/>
<br/>
<strong>Гибкость системы.</strong> Любое приложение приходится менять со временем — изменяются требования, добавляются новые. Чем быстрее и удобнее можно внести изменения в существующий функционал, чем меньше проблем и ошибок это вызовет — тем <em>гибче</em> и конкурентоспособнее система. Поэтому в процессе разработки старайтесь оценивать то, что получается, на предмет того, как вам это потом, возможно, придется менять. Спросите у себя: «А что будет, если текущее архитектурное решение окажется неверным?», «Какое количество кода подвергнется при этом изменениям?». Изменение одного фрагмента системы не должно влиять на ее другие фрагменты. По возможности, архитектурные решения не должны «вырубаться в камне», и последствия архитектурных ошибок должны быть в разумной степени ограничены. "<em>Хорошая архитектура позволяет ОТКЛАДЫВАТЬ принятие ключевых решений</em>" (Боб Мартин) и минимизирует «цену» ошибок.<br/>
<br/>
<strong>Расширяемость системы</strong>. Возможность добавлять в систему новые сущности и функции, не нарушая ее основной структуры. На начальном этапе в систему имеет смысл закладывать лишь основной и самый необходимый функционал (принцип YAGNI — you ain’t gonna need it, «Вам это не понадобится») Но при этом архитектура должна позволять легко наращивать дополнительный функционал по мере необходимости. Причем так, чтобы внесение <em>наиболее вероятных</em> изменений требовало <em>наименьших усилии</em>.<br/>
<br/>
Требование, чтобы архитектура системы обладала <em>гибкостью</em> и <em>расширяемостью</em> (то есть была способна к изменениям и эволюции) является настолько важным, что оно даже сформулировано в виде отдельного принципа — «<strong>Принципа открытости/закрытости</strong>» (<strong>Open-Closed Principle</strong> — второй из пяти принципов SOLID): <em>Программные сущности (классы, модули, функции и т.п.) должны быть открытыми для расширения, но закрытыми для модификации.</em><br/>
<br/>
Иными словами: <em>Должна быть возможность расширить/изменить поведение системы без изменения/переписывания уже существующих частей системы.</em><br/>
<br/>
Это означает, что приложение следует проектировать так, чтобы изменение его поведения и добавление новой функциональности достигалось бы за счет написания нового кода (расширения), и при этом не приходилось бы менять уже существующий код. В таком случае появление новых требований не повлечет за собой модификацию существующей логики, а сможет быть реализовано прежде всего за счет ее расширения. Именно этот принцип является основой «плагинной архитектуры» (Plugin Architecture). О том, за счет каких техник это может быть достигнуто, будет рассказано дальше.<br/>
<br/>
<strong>Масштабируемость процесса разработки</strong>. Возможность сократить срок разработки за счёт добавления к проекту новых людей. Архитектура должна позволять распараллелить процесс разработки, так чтобы множество людей могли работать над программой одновременно.<br/>
<br/>
<strong>Тестируемость</strong>. Код, который легче тестировать, будет содержать меньше ошибок и надежнее работать. Но тесты не только улучшают качество кода. Многие разработчики приходят к выводу, что требование «хорошей тестируемости» является также направляющей силой, автоматически ведущей к хорошему дизайну, и одновременно одним из важнейших критериев, позволяющих оценить его качество: "<em>Используйте принцип «тестируемости» класса в качестве «лакмусовой бумажки» хорошего дизайна класса. Даже если вы не напишите ни строчки тестового кода, ответ на этот вопрос в 90% случаев поможет понять, насколько все «хорошо» или «плохо» с его дизайном</em>" (<a href="http://habrahabr.ru/post/133287/">Идеальная архитектура</a>).<br/>
<br/>
Существует целая методология разработки программ на основе тестов, которая так и называется — <em>Разработка через тестирование</em> (<em>Test-Driven Development, TDD</em>).<br/>
<br/>
<strong>Возможность повторного использования</strong>. Систему желательно проектировать так, чтобы ее фрагменты можно было повторно использовать в других системах.<br/>
<br/>
<strong>Хорошо структурированный, читаемый и понятный код. Сопровождаемость</strong>. Над программой, как правило, работает множество людей — одни уходят, приходят новые. После написания сопровождать программу тоже, как правило, приходится людям, не участвовавшем в ее разработке. Поэтому хорошая архитектура должна давать возможность относительно легко и быстро разобраться в системе новым людям. Проект должен быть хорошо структурирован, не содержать дублирования, иметь хорошо оформленный код и желательно документацию. И по возможности в системе лучше применять стандартные, общепринятые решения привычные для программистов. Чем экзотичнее система, тем сложнее ее понять другим (<em>Принцип наименьшего удивления — Principle of least astonishment</em>. Обычно, он используется в отношении пользовательского интерфейса, но применим и к написанию кода).<br/>
<br/>
Ну и для полноты <a href="http://sergeyteplyakov.blogspot.com.es/2013/01/blog-post_29.html">критерии плохого дизайна</a>:<br/>
<br/>
<ol>
<li>Его тяжело изменить, поскольку любое изменение влияет на слишком большое количество других частей системы. (<strong>Жесткость, Rigidity</strong>).</li>
<li>При внесении изменений неожиданно ломаются другие части системы. (<strong>Хрупкость, Fragility</strong>).</li>
<li>Код тяжело использовать повторно в другом приложении, поскольку его слишком тяжело «выпутать» из текущего приложения. (<strong>Неподвижность, Immobility</strong>).</li>
</ol><br/>
<h1>Модульная архитектура. Декомпозиция как основа</h1><br/>
<br/>
<img src="https://habrastorage.org/r/w1560/files/965/721/560/9657215601f14952bb35870f5caf783d.png" alt="software architecture" data-src="https://habrastorage.org/files/965/721/560/9657215601f14952bb35870f5caf783d.png"/><br/>
<br/>
Не смотря на разнообразие критериев, все же главной при разработке больших систем считается задача снижения сложности. А для снижения сложности ничего, кроме деления на части, пока не придумано. Иногда это называют принципом «разделяй и властвуй» (divide et impera), но по сути речь идет об <strong>иерархической декомпозиции</strong>. Сложная система должна строится из небольшого количества более простых подсистем, каждая из которых, в свою очередь, строится из частей меньшего размера, и т.д., до тех пор, пока самые небольшие части не будут достаточно просты для непосредственного понимания и создания.<br/>
<br/>
Удача заключается в том, что данное решение является не только единственно известным, но и универсальным. Помимо снижения сложности, оно одновременно обеспечивает гибкость системы, дает хорошие возможности для масштабирования, а также позволяет повышать устойчивость за счет дублирования критически важных частей.<br/>
<br/>
Соответственно, когда речь идет о построении архитектуры программы, создании ее структуры, под этим, главным образом, подразумевается декомпозиция программы на подсистемы (функциональные модули, сервисы, слои, подпрограммы) и организация их взаимодействия друг с другом и внешним миром. Причем, чем более независимы подсистемы, тем безопаснее сосредоточиться на разработке каждой из них в отдельности в конкретный момент времени и при этом не заботиться обо всех остальных частях.<br/>
<br/>
В этом случае программа из «спагетти-кода» превращается в конструктор, состоящий из набора модулей/подпрограмм, взаимодействующих друг с другом по хорошо определенным и простым правилам, что собственно и позволяет контролировать ее сложность, а также дает возможность получить все те преимущества, которые обычно соотносятся с понятием хорошая архитектура:<br/>
<ul>
<li><strong>Масштабируемость (Scalability)</strong><br/>
возможность расширять систему и увеличивать ее производительность, за счет добавления новых модулей.</li>
<li><strong>Ремонтопригодность (Maintainability)</strong><br/>
изменение одного модуля не требует изменения других модулей</li>
<li><strong>Заменимость модулей (Swappability)</strong><br/>
модуль легко заменить на другой</li>
<li><strong>Возможность тестирования (Unit Testing)</strong><br/>
модуль можно отсоединить от всех остальных и протестировать / починить</li>
<li><strong>Переиспользование (Reusability)</strong><br/>
модуль может быть переиспользован в других программах и другом окружении</li>
<li><strong>Сопровождаемость (Maintenance)</strong><br/>
разбитую на модули программу легче понимать и сопровождать</li>
</ul><br/>
Можно сказать, что в разбиении сложной проблемы на простые фрагменты и заключается цель всех методик проектирования. А термином «архитектура», в большинстве случаев, просто обозначают результат такого деления, плюс "<em>некие конструктивные решения, которые после их принятия с трудом поддаются изменению</em>" (Мартин Фаулер «Архитектура корпоративных программных приложений»). Поэтому большинство определений в той или иной форме сводятся к следующему:<br/>
<br/>
"<em>Архитектура идентифицирует главные компоненты системы и способы их взаимодействия. Также это выбор таких решений, которые интерпретируются как основополагающие и не подлежащие изменению в будущем.</em>"<br/>
<br/>
"<em>Архитектура — это <strong>организация системы</strong>, воплощенная в ее <strong>компонентах</strong>, их <strong>отношениях</strong> между собой и с <strong>окружением</strong>.</em><br/>
<em><strong>Система</strong> — это набор компонентов, объединенных для выполнения определенной функции.</em>"<br/>
<br/>
Таким образом, хорошая архитектура это, прежде всего, <strong>модульная</strong>/<strong>блочная архитектура</strong>. Чтобы получить хорошую архитектуру надо знать, как правильно делать декомпозицию системы. А значит, необходимо понимать — какая декомпозиция считается «правильной» и каким образом ее лучше проводить?<br/>
<br/>
<h1>«Правильная» декомпозиция</h1><br/>
<strong>1. Иерархическая</strong><br/>
<br/>
Не стоит сходу рубить приложение на сотни классов. Как уже говорилось, декомпозицию надо проводить <strong>иерархически</strong> — сначала систему разбивают на крупные функциональные модули/подсистемы, описывающие ее работу в самом общем виде. Затем, полученные модули, анализируются более детально и, в свою очередь, делятся на под-модули либо на объекты.<br/>
<br/>
Перед тем как выделять объекты разделите систему на основные смысловые блоки хотя бы мысленно. Для небольших приложений двух уровней иерархии часто оказывается вполне достаточно — система вначале делится на подсистемы/пакеты, а пакеты делятся на классы.<br/>
<br/>
<img src="https://habrastorage.org/r/w1560/files/8d8/e4d/84b/8d8e4d84b56744c3911775106cd5a28d.png" alt="software decomposition" data-src="https://habrastorage.org/files/8d8/e4d/84b/8d8e4d84b56744c3911775106cd5a28d.png"/><br/>
<br/>
Эта мысль, при всей своей очевидности, не так банальна как кажется. Например, в чем заключается суть такого распространенного «архитектурного шаблона» как Модель-Вид-Контроллер (MVC)? Всего навсего в отделении <strong>представления</strong> от <strong>бизнес-логики</strong>, то есть в том, что любое пользовательское приложение вначале делится на два модуля — один из которых отвечает за реализацию собственно самой бизнес логики (Модель), а второй — за взаимодействие с пользователем (Пользовательский Интерфейс или Представление). Затем, для того чтобы эти модули могли разрабатываться независимо, связь между ними ослабляется с помощью паттерна «Наблюдатель» (подробно о способах ослабления связей будет рассказано дальше) и мы фактически получаем один из самых мощных и востребованных «шаблонов», которые используются в настоящее время.<br/>
<br/>
Типичными модулями первого уровня (полученными в результате первого деления системы на наиболее крупные составные части) как раз и являются — <em>«бизнес-логика», «пользовательский интерфейс», «доступ к БД», «связь с конкретным оборудованием или ОС».</em><br/>
<br/>
Для обозримости на каждом иерархическом уровне рекомендуют выделять от 2 до 7 модулей.<br/>
<br/>
<strong>2. Функциональная</strong><br/>
<br/>
Деление на модули/подсистемы лучше всего производить исходя из тех задач, которые решает система. Основная задача разбивается на составляющие ее подзадачи, которые могут решаться/выполняться независимо друг от друга. Каждый модуль должен отвечать за решение какой-то подзадачи и выполнять соответствующую ей <strong>функцию</strong>. Помимо функционального назначения модуль характеризуется также набором данных, необходимых ему для выполнения его функции, то есть:<br/>
<br/>
<em>Модуль</em> = <em>Функция</em> + <em>Данные</em>, необходимые для ее выполнения.<br/>
<br/>
Причем желательно, чтобы свою функцию модуль мог выполнить самостоятельно, без помощи остальных модулей, лишь на основе своих входящих данных.<br/>
<br/>
<em>Модуль — это не произвольный кусок кода, а отдельная функционально осмысленная и законченная программная единица</em> (<em>подпрограмма), которая обеспечивает решение некоторой задачи и в идеале может работать самостоятельно или в другом окружении и быть переиспользуемой. Модуль должен быть некой "целостностью, способной к относительной самостоятельности в поведении и развитии" (Кристофер Александер).</em><br/>
<br/>
Таким образом, грамотная декомпозиция основывается, прежде всего, на анализе <strong>функций системы</strong> и необходимых для выполнения этих функций данных.<br/>
<br/>
<strong>3. High Cohesion + Low Coupling</strong><br/>
Самым же главным критерием качества декомпозиции является то, насколько модули сфокусированы на решение своих задач и независимы. Обычно это формулируют следующим образом: "<em>Модули, полученные в результате декомпозиции, должны быть максимально сопряженны внутри (high internal cohesion) и минимально связанны друг с другом (low external coupling).</em>"<br/>
<br/>
<ul>
<li><strong>High Cohesion</strong>, высокая сопряженность или «сплоченность» внутри модуля, говорит о том, модуль сфокусирован на решении одной узкой проблемы, а не занимается выполнением разнородных функций или несвязанных между собой обязанностей. (<em>Сопряженность</em> — <em>cohesion</em>, характеризует степень, в которой задачи, выполняемые модулем, связаны друг с другом )<br/>
<br/>
Следствием High Cohesion является <strong>принцип единственной ответственности</strong> (<strong>Single Responsibility Principle</strong> — первый из пяти принципов SOLID), согласно которому любой объект/модуль должен иметь лишь одну обязанность и соответственно не должно быть больше одной причины для его изменения.<br/>
<br/>
</li>
<li><strong>Low Coupling</strong>, слабая связанность, означает что модули, на которые разбивается система, должны быть, по возможности, независимы или <em>слабо связанны</em> друг с другом. Они должны иметь возможность взаимодействовать, но при этом <em>как можно меньше знать друг о друге</em> (<strong>принцип минимального знания</strong>).<br/>
<br/>
Это значит, что при правильном проектировании, при изменении одного модуля, не придется править другие или эти изменения будут минимальными. Чем слабее связанность, тем легче писать/понимать/расширять/чинить программу.</li>
</ul><br/>
Считается, что хорошо спроектированные модули должны обладать следующими свойствами:<br/>
<ul>
<li><strong>функциональная целостность и завершенность</strong> — каждый модуль реализует одну функцию, но реализует хорошо и полностью; модуль самостоятельно (без помощи дополнительных средств) выполняет полный набор операций для реализации своей функции.</li>
<li><strong>один вход и один выход</strong> — на входе программный модуль получает определенный набор исходных данных, выполняет содержательную обработку и возвращает один набор результатных данных, т.е. реализуется стандартный принцип IPO — <em>вход–процесс–выход</em>;</li>
<li><strong>логическая независимость</strong> — результат работы программного модуля зависит только от исходных данных, но не зависит от работы других модулей;</li>
<li><strong>слабые информационные связи с другими модулями</strong> — обмен информацией между модулями должен быть по возможности минимизирован.</li>
</ul><br/>
Грамотная декомпозиция — это своего рода искусство и гигантская проблема для многих программистов. Простота тут очень обманчива, а ошибки обходятся очень дорого. Если выделенные модули оказываются сильно сцеплены друг с другом, если их не удается разрабатывать независимо или не ясно за какую конкретно функцию каждый из них отвечает, то стоит задуматься а правильно ли вообще производится деление. Должно быть понятно, какую роль выполняет каждый модуль. Самый же надежный критерий того, что декомпозиция делается правильно, это если модули получаются самостоятельными и ценными сами по себе подпрограммами, которые могут быть использованы в отрыве от всего остального приложения (а значит, могут быть переиспользуемы).<br/>
<br/>
Делая декомпозицию системы желательно проверять ее качество задавая себе вопросы: "<em>Какую функцию выполняет каждый модуль?</em>", “<em>Насколько модули легко тестировать?</em>”, “<em>Возможно ли использовать модули самостоятельно или в другом окружении?</em>”, “<em>Как сильно изменения в одном модуле отразятся на остальных?</em>”<br/>
<br/>
В первую очередь следует, конечно же, стремиться к тому, чтобы модули были предельно автономны. Как и было сказано, это является ключевым параметром правильной декомпозиции. Поэтому проводить ее нужно таким образом, чтобы модули <strong>изначально</strong> слабо зависели друг от друга. Но кроме того, имеется ряд специальных техник и шаблонов, позволяющих затем дополнительно <em>минимизировать и ослабить связи между подсистемами.</em> Например, в случае MVC для этой цели использовался шаблон «Наблюдатель», но возможны и другие решения. Можно сказать, что техники для <em>уменьшения связанности</em>, как раз и составляют основной «инструментарий архитектора». Только необходимо понимать, что речь идет о всех подсистемах и <strong>ослаблять связанность нужно на всех уровнях иерархии</strong>, то есть не только между классам, но также и между модулями на каждом иерархическом уровне.<br/>
<br/>
<h1>Как ослаблять связанность между модулями</h1><br/>
Для наглядности, картинка из неплохой статьи "<a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.43.6026&amp;amp;rep=rep1&amp;amp;type=pdf">Decoupling of Object-Oriented Systems</a>", иллюстрирующая основные моменты, о которых будет идти речь.<br/>
<br/>
<img src="https://habrastorage.org/r/w1560/files/9b7/5a0/1a8/9b75a01a808341d29b9bbaa8da1f2734.png" alt="Decoupling architecture" data-src="https://habrastorage.org/files/9b7/5a0/1a8/9b75a01a808341d29b9bbaa8da1f2734.png"/><br/>
<br/>
<h3>1. Интерфейсы. Фасад</h3><br/>
Главным, что позволяет уменьшать связанность системы, являются конечно же <em>Интерфейсы</em> (и стоящий за ними принцип <em>Инкапсуляция + Абстракция + Полиморфизм)</em>:<br/>
<br/>
<ul>
<li>Модули должны быть друг для друга "черными ящиками" (<em>инкапсуляция</em>). Это означает, что один модуль не должен «лезть» внутрь другого модуля и что либо знать о его внутренней структуре. Объекты одной подсистемы не должны обращаться напрямую к объектам другой подсистемы</li>
<li>Модули/подсистемы должны взаимодействовать друг с другом лишь посредством <em>интерфейсов</em> (то есть, <em>абстракций</em>, не зависящих от деталей реализации) Соответственно каждый модуль должен иметь четко определенный интерфейс или интерфейсы для взаимодействия с другими модулями.</li>
</ul><br/>
Принцип «черного ящика» (<em>инкапсуляция</em>) позволяет рассматривать структуру каждой подсистемы независимо от других подсистем. Модуль, представляющий собой черный ящик, можно относительно свободно менять. Проблемы могут возникнуть лишь на стыке разных модулей (или модуля и окружения). И вот это взаимодействие нужно описывать в максимально общей (<em>абстрактной</em>) форме — в форме интерфейса. В этом случае код будет работать одинаково с любой реализацией, соответствующей контракту интерфейса. Собственно именно эта возможность работать с различными реализациями (модулями или объектами) через унифицированный интерфейс и называется полиморфизмом. Полиморфизм это вовсе не переопределение методов, как иногда ошибочно полагают, а прежде всего — <em>взаимозаменяемость</em> модулей/объектов с одинаковым интерфейсом, или «один интерфейс, множество реализаций» (подробнее <a href="https://habrahabr.ru/post/37610/">тут</a>). Для реализации полиморфизма механизм наследования совсем не нужен. Это важно понимать, поскольку наследования вообще, по возможности, следует избегать.<br/>
<br/>
Благодаря интерфейсам и полиморфизму, как раз и достигается возможность модифицировать и расширять код, без изменения того, что уже написано (Open-Closed Principle). До тех пор, пока взаимодействие модулей описано исключительно в виде интерфейсов, и не завязано на конкретные реализации, мы имеем возможность абсолютно «безболезненно» для системы заменить один модуль на любой другой, реализующий тот же самый интерфейс, а также добавить новый и тем самым расширить функциональность. Это как в конструкторе или «плагинной архитектуре» (plugin architecture) — интерфейс служит своего рода коннектором, куда может быть подключен любой модуль с подходящим разъемом. Гибкость конструктора обеспечивается тем, что мы можем просто заменить одни модули/«детали» на другие, с такими же разъемами (с тем же интерфейсом), а также добавить сколько угодно новых деталей (при этом уже существующие детали никак не изменяются и не переделываются). Подробнее про Open-Closed Principle и про то, как он может быть реализован можно почитать <a href="http://sergeyteplyakov.blogspot.ca/2014/08/open-closed-principle.html">тут</a> + хорошая статья <a href="http://blog.8thlight.com/uncle-bob/2014/05/12/TheOpenClosedPrinciple.html">на английском</a>.<br/>
<br/>
Интерфейсы позволяют строить систему более высокого уровня, рассматривая каждую подсистему как единое целое и игнорируя ее внутреннее устройство. Они дают возможность модулям взаимодействовать и при этом ничего не знать о внутренней структуре друг друга, тем самым в полной мере реализуя <em>принцип минимального знания</em>, являющейся основой <em>слабой связанности.</em> Причем, чем в более общей/абстрактной форме определены интерфейсы и чем меньше ограничений они накладывают на взаимодействие, тем гибче система. Отсюда фактически следует еще один из принципов SOLID — <strong>Принцип разделения интерфейса (Interface Segregation Principle)</strong>, который выступает против «толстых интерфейсов» и говорит, что большие, объемные интерфейсы надо разбивать на более маленькие и специфические, чтобы клиенты маленьких интерфейсов (зависящие модули) знали только о методах, которые необходимы им в работе. Формулируется он следующим образом: "<em>Клиенты не должны зависеть от методов (знать о методах), которые они не используют</em>" или “<em>Много специализированных интерфейсов лучше, чем один универсальный”.</em><br/>
<br/>
Итак, когда взаимодействие и зависимости модулей описываются лишь с помощью интерфейсов, те есть <em>абстракций</em>, без использования знаний об их внутреннем устройстве и структуре, то фактически тем самым реализуется <em>инкапсуляция</em>, плюс мы имеем возможность расширять/изменять поведения системы за счет добавления и использования различных реализаций, то есть за счет <em>полиморфизма.</em> Из этого следует, что концепция интерфейсов включает в себя и в некотором смысле обобщает почти все основные принципы ООП — Инкапсуляцию, Абстракцию, Полиморфизм. Но тут возникает один вопрос. Когда проектирование идет не на уровне объектов, которые сами же и реализуют соответствующие интерфейсы, а на уровне модулей, то что является реализацией интерфейса модуля? Ответ: если говорить языком шаблонов, то как вариант, за реализацию интерфейса модуля может отвечать специальный объект — <strong>Фасад</strong>.<br/>
<br/>
<em>Фасад — это объект-интерфейс, аккумулирующий в себе высокоуровневый набор операций для работы с некоторой подсистемой, скрывающий за собой ее внутреннюю структуру и истинную сложность. Обеспечивает защиту от изменений в реализации подсистемы. Служит единой точкой входа — "вы пинаете фасад, а он знает, кого там надо пнуть в этой подсистеме, чтобы получить нужное"</em>.<br/>
<br/>
Таким образом, мы получаем первый, самый важный паттерн, позволяющий использовать концепцию интерфейсов при проектировании модулей и тем самым ослаблять их связанность — «<em>Фасад»</em>. Помимо этого «Фасад» вообще дает возможность работать с модулями точно также как с обычными объектами и применять при проектировании модулей все те полезные принципы и техники, которые используются при проектирования классов.<br/>
<br/>
<img src="https://habrastorage.org/r/w1560/files/f29/b83/8b1/f29b838b11df4acda0009ace9b6f9ed7.png" alt="Facade Decoupling architecture" data-src="https://habrastorage.org/files/f29/b83/8b1/f29b838b11df4acda0009ace9b6f9ed7.png"/><br/>
<br/>
<em>Замечание: Хотя большинство программистов понимают важность интерфейсов при проектировании классов (объектов), складывается впечатление, что идея необходимости использовать интерфейсы также и на уровне модулей только зарождается. Мне встретилось очень мало статей и проектов, где интерфейсы бы применялись для ослабления связанности между модулями/слоями и соответственно использовался бы паттерн «Фасад». Кто, например, видел «Фасад» на схемах уже упоминавшегося «архитектурного шаблона» Модель-Вид-Контроллер, или хотя бы слышал его упоминание среди паттернов, входящих в состав MVC (наряду с Observer и Composite)? А ведь он там должен быть, поскольку Модель это не класс, это модуль, причем центральный. И у создателя MVC Трюгве Реенскауга он, конечно же, был (смотрим «</em><a href="http://heim.ifi.uio.no/~trygver/2003/javazone-jaoo/MVC_pattern.pdf">The Model-View-Controller (MVC ). Its Past and Present</a><em>», только учитываем, что это писалось в 1973 году и то, что мы сейчас называем Представлением — Presentaition/UI тогда называлось Editior). Странным образом «Фасад» потерялся на многие годы и вновь обнаружить его мне удалось лишь недавно, в основном, в обобщенном варианте MVC от Microsoft («</em><a href="https://msdn.microsoft.com/en-us/library/ee658099.aspx">Microsoft Application Architecture Guide</a><em>»). Вот соответствующие слайды:</em><br/>
<br/>
<img src="https://habrastorage.org/r/w1560/files/171/01d/d78/17101dd785b84564b54477fe7015589b.png" alt="Facade MVC Model-View-Controller Decoupling" data-src="https://habrastorage.org/files/171/01d/d78/17101dd785b84564b54477fe7015589b.png"/><br/>
<br/>
<em>А разработчикам, к сожалению, приходится заново «переоткрывать» идею, что к объектам Модели, отвечающей за бизнес-логику приложения, нужно обращаться не напрямую а через интерфейс, то есть «Фасад», как например, в этой</em> <a href="http://alvinjayreyes.com/2011/09/11/ejb-architectural-patterns-session-facade/">статье</a><em>, откуда для полноты картины взят еще один слайд:</em><br/>
<br/>
<img src="https://habrastorage.org/r/w1560/files/0ce/540/28e/0ce54028e75c44e6848fbf98274cce79.png" alt="Facade MVC Model-View-Controller Decoupling" data-src="https://habrastorage.org/files/0ce/540/28e/0ce54028e75c44e6848fbf98274cce79.png"/><br/>
<br/>
<h3>2. Dependency Inversion. Корректное создание и получение зависимостей</h3><br/>
Формально, требование, чтобы модули не содержали ссылок на конкретные реализации, а все зависимости и взаимодействие между ними строились исключительно на основе абстракций, то есть интерфейсов, выражается принципом <strong>Инвертирования зависимостей</strong> (<strong>Dependency Inversion</strong> — последний из пяти принципов SOLID):<br/>
<ul>
<li>Модули верхнего уровня не должны зависеть от модулей нижнего уровня. И те, и другие должны зависеть от абстракций.</li>
<li>Абстракции не должны зависеть от деталей. Реализация должна зависеть от абстракции.</li>
</ul><br/>
У этого принципа не самая очевидная формулировка, но суть его, как и было сказано, выражается правилом: «<em>Все зависимости должны быть в виде интерфейсов</em>». Подробно и очень хорошо принцип инвертирования зависимостей разбирается в статье <a href="http://www.skipy.ru/architecture/module_design.html#principles">Модульный дизайн или «что такое DIP, SRP, IoC, DI и т.п.»</a>. Статья из разряда must-read, лучшее, что доводилось читать по архитектуре ПО.<br/>
<br/>
Не смотря на свою фундаментальность и кажущуюся простоту это правило нарушается, пожалуй, чаще всего. А именно, каждый раз, когда в коде программы/модуля мы используем оператор new и создаем новый объект конкретного типа, то тем самым вместо зависимости от интерфейса образуется зависимость от реализации.<br/>
<br/>
Понятно, что этого нельзя избежать и объекты где-то должны создаваться. Но, по крайней мере, нужно свести к минимуму количество мест, где это делается и в которых явно указываются классы, а также локализовать и изолировать такие места, чтобы они не были разбросаны по всему коду программы. Решение заключается в том, чтобы сконцентрировать создание новых объектов в рамках специализированных объектов и модулей — фабрик, сервис локаторов, IoC-контейнеров.<br/>
<br/>
В каком-то смысле такое решение следует <a href="http://www.life-prog.ru/2_31166_printsip-edinstvennogo-vibora.html">Принципу единственного выбора</a> (Single Choice Principle), который говорит: "<em>всякий раз, когда система программного обеспечения должна поддерживать множество альтернатив, их полный список должен быть известен только одному модулю системы</em>". В этом случае, если в будущем придется добавить новые варианты (или новые реализации, как в рассматриваемом нами случае создания новых объектов), то достаточно будет произвести обновление только того модуля, в котором содержится эта информация, а все остальные модули останутся незатронутыми и смогут продолжать свою работу как обычно.<br/>
<br/>
Ну а теперь разберем подробнее, как это делается на практике и каким образом модули могут <em>корректно создавать и получать свои «зависимости»</em>, не нарушая принципа Dependency Inversion.<br/>
<br/>
Итак, при проектировании модуля должны быть определены следующие ключевые вещи:<br/>
<ul>
<li>что модуль делает, какую функцию выполняет</li>
<li>что модулю нужно от его окружения, то есть с какими объектами/модулями ему придется иметь дело и</li>
<li><em>как он это будет получать</em></li>
</ul><br/>
Крайне важно то, <em>как модуль получает ссылки на объекты, которые он использует в своей работе</em>. И тут возможны следующие варианты:<br/>
<br/>
<ol>
<li><em>Модуль сам создает объекты необходимые ему для работы</em>.<br/>
<br/>
Но, как и было сказано, модуль не может это сделать напрямую — для создания необходимо вызвать конструктор конкретного типа, и в результате модуль будет зависеть не от интерфейса, а от конкретной реализации. Решить проблему в данном случае позволяет шаблон <a href="http://cpp-reference.ru/patterns/creational-patterns/factory-method/">Фабричный Метод</a> (<strong>Factory Method</strong>).<br/>
<br/>
"Суть заключается в том, что вместо непосредственного инстанцирования объекта через new, мы предоставляем классу-клиенту некоторый интерфейс для создания объектов. Поскольку такой интерфейс при правильном дизайне всегда может быть переопределён, мы получаем определённую гибкость при использовании низкоуровневых модулей в модулях высокого уровня".<br/>
<br/>
В случаях, когда нужно создавать группы или семейства взаимосвязанных объектов, вместо Фабричного Метода используется <a href="http://cpp-reference.ru/patterns/creational-patterns/abstract-factory/">Абстрактная Фабрика</a> (<strong>Abstract factory</strong>).<br/>
<br/>
</li>
<li><em>Модуль берет необходимые объекты у того, у кого они уже есть</em> (обычно это некоторый, известный всем репозиторий, в котором уже лежит все, что только может понадобиться для работы программы).<br/>
<br/>
Этот подход реализуется шаблоном <strong>Локатор Сервисов</strong> (<strong>Service Locator</strong>), основная идея которого заключается в том, что в программе имеется объект, знающий, как получить все зависимости (сервисы), которые могут потребоваться.<br/>
<br/>
Главное отличие от фабрик в том, что Service Locator не создаёт объекты, а фактически уже содержит в себе инстанцированные объекты (или знает где/как их получить, а если и создает, то только один раз при первом обращении). Фабрика при каждом обращении создает новый объект, который вы получаете в полную собственность и можете делать с ним что хотите. Локатор же сервисов выдает ссылки на одни и те же, уже существующие объекты. Поэтому с объектами, выданными Service Locator, нужно быть очень осторожным, так как одновременно с вами ими может пользоваться кто-то еще.<br/>
<br/>
Объекты в Service Locator могут быть добавлены напрямую, через конфигурационный файл, да и вообще любым удобным программисту способом. Сам Service Locator может быть статическим классом с набором статических методов, синглетоном или интерфейсом и передаваться требуемым классам через конструктор или метод.<br/>
<br/>
Вообще говоря, Service Locator иногда называют антипаттерном и не рекомендуют использовать (главным образом потому, что он создает неявные связности и дает лишь видимость хорошего дизайна). Подробно можно почитать у Марка Симана:<br/>
<a href="http://blog.ploeh.dk/2010/02/03/ServiceLocatorIsAnAntiPattern.aspx">Service Locator is an Anti-Pattern</a> <br/>
<a href="http://blog.ploeh.dk/2010/11/01/PatternRecognitionAbstractFactoryOrServiceLocator.aspx">Abstract Factory or Service Locator?</a><br/>
<br/>
</li>
<li><em>Модуль вообще не заботиться о «добывании» зависимостей.</em> Он лишь определяет, что ему нужно для работы, а все необходимые зависимости ему поставляются («впрыскиваются») из вне кем-то другим.<br/>
<br/>
Это так и называется — <strong>Внедрение Зависимостей</strong> (<strong>Dependency Injection</strong>). Обычно требуемые зависимости передаются либо в качестве параметров конструктора (<em>Constructor Injection</em>), либо через методы класса (<em>Setter injection</em>).<br/>
<br/>
Такой подход <em>инвертирует процесс создания зависимости</em> — вместо самого модуля создание зависимостей контролирует кто-то извне. Модуль из активного элемента, становится пассивным — не он делает, а для него делают. Такое изменение направления действия называется <strong>Инверсия Контроля</strong> (<strong>Inversion of Control</strong>), или <em>Принцип Голливуда</em> — «Не звоните нам, мы сами вам позвоним».<br/>
<br/>
Это самое гибкое решение, дающее модулям наибольшую автономность. Можно сказать, что только оно в полной мере реализует «<em>Принцип единственной ответственности</em>» — модуль должен быть полностью сфокусирован на том, чтобы хорошо выполнять свою функцию и не заботиться ни о чем другом. Обеспечение его всем необходимым для работы это отдельная задача, которой должен заниматься соответствующий «специалист» (обычно управлением зависимостями и их внедрениями занимается некий контейнер — IoC-контейнер).<br/>
<br/>
По сути, здесь все как в жизни: в хорошо организованной компании программисты программируют, а столы, компьютеры и все необходимое им для работы покупает и обеспечивает кладовщик. Или, если использовать метафору программы как конструктора — модуль не должен думать о проводах, сборкой конструктора занимается кто-то другой, а не сами детали.</li>
</ol><br/>
Более подробно и с примерами о способах создания и получения зависимостей можно почитать, например, в этой <a href="http://habrahabr.ru/post/244517/">статье</a> (только надо иметь ввиду, что хотя автор пишет о <em>Dependency Inversion</em>, он использует термин <em>Inversion of Control</em>; возможно потому, что в русской википедии содержится ошибка и этим терминам даны одинаковые определения). А принцип <em>Inversion of Control</em> (вместе с <em>Dependency Injection</em> и <em>Service Locator</em>) детально разбирается Мартином Фаулером и есть переводы обеих его статей: "<a href="http://yugeon-dev.blogspot.com.es/2010/07/inversion-of-control-containers-and_21.html">Inversion of Control Containers and the Dependency Injection pattern</a>" и “<a href="http://habrahabr.ru/post/116232/">Inversion of Control</a>”.<br/>
<br/>
Не будет преувеличением сказать, что использование интерфейсов для описания зависимостей между модулями (<em>Dependency Inversion</em>) + корректное создание и внедрение этих зависимостей (прежде всего <em>Dependency Injection</em>) являются центральными/базовыми техниками для снижения связанности. Они служат тем фундаментом, на котором вообще держится слабая связанность кода, его гибкость, устойчивость к изменениям, переиспользование, и без которого все остальные техники имеют мало смысла. Но, если с фундаментом все в порядке, то знание дополнительных приемов может быть очень даже полезным. Поэтому продолжим.<br/>
<br/>
<h3>3. Замена прямых зависимостей на обмен сообщениями</h3><br/>
Иногда модулю нужно всего лишь <em>известить</em> других о том, что в нем произошли какие-то события/изменения и ему не важно, что с этой информацией будет происходить потом. В этом случае модулям вовсе нет необходимости «знать друг о друге», то есть содержать прямые ссылки и взаимодействовать непосредственно, а достаточно всего лишь обмениваться сообщениями (messages) или событиями (events).<br/>
<br/>
Связь модулей через <em>обмен сообщениями</em> является гораздо более слабой, чем прямая зависимость и реализуется она чаще всего с помощью следующих шаблонов:<br/>
<br/>
<ul>
<li><strong>Наблюдатель (Observer).</strong> Применяется в случае зависимости «<em>один-ко-многим</em>», когда множество модулей зависят от состояния одного — основного. Использует механизм <a href="https://en.wikipedia.org/wiki/Publish–subscribe_pattern">рассылки</a>, который заключается в том, что основной модуль просто осуществляет рассылку одинаковых сообщений всем своим подписчикам, а модули, заинтересованные в этой информации, реализуют интерфейс «подписчика» и подписываются на рассылку. Находит широкое применение в системах с пользовательским интерфейсом, позволяя ядру приложения (модели) оставаться независимым и при этом информировать связанные с ним интерфейсы о том что произошли какие-то изменения и нужно обновиться.<br/>
<br/>
Организация взаимодействия посредством рассылки сообщений имеет дополнительный «бонус» — необязательность существования «подписчиков» на «опубликованные» (т.е. рассылаемые) сообщения. Качественно спроектированная подобная система допускает добавление/удаление модулей в любое время.<br/>
<br/>
</li>
<li><strong>Посредник (Mediator).</strong> Применяется, когда между модулями имеется зависимость «<em>многие ко многим</em>. Медиатор выступает в качестве посредника в общении между модулями<strong>,</strong> действуя как центр связи и избавляет модули от необходимости явно ссылаться друг на друга. В результате взаимодействие модулей друг с другом («все со всеми») заменяется взаимодействием модулей лишь с посредником («один со всеми»). Говорят, что посредник <em>инкапсулирует взаимодействие</em> между множеством модулей.<br/>
<br/>
<img src="https://habrastorage.org/r/w1560/files/598/704/b45/598704b45b854f4baf30aa214210aff5.png" alt="Mediator Посредник" data-src="https://habrastorage.org/files/598/704/b45/598704b45b854f4baf30aa214210aff5.png"/><br/>
<br/>
Типичный пример — контроль трафика в аэропорту. Все сообщения, исходящие от самолетов, поступают в башню управления диспетчеру, вместо того, чтобы пересылаться между самолетами напрямую. А диспетчер уже принимает решения о том, какие самолеты могут взлетать или садиться, и в свою очередь отправляет самолетам соответствующие сообщения. Подробнее, например, <a href="http://cpp-reference.ru/patterns/behavioral-patterns/mediator/">тут</a>.</li>
</ul><br/>
<em>Дополнение: Модули могут пересылать друг другу не только «простые сообщения, но и объекты-команды. Такое взаимодействие описывается шаблоном</em> <strong>Команда</strong> (<strong>Command</strong>). <em>Суть заключается в инкапсулировании запроса на выполнение определенного действия в виде отдельного объекта (фактически этот объект содержит один единственный метод execute()), что позволяет затем передавать это действие другим модулям на выполнение в качестве параметра, и вообще производить с объектом-командой любые операции, какие могут быть произведены над обычными объектами. Кратко рассмотрен</em> <a href="http://cpp-reference.ru/patterns/behavioral-patterns/command/">тут</a><em>, соответствующая глава из книги банды четырех</em> <a href="http://ooad.asf.ru/Pattern.aspx?IdKat=7&amp;amp;IdPat=33">тут</a><em>, есть также статья на</em> <a href="https://habrahabr.ru/post/114455/">хабре</a><em>.</em><br/>
<br/>
<h3>4. Замена прямых зависимостей на синхронизацию через общее ядро</h3><br/>
Данный подход обобщает и развивает идею заложенную в шаблоне «Посредник». Когда в системе присутствует большое количество модулей, их прямое взаимодействие друг с другом становится слишком сложным. Поэтому имеет смысл взаимодействие «все со всеми» заменить на взаимодействие «один со всеми». Для этого вводится некий обобщенный посредник, это может быть общее ядро приложения, хранилище или шина данных, а все остальные модули становятся независимыми друг от друга клиентами, использующими сервисы этого ядра или выполняющими обработку содержащейся там информации. Реализация этой идеи позволяет модулям-клиентам общаться друг с другом через посредника и при этом ничего друг о друге не знать.<br/>
<br/>
Ядро-посредник может как знать о модулях-клиентах и управлять ими (пример — <a href="https://www.ibm.com/developerworks/ru/library/os-apache_5/">архитектура apache</a> ), так и может быть полностью, или почти полностью, независимым и ничего о клиентах не знать. В сущности именно этот подход реализован в «шаблоне» Модель-Вид-Контроллер (MVC), где с одной Моделью (являющейся ядром приложение и общим хранилищем данных) могут взаимодействовать множество Пользовательских Интерфейсов, которые работают синхронно и при этом не знают друг о друге, а Модель не знает о них. Ничто не мешает подключить к общей модели и синхронизировать таким образом не только интерфейсы, но и другие вспомогательные модули.<br/>
<br/>
Очень активно эта идея также используется при разработке игр, где независимые модули, отвечающие за графику, звук, физику, управление программой синхронизируются друг с другом через игровое ядро (модель), где хранятся все данные о состоянии игры и ее персонажах. В отличие от MVC, в играх согласование модулей с ядром (моделью) происходит не за счет шаблона «Наблюдатель», а по таймеру, что само по себе является интересным архитектурным решением весьма полезным для программ с анимацией и «бегущей» графикой.<br/>
<br/>
<h3>5. Закон Деметры (law of Demeter)</h3><br/>
<a href="https://ru.wikipedia.org/wiki/%D0%97%D0%B0%D0%BA%D0%BE%D0%BD_%D0%94%D0%B5%D0%BC%D0%B5%D1%82%D1%80%D1%8B">Закон Деметры</a> запрещает использование неявных зависимостей: "<em>Объект A не должен иметь возможность получить непосредственный доступ к объекту C, если у объекта A есть доступ к объекту B и у объекта B есть доступ к объекту C</em>". <a href="http://alvinalexander.com/java/java-law-of-demeter-java-examples">Java-пример</a>.<br/>
<br/>
Это означает, что все зависимости в коде должны быть «явными» — классы/модули могут использовать в работе только «свои зависимости» и не должны лезть через них к другим. Кратко этот принцип формулируют еще таким образом: "<em>Взаимодействуй только с непосредственными друзьями, а не с друзьями друзей</em>". Тем самым достигается меньшая связанность кода, а также большая наглядность и прозрачность его дизайна.<br/>
<br/>
Закон Деметры реализует уже упоминавшийся «<em>принцип минимального знания</em>», являющейся основой слабой связанности и заключающийся в том, что объект/модуль должен знать как можно меньше деталей о структуре и свойствах других объектов/модулей и вообще чего угодно, <strong>включая собственные подкомпоненты</strong>. Аналогия из жизни: Если Вы хотите, чтобы собака побежала, глупо командовать ее лапами, лучше отдать команду собаке, а она уже разберётся со своими лапами сама.<br/>
<br/>
<h3>6. Композиция вместо наследования</h3><br/>
Одну из самых сильных связей между объектами дает наследование, поэтому, по возможности, его следует избегать и заменять композицией. Эта тема хорошо раскрыта в статье Герба Саттера — «<a href="http://programming-lang.com/ru/comp_programming/satter/0/j84.html">Предпочитайте композицию наследованию</a>».<br/>
<br/>
Могу только посоветовать в данном контексте обратить внимание на шаблон <a href="https://ru.wikipedia.org/wiki/Шаблон_делегирования">Делегат</a> (<strong>Delegation/Delegate</strong>) и пришедший из игр шаблон <strong>Компонет</strong> (<strong>Component</strong>), который подробно описан в книге «Game Programming Patterns» (соответствующая глава из этой книги на <a href="http://gameprogrammingpatterns.com/component.html">английском</a> и ее <a href="http://live13.livejournal.com/473028.html">перевод</a>).<br/>
<br/>
<h1>Что почитать</h1><br/>
Статьи в интернете:<br/>
<ul>
<li><a href="http://uml-tutorials.trireme.com/uml_tutorial_6_1.htm">Design patterns for decoupling</a> (небольшая полезная глава из <a href="http://uml-tutorials.trireme.com/">UML Tutorial</a>);</li>
<li><a href="https://dev.by/lenta/apalon/nemnogo-pro-arhitekturu">Немного про архитектуру</a>;</li>
<li><a href="https://addyosmani.com/largescalejavascript/">Patterns For Large-Scale JavaScript Application Architecture</a>;</li>
<li><a href="http://www.artlebedev.ru/tools/technogrette/js/observable/">Слабое связывание компонентов в JavaScript</a>;</li>
<li><a href="http://habrahabr.ru/company/mailru/blog/267277/">Как писать тестируемый код</a> — статья из которой хорошо видно что критерии тестируемости кода и хорошего дизайна совпадают;</li>
<li><a href="http://martinfowler.com/design.html">сайт</a> Мартина Фаулера.</li>
</ul><br/>
Замечательный ресурс — <a href="http://rus-linux.net/MyLDP/BOOKS/Architecture-Open-Source-Applications/index.html">Архитектура приложений с открытым исходным кодом</a>, где "<em>авторы четырех дюжин приложений с открытым исходным кодом рассказывают о структуре созданных ими программ и о том, как эти программы создавались. Каковы их основные компоненты? Как они взаимодействуют? И что открыли для себя их создатели в процессе разработки? В ответах на эти вопросы авторы статей, собранных в данных книгах, дают вам уникальную возможность проникнуть в то, как они творят</em>". Одна из статей полностью была опубликована на хабре — «<a href="http://habrahabr.ru/post/185636/">Масштабируемая веб-архитектура и распределенные системы</a>».<br/>
<br/>
Интересные решения и идеи можно найти в материалах, посвященных разработке игр. <a href="http://gameprogrammingpatterns.com/contents.html">Game Programming Patterns</a> — большой сайт с подробным описанием многих шаблонов и примерами их применения к задаче создания игр (оказывается, есть уже его перевод — «<a href="http://live13.livejournal.com/462582.html">Шаблоны игрового программирования</a>», спасибо <a href="https://habrahabr.ru/users/strannik_k/">strannik_k</a> за ссылку). Возможно будет полезна также статья «<a href="http://www.dtf.ru/articles/read.php?id=40757">Гибкая и масштабируемая архитектура для компьютерных игр</a>» (и ее <a href="https://www.tjhsst.edu/~rlatimer/techlab07/plummer_thesis.pdf">оригинал</a>. Нужно только иметь ввиду что автор почему-то композицию называет шаблоном "Наблюдатель").<br/>
<br/>
По поводу паттернов проектирования:<br/>
<ul>
<li>Интересная «<a href="http://rsdn.ru/forum/design/3774238">Мысль про паттерны проектирования</a>»;</li>
<li>Удобный сайт с краткими описаниями и схемами всех шаблонов проектирования — «<a href="http://citforum.ru/SE/project/pattern/index.shtml#toc">Обзор паттернов проектирования</a>»;</li>
<li>сайт на базе книги банды четырех, где все шаблоны описаны очень подробно — «<a href="http://ooad.asf.ru/Patterns.aspx">Шаблоны [Patterns] проектирования</a>».</li>
</ul><br/>
Есть еще принципы/паттерны GRASP, описанные Крэгом Лэрманом в книге «<a href="http://www.ozon.ru/context/detail/id/3105480/">Применение UML 2.0 и шаблонов проектирования</a>», но они больше запутывают чем проясняют. Краткий обзор и обсуждение на <a href="http://habrahabr.ru/post/38323/">хабре</a> (самое ценное в комментариях).<br/>
<br/>
Ну и конечно же книги:<br/>
<ul>
<li>Мартин Фаулер «<a href="http://www.ozon.ru/context/detail/id/1616782/">Архитектура корпоративных программных приложений</a>»;</li>
<li>Стив Макконнелл «<a href="http://www.ozon.ru/context/detail/id/5508646/">Совершенный код</a>»;</li>
<li>Шаблоны проектирования от банды четырех (Gang of Four, GoF) — «<a href="http://www.ozon.ru/context/detail/id/2457392/">Приемы объектно-ориентированного проектирования. Паттерны проектирования</a>».</li>
</ul></div></div></div> <DIV class="v-portal" style="display:none;"></DIV></div> <!----> <!----></div> <div class="tm-article-presenter__meta"><div class="tm-separated-list tm-article-presenter__meta-list"><span class="tm-separated-list__title">Теги:</span> <ul class="tm-separated-list__list"><li class="tm-separated-list__item"><a href="https://habr.com/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5B%D0%B0%D1%80%D1%85%D0%B8%D1%82%D0%B5%D0%BA%D1%82%D1%83%D1%80%D0%B0%20%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D0%B9%5D" class="tm-tags-list__link">архитектура приложений</a></li><li class="tm-separated-list__item"><a href="https://habr.com/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5B%D0%BF%D1%80%D0%B8%D0%BD%D1%86%D0%B8%D0%BF%D1%8B%20%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F%5D" class="tm-tags-list__link">принципы проектирования</a></li></ul></div> <div class="tm-separated-list tm-article-presenter__meta-list"><span class="tm-separated-list__title">Хабы:</span> <ul class="tm-separated-list__list"><li class="tm-separated-list__item"><a href="https://habr.com/ru/hub/webdev/" class="tm-hubs-list__link">
    Разработка веб-сайтов
  </a></li><li class="tm-separated-list__item"><a href="https://habr.com/ru/hub/analysis_design/" class="tm-hubs-list__link">
    Анализ и проектирование систем
  </a></li><li class="tm-separated-list__item"><a href="https://habr.com/ru/hub/refactoring/" class="tm-hubs-list__link">
    Проектирование и рефакторинг
  </a></li></ul></div></div></article></div> <!----></div> <div class="tm-article-sticky-panel"><div class="tm-data-icons tm-article-sticky-panel__icons"><div class="tm-article-rating tm-data-icons__item"><div class="tm-votes-meter tm-article-rating__votes-switcher"><svg height="24" width="24" class="tm-svg-img tm-votes-meter__icon tm-votes-meter__icon_appearance-article"><title>Всего голосов 88: ↑85 и ↓3</title> <use xlink:href="/img/megazord-v25.4b679db1.svg#counter-rating"></use></svg> <span title="Всего голосов 88: ↑85 и ↓3" class="tm-votes-meter__value tm-votes-meter__value_positive tm-votes-meter__value_appearance-article tm-votes-meter__value_rating">+82</span></div> <DIV class="v-portal" style="display:none;"></DIV></div> <!----> <span title="Количество просмотров" class="tm-icon-counter tm-data-icons__item"><svg height="24" width="24" class="tm-svg-img tm-icon-counter__icon"><title>Просмотры</title> <use xlink:href="/img/megazord-v25.4b679db1.svg#counter-views"></use></svg> <span class="tm-icon-counter__value">551K</span></span> <button title="Добавить в закладки" type="button" class="bookmarks-button tm-data-icons__item"><span title="Добавить в закладки" class="tm-svg-icon__wrapper bookmarks-button__icon"><svg height="24" width="24" class="tm-svg-img tm-svg-icon"><title>Добавить в закладки</title> <use xlink:href="/img/megazord-v25.4b679db1.svg#counter-favorite"></use></svg></span> <span title="Количество пользователей, добавивших публикацию в закладки" class="bookmarks-button__counter">
    2872
  </span></button> <!----> <div title="Поделиться" class="tm-sharing tm-data-icons__item"><button type="button" class="tm-sharing__button"><svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" class="tm-sharing__icon"><path fill="currentColor" d="M13.8 13.8V18l7.2-6.6L13.8 5v3.9C5 8.9 3 18.6 3 18.6c2.5-4.4 6-4.8 10.8-4.8z"></path></svg></button> <DIV class="v-portal" style="display:none;"></DIV></div> <DIV class="v-portal" style="display:none;"></DIV></div> </div></div> <DIV class="v-portal" style="display:none;"></DIV> <div class="tm-article-presenter__footer"><div class="tm-article-blocks"><!----> <section class="tm-block tm-block_spacing-bottom"><!----> <div class="tm-block__body tm-block__body_variant-balanced"><div class="tm-article-author"> <div class="tm-user-card tm-article-author__user-card tm-user-card_variant-article"><div class="tm-user-card__info-container"><div class="tm-user-card__header"><div class="tm-user-card__header-data"><a href="https://habr.com/ru/users/cobiot/" class="tm-user-card__userpic tm-user-card__userpic_size-40"><div class="tm-entity-image"><svg class="tm-svg-img tm-image-placeholder tm-image-placeholder_blue"><!----> <use xlink:href="/img/megazord-v25.4b679db1.svg#placeholder-user"></use></svg></div></a> <div class="tm-user-card__meta"><div title=" 105 голосов " class="tm-karma tm-user-card__karma"><div class="tm-karma__votes tm-karma__votes_positive">
    97
  </div> <div class="tm-karma__text">
    Карма
  </div></div> <div title="Рейтинг пользователя" class="tm-rating tm-user-card__rating"><div class="tm-rating__header"> <div class="tm-rating__counter">0</div></div> <div class="tm-rating__text">
    Рейтинг
  </div></div></div></div></div> <div class="tm-user-card__info tm-user-card__info_variant-article"><div class="tm-user-card__title tm-user-card__title_variant-article"><!----> <a href="https://habr.com/ru/users/cobiot/" class="tm-user-card__nickname tm-user-card__nickname_variant-article">
          @cobiot
        </a> <!----></div> <p class="tm-user-card__short-info tm-user-card__short-info_variant-article">Пользователь</p></div></div> <div class="tm-user-card__buttons tm-user-card__buttons_variant-article"><!----> <!----> <!----> <!----> <!----></div></div> <!----></div> <DIV class="v-portal" style="display:none;"></DIV></div> <!----></section> <div class="tm-article-blocks__comments"><div class="tm-article-page-comments"><div class="tm-article-comments-counter-link tm-article-comments-counter-button"><a href="https://habr.com/ru/post/276593/comments/" class="tm-article-comments-counter-link__link tm-article-comments-counter-link__link_button-style"><svg height="24" width="24" class="tm-svg-img tm-article-comments-counter-link__icon tm-article-comments-counter-link__icon_contrasted"><title>Комментарии</title> <use xlink:href="/img/megazord-v25.4b679db1.svg#counter-comments"></use></svg> <span class="tm-article-comments-counter-link__value tm-article-comments-counter-link__value_contrasted">
       Комментарии 44 
    </span></a> <!----></div></div></div> <div class="tm-ad-banner__container tm-page-article__banner"><!----> <div id="articleBottomBanner1725" class="tm-ad-banner"></div></div> <!----> <!----> <!----> <!----> </div></div></div></div></div> <div class="tm-page__sidebar"><div class="tm-layout-sidebar"><div class="tm-layout-sidebar__ads tm-layout-sidebar__ads_initial"><div class="tm-ad-banner__container tm-layout-sidebar__banner"><!----> <div id="sidebarBanner1726" class="tm-ad-banner"></div></div></div> <div class="tm-sexy-sidebar tm-sexy-sidebar_initial" style="margin-top:0px;"><!----> <section data-async-called="true" class="tm-block tm-block_spacing-bottom"><header class="tm-block__header"><h2 class="tm-block__title">Работа</h2> <!----></header> <div class="tm-block__body"><div class="tm-vacancies-block__item"><a href="https://career.habr.com/vacancies/sistemnij_analitik" target="_blank" class="tm-vacancies-block__vacancy-title">
        Cистемный аналитик
      </a> <div class="tm-vacancies-block__vacancies-count">
        415
    вакансий
      </div></div></div> <footer class="tm-block__footer"><a href="https://career.habr.com/catalog" class="tm-block-extralink">
      Все вакансии
    </a></footer></section></div></div></div></div></div></div></main> <!----></div> <div class="tm-footer-menu"><div class="tm-page-width"><div class="tm-footer-menu__container"><div class="tm-footer-menu__block"><h3 class="tm-footer-menu__block-title">
          Ваш аккаунт
        </h3> <div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><li class="tm-footer-menu__list-item"><a href="https://habr.com/kek/v1/auth/habrahabr/?back=/ru/post/276593/&amp;hl=ru" rel="nofollow" target="_self">
                Войти
              </a></li><li class="tm-footer-menu__list-item"><a href="https://habr.com/kek/v1/auth/habrahabr-register/?back=/ru/post/276593/&amp;hl=ru" rel="nofollow" target="_self">
                Регистрация
              </a></li></ul></div></div><div class="tm-footer-menu__block"><h3 class="tm-footer-menu__block-title">
          Разделы
        </h3> <div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><li class="tm-footer-menu__list-item"><a href="https://habr.com/ru/" class="footer-menu__item-link router-link-active">
                Публикации
              </a></li><li class="tm-footer-menu__list-item"><a href="https://habr.com/ru/news/" class="footer-menu__item-link">
                Новости
              </a></li><li class="tm-footer-menu__list-item"><a href="https://habr.com/ru/hubs/" class="footer-menu__item-link">
                Хабы
              </a></li><li class="tm-footer-menu__list-item"><a href="https://habr.com/ru/companies/" class="footer-menu__item-link">
                Компании
              </a></li><li class="tm-footer-menu__list-item"><a href="https://habr.com/ru/users/" class="footer-menu__item-link">
                Авторы
              </a></li><li class="tm-footer-menu__list-item"><a href="https://habr.com/ru/sandbox/" class="footer-menu__item-link">
                Песочница
              </a></li></ul></div></div><div class="tm-footer-menu__block"><h3 class="tm-footer-menu__block-title">
          Информация
        </h3> <div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><li class="tm-footer-menu__list-item"><a href="https://habr.com/ru/docs/help/" class="footer-menu__item-link">
                Устройство сайта
              </a></li><li class="tm-footer-menu__list-item"><a href="https://habr.com/ru/docs/authors/codex/" class="footer-menu__item-link">
                Для авторов
              </a></li><li class="tm-footer-menu__list-item"><a href="https://habr.com/ru/docs/companies/corpblogs/" class="footer-menu__item-link">
                Для компаний
              </a></li><li class="tm-footer-menu__list-item"><a href="https://habr.com/ru/docs/docs/transparency/" class="footer-menu__item-link">
                Документы
              </a></li><li class="tm-footer-menu__list-item"><a href="https://account.habr.com/info/agreement" target="_blank">
                Соглашение
              </a></li><li class="tm-footer-menu__list-item"><a href="https://account.habr.com/info/confidential/" target="_blank">
                Конфиденциальность
              </a></li></ul></div></div><div class="tm-footer-menu__block"><h3 class="tm-footer-menu__block-title">
          Услуги
        </h3> <div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><li class="tm-footer-menu__list-item"><a href="https://docs.google.com/presentation/d/e/2PACX-1vQLwRfQmXibiUlWaRg-BAc38s7oM3lJiaPju7qmdJsp8ysIvZ_G-Npem0njJLMozE2bPHMpDqiI5hhy/pub?start=false&amp;loop=false&amp;delayms=60000&amp;slide=id.g91a03369cd_4_297" target="_blank">
                Реклама
              </a></li><li class="tm-footer-menu__list-item"><a href="https://habrastorage.org/storage/stuff/habr/service_price.pdf" target="_blank">
                Тарифы
              </a></li><li class="tm-footer-menu__list-item"><a href="https://docs.google.com/presentation/d/e/2PACX-1vQJJds8-Di7BQSP_guHxICN7woVYoN5NP_22ra-BIo4bqnTT9FR6fB-Ku2P0AoRpX0Ds-LRkDeAoD8F/pub?start=false&amp;loop=false&amp;delayms=60000" target="_blank">
                Контент
              </a></li><li class="tm-footer-menu__list-item"><a href="https://tmtm.timepad.ru/" target="_blank">
                Семинары
              </a></li><li class="tm-footer-menu__list-item"><a href="https://habr.com/ru/megaprojects/" class="footer-menu__item-link">
                Мегапроекты
              </a></li></ul></div></div></div></div></div> <div class="tm-footer"><div class="tm-page-width"><div class="tm-footer__container"><!----> <div class="tm-footer__social"><a href="https://www.facebook.com/habrahabr.ru" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Facebook</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-facebook"></use></svg></a><a href="https://twitter.com/habr_com" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Twitter</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-twitter"></use></svg></a><a href="https://vk.com/habr" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>VK</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-vkontakte"></use></svg></a><a href="https://telegram.me/habr_com" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Telegram</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-telegram"></use></svg></a><a href="https://www.youtube.com/channel/UCd_sTwKqVrweTt4oAKY5y4w" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Youtube</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-youtube"></use></svg></a><a href="https://zen.yandex.ru/habr" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Яндекс Дзен</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-zen"></use></svg></a></div> <DIV class="v-portal" style="display:none;"></DIV> <button class="tm-footer__link"><!---->
        Настройка языка
      </button> <a href="https://habr.com/ru/about" class="tm-footer__link">
        О сайте
      </a> <a href="https://habr.com/ru/feedback/" class="tm-footer__link">
        Техническая поддержка
      </a> <!----> <a href="https://habr.com/berserk-mode-nope" class="tm-footer__link">
        Вернуться на старую версию
      </a> <div class="tm-footer-copyright"><span class="tm-copyright"><span class="tm-copyright__years">© 2006–2022 </span> <span class="tm-copyright__name">«<a href="https://company.habr.com/" rel="noopener" target="_blank" class="tm-copyright__link">Habr</a>»</span></span></div></div></div></div> <!----> <!----></div> <div class="vue-portal-target"></div></div>
<script>window.__INITIAL_STATE__={"adblock":{"hasAcceptableAdsFilter":false,"hasAdblock":false},"articlesList":{"articlesList":{"276593":{"id":"276593","timePublished":"2016-02-04T13:18:04+00:00","isCorporative":false,"lang":"ru","titleHtml":"Создание архитектуры программы или как проектировать табуретку","leadData":{"textHtml":"Взявшись за написание небольшого, но реального и растущего проекта, мы «на собственной шкуре» убедились, насколько важно то, чтобы программа не только хорошо работала, но и была хорошо организована. Не верьте, что продуманная архитектура нужна только большим проектам (просто для больших проектов «смертельность» отсутствия архитектуры очевидна). Сложность, как правило, растет гораздо быстрее размеров программы. И если не позаботиться об этом заранее, то довольно быстро наступает момент, когда ты перестаешь ее контролировать. Правильная архитектура экономит очень много сил, времени и денег. А нередко вообще определяет то, выживет ваш проект или нет. И даже если речь идет всего лишь о «построении табуретки» все равно вначале очень полезно ее спроектировать.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nК моему удивлению оказалось, что на вроде бы актуальный вопрос: «Как построить хорошую\u002Fкрасивую архитектуру ПО?» — не так легко найти ответ. Не смотря на то, что есть много книг и статей, посвященных и шаблонам проектирования и принципам проектирования, например, принципам SOLID (кратко описаны \u003Ca href=\"http:\u002F\u002Finfo.javarush.ru\u002Ftranslation\u002F2013\u002F08\u002F06\u002F%D0%9F%D1%8F%D1%82%D1%8C-%D0%BE%D1%81%D0%BD%D0%BE%D0%B2%D0%BD%D1%8B%D1%85-%D0%BF%D1%80%D0%B8%D0%BD%D1%86%D0%B8%D0%BF%D0%BE%D0%B2-%D0%B4%D0%B8%D0%B7%D0%B0%D0%B9%D0%BD%D0%B0-%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D0%BE%D0%B2-S-O-L-I-D-%D0%B2-Java.html\"\u003Eтут\u003C\u002Fa\u003E, подробно и с примерами можно посмотреть \u003Ca href=\"http:\u002F\u002Figor.quatrocode.com\u002F2008\u002F09\u002Fsolid-top-5.html\"\u003Eтут\u003C\u002Fa\u003E, \u003Ca href=\"http:\u002F\u002Fblog.byndyu.ru\u002F2009\u002F10\u002Fsolid.html\"\u003Eтут\u003C\u002Fa\u003E и \u003Ca href=\"http:\u002F\u002Fsergeyteplyakov.blogspot.com.es\u002F2014\u002F10\u002Fsolid.html\"\u003Eтут\u003C\u002Fa\u003E) и тому, как правильно оформлять код, все равно оставалось чувство, что чего-то важного не хватает. Это было похоже на то, как если бы вам дали множество замечательных и полезных инструментов, но забыли главное — объяснить, а как же «проектировать табуретку».\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nХотелось разобраться, что вообще в себя включает процесс создания архитектуры программы, какие задачи при этом решаются, какие критерии используются (чтобы правила и принципы перестали быть всего лишь догмами, а стали бы понятны их логика и назначение). Тогда будет понятнее и какие инструменты лучше использовать в том или ином случае.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nДанная статья является попыткой ответить на эти вопросы хотя бы в первом приближении.","imageUrl":null,"buttonTextHtml":"Читать дальше &rarr;","image":null},"editorVersion":"1.0","postType":"article","postLabels":[{"type":"sandbox","data":null}],"author":{"scoreStats":{"score":97,"votesCount":105},"rating":0,"relatedData":null,"contacts":[],"authorContacts":[],"paymentDetails":{"paymentYandexMoney":null,"paymentPayPalMe":null,"paymentWebmoney":null},"id":"1160794","alias":"cobiot","fullname":null,"avatarUrl":null,"speciality":null},"statistics":{"commentsCount":44,"favoritesCount":2872,"readingCount":550954,"score":82,"votesCount":88},"hubs":[{"relatedData":null,"id":"91","alias":"webdev","type":"collective","title":"Разработка веб-сайтов","titleHtml":"Разработка веб-сайтов","isProfiled":true},{"relatedData":null,"id":"397","alias":"analysis_design","type":"collective","title":"Анализ и проектирование систем","titleHtml":"Анализ и проектирование систем","isProfiled":true},{"relatedData":null,"id":"7504","alias":"refactoring","type":"collective","title":"Проектирование и рефакторинг","titleHtml":"Проектирование и рефакторинг","isProfiled":true}],"flows":[{"id":"1","alias":"develop","title":"Разработка"}],"relatedData":null,"textHtml":"\u003Cdiv xmlns=\"http:\u002F\u002Fwww.w3.org\u002F1999\u002Fxhtml\"\u003EВзявшись за написание небольшого, но реального и растущего проекта, мы «на собственной шкуре» убедились, насколько важно то, чтобы программа не только хорошо работала, но и была хорошо организована. Не верьте, что продуманная архитектура нужна только большим проектам (просто для больших проектов «смертельность» отсутствия архитектуры очевидна). Сложность, как правило, растет гораздо быстрее размеров программы. И если не позаботиться об этом заранее, то довольно быстро наступает момент, когда ты перестаешь ее контролировать. Правильная архитектура экономит очень много сил, времени и денег. А нередко вообще определяет то, выживет ваш проект или нет. И даже если речь идет всего лишь о «построении табуретки» все равно вначале очень полезно ее спроектировать.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nК моему удивлению оказалось, что на вроде бы актуальный вопрос: «Как построить хорошую\u002Fкрасивую архитектуру ПО?» — не так легко найти ответ. Не смотря на то, что есть много книг и статей, посвященных и шаблонам проектирования и принципам проектирования, например, принципам SOLID (кратко описаны \u003Ca href=\"http:\u002F\u002Finfo.javarush.ru\u002Ftranslation\u002F2013\u002F08\u002F06\u002F%D0%9F%D1%8F%D1%82%D1%8C-%D0%BE%D1%81%D0%BD%D0%BE%D0%B2%D0%BD%D1%8B%D1%85-%D0%BF%D1%80%D0%B8%D0%BD%D1%86%D0%B8%D0%BF%D0%BE%D0%B2-%D0%B4%D0%B8%D0%B7%D0%B0%D0%B9%D0%BD%D0%B0-%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D0%BE%D0%B2-S-O-L-I-D-%D0%B2-Java.html\"\u003Eтут\u003C\u002Fa\u003E, подробно и с примерами можно посмотреть \u003Ca href=\"http:\u002F\u002Figor.quatrocode.com\u002F2008\u002F09\u002Fsolid-top-5.html\"\u003Eтут\u003C\u002Fa\u003E, \u003Ca href=\"http:\u002F\u002Fblog.byndyu.ru\u002F2009\u002F10\u002Fsolid.html\"\u003Eтут\u003C\u002Fa\u003E и \u003Ca href=\"http:\u002F\u002Fsergeyteplyakov.blogspot.com.es\u002F2014\u002F10\u002Fsolid.html\"\u003Eтут\u003C\u002Fa\u003E) и тому, как правильно оформлять код, все равно оставалось чувство, что чего-то важного не хватает. Это было похоже на то, как если бы вам дали множество замечательных и полезных инструментов, но забыли главное — объяснить, а как же «проектировать табуретку».\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nХотелось разобраться, что вообще в себя включает процесс создания архитектуры программы, какие задачи при этом решаются, какие критерии используются (чтобы правила и принципы перестали быть всего лишь догмами, а стали бы понятны их логика и назначение). Тогда будет понятнее и какие инструменты лучше использовать в том или ином случае.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nДанная статья является попыткой ответить на эти вопросы хотя бы в первом приближении.\u003Ca name=\"habracut\"\u003E\u003C\u002Fa\u003E Материал собирался для себя, но, может, он окажется полезен кому-то еще. Мне данная работа позволила не только узнать много нового, но и в ином контексте взглянуть на кажущиеся уже почти банальными основные принципы ООП и по настоящему оценить их важность.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nИнформации оказалось довольно много, поэтому приведены лишь общая идея и краткие описания, дающие начальное представление о теме и понимание, где искать дальше.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ch1\u003EКритерии хорошей архитектуры\u003C\u002Fh1\u003E\u003Cbr\u002F\u003E\r\nВообще говоря, не существует общепринятого термина «архитектура программного обеспечения». Тем не менее, когда дело касается практики, то для большинства разработчиков и так понятно какой код является хорошим, а какой плохим. \u003Cem\u003EХорошая архитектура\u003C\u002Fem\u003E это прежде всего \u003Cem\u003Eвыгодная\u003C\u002Fem\u003E архитектура, делающая процесс разработки и сопровождения программы более простым и эффективным. Программу с хорошей архитектурой легче расширять и изменять, а также тестировать, отлаживать и понимать. То есть, на самом деле можно сформулировать список вполне разумных и универсальных критериев:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cstrong\u003EЭффективность системы\u003C\u002Fstrong\u003E. В первую очередь программа, конечно же, должна решать поставленные задачи и хорошо выполнять свои функции, причем в различных условиях. Сюда можно отнести такие характеристики, как надежность, безопасность, производительность, способность справляться с увеличением нагрузки (масштабируемость) и т.п.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cstrong\u003EГибкость системы.\u003C\u002Fstrong\u003E Любое приложение приходится менять со временем — изменяются требования, добавляются новые. Чем быстрее и удобнее можно внести изменения в существующий функционал, чем меньше проблем и ошибок это вызовет — тем \u003Cem\u003Eгибче\u003C\u002Fem\u003E и конкурентоспособнее система. Поэтому в процессе разработки старайтесь оценивать то, что получается, на предмет того, как вам это потом, возможно, придется менять. Спросите у себя: «А что будет, если текущее архитектурное решение окажется неверным?», «Какое количество кода подвергнется при этом изменениям?». Изменение одного фрагмента системы не должно влиять на ее другие фрагменты. По возможности, архитектурные решения не должны «вырубаться в камне», и последствия архитектурных ошибок должны быть в разумной степени ограничены. \"\u003Cem\u003EХорошая архитектура позволяет ОТКЛАДЫВАТЬ принятие ключевых решений\u003C\u002Fem\u003E\" (Боб Мартин) и минимизирует «цену» ошибок.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cstrong\u003EРасширяемость системы\u003C\u002Fstrong\u003E. Возможность добавлять в систему новые сущности и функции, не нарушая ее основной структуры. На начальном этапе в систему имеет смысл закладывать лишь основной и самый необходимый функционал (принцип YAGNI — you ain’t gonna need it, «Вам это не понадобится») Но при этом архитектура должна позволять легко наращивать дополнительный функционал по мере необходимости. Причем так, чтобы внесение \u003Cem\u003Eнаиболее вероятных\u003C\u002Fem\u003E изменений требовало \u003Cem\u003Eнаименьших усилии\u003C\u002Fem\u003E.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nТребование, чтобы архитектура системы обладала \u003Cem\u003Eгибкостью\u003C\u002Fem\u003E и \u003Cem\u003Eрасширяемостью\u003C\u002Fem\u003E (то есть была способна к изменениям и эволюции) является настолько важным, что оно даже сформулировано в виде отдельного принципа — «\u003Cstrong\u003EПринципа открытости\u002Fзакрытости\u003C\u002Fstrong\u003E» (\u003Cstrong\u003EOpen-Closed Principle\u003C\u002Fstrong\u003E — второй из пяти принципов SOLID): \u003Cem\u003EПрограммные сущности (классы, модули, функции и т.п.) должны быть открытыми для расширения, но закрытыми для модификации.\u003C\u002Fem\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nИными словами: \u003Cem\u003EДолжна быть возможность расширить\u002Fизменить поведение системы без изменения\u002Fпереписывания уже существующих частей системы.\u003C\u002Fem\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nЭто означает, что приложение следует проектировать так, чтобы изменение его поведения и добавление новой функциональности достигалось бы за счет написания нового кода (расширения), и при этом не приходилось бы менять уже существующий код. В таком случае появление новых требований не повлечет за собой модификацию существующей логики, а сможет быть реализовано прежде всего за счет ее расширения. Именно этот принцип является основой «плагинной архитектуры» (Plugin Architecture). О том, за счет каких техник это может быть достигнуто, будет рассказано дальше.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cstrong\u003EМасштабируемость процесса разработки\u003C\u002Fstrong\u003E. Возможность сократить срок разработки за счёт добавления к проекту новых людей. Архитектура должна позволять распараллелить процесс разработки, так чтобы множество людей могли работать над программой одновременно.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cstrong\u003EТестируемость\u003C\u002Fstrong\u003E. Код, который легче тестировать, будет содержать меньше ошибок и надежнее работать. Но тесты не только улучшают качество кода. Многие разработчики приходят к выводу, что требование «хорошей тестируемости» является также направляющей силой, автоматически ведущей к хорошему дизайну, и одновременно одним из важнейших критериев, позволяющих оценить его качество: \"\u003Cem\u003EИспользуйте принцип «тестируемости» класса в качестве «лакмусовой бумажки» хорошего дизайна класса. Даже если вы не напишите ни строчки тестового кода, ответ на этот вопрос в 90% случаев поможет понять, насколько все «хорошо» или «плохо» с его дизайном\u003C\u002Fem\u003E\" (\u003Ca href=\"http:\u002F\u002Fhabrahabr.ru\u002Fpost\u002F133287\u002F\"\u003EИдеальная архитектура\u003C\u002Fa\u003E).\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nСуществует целая методология разработки программ на основе тестов, которая так и называется — \u003Cem\u003EРазработка через тестирование\u003C\u002Fem\u003E (\u003Cem\u003ETest-Driven Development, TDD\u003C\u002Fem\u003E).\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cstrong\u003EВозможность повторного использования\u003C\u002Fstrong\u003E. Систему желательно проектировать так, чтобы ее фрагменты можно было повторно использовать в других системах.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cstrong\u003EХорошо структурированный, читаемый и понятный код. Сопровождаемость\u003C\u002Fstrong\u003E. Над программой, как правило, работает множество людей — одни уходят, приходят новые. После написания сопровождать программу тоже, как правило, приходится людям, не участвовавшем в ее разработке. Поэтому хорошая архитектура должна давать возможность относительно легко и быстро разобраться в системе новым людям. Проект должен быть хорошо структурирован, не содержать дублирования, иметь хорошо оформленный код и желательно документацию. И по возможности в системе лучше применять стандартные, общепринятые решения привычные для программистов. Чем экзотичнее система, тем сложнее ее понять другим (\u003Cem\u003EПринцип наименьшего удивления — Principle of least astonishment\u003C\u002Fem\u003E. Обычно, он используется в отношении пользовательского интерфейса, но применим и к написанию кода).\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nНу и для полноты \u003Ca href=\"http:\u002F\u002Fsergeyteplyakov.blogspot.com.es\u002F2013\u002F01\u002Fblog-post_29.html\"\u003Eкритерии плохого дизайна\u003C\u002Fa\u003E:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Col\u003E\r\n\u003Cli\u003EЕго тяжело изменить, поскольку любое изменение влияет на слишком большое количество других частей системы. (\u003Cstrong\u003EЖесткость, Rigidity\u003C\u002Fstrong\u003E).\u003C\u002Fli\u003E\r\n\u003Cli\u003EПри внесении изменений неожиданно ломаются другие части системы. (\u003Cstrong\u003EХрупкость, Fragility\u003C\u002Fstrong\u003E).\u003C\u002Fli\u003E\r\n\u003Cli\u003EКод тяжело использовать повторно в другом приложении, поскольку его слишком тяжело «выпутать» из текущего приложения. (\u003Cstrong\u003EНеподвижность, Immobility\u003C\u002Fstrong\u003E).\u003C\u002Fli\u003E\r\n\u003C\u002Fol\u003E\u003Cbr\u002F\u003E\r\n\u003Ch1\u003EМодульная архитектура. Декомпозиция как основа\u003C\u002Fh1\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw1560\u002Ffiles\u002F965\u002F721\u002F560\u002F9657215601f14952bb35870f5caf783d.png\" alt=\"software architecture\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Ffiles\u002F965\u002F721\u002F560\u002F9657215601f14952bb35870f5caf783d.png\"\u002F\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nНе смотря на разнообразие критериев, все же главной при разработке больших систем считается задача снижения сложности. А для снижения сложности ничего, кроме деления на части, пока не придумано. Иногда это называют принципом «разделяй и властвуй» (divide et impera), но по сути речь идет об \u003Cstrong\u003Eиерархической декомпозиции\u003C\u002Fstrong\u003E. Сложная система должна строится из небольшого количества более простых подсистем, каждая из которых, в свою очередь, строится из частей меньшего размера, и т.д., до тех пор, пока самые небольшие части не будут достаточно просты для непосредственного понимания и создания.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nУдача заключается в том, что данное решение является не только единственно известным, но и универсальным. Помимо снижения сложности, оно одновременно обеспечивает гибкость системы, дает хорошие возможности для масштабирования, а также позволяет повышать устойчивость за счет дублирования критически важных частей.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nСоответственно, когда речь идет о построении архитектуры программы, создании ее структуры, под этим, главным образом, подразумевается декомпозиция программы на подсистемы (функциональные модули, сервисы, слои, подпрограммы) и организация их взаимодействия друг с другом и внешним миром. Причем, чем более независимы подсистемы, тем безопаснее сосредоточиться на разработке каждой из них в отдельности в конкретный момент времени и при этом не заботиться обо всех остальных частях.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nВ этом случае программа из «спагетти-кода» превращается в конструктор, состоящий из набора модулей\u002Fподпрограмм, взаимодействующих друг с другом по хорошо определенным и простым правилам, что собственно и позволяет контролировать ее сложность, а также дает возможность получить все те преимущества, которые обычно соотносятся с понятием хорошая архитектура:\u003Cbr\u002F\u003E\r\n\u003Cul\u003E\r\n\u003Cli\u003E\u003Cstrong\u003EМасштабируемость (Scalability)\u003C\u002Fstrong\u003E\u003Cbr\u002F\u003E\r\nвозможность расширять систему и увеличивать ее производительность, за счет добавления новых модулей.\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Cstrong\u003EРемонтопригодность (Maintainability)\u003C\u002Fstrong\u003E\u003Cbr\u002F\u003E\r\nизменение одного модуля не требует изменения других модулей\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Cstrong\u003EЗаменимость модулей (Swappability)\u003C\u002Fstrong\u003E\u003Cbr\u002F\u003E\r\nмодуль легко заменить на другой\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Cstrong\u003EВозможность тестирования (Unit Testing)\u003C\u002Fstrong\u003E\u003Cbr\u002F\u003E\r\nмодуль можно отсоединить от всех остальных и протестировать \u002F починить\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Cstrong\u003EПереиспользование (Reusability)\u003C\u002Fstrong\u003E\u003Cbr\u002F\u003E\r\nмодуль может быть переиспользован в других программах и другом окружении\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Cstrong\u003EСопровождаемость (Maintenance)\u003C\u002Fstrong\u003E\u003Cbr\u002F\u003E\r\nразбитую на модули программу легче понимать и сопровождать\u003C\u002Fli\u003E\r\n\u003C\u002Ful\u003E\u003Cbr\u002F\u003E\r\nМожно сказать, что в разбиении сложной проблемы на простые фрагменты и заключается цель всех методик проектирования. А термином «архитектура», в большинстве случаев, просто обозначают результат такого деления, плюс \"\u003Cem\u003Eнекие конструктивные решения, которые после их принятия с трудом поддаются изменению\u003C\u002Fem\u003E\" (Мартин Фаулер «Архитектура корпоративных программных приложений»). Поэтому большинство определений в той или иной форме сводятся к следующему:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\"\u003Cem\u003EАрхитектура идентифицирует главные компоненты системы и способы их взаимодействия. Также это выбор таких решений, которые интерпретируются как основополагающие и не подлежащие изменению в будущем.\u003C\u002Fem\u003E\"\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\"\u003Cem\u003EАрхитектура — это \u003Cstrong\u003Eорганизация системы\u003C\u002Fstrong\u003E, воплощенная в ее \u003Cstrong\u003Eкомпонентах\u003C\u002Fstrong\u003E, их \u003Cstrong\u003Eотношениях\u003C\u002Fstrong\u003E между собой и с \u003Cstrong\u003Eокружением\u003C\u002Fstrong\u003E.\u003C\u002Fem\u003E\u003Cbr\u002F\u003E\r\n\u003Cem\u003E\u003Cstrong\u003EСистема\u003C\u002Fstrong\u003E — это набор компонентов, объединенных для выполнения определенной функции.\u003C\u002Fem\u003E\"\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nТаким образом, хорошая архитектура это, прежде всего, \u003Cstrong\u003Eмодульная\u003C\u002Fstrong\u003E\u002F\u003Cstrong\u003Eблочная архитектура\u003C\u002Fstrong\u003E. Чтобы получить хорошую архитектуру надо знать, как правильно делать декомпозицию системы. А значит, необходимо понимать — какая декомпозиция считается «правильной» и каким образом ее лучше проводить?\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ch1\u003E«Правильная» декомпозиция\u003C\u002Fh1\u003E\u003Cbr\u002F\u003E\r\n\u003Cstrong\u003E1. Иерархическая\u003C\u002Fstrong\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nНе стоит сходу рубить приложение на сотни классов. Как уже говорилось, декомпозицию надо проводить \u003Cstrong\u003Eиерархически\u003C\u002Fstrong\u003E — сначала систему разбивают на крупные функциональные модули\u002Fподсистемы, описывающие ее работу в самом общем виде. Затем, полученные модули, анализируются более детально и, в свою очередь, делятся на под-модули либо на объекты.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nПеред тем как выделять объекты разделите систему на основные смысловые блоки хотя бы мысленно. Для небольших приложений двух уровней иерархии часто оказывается вполне достаточно — система вначале делится на подсистемы\u002Fпакеты, а пакеты делятся на классы.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw1560\u002Ffiles\u002F8d8\u002Fe4d\u002F84b\u002F8d8e4d84b56744c3911775106cd5a28d.png\" alt=\"software decomposition\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Ffiles\u002F8d8\u002Fe4d\u002F84b\u002F8d8e4d84b56744c3911775106cd5a28d.png\"\u002F\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nЭта мысль, при всей своей очевидности, не так банальна как кажется. Например, в чем заключается суть такого распространенного «архитектурного шаблона» как Модель-Вид-Контроллер (MVC)? Всего навсего в отделении \u003Cstrong\u003Eпредставления\u003C\u002Fstrong\u003E от \u003Cstrong\u003Eбизнес-логики\u003C\u002Fstrong\u003E, то есть в том, что любое пользовательское приложение вначале делится на два модуля — один из которых отвечает за реализацию собственно самой бизнес логики (Модель), а второй — за взаимодействие с пользователем (Пользовательский Интерфейс или Представление). Затем, для того чтобы эти модули могли разрабатываться независимо, связь между ними ослабляется с помощью паттерна «Наблюдатель» (подробно о способах ослабления связей будет рассказано дальше) и мы фактически получаем один из самых мощных и востребованных «шаблонов», которые используются в настоящее время.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nТипичными модулями первого уровня (полученными в результате первого деления системы на наиболее крупные составные части) как раз и являются — \u003Cem\u003E«бизнес-логика», «пользовательский интерфейс», «доступ к БД», «связь с конкретным оборудованием или ОС».\u003C\u002Fem\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nДля обозримости на каждом иерархическом уровне рекомендуют выделять от 2 до 7 модулей.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cstrong\u003E2. Функциональная\u003C\u002Fstrong\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nДеление на модули\u002Fподсистемы лучше всего производить исходя из тех задач, которые решает система. Основная задача разбивается на составляющие ее подзадачи, которые могут решаться\u002Fвыполняться независимо друг от друга. Каждый модуль должен отвечать за решение какой-то подзадачи и выполнять соответствующую ей \u003Cstrong\u003Eфункцию\u003C\u002Fstrong\u003E. Помимо функционального назначения модуль характеризуется также набором данных, необходимых ему для выполнения его функции, то есть:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cem\u003EМодуль\u003C\u002Fem\u003E = \u003Cem\u003EФункция\u003C\u002Fem\u003E + \u003Cem\u003EДанные\u003C\u002Fem\u003E, необходимые для ее выполнения.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nПричем желательно, чтобы свою функцию модуль мог выполнить самостоятельно, без помощи остальных модулей, лишь на основе своих входящих данных.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cem\u003EМодуль — это не произвольный кусок кода, а отдельная функционально осмысленная и законченная программная единица\u003C\u002Fem\u003E (\u003Cem\u003Eподпрограмма), которая обеспечивает решение некоторой задачи и в идеале может работать самостоятельно или в другом окружении и быть переиспользуемой. Модуль должен быть некой \"целостностью, способной к относительной самостоятельности в поведении и развитии\" (Кристофер Александер).\u003C\u002Fem\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nТаким образом, грамотная декомпозиция основывается, прежде всего, на анализе \u003Cstrong\u003Eфункций системы\u003C\u002Fstrong\u003E и необходимых для выполнения этих функций данных.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cstrong\u003E3. High Cohesion + Low Coupling\u003C\u002Fstrong\u003E\u003Cbr\u002F\u003E\r\nСамым же главным критерием качества декомпозиции является то, насколько модули сфокусированы на решение своих задач и независимы. Обычно это формулируют следующим образом: \"\u003Cem\u003EМодули, полученные в результате декомпозиции, должны быть максимально сопряженны внутри (high internal cohesion) и минимально связанны друг с другом (low external coupling).\u003C\u002Fem\u003E\"\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cul\u003E\r\n\u003Cli\u003E\u003Cstrong\u003EHigh Cohesion\u003C\u002Fstrong\u003E, высокая сопряженность или «сплоченность» внутри модуля, говорит о том, модуль сфокусирован на решении одной узкой проблемы, а не занимается выполнением разнородных функций или несвязанных между собой обязанностей. (\u003Cem\u003EСопряженность\u003C\u002Fem\u003E — \u003Cem\u003Ecohesion\u003C\u002Fem\u003E, характеризует степень, в которой задачи, выполняемые модулем, связаны друг с другом )\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nСледствием High Cohesion является \u003Cstrong\u003Eпринцип единственной ответственности\u003C\u002Fstrong\u003E (\u003Cstrong\u003ESingle Responsibility Principle\u003C\u002Fstrong\u003E — первый из пяти принципов SOLID), согласно которому любой объект\u002Fмодуль должен иметь лишь одну обязанность и соответственно не должно быть больше одной причины для его изменения.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Cstrong\u003ELow Coupling\u003C\u002Fstrong\u003E, слабая связанность, означает что модули, на которые разбивается система, должны быть, по возможности, независимы или \u003Cem\u003Eслабо связанны\u003C\u002Fem\u003E друг с другом. Они должны иметь возможность взаимодействовать, но при этом \u003Cem\u003Eкак можно меньше знать друг о друге\u003C\u002Fem\u003E (\u003Cstrong\u003Eпринцип минимального знания\u003C\u002Fstrong\u003E).\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nЭто значит, что при правильном проектировании, при изменении одного модуля, не придется править другие или эти изменения будут минимальными. Чем слабее связанность, тем легче писать\u002Fпонимать\u002Fрасширять\u002Fчинить программу.\u003C\u002Fli\u003E\r\n\u003C\u002Ful\u003E\u003Cbr\u002F\u003E\r\nСчитается, что хорошо спроектированные модули должны обладать следующими свойствами:\u003Cbr\u002F\u003E\r\n\u003Cul\u003E\r\n\u003Cli\u003E\u003Cstrong\u003Eфункциональная целостность и завершенность\u003C\u002Fstrong\u003E — каждый модуль реализует одну функцию, но реализует хорошо и полностью; модуль самостоятельно (без помощи дополнительных средств) выполняет полный набор операций для реализации своей функции.\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Cstrong\u003Eодин вход и один выход\u003C\u002Fstrong\u003E — на входе программный модуль получает определенный набор исходных данных, выполняет содержательную обработку и возвращает один набор результатных данных, т.е. реализуется стандартный принцип IPO — \u003Cem\u003Eвход–процесс–выход\u003C\u002Fem\u003E;\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Cstrong\u003Eлогическая независимость\u003C\u002Fstrong\u003E — результат работы программного модуля зависит только от исходных данных, но не зависит от работы других модулей;\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Cstrong\u003Eслабые информационные связи с другими модулями\u003C\u002Fstrong\u003E — обмен информацией между модулями должен быть по возможности минимизирован.\u003C\u002Fli\u003E\r\n\u003C\u002Ful\u003E\u003Cbr\u002F\u003E\r\nГрамотная декомпозиция — это своего рода искусство и гигантская проблема для многих программистов. Простота тут очень обманчива, а ошибки обходятся очень дорого. Если выделенные модули оказываются сильно сцеплены друг с другом, если их не удается разрабатывать независимо или не ясно за какую конкретно функцию каждый из них отвечает, то стоит задуматься а правильно ли вообще производится деление. Должно быть понятно, какую роль выполняет каждый модуль. Самый же надежный критерий того, что декомпозиция делается правильно, это если модули получаются самостоятельными и ценными сами по себе подпрограммами, которые могут быть использованы в отрыве от всего остального приложения (а значит, могут быть переиспользуемы).\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nДелая декомпозицию системы желательно проверять ее качество задавая себе вопросы: \"\u003Cem\u003EКакую функцию выполняет каждый модуль?\u003C\u002Fem\u003E\", “\u003Cem\u003EНасколько модули легко тестировать?\u003C\u002Fem\u003E”, “\u003Cem\u003EВозможно ли использовать модули самостоятельно или в другом окружении?\u003C\u002Fem\u003E”, “\u003Cem\u003EКак сильно изменения в одном модуле отразятся на остальных?\u003C\u002Fem\u003E”\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nВ первую очередь следует, конечно же, стремиться к тому, чтобы модули были предельно автономны. Как и было сказано, это является ключевым параметром правильной декомпозиции. Поэтому проводить ее нужно таким образом, чтобы модули \u003Cstrong\u003Eизначально\u003C\u002Fstrong\u003E слабо зависели друг от друга. Но кроме того, имеется ряд специальных техник и шаблонов, позволяющих затем дополнительно \u003Cem\u003Eминимизировать и ослабить связи между подсистемами.\u003C\u002Fem\u003E Например, в случае MVC для этой цели использовался шаблон «Наблюдатель», но возможны и другие решения. Можно сказать, что техники для \u003Cem\u003Eуменьшения связанности\u003C\u002Fem\u003E, как раз и составляют основной «инструментарий архитектора». Только необходимо понимать, что речь идет о всех подсистемах и \u003Cstrong\u003Eослаблять связанность нужно на всех уровнях иерархии\u003C\u002Fstrong\u003E, то есть не только между классам, но также и между модулями на каждом иерархическом уровне.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ch1\u003EКак ослаблять связанность между модулями\u003C\u002Fh1\u003E\u003Cbr\u002F\u003E\r\nДля наглядности, картинка из неплохой статьи \"\u003Ca href=\"http:\u002F\u002Fciteseerx.ist.psu.edu\u002Fviewdoc\u002Fdownload?doi=10.1.1.43.6026&amp;amp;rep=rep1&amp;amp;type=pdf\"\u003EDecoupling of Object-Oriented Systems\u003C\u002Fa\u003E\", иллюстрирующая основные моменты, о которых будет идти речь.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw1560\u002Ffiles\u002F9b7\u002F5a0\u002F1a8\u002F9b75a01a808341d29b9bbaa8da1f2734.png\" alt=\"Decoupling architecture\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Ffiles\u002F9b7\u002F5a0\u002F1a8\u002F9b75a01a808341d29b9bbaa8da1f2734.png\"\u002F\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ch3\u003E1. Интерфейсы. Фасад\u003C\u002Fh3\u003E\u003Cbr\u002F\u003E\r\nГлавным, что позволяет уменьшать связанность системы, являются конечно же \u003Cem\u003EИнтерфейсы\u003C\u002Fem\u003E (и стоящий за ними принцип \u003Cem\u003EИнкапсуляция + Абстракция + Полиморфизм)\u003C\u002Fem\u003E:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cul\u003E\r\n\u003Cli\u003EМодули должны быть друг для друга \"черными ящиками\" (\u003Cem\u003Eинкапсуляция\u003C\u002Fem\u003E). Это означает, что один модуль не должен «лезть» внутрь другого модуля и что либо знать о его внутренней структуре. Объекты одной подсистемы не должны обращаться напрямую к объектам другой подсистемы\u003C\u002Fli\u003E\r\n\u003Cli\u003EМодули\u002Fподсистемы должны взаимодействовать друг с другом лишь посредством \u003Cem\u003Eинтерфейсов\u003C\u002Fem\u003E (то есть, \u003Cem\u003Eабстракций\u003C\u002Fem\u003E, не зависящих от деталей реализации) Соответственно каждый модуль должен иметь четко определенный интерфейс или интерфейсы для взаимодействия с другими модулями.\u003C\u002Fli\u003E\r\n\u003C\u002Ful\u003E\u003Cbr\u002F\u003E\r\nПринцип «черного ящика» (\u003Cem\u003Eинкапсуляция\u003C\u002Fem\u003E) позволяет рассматривать структуру каждой подсистемы независимо от других подсистем. Модуль, представляющий собой черный ящик, можно относительно свободно менять. Проблемы могут возникнуть лишь на стыке разных модулей (или модуля и окружения). И вот это взаимодействие нужно описывать в максимально общей (\u003Cem\u003Eабстрактной\u003C\u002Fem\u003E) форме — в форме интерфейса. В этом случае код будет работать одинаково с любой реализацией, соответствующей контракту интерфейса. Собственно именно эта возможность работать с различными реализациями (модулями или объектами) через унифицированный интерфейс и называется полиморфизмом. Полиморфизм это вовсе не переопределение методов, как иногда ошибочно полагают, а прежде всего — \u003Cem\u003Eвзаимозаменяемость\u003C\u002Fem\u003E модулей\u002Fобъектов с одинаковым интерфейсом, или «один интерфейс, множество реализаций» (подробнее \u003Ca href=\"https:\u002F\u002Fhabrahabr.ru\u002Fpost\u002F37610\u002F\"\u003Eтут\u003C\u002Fa\u003E). Для реализации полиморфизма механизм наследования совсем не нужен. Это важно понимать, поскольку наследования вообще, по возможности, следует избегать.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nБлагодаря интерфейсам и полиморфизму, как раз и достигается возможность модифицировать и расширять код, без изменения того, что уже написано (Open-Closed Principle). До тех пор, пока взаимодействие модулей описано исключительно в виде интерфейсов, и не завязано на конкретные реализации, мы имеем возможность абсолютно «безболезненно» для системы заменить один модуль на любой другой, реализующий тот же самый интерфейс, а также добавить новый и тем самым расширить функциональность. Это как в конструкторе или «плагинной архитектуре» (plugin architecture) — интерфейс служит своего рода коннектором, куда может быть подключен любой модуль с подходящим разъемом. Гибкость конструктора обеспечивается тем, что мы можем просто заменить одни модули\u002F«детали» на другие, с такими же разъемами (с тем же интерфейсом), а также добавить сколько угодно новых деталей (при этом уже существующие детали никак не изменяются и не переделываются). Подробнее про Open-Closed Principle и про то, как он может быть реализован можно почитать \u003Ca href=\"http:\u002F\u002Fsergeyteplyakov.blogspot.ca\u002F2014\u002F08\u002Fopen-closed-principle.html\"\u003Eтут\u003C\u002Fa\u003E + хорошая статья \u003Ca href=\"http:\u002F\u002Fblog.8thlight.com\u002Funcle-bob\u002F2014\u002F05\u002F12\u002FTheOpenClosedPrinciple.html\"\u003Eна английском\u003C\u002Fa\u003E.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nИнтерфейсы позволяют строить систему более высокого уровня, рассматривая каждую подсистему как единое целое и игнорируя ее внутреннее устройство. Они дают возможность модулям взаимодействовать и при этом ничего не знать о внутренней структуре друг друга, тем самым в полной мере реализуя \u003Cem\u003Eпринцип минимального знания\u003C\u002Fem\u003E, являющейся основой \u003Cem\u003Eслабой связанности.\u003C\u002Fem\u003E Причем, чем в более общей\u002Fабстрактной форме определены интерфейсы и чем меньше ограничений они накладывают на взаимодействие, тем гибче система. Отсюда фактически следует еще один из принципов SOLID — \u003Cstrong\u003EПринцип разделения интерфейса (Interface Segregation Principle)\u003C\u002Fstrong\u003E, который выступает против «толстых интерфейсов» и говорит, что большие, объемные интерфейсы надо разбивать на более маленькие и специфические, чтобы клиенты маленьких интерфейсов (зависящие модули) знали только о методах, которые необходимы им в работе. Формулируется он следующим образом: \"\u003Cem\u003EКлиенты не должны зависеть от методов (знать о методах), которые они не используют\u003C\u002Fem\u003E\" или “\u003Cem\u003EМного специализированных интерфейсов лучше, чем один универсальный”.\u003C\u002Fem\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nИтак, когда взаимодействие и зависимости модулей описываются лишь с помощью интерфейсов, те есть \u003Cem\u003Eабстракций\u003C\u002Fem\u003E, без использования знаний об их внутреннем устройстве и структуре, то фактически тем самым реализуется \u003Cem\u003Eинкапсуляция\u003C\u002Fem\u003E, плюс мы имеем возможность расширять\u002Fизменять поведения системы за счет добавления и использования различных реализаций, то есть за счет \u003Cem\u003Eполиморфизма.\u003C\u002Fem\u003E Из этого следует, что концепция интерфейсов включает в себя и в некотором смысле обобщает почти все основные принципы ООП — Инкапсуляцию, Абстракцию, Полиморфизм. Но тут возникает один вопрос. Когда проектирование идет не на уровне объектов, которые сами же и реализуют соответствующие интерфейсы, а на уровне модулей, то что является реализацией интерфейса модуля? Ответ: если говорить языком шаблонов, то как вариант, за реализацию интерфейса модуля может отвечать специальный объект — \u003Cstrong\u003EФасад\u003C\u002Fstrong\u003E.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cem\u003EФасад — это объект-интерфейс, аккумулирующий в себе высокоуровневый набор операций для работы с некоторой подсистемой, скрывающий за собой ее внутреннюю структуру и истинную сложность. Обеспечивает защиту от изменений в реализации подсистемы. Служит единой точкой входа — \"вы пинаете фасад, а он знает, кого там надо пнуть в этой подсистеме, чтобы получить нужное\"\u003C\u002Fem\u003E.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nТаким образом, мы получаем первый, самый важный паттерн, позволяющий использовать концепцию интерфейсов при проектировании модулей и тем самым ослаблять их связанность — «\u003Cem\u003EФасад»\u003C\u002Fem\u003E. Помимо этого «Фасад» вообще дает возможность работать с модулями точно также как с обычными объектами и применять при проектировании модулей все те полезные принципы и техники, которые используются при проектирования классов.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw1560\u002Ffiles\u002Ff29\u002Fb83\u002F8b1\u002Ff29b838b11df4acda0009ace9b6f9ed7.png\" alt=\"Facade Decoupling architecture\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Ffiles\u002Ff29\u002Fb83\u002F8b1\u002Ff29b838b11df4acda0009ace9b6f9ed7.png\"\u002F\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cem\u003EЗамечание: Хотя большинство программистов понимают важность интерфейсов при проектировании классов (объектов), складывается впечатление, что идея необходимости использовать интерфейсы также и на уровне модулей только зарождается. Мне встретилось очень мало статей и проектов, где интерфейсы бы применялись для ослабления связанности между модулями\u002Fслоями и соответственно использовался бы паттерн «Фасад». Кто, например, видел «Фасад» на схемах уже упоминавшегося «архитектурного шаблона» Модель-Вид-Контроллер, или хотя бы слышал его упоминание среди паттернов, входящих в состав MVC (наряду с Observer и Composite)? А ведь он там должен быть, поскольку Модель это не класс, это модуль, причем центральный. И у создателя MVC Трюгве Реенскауга он, конечно же, был (смотрим «\u003C\u002Fem\u003E\u003Ca href=\"http:\u002F\u002Fheim.ifi.uio.no\u002F~trygver\u002F2003\u002Fjavazone-jaoo\u002FMVC_pattern.pdf\"\u003EThe Model-View-Controller (MVC ). Its Past and Present\u003C\u002Fa\u003E\u003Cem\u003E», только учитываем, что это писалось в 1973 году и то, что мы сейчас называем Представлением — Presentaition\u002FUI тогда называлось Editior). Странным образом «Фасад» потерялся на многие годы и вновь обнаружить его мне удалось лишь недавно, в основном, в обобщенном варианте MVC от Microsoft («\u003C\u002Fem\u003E\u003Ca href=\"https:\u002F\u002Fmsdn.microsoft.com\u002Fen-us\u002Flibrary\u002Fee658099.aspx\"\u003EMicrosoft Application Architecture Guide\u003C\u002Fa\u003E\u003Cem\u003E»). Вот соответствующие слайды:\u003C\u002Fem\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw1560\u002Ffiles\u002F171\u002F01d\u002Fd78\u002F17101dd785b84564b54477fe7015589b.png\" alt=\"Facade MVC Model-View-Controller Decoupling\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Ffiles\u002F171\u002F01d\u002Fd78\u002F17101dd785b84564b54477fe7015589b.png\"\u002F\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cem\u003EА разработчикам, к сожалению, приходится заново «переоткрывать» идею, что к объектам Модели, отвечающей за бизнес-логику приложения, нужно обращаться не напрямую а через интерфейс, то есть «Фасад», как например, в этой\u003C\u002Fem\u003E \u003Ca href=\"http:\u002F\u002Falvinjayreyes.com\u002F2011\u002F09\u002F11\u002Fejb-architectural-patterns-session-facade\u002F\"\u003Eстатье\u003C\u002Fa\u003E\u003Cem\u003E, откуда для полноты картины взят еще один слайд:\u003C\u002Fem\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw1560\u002Ffiles\u002F0ce\u002F540\u002F28e\u002F0ce54028e75c44e6848fbf98274cce79.png\" alt=\"Facade MVC Model-View-Controller Decoupling\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Ffiles\u002F0ce\u002F540\u002F28e\u002F0ce54028e75c44e6848fbf98274cce79.png\"\u002F\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ch3\u003E2. Dependency Inversion. Корректное создание и получение зависимостей\u003C\u002Fh3\u003E\u003Cbr\u002F\u003E\r\nФормально, требование, чтобы модули не содержали ссылок на конкретные реализации, а все зависимости и взаимодействие между ними строились исключительно на основе абстракций, то есть интерфейсов, выражается принципом \u003Cstrong\u003EИнвертирования зависимостей\u003C\u002Fstrong\u003E (\u003Cstrong\u003EDependency Inversion\u003C\u002Fstrong\u003E — последний из пяти принципов SOLID):\u003Cbr\u002F\u003E\r\n\u003Cul\u003E\r\n\u003Cli\u003EМодули верхнего уровня не должны зависеть от модулей нижнего уровня. И те, и другие должны зависеть от абстракций.\u003C\u002Fli\u003E\r\n\u003Cli\u003EАбстракции не должны зависеть от деталей. Реализация должна зависеть от абстракции.\u003C\u002Fli\u003E\r\n\u003C\u002Ful\u003E\u003Cbr\u002F\u003E\r\nУ этого принципа не самая очевидная формулировка, но суть его, как и было сказано, выражается правилом: «\u003Cem\u003EВсе зависимости должны быть в виде интерфейсов\u003C\u002Fem\u003E». Подробно и очень хорошо принцип инвертирования зависимостей разбирается в статье \u003Ca href=\"http:\u002F\u002Fwww.skipy.ru\u002Farchitecture\u002Fmodule_design.html#principles\"\u003EМодульный дизайн или «что такое DIP, SRP, IoC, DI и т.п.»\u003C\u002Fa\u003E. Статья из разряда must-read, лучшее, что доводилось читать по архитектуре ПО.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nНе смотря на свою фундаментальность и кажущуюся простоту это правило нарушается, пожалуй, чаще всего. А именно, каждый раз, когда в коде программы\u002Fмодуля мы используем оператор new и создаем новый объект конкретного типа, то тем самым вместо зависимости от интерфейса образуется зависимость от реализации.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nПонятно, что этого нельзя избежать и объекты где-то должны создаваться. Но, по крайней мере, нужно свести к минимуму количество мест, где это делается и в которых явно указываются классы, а также локализовать и изолировать такие места, чтобы они не были разбросаны по всему коду программы. Решение заключается в том, чтобы сконцентрировать создание новых объектов в рамках специализированных объектов и модулей — фабрик, сервис локаторов, IoC-контейнеров.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nВ каком-то смысле такое решение следует \u003Ca href=\"http:\u002F\u002Fwww.life-prog.ru\u002F2_31166_printsip-edinstvennogo-vibora.html\"\u003EПринципу единственного выбора\u003C\u002Fa\u003E (Single Choice Principle), который говорит: \"\u003Cem\u003Eвсякий раз, когда система программного обеспечения должна поддерживать множество альтернатив, их полный список должен быть известен только одному модулю системы\u003C\u002Fem\u003E\". В этом случае, если в будущем придется добавить новые варианты (или новые реализации, как в рассматриваемом нами случае создания новых объектов), то достаточно будет произвести обновление только того модуля, в котором содержится эта информация, а все остальные модули останутся незатронутыми и смогут продолжать свою работу как обычно.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nНу а теперь разберем подробнее, как это делается на практике и каким образом модули могут \u003Cem\u003Eкорректно создавать и получать свои «зависимости»\u003C\u002Fem\u003E, не нарушая принципа Dependency Inversion.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nИтак, при проектировании модуля должны быть определены следующие ключевые вещи:\u003Cbr\u002F\u003E\r\n\u003Cul\u003E\r\n\u003Cli\u003Eчто модуль делает, какую функцию выполняет\u003C\u002Fli\u003E\r\n\u003Cli\u003Eчто модулю нужно от его окружения, то есть с какими объектами\u002Fмодулями ему придется иметь дело и\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Cem\u003Eкак он это будет получать\u003C\u002Fem\u003E\u003C\u002Fli\u003E\r\n\u003C\u002Ful\u003E\u003Cbr\u002F\u003E\r\nКрайне важно то, \u003Cem\u003Eкак модуль получает ссылки на объекты, которые он использует в своей работе\u003C\u002Fem\u003E. И тут возможны следующие варианты:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Col\u003E\r\n\u003Cli\u003E\u003Cem\u003EМодуль сам создает объекты необходимые ему для работы\u003C\u002Fem\u003E.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nНо, как и было сказано, модуль не может это сделать напрямую — для создания необходимо вызвать конструктор конкретного типа, и в результате модуль будет зависеть не от интерфейса, а от конкретной реализации. Решить проблему в данном случае позволяет шаблон \u003Ca href=\"http:\u002F\u002Fcpp-reference.ru\u002Fpatterns\u002Fcreational-patterns\u002Ffactory-method\u002F\"\u003EФабричный Метод\u003C\u002Fa\u003E (\u003Cstrong\u003EFactory Method\u003C\u002Fstrong\u003E).\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\"Суть заключается в том, что вместо непосредственного инстанцирования объекта через new, мы предоставляем классу-клиенту некоторый интерфейс для создания объектов. Поскольку такой интерфейс при правильном дизайне всегда может быть переопределён, мы получаем определённую гибкость при использовании низкоуровневых модулей в модулях высокого уровня\".\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nВ случаях, когда нужно создавать группы или семейства взаимосвязанных объектов, вместо Фабричного Метода используется \u003Ca href=\"http:\u002F\u002Fcpp-reference.ru\u002Fpatterns\u002Fcreational-patterns\u002Fabstract-factory\u002F\"\u003EАбстрактная Фабрика\u003C\u002Fa\u003E (\u003Cstrong\u003EAbstract factory\u003C\u002Fstrong\u003E).\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Cem\u003EМодуль берет необходимые объекты у того, у кого они уже есть\u003C\u002Fem\u003E (обычно это некоторый, известный всем репозиторий, в котором уже лежит все, что только может понадобиться для работы программы).\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nЭтот подход реализуется шаблоном \u003Cstrong\u003EЛокатор Сервисов\u003C\u002Fstrong\u003E (\u003Cstrong\u003EService Locator\u003C\u002Fstrong\u003E), основная идея которого заключается в том, что в программе имеется объект, знающий, как получить все зависимости (сервисы), которые могут потребоваться.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nГлавное отличие от фабрик в том, что Service Locator не создаёт объекты, а фактически уже содержит в себе инстанцированные объекты (или знает где\u002Fкак их получить, а если и создает, то только один раз при первом обращении). Фабрика при каждом обращении создает новый объект, который вы получаете в полную собственность и можете делать с ним что хотите. Локатор же сервисов выдает ссылки на одни и те же, уже существующие объекты. Поэтому с объектами, выданными Service Locator, нужно быть очень осторожным, так как одновременно с вами ими может пользоваться кто-то еще.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nОбъекты в Service Locator могут быть добавлены напрямую, через конфигурационный файл, да и вообще любым удобным программисту способом. Сам Service Locator может быть статическим классом с набором статических методов, синглетоном или интерфейсом и передаваться требуемым классам через конструктор или метод.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nВообще говоря, Service Locator иногда называют антипаттерном и не рекомендуют использовать (главным образом потому, что он создает неявные связности и дает лишь видимость хорошего дизайна). Подробно можно почитать у Марка Симана:\u003Cbr\u002F\u003E\r\n\u003Ca href=\"http:\u002F\u002Fblog.ploeh.dk\u002F2010\u002F02\u002F03\u002FServiceLocatorIsAnAntiPattern.aspx\"\u003EService Locator is an Anti-Pattern\u003C\u002Fa\u003E \u003Cbr\u002F\u003E\r\n\u003Ca href=\"http:\u002F\u002Fblog.ploeh.dk\u002F2010\u002F11\u002F01\u002FPatternRecognitionAbstractFactoryOrServiceLocator.aspx\"\u003EAbstract Factory or Service Locator?\u003C\u002Fa\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Cem\u003EМодуль вообще не заботиться о «добывании» зависимостей.\u003C\u002Fem\u003E Он лишь определяет, что ему нужно для работы, а все необходимые зависимости ему поставляются («впрыскиваются») из вне кем-то другим.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nЭто так и называется — \u003Cstrong\u003EВнедрение Зависимостей\u003C\u002Fstrong\u003E (\u003Cstrong\u003EDependency Injection\u003C\u002Fstrong\u003E). Обычно требуемые зависимости передаются либо в качестве параметров конструктора (\u003Cem\u003EConstructor Injection\u003C\u002Fem\u003E), либо через методы класса (\u003Cem\u003ESetter injection\u003C\u002Fem\u003E).\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nТакой подход \u003Cem\u003Eинвертирует процесс создания зависимости\u003C\u002Fem\u003E — вместо самого модуля создание зависимостей контролирует кто-то извне. Модуль из активного элемента, становится пассивным — не он делает, а для него делают. Такое изменение направления действия называется \u003Cstrong\u003EИнверсия Контроля\u003C\u002Fstrong\u003E (\u003Cstrong\u003EInversion of Control\u003C\u002Fstrong\u003E), или \u003Cem\u003EПринцип Голливуда\u003C\u002Fem\u003E — «Не звоните нам, мы сами вам позвоним».\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nЭто самое гибкое решение, дающее модулям наибольшую автономность. Можно сказать, что только оно в полной мере реализует «\u003Cem\u003EПринцип единственной ответственности\u003C\u002Fem\u003E» — модуль должен быть полностью сфокусирован на том, чтобы хорошо выполнять свою функцию и не заботиться ни о чем другом. Обеспечение его всем необходимым для работы это отдельная задача, которой должен заниматься соответствующий «специалист» (обычно управлением зависимостями и их внедрениями занимается некий контейнер — IoC-контейнер).\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nПо сути, здесь все как в жизни: в хорошо организованной компании программисты программируют, а столы, компьютеры и все необходимое им для работы покупает и обеспечивает кладовщик. Или, если использовать метафору программы как конструктора — модуль не должен думать о проводах, сборкой конструктора занимается кто-то другой, а не сами детали.\u003C\u002Fli\u003E\r\n\u003C\u002Fol\u003E\u003Cbr\u002F\u003E\r\nБолее подробно и с примерами о способах создания и получения зависимостей можно почитать, например, в этой \u003Ca href=\"http:\u002F\u002Fhabrahabr.ru\u002Fpost\u002F244517\u002F\"\u003Eстатье\u003C\u002Fa\u003E (только надо иметь ввиду, что хотя автор пишет о \u003Cem\u003EDependency Inversion\u003C\u002Fem\u003E, он использует термин \u003Cem\u003EInversion of Control\u003C\u002Fem\u003E; возможно потому, что в русской википедии содержится ошибка и этим терминам даны одинаковые определения). А принцип \u003Cem\u003EInversion of Control\u003C\u002Fem\u003E (вместе с \u003Cem\u003EDependency Injection\u003C\u002Fem\u003E и \u003Cem\u003EService Locator\u003C\u002Fem\u003E) детально разбирается Мартином Фаулером и есть переводы обеих его статей: \"\u003Ca href=\"http:\u002F\u002Fyugeon-dev.blogspot.com.es\u002F2010\u002F07\u002Finversion-of-control-containers-and_21.html\"\u003EInversion of Control Containers and the Dependency Injection pattern\u003C\u002Fa\u003E\" и “\u003Ca href=\"http:\u002F\u002Fhabrahabr.ru\u002Fpost\u002F116232\u002F\"\u003EInversion of Control\u003C\u002Fa\u003E”.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nНе будет преувеличением сказать, что использование интерфейсов для описания зависимостей между модулями (\u003Cem\u003EDependency Inversion\u003C\u002Fem\u003E) + корректное создание и внедрение этих зависимостей (прежде всего \u003Cem\u003EDependency Injection\u003C\u002Fem\u003E) являются центральными\u002Fбазовыми техниками для снижения связанности. Они служат тем фундаментом, на котором вообще держится слабая связанность кода, его гибкость, устойчивость к изменениям, переиспользование, и без которого все остальные техники имеют мало смысла. Но, если с фундаментом все в порядке, то знание дополнительных приемов может быть очень даже полезным. Поэтому продолжим.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ch3\u003E3. Замена прямых зависимостей на обмен сообщениями\u003C\u002Fh3\u003E\u003Cbr\u002F\u003E\r\nИногда модулю нужно всего лишь \u003Cem\u003Eизвестить\u003C\u002Fem\u003E других о том, что в нем произошли какие-то события\u002Fизменения и ему не важно, что с этой информацией будет происходить потом. В этом случае модулям вовсе нет необходимости «знать друг о друге», то есть содержать прямые ссылки и взаимодействовать непосредственно, а достаточно всего лишь обмениваться сообщениями (messages) или событиями (events).\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nСвязь модулей через \u003Cem\u003Eобмен сообщениями\u003C\u002Fem\u003E является гораздо более слабой, чем прямая зависимость и реализуется она чаще всего с помощью следующих шаблонов:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cul\u003E\r\n\u003Cli\u003E\u003Cstrong\u003EНаблюдатель (Observer).\u003C\u002Fstrong\u003E Применяется в случае зависимости «\u003Cem\u003Eодин-ко-многим\u003C\u002Fem\u003E», когда множество модулей зависят от состояния одного — основного. Использует механизм \u003Ca href=\"https:\u002F\u002Fen.wikipedia.org\u002Fwiki\u002FPublish–subscribe_pattern\"\u003Eрассылки\u003C\u002Fa\u003E, который заключается в том, что основной модуль просто осуществляет рассылку одинаковых сообщений всем своим подписчикам, а модули, заинтересованные в этой информации, реализуют интерфейс «подписчика» и подписываются на рассылку. Находит широкое применение в системах с пользовательским интерфейсом, позволяя ядру приложения (модели) оставаться независимым и при этом информировать связанные с ним интерфейсы о том что произошли какие-то изменения и нужно обновиться.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nОрганизация взаимодействия посредством рассылки сообщений имеет дополнительный «бонус» — необязательность существования «подписчиков» на «опубликованные» (т.е. рассылаемые) сообщения. Качественно спроектированная подобная система допускает добавление\u002Fудаление модулей в любое время.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Cstrong\u003EПосредник (Mediator).\u003C\u002Fstrong\u003E Применяется, когда между модулями имеется зависимость «\u003Cem\u003Eмногие ко многим\u003C\u002Fem\u003E. Медиатор выступает в качестве посредника в общении между модулями\u003Cstrong\u003E,\u003C\u002Fstrong\u003E действуя как центр связи и избавляет модули от необходимости явно ссылаться друг на друга. В результате взаимодействие модулей друг с другом («все со всеми») заменяется взаимодействием модулей лишь с посредником («один со всеми»). Говорят, что посредник \u003Cem\u003Eинкапсулирует взаимодействие\u003C\u002Fem\u003E между множеством модулей.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw1560\u002Ffiles\u002F598\u002F704\u002Fb45\u002F598704b45b854f4baf30aa214210aff5.png\" alt=\"Mediator Посредник\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Ffiles\u002F598\u002F704\u002Fb45\u002F598704b45b854f4baf30aa214210aff5.png\"\u002F\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nТипичный пример — контроль трафика в аэропорту. Все сообщения, исходящие от самолетов, поступают в башню управления диспетчеру, вместо того, чтобы пересылаться между самолетами напрямую. А диспетчер уже принимает решения о том, какие самолеты могут взлетать или садиться, и в свою очередь отправляет самолетам соответствующие сообщения. Подробнее, например, \u003Ca href=\"http:\u002F\u002Fcpp-reference.ru\u002Fpatterns\u002Fbehavioral-patterns\u002Fmediator\u002F\"\u003Eтут\u003C\u002Fa\u003E.\u003C\u002Fli\u003E\r\n\u003C\u002Ful\u003E\u003Cbr\u002F\u003E\r\n\u003Cem\u003EДополнение: Модули могут пересылать друг другу не только «простые сообщения, но и объекты-команды. Такое взаимодействие описывается шаблоном\u003C\u002Fem\u003E \u003Cstrong\u003EКоманда\u003C\u002Fstrong\u003E (\u003Cstrong\u003ECommand\u003C\u002Fstrong\u003E). \u003Cem\u003EСуть заключается в инкапсулировании запроса на выполнение определенного действия в виде отдельного объекта (фактически этот объект содержит один единственный метод execute()), что позволяет затем передавать это действие другим модулям на выполнение в качестве параметра, и вообще производить с объектом-командой любые операции, какие могут быть произведены над обычными объектами. Кратко рассмотрен\u003C\u002Fem\u003E \u003Ca href=\"http:\u002F\u002Fcpp-reference.ru\u002Fpatterns\u002Fbehavioral-patterns\u002Fcommand\u002F\"\u003Eтут\u003C\u002Fa\u003E\u003Cem\u003E, соответствующая глава из книги банды четырех\u003C\u002Fem\u003E \u003Ca href=\"http:\u002F\u002Fooad.asf.ru\u002FPattern.aspx?IdKat=7&amp;amp;IdPat=33\"\u003Eтут\u003C\u002Fa\u003E\u003Cem\u003E, есть также статья на\u003C\u002Fem\u003E \u003Ca href=\"https:\u002F\u002Fhabrahabr.ru\u002Fpost\u002F114455\u002F\"\u003Eхабре\u003C\u002Fa\u003E\u003Cem\u003E.\u003C\u002Fem\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ch3\u003E4. Замена прямых зависимостей на синхронизацию через общее ядро\u003C\u002Fh3\u003E\u003Cbr\u002F\u003E\r\nДанный подход обобщает и развивает идею заложенную в шаблоне «Посредник». Когда в системе присутствует большое количество модулей, их прямое взаимодействие друг с другом становится слишком сложным. Поэтому имеет смысл взаимодействие «все со всеми» заменить на взаимодействие «один со всеми». Для этого вводится некий обобщенный посредник, это может быть общее ядро приложения, хранилище или шина данных, а все остальные модули становятся независимыми друг от друга клиентами, использующими сервисы этого ядра или выполняющими обработку содержащейся там информации. Реализация этой идеи позволяет модулям-клиентам общаться друг с другом через посредника и при этом ничего друг о друге не знать.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nЯдро-посредник может как знать о модулях-клиентах и управлять ими (пример — \u003Ca href=\"https:\u002F\u002Fwww.ibm.com\u002Fdeveloperworks\u002Fru\u002Flibrary\u002Fos-apache_5\u002F\"\u003Eархитектура apache\u003C\u002Fa\u003E ), так и может быть полностью, или почти полностью, независимым и ничего о клиентах не знать. В сущности именно этот подход реализован в «шаблоне» Модель-Вид-Контроллер (MVC), где с одной Моделью (являющейся ядром приложение и общим хранилищем данных) могут взаимодействовать множество Пользовательских Интерфейсов, которые работают синхронно и при этом не знают друг о друге, а Модель не знает о них. Ничто не мешает подключить к общей модели и синхронизировать таким образом не только интерфейсы, но и другие вспомогательные модули.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nОчень активно эта идея также используется при разработке игр, где независимые модули, отвечающие за графику, звук, физику, управление программой синхронизируются друг с другом через игровое ядро (модель), где хранятся все данные о состоянии игры и ее персонажах. В отличие от MVC, в играх согласование модулей с ядром (моделью) происходит не за счет шаблона «Наблюдатель», а по таймеру, что само по себе является интересным архитектурным решением весьма полезным для программ с анимацией и «бегущей» графикой.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ch3\u003E5. Закон Деметры (law of Demeter)\u003C\u002Fh3\u003E\u003Cbr\u002F\u003E\r\n\u003Ca href=\"https:\u002F\u002Fru.wikipedia.org\u002Fwiki\u002F%D0%97%D0%B0%D0%BA%D0%BE%D0%BD_%D0%94%D0%B5%D0%BC%D0%B5%D1%82%D1%80%D1%8B\"\u003EЗакон Деметры\u003C\u002Fa\u003E запрещает использование неявных зависимостей: \"\u003Cem\u003EОбъект A не должен иметь возможность получить непосредственный доступ к объекту C, если у объекта A есть доступ к объекту B и у объекта B есть доступ к объекту C\u003C\u002Fem\u003E\". \u003Ca href=\"http:\u002F\u002Falvinalexander.com\u002Fjava\u002Fjava-law-of-demeter-java-examples\"\u003EJava-пример\u003C\u002Fa\u003E.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nЭто означает, что все зависимости в коде должны быть «явными» — классы\u002Fмодули могут использовать в работе только «свои зависимости» и не должны лезть через них к другим. Кратко этот принцип формулируют еще таким образом: \"\u003Cem\u003EВзаимодействуй только с непосредственными друзьями, а не с друзьями друзей\u003C\u002Fem\u003E\". Тем самым достигается меньшая связанность кода, а также большая наглядность и прозрачность его дизайна.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nЗакон Деметры реализует уже упоминавшийся «\u003Cem\u003Eпринцип минимального знания\u003C\u002Fem\u003E», являющейся основой слабой связанности и заключающийся в том, что объект\u002Fмодуль должен знать как можно меньше деталей о структуре и свойствах других объектов\u002Fмодулей и вообще чего угодно, \u003Cstrong\u003Eвключая собственные подкомпоненты\u003C\u002Fstrong\u003E. Аналогия из жизни: Если Вы хотите, чтобы собака побежала, глупо командовать ее лапами, лучше отдать команду собаке, а она уже разберётся со своими лапами сама.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ch3\u003E6. Композиция вместо наследования\u003C\u002Fh3\u003E\u003Cbr\u002F\u003E\r\nОдну из самых сильных связей между объектами дает наследование, поэтому, по возможности, его следует избегать и заменять композицией. Эта тема хорошо раскрыта в статье Герба Саттера — «\u003Ca href=\"http:\u002F\u002Fprogramming-lang.com\u002Fru\u002Fcomp_programming\u002Fsatter\u002F0\u002Fj84.html\"\u003EПредпочитайте композицию наследованию\u003C\u002Fa\u003E».\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nМогу только посоветовать в данном контексте обратить внимание на шаблон \u003Ca href=\"https:\u002F\u002Fru.wikipedia.org\u002Fwiki\u002FШаблон_делегирования\"\u003EДелегат\u003C\u002Fa\u003E (\u003Cstrong\u003EDelegation\u002FDelegate\u003C\u002Fstrong\u003E) и пришедший из игр шаблон \u003Cstrong\u003EКомпонет\u003C\u002Fstrong\u003E (\u003Cstrong\u003EComponent\u003C\u002Fstrong\u003E), который подробно описан в книге «Game Programming Patterns» (соответствующая глава из этой книги на \u003Ca href=\"http:\u002F\u002Fgameprogrammingpatterns.com\u002Fcomponent.html\"\u003Eанглийском\u003C\u002Fa\u003E и ее \u003Ca href=\"http:\u002F\u002Flive13.livejournal.com\u002F473028.html\"\u003Eперевод\u003C\u002Fa\u003E).\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ch1\u003EЧто почитать\u003C\u002Fh1\u003E\u003Cbr\u002F\u003E\r\nСтатьи в интернете:\u003Cbr\u002F\u003E\r\n\u003Cul\u003E\r\n\u003Cli\u003E\u003Ca href=\"http:\u002F\u002Fuml-tutorials.trireme.com\u002Fuml_tutorial_6_1.htm\"\u003EDesign patterns for decoupling\u003C\u002Fa\u003E (небольшая полезная глава из \u003Ca href=\"http:\u002F\u002Fuml-tutorials.trireme.com\u002F\"\u003EUML Tutorial\u003C\u002Fa\u003E);\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fdev.by\u002Flenta\u002Fapalon\u002Fnemnogo-pro-arhitekturu\"\u003EНемного про архитектуру\u003C\u002Fa\u003E;\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Faddyosmani.com\u002Flargescalejavascript\u002F\"\u003EPatterns For Large-Scale JavaScript Application Architecture\u003C\u002Fa\u003E;\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ca href=\"http:\u002F\u002Fwww.artlebedev.ru\u002Ftools\u002Ftechnogrette\u002Fjs\u002Fobservable\u002F\"\u003EСлабое связывание компонентов в JavaScript\u003C\u002Fa\u003E;\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ca href=\"http:\u002F\u002Fhabrahabr.ru\u002Fcompany\u002Fmailru\u002Fblog\u002F267277\u002F\"\u003EКак писать тестируемый код\u003C\u002Fa\u003E — статья из которой хорошо видно что критерии тестируемости кода и хорошего дизайна совпадают;\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ca href=\"http:\u002F\u002Fmartinfowler.com\u002Fdesign.html\"\u003Eсайт\u003C\u002Fa\u003E Мартина Фаулера.\u003C\u002Fli\u003E\r\n\u003C\u002Ful\u003E\u003Cbr\u002F\u003E\r\nЗамечательный ресурс — \u003Ca href=\"http:\u002F\u002Frus-linux.net\u002FMyLDP\u002FBOOKS\u002FArchitecture-Open-Source-Applications\u002Findex.html\"\u003EАрхитектура приложений с открытым исходным кодом\u003C\u002Fa\u003E, где \"\u003Cem\u003Eавторы четырех дюжин приложений с открытым исходным кодом рассказывают о структуре созданных ими программ и о том, как эти программы создавались. Каковы их основные компоненты? Как они взаимодействуют? И что открыли для себя их создатели в процессе разработки? В ответах на эти вопросы авторы статей, собранных в данных книгах, дают вам уникальную возможность проникнуть в то, как они творят\u003C\u002Fem\u003E\". Одна из статей полностью была опубликована на хабре — «\u003Ca href=\"http:\u002F\u002Fhabrahabr.ru\u002Fpost\u002F185636\u002F\"\u003EМасштабируемая веб-архитектура и распределенные системы\u003C\u002Fa\u003E».\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nИнтересные решения и идеи можно найти в материалах, посвященных разработке игр. \u003Ca href=\"http:\u002F\u002Fgameprogrammingpatterns.com\u002Fcontents.html\"\u003EGame Programming Patterns\u003C\u002Fa\u003E — большой сайт с подробным описанием многих шаблонов и примерами их применения к задаче создания игр (оказывается, есть уже его перевод — «\u003Ca href=\"http:\u002F\u002Flive13.livejournal.com\u002F462582.html\"\u003EШаблоны игрового программирования\u003C\u002Fa\u003E», спасибо \u003Ca href=\"https:\u002F\u002Fhabrahabr.ru\u002Fusers\u002Fstrannik_k\u002F\"\u003Estrannik_k\u003C\u002Fa\u003E за ссылку). Возможно будет полезна также статья «\u003Ca href=\"http:\u002F\u002Fwww.dtf.ru\u002Farticles\u002Fread.php?id=40757\"\u003EГибкая и масштабируемая архитектура для компьютерных игр\u003C\u002Fa\u003E» (и ее \u003Ca href=\"https:\u002F\u002Fwww.tjhsst.edu\u002F~rlatimer\u002Ftechlab07\u002Fplummer_thesis.pdf\"\u003Eоригинал\u003C\u002Fa\u003E. Нужно только иметь ввиду что автор почему-то композицию называет шаблоном \"Наблюдатель\").\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nПо поводу паттернов проектирования:\u003Cbr\u002F\u003E\r\n\u003Cul\u003E\r\n\u003Cli\u003EИнтересная «\u003Ca href=\"http:\u002F\u002Frsdn.ru\u002Fforum\u002Fdesign\u002F3774238\"\u003EМысль про паттерны проектирования\u003C\u002Fa\u003E»;\u003C\u002Fli\u003E\r\n\u003Cli\u003EУдобный сайт с краткими описаниями и схемами всех шаблонов проектирования — «\u003Ca href=\"http:\u002F\u002Fcitforum.ru\u002FSE\u002Fproject\u002Fpattern\u002Findex.shtml#toc\"\u003EОбзор паттернов проектирования\u003C\u002Fa\u003E»;\u003C\u002Fli\u003E\r\n\u003Cli\u003Eсайт на базе книги банды четырех, где все шаблоны описаны очень подробно — «\u003Ca href=\"http:\u002F\u002Fooad.asf.ru\u002FPatterns.aspx\"\u003EШаблоны [Patterns] проектирования\u003C\u002Fa\u003E».\u003C\u002Fli\u003E\r\n\u003C\u002Ful\u003E\u003Cbr\u002F\u003E\r\nЕсть еще принципы\u002Fпаттерны GRASP, описанные Крэгом Лэрманом в книге «\u003Ca href=\"http:\u002F\u002Fwww.ozon.ru\u002Fcontext\u002Fdetail\u002Fid\u002F3105480\u002F\"\u003EПрименение UML 2.0 и шаблонов проектирования\u003C\u002Fa\u003E», но они больше запутывают чем проясняют. Краткий обзор и обсуждение на \u003Ca href=\"http:\u002F\u002Fhabrahabr.ru\u002Fpost\u002F38323\u002F\"\u003Eхабре\u003C\u002Fa\u003E (самое ценное в комментариях).\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nНу и конечно же книги:\u003Cbr\u002F\u003E\r\n\u003Cul\u003E\r\n\u003Cli\u003EМартин Фаулер «\u003Ca href=\"http:\u002F\u002Fwww.ozon.ru\u002Fcontext\u002Fdetail\u002Fid\u002F1616782\u002F\"\u003EАрхитектура корпоративных программных приложений\u003C\u002Fa\u003E»;\u003C\u002Fli\u003E\r\n\u003Cli\u003EСтив Макконнелл «\u003Ca href=\"http:\u002F\u002Fwww.ozon.ru\u002Fcontext\u002Fdetail\u002Fid\u002F5508646\u002F\"\u003EСовершенный код\u003C\u002Fa\u003E»;\u003C\u002Fli\u003E\r\n\u003Cli\u003EШаблоны проектирования от банды четырех (Gang of Four, GoF) — «\u003Ca href=\"http:\u002F\u002Fwww.ozon.ru\u002Fcontext\u002Fdetail\u002Fid\u002F2457392\u002F\"\u003EПриемы объектно-ориентированного проектирования. Паттерны проектирования\u003C\u002Fa\u003E».\u003C\u002Fli\u003E\r\n\u003C\u002Ful\u003E\u003C\u002Fdiv\u003E","tags":[{"titleHtml":"архитектура приложений"},{"titleHtml":"принципы проектирования"}],"metadata":{"stylesUrls":[],"scriptUrls":[],"shareImageUrl":"https:\u002F\u002Fhabr.com\u002Fshare\u002Fpublication\u002F276593\u002F385fbb9492f41423ccf6b6e7ff51609a\u002F","shareImageWidth":1200,"shareImageHeight":630,"vkShareImageUrl":"https:\u002F\u002Fhabr.com\u002Fshare\u002Fpublication\u002F276593\u002F385fbb9492f41423ccf6b6e7ff51609a\u002F?format=vk","schemaJsonLd":"{\"@context\":\"http:\\\u002F\\\u002Fschema.org\",\"@type\":\"Article\",\"mainEntityOfPage\":{\"@type\":\"WebPage\",\"@id\":\"https:\\\u002F\\\u002Fhabr.com\\\u002Fru\\\u002Fpost\\\u002F276593\\\u002F\"},\"headline\":\"Создание архитектуры программы или как проектировать табуретку\",\"datePublished\":\"2016-02-04T16:18:04+03:00\",\"dateModified\":\"2016-02-04T23:37:11+03:00\",\"author\":{\"@type\":\"Person\",\"name\":\"cobiot\"},\"publisher\":{\"@type\":\"Organization\",\"name\":\"Habr\",\"logo\":{\"@type\":\"ImageObject\",\"url\":\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fwebt\\\u002Fa_\\\u002Flk\\\u002F9m\\\u002Fa_lk9mjkccjox-zccjrpfolmkmq.png\"}},\"description\":\"Взявшись за написание небольшого, но реального и растущего проекта, мы &laquo;на собственной шкуре&raquo; убедились, насколько важно то, чтобы программа не только хорошо раб...\",\"url\":\"https:\\\u002F\\\u002Fhabr.com\\\u002Fru\\\u002Fpost\\\u002F276593\\\u002F#post-content-body\",\"about\":[\"h_webdev\",\"h_analysis_design\",\"h_refactoring\",\"f_develop\"],\"image\":[\"https:\\\u002F\\\u002Fhabr.com\\\u002Fshare\\\u002Fpublication\\\u002F276593\\\u002F385fbb9492f41423ccf6b6e7ff51609a\\\u002F\"]}","metaDescription":"Взявшись за написание небольшого, но реального и растущего проекта, мы «на собственной шкуре» убедились, насколько важно то, чтобы программа не только хорошо работала, но и была хорошо организована....","mainImageUrl":null,"amp":true,"customTrackerLinks":[]},"polls":[],"commentsEnabled":true,"rulesRemindEnabled":false,"votesEnabled":true,"status":"published","plannedPublishTime":null,"checked":null,"isEditorial":false}},"articlesIds":{},"isLoading":false,"pagesCount":{},"route":{},"reasonsList":null,"view":"cards","lastVisitedRoute":{},"ssrCommentsArticleIds":[""],"karma":{}},"authorContribution":{"authors":{}},"betaTest":{"currentAnnouncement":null,"announcements":{},"announcementCards":null,"announcementComments":{},"announcementCommentThreads":{},"announcementCommentingStatuses":{},"archivedList":[]},"authorStatistics":{"articleRefs":{},"articleIds":{},"pagesCount":{},"route":{},"viewsCount":[],"maxStatsCount":{}},"career":{"seoLandings":[{"title":"Cистемный аналитик","vacanciesCount":415,"itemUrl":"https:\u002F\u002Fcareer.habr.com\u002Fvacancies\u002Fsistemnij_analitik","itemHubs":["uml","prototyping","analysis_design","productpm"]}],"hubs":"webdev,analysis_design,refactoring"},"comments":{"articleComments":{},"searchCommentsResults":null,"previewComment":null,"pagesCount":null,"commentAccess":{},"scrollParents":{},"pageArticleComments":{"lastViewedComment":0,"postId":null,"lastCommentTimestamp":"","moderated":[],"moderatedIds":[],"commentRoute":""}},"companies":{"companyRefs":{},"companyIds":{},"companyTopIds":{},"pagesCount":{},"companyProfiles":{},"companiesCategories":[],"companiesCategoriesTotalCount":0,"companiesWidgets":{},"companiesWorkers":{},"companiesFans":{},"route":{},"isLoading":false,"companyWorkersLoading":false,"companyFansLoading":false,"vacancies":{},"workplaceInfo":null},"companyAdmin":{"companyInfo":null,"companyInfoLoading":false,"faqArticles":null,"brandingPreviewImageUrl":null},"companiesContribution":{"hubs":{},"flows":{},"companyRefs":{}},"companyHubsContribution":{"contributionRefs":{"hubRefs":{},"hubIds":{}}},"conversation":{"messages":[],"respondent":null,"isLoadMore":false},"conversations":{"conversations":[],"unreadCount":0,"pagesCount":0,"isLoadMore":false},"desktopState":{"desktopFl":null,"desktopHl":null,"isChecked":false,"isLoginDemanded":false},"docs":{"menu":{},"articles":{},"mainMenu":[],"loading":{"main":false,"dropdown":false,"article":false}},"feature":{"isProbablyVisible":"true"},"flows":{"flows":[{"alias":"develop","id":1,"route":{"name":"FLOW_PAGE","params":{"flowName":"develop"}}},{"alias":"admin","id":6,"route":{"name":"FLOW_PAGE","params":{"flowName":"admin"}}},{"alias":"design","id":2,"route":{"name":"FLOW_PAGE","params":{"flowName":"design"}}},{"alias":"management","id":3,"route":{"name":"FLOW_PAGE","params":{"flowName":"management"}}},{"alias":"marketing","id":4,"route":{"name":"FLOW_PAGE","params":{"flowName":"marketing"}}},{"alias":"popsci","id":7,"route":{"name":"FLOW_PAGE","params":{"flowName":"popsci"}}}]},"global":{"isPwa":false,"device":"desktop","isHabrCom":true},"hubs":{"hubRefs":{},"hubIds":{},"pagesCount":{},"isLoading":false,"route":{}},"hubsBlock":{"hubRefs":{},"hubIds":{}},"i18n":{"fl":"ru","hl":"ru"},"info":{"infoPage":{},"isLoading":true},"location":{"urlStruct":{"protocol":null,"slashes":null,"auth":null,"host":null,"port":null,"hostname":null,"hash":null,"search":null,"query":{},"pathname":null,"path":null,"href":""},"searchQuery":null},"me":{"user":null,"ppgDemanded":false,"karmaResetInfo":{"canReincarnate":null,"wasReincarnated":null,"currentScore":null},"notes":null},"mostReadingList":{"mostReadingListIds":[],"mostReadingListRefs":null,"promoPost":null},"pinnedPost":{"pinnedPost":null},"ppa":{"articles":{},"card":null,"transactions":null,"totalTransactions":null,"isAccessible":null},"projectsBlocks":{"activeBlocks":{}},"promoData":{"isLoading":false,"hasLoaded":false,"featurer":null,"megaposts":null,"promoLinks":null,"promoPosts":null},"pullRefresh":{"shouldRefresh":false},"sandbox":{"articleIds":[],"articleRefs":{},"pagesCount":null,"route":{},"lastVisitedRoute":{},"isLoading":false},"search":{"searchQueryError":null},"settingsOther":{"inputs":{"uiLang":{"errors":[],"ref":null,"value":""},"articlesLangEnglish":{"errors":[],"ref":null,"value":false},"articlesLangRussian":{"errors":[],"ref":null,"value":false},"agreement":{"errors":[],"ref":null,"value":false},"email":{"errors":[],"ref":null,"value":true},"digest":{"errors":[],"ref":null,"value":true}}},"similarList":{"similarListIds":[],"similarListRefs":null},"ssr":{"error":null,"isDataLoaded":false,"isDataLoading":false,"isHydrationFailed":false,"isServer":false},"technotext":{"nominationsList":[]},"userHubsContribution":{"contributionRefs":{"hubRefs":{},"hubIds":{}}},"userInvites":{"availableInvites":0,"usedInvitesIds":[],"usedInvitesRefs":{},"usedInvitesPagesCount":0,"unusedInvitesIds":[],"unusedInvitesRefs":{},"unusedInvitesPagesCount":0},"users":{"authorRefs":{},"authorIds":{},"pagesCount":{},"authorProfiles":{},"userHubs":{},"userInvitations":{},"authorFollowers":{},"authorFollowed":{},"userSpecialization":{},"karmaStats":[],"statistics":null,"isLoading":false,"authorFollowersLoading":false,"authorFollowedLoading":false,"userHubsLoading":false,"userInvitationsLoading":false,"route":{}},"viewport":{"prevScrollY":{},"scrollY":0,"width":0},"tracker":{"items":{},"pagesCache":{},"markedViewedSilently":{},"markedRead":{},"unreadCounters":{"applications":null,"system":null,"mentions":null,"subscribers":null,"posts_and_comments":null},"unviewedCounters":{"applications":null,"system":null,"mentions":null,"subscribers":null,"posts_and_comments":null}}};(function(){var s;(s=document.currentScript||document.scripts[document.scripts.length-1]).parentNode.removeChild(s);}());</script>
<script src="https://assets.habr.com/habr-web/js/chunk-vendors.da6c6b36.js" defer></script><script src="https://assets.habr.com/habr-web/js/app.92df6f6d.js" defer></script>



    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    </script>
  
  <script type="text/javascript" >
    (function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
    m[i].l=1*new Date();k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})
    (window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");

    ym(24049213, "init", {
      defer:true,
      trackLinks:true,
      accurateTrackBounce:true,
      webvisor:false,
    });
  </script>
  <noscript>
    <div>
      <img src="https://mc.yandex.ru/watch/24049213" style="position:absolute; left:-9999px;" alt="" />
    </div>
  </noscript>
  
    <script type="text/javascript">
      window.addEventListener('load', function () {
        setTimeout(() => {
          const img = new Image();
          img.src = 'https://vk.com/rtrg?p=VK-RTRG-421343-57vKE';
        }, 0);
      });
    </script>
  
<script src="https://habr.com/js/ads.js" onload="window['zhY4i4nJ9K'] = true"></script>
</body>
</html>
