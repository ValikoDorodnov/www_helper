<!DOCTYPE html>
<html lang="ru" data-vue-meta="%7B%22lang%22:%7B%22ssr%22:%22ru%22%7D%7D">
<head >
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1.0,viewport-fit=cover">
  <meta name="referrer" content="unsafe-url">
  <title>Пирамида тестов на практике / Хабр</title>
  <style>
    /* cyrillic-ext */
    @font-face {
      font-family: 'Fira Sans';
      font-style: normal;
      font-weight: 500;
      font-display: swap;
      src: url(https://fonts.gstatic.com/s/firasans/v11/va9B4kDNxMZdWfMOD5VnZKveSxf6TF0.woff2) format('woff2');
      unicode-range: U+0460-052F, U+1C80-1C88, U+20B4, U+2DE0-2DFF, U+A640-A69F, U+FE2E-FE2F;
    }

    /* cyrillic */
    @font-face {
      font-family: 'Fira Sans';
      font-style: normal;
      font-weight: 500;
      font-display: swap;
      src: url(https://fonts.gstatic.com/s/firasans/v11/va9B4kDNxMZdWfMOD5VnZKveQhf6TF0.woff2) format('woff2');
      unicode-range: U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116;
    }

    /* latin-ext */
    @font-face {
      font-family: 'Fira Sans';
      font-style: normal;
      font-weight: 500;
      font-display: swap;
      src: url(https://fonts.gstatic.com/s/firasans/v11/va9B4kDNxMZdWfMOD5VnZKveSBf6TF0.woff2) format('woff2');
      unicode-range: U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;
    }

    /* latin */
    @font-face {
      font-family: 'Fira Sans';
      font-style: normal;
      font-weight: 500;
      font-display: swap;
      src: url(https://fonts.gstatic.com/s/firasans/v11/va9B4kDNxMZdWfMOD5VnZKveRhf6.woff2) format('woff2');
      unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
    }

    /* non-breaking hyphen */
    @font-face {
      font-family: 'Fira Sans';
      font-style: normal;
      font-weight: 500;
      font-display: swap;
      src: url(https://fonts.gstatic.com/l/font?kit=KFOlCnqEu92Fr1MmEU9vBh0_IsHAlmrO6g&skey=ee881451c540fdec&v=v29) format('woff2');
      unicode-range: U+02011;
    }
  </style>
  <link rel="preload" href="https://assets.habr.com/habr-web/css/chunk-vendors.e7843cc0.css" as="style"><link rel="preload" href="https://assets.habr.com/habr-web/js/chunk-vendors.da6c6b36.js" as="script"><link rel="preload" href="https://assets.habr.com/habr-web/css/app.4de4e95a.css" as="style"><link rel="preload" href="https://assets.habr.com/habr-web/js/app.92df6f6d.js" as="script">
  <link rel="stylesheet" href="https://assets.habr.com/habr-web/css/chunk-vendors.e7843cc0.css"><link rel="stylesheet" href="https://assets.habr.com/habr-web/css/app.4de4e95a.css">
  <script>window.i18nFetch = new Promise((res, rej) => {
          const xhr = new XMLHttpRequest();
          xhr.open('GET', '/js/i18n/ru-compiled.2822d469ec31a56409ac330bbcf7fcbf.json');
          xhr.responseType = 'json';
          xhr.onload = function(e) {
            if (this.status === 200) {
              res({ru: xhr.response});
            } else {
              rej(e);
            }
          };
          xhr.send();
        });</script>
  
  <script data-vue-meta="ssr" type="application/ld+json" data-vmid="ldjson-schema">{"@context":"http:\/\/schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/habr.com\/ru\/post\/358950\/"},"headline":"Пирамида тестов на практике","datePublished":"2018-05-20T14:38:20+03:00","dateModified":"2018-05-20T16:26:55+03:00","author":{"@type":"Person","name":"Анатолий Ализар"},"publisher":{"@type":"Organization","name":"Habr","logo":{"@type":"ImageObject","url":"https:\/\/habrastorage.org\/webt\/a_\/lk\/9m\/a_lk9mjkccjox-zccjrpfolmkmq.png"}},"description":"Об авторе: Хэм Фокке &mdash; разработчик и консультант ThoughtWorks в Германии. Устав от деплоя в три ночи, он добавил в свой инструментарий средства непрерывной доста...","url":"https:\/\/habr.com\/ru\/post\/358950\/#post-content-body","about":["h_microformats","h_it_testing","h_web_testing","h_dev_management","h_devops","f_develop","f_management","f_admin"],"image":["https:\/\/habrastorage.org\/getpro\/habr\/post_images\/753\/224\/111\/753224111d9c766c7e6040411e6a5cf9.jpg","https:\/\/habrastorage.org\/getpro\/habr\/post_images\/ea3\/308\/1dd\/ea33081ddc613a817b10881041035a29.png","https:\/\/habrastorage.org\/getpro\/habr\/post_images\/a3a\/60c\/b8b\/a3a60cb8b4d4f10699cc6862d5bcf8fc.png","https:\/\/habrastorage.org\/getpro\/habr\/post_images\/f6c\/930\/f2d\/f6c930f2d4ae8a6068696ace34e9566e.png","https:\/\/habrastorage.org\/getpro\/habr\/post_images\/813\/284\/1c5\/8132841c5c334aad6d292c69c1807de3.png","https:\/\/habrastorage.org\/getpro\/habr\/post_images\/ae4\/727\/6e6\/ae47276e66f80ee73f38ea2a995b8c13.png","https:\/\/habrastorage.org\/getpro\/habr\/post_images\/9be\/489\/778\/9be48977803c4fd5bd9882450db5b4ff.png","https:\/\/habrastorage.org\/getpro\/habr\/post_images\/089\/6ef\/aaf\/0896efaaf776a8d308a008d0d2ef625e.png","https:\/\/habrastorage.org\/getpro\/habr\/post_images\/15b\/98f\/5bd\/15b98f5bd52634719eff1280a4117f3b.png","https:\/\/habrastorage.org\/getpro\/habr\/post_images\/420\/a0f\/17c\/420a0f17c800a1ac4a65a883813da8ae.png","https:\/\/habrastorage.org\/getpro\/habr\/post_images\/25e\/dba\/1c2\/25edba1c2090bc04cf76e018a53ee451.png","https:\/\/habrastorage.org\/getpro\/habr\/post_images\/1e1\/d34\/9b2\/1e1d349b260edb4f442fac4bcbabb8b1.png","https:\/\/habrastorage.org\/getpro\/habr\/post_images\/91a\/118\/3e7\/91a1183e77f1850a1df00b819503b109.png","https:\/\/habrastorage.org\/getpro\/habr\/post_images\/65d\/c55\/38f\/65dc5538f1f4ff98c973d5cc43f6a152.png"]}</script>
  <script src="https://www.googletagservices.com/tag/js/gpt.js" async></script>
  <style>.grecaptcha-badge{visibility: hidden;}</style>
  <meta name="habr-version" content="2.64.0">
  
  <meta data-vue-meta="ssr" property="fb:app_id" content="444736788986613"><meta data-vue-meta="ssr" property="fb:pages" content="472597926099084"><meta data-vue-meta="ssr" name="twitter:card" content="summary_large_image"><meta data-vue-meta="ssr" name="twitter:site" content="@habr_com"><meta data-vue-meta="ssr" property="og:site_name" content="Хабр" data-vmid="og:site_name"><meta data-vue-meta="ssr" property="og:title" content="Пирамида тестов на практике" data-vmid="og:title"><meta data-vue-meta="ssr" name="twitter:title" content="Пирамида тестов на практике" data-vmid="twitter:title"><meta data-vue-meta="ssr" name="aiturec:title" content="Пирамида тестов на практике" data-vmid="aiturec:title"><meta data-vue-meta="ssr" name="description" content="Об авторе: Хэм Фокке — разработчик и консультант ThoughtWorks в Германии. Устав от деплоя в три ночи, он добавил в свой инструментарий средства непрерывной доставки и тщательной автоматизации. Сейчас..." data-vmid="description"><meta data-vue-meta="ssr" itemprop="description" content="Об авторе: Хэм Фокке — разработчик и консультант ThoughtWorks в Германии. Устав от деплоя в три ночи, он добавил в свой инструментарий средства непрерывной доставки и тщательной автоматизации. Сейчас..." data-vmid="description:itemprop"><meta data-vue-meta="ssr" property="og:description" content="Об авторе: Хэм Фокке — разработчик и консультант ThoughtWorks в Германии. Устав от деплоя в три ночи, он добавил в свой инструментарий средства непрерывной доставки и тщательной автоматизации. Сейчас..." data-vmid="og:description"><meta data-vue-meta="ssr" name="twitter:description" content="Об авторе: Хэм Фокке — разработчик и консультант ThoughtWorks в Германии. Устав от деплоя в три ночи, он добавил в свой инструментарий средства непрерывной доставки и тщательной автоматизации. Сейчас..." data-vmid="twitter:description"><meta data-vue-meta="ssr" property="aiturec:description" content="Об авторе: Хэм Фокке — разработчик и консультант ThoughtWorks в Германии. Устав от деплоя в три ночи, он добавил в свой инструментарий средства непрерывной доставки и тщательной автоматизации. Сейчас..." data-vmid="aiturec:description"><meta data-vue-meta="ssr" itemprop="image" content="https://habr.com/share/publication/358950/35e3dde4f2d0faf7cd6ce5000dc545b6/" data-vmid="image:itemprop"><meta data-vue-meta="ssr" property="og:image" content="https://habr.com/share/publication/358950/35e3dde4f2d0faf7cd6ce5000dc545b6/" data-vmid="og:image"><meta data-vue-meta="ssr" property="og:image:width" content="1200" data-vmid="og:image:width"><meta data-vue-meta="ssr" property="og:image:height" content="630" data-vmid="og:image:height"><meta data-vue-meta="ssr" property="aiturec:image" content="https://habr.com/share/publication/358950/35e3dde4f2d0faf7cd6ce5000dc545b6/" data-vmid="aiturec:image"><meta data-vue-meta="ssr" name="twitter:image" content="https://habr.com/share/publication/358950/35e3dde4f2d0faf7cd6ce5000dc545b6/" data-vmid="twitter:image"><meta data-vue-meta="ssr" property="vk:image" content="https://habr.com/share/publication/358950/35e3dde4f2d0faf7cd6ce5000dc545b6/?format=vk" data-vmid="vk:image"><meta data-vue-meta="ssr" property="aiturec:item_id" content="358950" data-vmid="aiturec:item_id"><meta data-vue-meta="ssr" property="aiturec:datetime" content="2018-05-20T11:38:20.000Z" data-vmid="aiturec:datetime"><meta data-vue-meta="ssr" content="https://habr.com/ru/post/358950/" property="og:url" data-vmid="og:url"><meta data-vue-meta="ssr" property="og:type" content="article" data-vmid="og:type"><meta data-vue-meta="ssr" property="og:locale" content="ru_RU" data-vmid="og:locale"><meta data-vue-meta="ssr" name="keywords" content="DevOps, пирамида тестов, Junit, Mockito, Wiremock, Pact, Selenium, REST-assured, Spring, TDD, SOLID, CDC-тесты, интеграционные тесты, модульные тесты, юнит-тесты, контрактные тесты, YAGNI, JSON, Galen, headless-браузер">
  <link data-vue-meta="ssr" href="https://habr.com/ru/rss/post/358950/?fl=ru" type="application/rss+xml" title="" rel="alternate" name="rss"><link data-vue-meta="ssr" href="index.html.1.44.html" rel="canonical" data-vmid="canonical"><link data-vue-meta="ssr" data-vmid="hreflang"><link data-vue-meta="ssr" image_src="image" href="https://habr.com/share/publication/358950/35e3dde4f2d0faf7cd6ce5000dc545b6/" data-vmid="image:href">
  <meta name="apple-mobile-web-app-status-bar-style" content="#303b44">
  <meta name="msapplication-TileColor" content="#629FBC">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="mobile-web-app-capable" content="yes">
  <link
    rel="shortcut icon"
    type="image/png"
    sizes="16x16"
    href="https://assets.habr.com/habr-web/img/favicons/favicon-16.png"
  >
  <link
    rel="shortcut icon"
    type="image/png"
    sizes="32x32"
    href="https://assets.habr.com/habr-web/img/favicons/favicon-32.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="76x76"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-76.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="120x120"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-120.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="152x152"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-152.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="180x180"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-180.png"
  >
  <link
    rel="apple-touch-icon"
    type="image/png"
    sizes="256x256"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-256.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1136x640.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2436x1125.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1792x828.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_828x1792.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1334x750.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1242x2668.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 736px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2208x1242.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1125x2436.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 736px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1242x2208.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2732x2048.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2688x1242.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 834px) and (device-height: 1112px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2224x1668.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_750x1334.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2048x2732.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2388x1668.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 834px) and (device-height: 1112px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1668x2224.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_640x1136.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1668x2388.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_2048x1536.png"
  >
  <link
    rel="apple-touch-startup-image"
    media="screen and (device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
    href="https://assets.habr.com/habr-web/img/splashes/splash_1536x2048.png"
  >
  <link
    rel="mask-icon"
    color="#77a2b6"
    href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-120.svg"
  >
  <link
    crossorigin="use-credentials"
    href="https://habr.com/manifest.webmanifest"
    rel="manifest"
  >
</head>
<body>


<div id="app" data-server-rendered="true" data-async-called="true"><div class="tm-layout__wrapper"><!----> <div></div> <!----> <header class="tm-header"><div class="tm-page-width"><div class="tm-header__container"><!----> <span class="tm-header__logo-wrap"><a href="https://habr.com/ru/" class="tm-header__logo tm-header__logo_ru"><svg height="16" width="16" class="tm-svg-img tm-header__icon"><title>Хабр</title> <use xlink:href="/img/habr-logo-ru.svg#logo"></use></svg></a> <span class="tm-header__beta-sign" style="display:none;">β</span></span> <div class="tm-dropdown tm-header__projects"><div class="tm-dropdown__head"><button class="tm-header__dropdown-toggle"><svg height="16" width="16" class="tm-svg-img tm-header__icon tm-header__icon_dropdown"><title>Открыть список</title> <use xlink:href="/img/megazord-v25.4b679db1.svg#arrow-down"></use></svg></button></div> <!----></div> <a href="https://habr.com/ru/sandbox/start/" class="tm-header__become-author-btn">
            Как стать автором
          </a> <div class="tm-feature tm-header__feature tm-feature_variant-inline"><!----></div> <!----> <!----></div></div></header> <div class="tm-layout"><div class="tm-page-progress-bar"></div> <div data-menu-sticky="true" class="tm-base-layout__header tm-base-layout__header_is-sticky"><div class="tm-page-width"><div class="tm-base-layout__header-wrapper"><div class="tm-main-menu"><div class="tm-main-menu__section"><nav class="tm-main-menu__section-content"><!----> <a href="https://habr.com/ru/flows/all" class="tm-main-menu__item">
        Все потоки
      </a> <a href="https://habr.com/ru/flows/develop/" class="tm-main-menu__item">
          Разработка
        </a><a href="https://habr.com/ru/flows/admin/" class="tm-main-menu__item">
          Администрирование
        </a><a href="https://habr.com/ru/flows/design/" class="tm-main-menu__item">
          Дизайн
        </a><a href="https://habr.com/ru/flows/management/" class="tm-main-menu__item">
          Менеджмент
        </a><a href="https://habr.com/ru/flows/marketing/" class="tm-main-menu__item">
          Маркетинг
        </a><a href="https://habr.com/ru/flows/popsci/" class="tm-main-menu__item">
          Научпоп
        </a></nav></div></div> <div class="tm-header-user-menu tm-base-layout__user-menu"><a href="https://habr.com/ru/search/" class="tm-header-user-menu__item tm-header-user-menu__search"><svg height="24" width="24" class="tm-svg-img tm-header-user-menu__icon tm-header-user-menu__icon_search tm-header-user-menu__icon_dark"><title>Поиск</title> <use xlink:href="/img/megazord-v25.4b679db1.svg#search"></use></svg></a> <!----> <!----> <!----> <div class="tm-header-user-menu__item tm-header-user-menu__user_desktop"><div class="tm-dropdown"><div class="tm-dropdown__head"><svg height="24" width="24" data-test-id="menu-toggle-guest" class="tm-svg-img tm-header-user-menu__icon"><title>Профиль</title> <use xlink:href="/img/megazord-v25.4b679db1.svg#header-user"></use></svg> <!----></div> <!----></div> <!----></div> <!----></div></div></div></div> <!----> <div class="tm-page-width"></div> <main class="tm-layout__container"><div hl="ru" data-async-called="true" class="tm-page"><div class="tm-page-width"><!----> <div class="tm-page__wrapper"><div class="tm-page__main tm-page__main_has-sidebar"><div class="pull-down"><div class="pull-down__header" style="height:0px;"><div class="pull-down__content" style="bottom:10px;"><svg height="24" width="24" class="tm-svg-img pull-down__arrow"><title>Обновить</title> <use xlink:href="/img/megazord-v25.4b679db1.svg#pull-arrow"></use></svg></div></div> <div class="tm-article-presenter"> <div class="tm-article-presenter__body"><div class="tm-misprint-area"><div class="tm-misprint-area__wrapper"><article class="tm-article-presenter__content tm-article-presenter__content_narrow"><div class="tm-article-presenter__header"> <div class="tm-article-snippet tm-article-presenter__snippet"><div class="tm-article-snippet__meta-container"><div class="tm-article-snippet__meta"><span class="tm-user-info tm-article-snippet__author"><a href="https://habr.com/ru/users/m1rko/" title="m1rko" class="tm-user-info__userpic"><div class="tm-entity-image"><img alt="" height="24" src="https://habrastorage.org/r/w32/getpro/habr/avatars/4ec/bd0/85d/4ecbd085d692835a931d03174ff19539.png" width="24" class="tm-entity-image__pic"></div></a> <span class="tm-user-info__user"><a href="https://habr.com/ru/users/m1rko/" class="tm-user-info__username">
      m1rko
    </a> </span></span> <span class="tm-article-snippet__datetime-published"><time datetime="2018-05-20T11:38:20.000Z" title="2018-05-20, 14:38">20  мая  2018 в 14:38</time></span></div> <!----></div> <h1 lang="ru" class="tm-article-snippet__title tm-article-snippet__title_h1"><span>Пирамида тестов на практике</span></h1> <div class="tm-article-snippet__hubs"><span class="tm-article-snippet__hubs-item"><a href="https://habr.com/ru/hub/microformats/" class="tm-article-snippet__hubs-item-link"><span>Микроформаты</span> <span title="Профильный хаб" class="tm-article-snippet__profiled-hub">*</span></a></span><span class="tm-article-snippet__hubs-item"><a href="https://habr.com/ru/hub/it_testing/" class="tm-article-snippet__hubs-item-link"><span>Тестирование IT-систем</span> <span title="Профильный хаб" class="tm-article-snippet__profiled-hub">*</span></a></span><span class="tm-article-snippet__hubs-item"><a href="https://habr.com/ru/hub/web_testing/" class="tm-article-snippet__hubs-item-link"><span>Тестирование веб-сервисов</span> <span title="Профильный хаб" class="tm-article-snippet__profiled-hub">*</span></a></span><span class="tm-article-snippet__hubs-item"><a href="https://habr.com/ru/hub/dev_management/" class="tm-article-snippet__hubs-item-link"><span>Управление разработкой</span> <span title="Профильный хаб" class="tm-article-snippet__profiled-hub">*</span></a></span><span class="tm-article-snippet__hubs-item"><a href="https://habr.com/ru/hub/devops/" class="tm-article-snippet__hubs-item-link"><span>DevOps</span> <span title="Профильный хаб" class="tm-article-snippet__profiled-hub">*</span></a></span></div> <div class="tm-article-snippet__labels"><div class="tm-article-snippet__label tm-article-snippet__label_variant-translation"><span>
        Перевод
      </span></div></div> <!----> <!----></div></div> <div class="tm-article-presenter__origin"><a href="https://martinfowler.com/articles/practical-test-pyramid.html" target="_blank" class="tm-article-presenter__origin-link">
                Автор оригинала:
                <span>
                  Ham Vocke
                </span></a></div> <div data-gallery-root="" lang="ru" class="tm-article-body"><div></div> <div id="post-content-body"><div><div class="article-formatted-body article-formatted-body_version-1"><div xmlns="http://www.w3.org/1999/xhtml"><img src="https://habrastorage.org/r/w780q1/getpro/habr/post_images/753/224/111/753224111d9c766c7e6040411e6a5cf9.jpg" align="left" data-src="https://habrastorage.org/getpro/habr/post_images/753/224/111/753224111d9c766c7e6040411e6a5cf9.jpg" data-blurred="true"/><font color="gray">Об авторе: <b><a href="http://www.hamvocke.com/">Хэм Фокке</a></b> — разработчик и консультант ThoughtWorks в Германии. Устав от деплоя в три ночи, он добавил в свой инструментарий средства непрерывной доставки и тщательной автоматизации. Сейчас налаживает такие системы другим командам для обеспечения надёжной и эффективной поставки программного обеспечения. Так он экономит компаниям время, которое эти надоедливые людишки тратили на свои выходки.</font> <br/>
<br/>
«Пирамида тестов» — метафора, которая означает группировку тестов программного обеспечения по разным уровням детализации. Она также даёт представление, сколько тестов должно быть в каждой из этих групп. Несмотря на то, что концепция тестовой пирамиды существует довольно давно, многие команды разработчиков по-прежнему пытаются неправильно реализовать её на практике должным образом. В этой статье рассматривается первоначальная концепция тестовой пирамиды и показано, как её воплотить в жизнь. Она показывает, какие виды тестов следует искать на разных уровнях пирамиды, и даёт практические примеры, как их можно реализовать.<br/>
<br/>
<div class="spoiler"><b class="spoiler_title">Содержание</b><div class="spoiler_text"><ul>
<li><a href="index.html.1.44.html#TheImportanceOftestAutomation">Важность автоматизации (тестов)</a></li>
<li><a href="index.html.1.44.html#TheTestPyramid">Пирамида тестов</a></li>
<li><a href="index.html.1.44.html#ToolsAndLibrariesWellLookAt">Какие инструменты и библиотеки мы рассмотрим</a></li>
<li><a href="index.html.1.44.html#TheSampleApplication">Пример приложения</a><br/>
<ul>
<li><a href="index.html.1.44.html#Functionality">Функциональность</a></li>
<li><a href="index.html.1.44.html#High-levelStructure">Высокоуровневые структуры</a></li>
<li><a href="index.html.1.44.html#InternalArchitecture">Внутренняя архитектура</a></li>
</ul></li>
<li><a href="index.html.1.44.html#UnitTests">Юнит-тесты</a><br/>
<ul>
<li><a href="index.html.1.44.html#WhatsAUnit">Что такое юнит?</a></li>
<li><a href="index.html.1.44.html#SociableAndSolitary">Общительные и одинокие тесты</a></li>
<li><a href="index.html.1.44.html#MockingAndStubbing">Имитации и заглушки</a></li>
<li><a href="index.html.1.44.html#WhatToTest">Что тестировать?</a></li>
<li><a href="index.html.1.44.html#TestStructure">Структура теста</a></li>
<li><a href="index.html.1.44.html#ImplementingAUnitTest">Реализация юнит-теста</a></li>
</ul></li>
<li><a href="index.html.1.44.html#IntegrationTests">Интеграционные тесты</a><br/>
<ul>
<li><a href="index.html.1.44.html#DatabaseIntegration">Интеграция БД</a></li>
<li><a href="index.html.1.44.html#IntegrationWithSeparateServices">Интеграция с отдельными сервисами</a></li>
</ul></li>
<li><a href="index.html.1.44.html#ContractTests">Контрактные тесты</a><br/>
<ul>
<li><a href="index.html.1.44.html#ConsumerTestourTeam">Тест потребителя (наша команда)</a></li>
<li><a href="index.html.1.44.html#ProviderTesttheOtherTeam">Тест поставщика (другая команда)</a></li>
<li><a href="index.html.1.44.html#ProviderTestourTeam">Тест поставщика (наша команда)</a></li>
</ul></li>
<li><a href="index.html.1.44.html#UiTests">Тесты UI</a></li>
<li><a href="index.html.1.44.html#End-to-endTests">Сквозные тесты</a><br/>
<ul>
<li><a href="index.html.1.44.html#UserInterfaceEnd-to-endTest">Сквозные тесты пользовательского интерфейса</a></li>
<li><a href="index.html.1.44.html#RestApiEnd-to-endTest">Сквозной тест REST API</a></li>
</ul></li>
<li><a href="index.html.1.44.html#acceptance">Приёмочные тесты — ваши фичи правильно работают?</a></li>
<li><a href="index.html.1.44.html#ExploratoryTesting">Исследовательское тестирование</a></li>
<li><a href="index.html.1.44.html#TheConfusionAboutTestingTerminology">Путаница с терминологией в тестировании</a></li>
<li><a href="index.html.1.44.html#PuttingTestsIntoYourDeploymentPipeline">Внедрение тестов в конвейер развёртывания</a></li>
<li><a href="index.html.1.44.html#AvoidTestDuplication">Избегайте дублирования тестов</a></li>
<li><a href="index.html.1.44.html#WritingCleanTestCode">Пишите чистый код для тестов</a></li>
<li><a href="index.html.1.44.html#Conclusion">Заключение</a></li>
</ul><br/>
<b>Примечания</b><br/>
<br/>
<ul>
<li><a href="index.html.1.44.html#private-methods-sidebar">Но мне действительно нужно протестировать этот закрытый метод</a></li>
<li><a href="index.html.1.44.html#SpecialisedTestHelpers">Специализированные тестовые хелперы</a></li>
</ul></div></div><a name="habracut"></a><div style="text-align:center;"><img src="https://habrastorage.org/r/w1560/getpro/habr/post_images/ea3/308/1dd/ea33081ddc613a817b10881041035a29.png" data-src="https://habrastorage.org/getpro/habr/post_images/ea3/308/1dd/ea33081ddc613a817b10881041035a29.png"/></div>Перед выпуском программное обеспечение нужно тестировать. По мере взросления софтверной отрасли созрели и подходы к тестированию. Вместо мириадов живых тестировщиков разработчики перешли к автоматизации большей части тестов. Автоматизация тестов позволяет узнать о баге в считанные секунды и минуты после его внесения в код, а не через несколько дней или недель.<br/>
<br/>
Резко сокращённый цикл обратной связи, подпитываемый автоматизированными тестами, идёт рука об руку с гибкими практиками разработки, непрерывной доставкой и культурой DevOps. Эффективный подход к тестированию обеспечивает быструю и уверенную разработку.<br/>
<br/>
В этой статье рассматривается, как должен выглядеть хорошо сформированный набор тестов, чтобы быть гибким, надёжным и поддерживаемым — независимо от того, создаете ли вы архитектуру микросервисов, мобильные приложения или экосистемы IoT. Мы также детально рассмотрим создание эффективных и удобочитаемых автоматизированных тестов.<br/>
<br/>
<a name="TheImportanceOftestAutomation"></a><h1>Важность автоматизации (тестов)</h1><br/>
Программное обеспечение стало неотъемлемой частью мира, в котором мы живём. Оно переросло первоначальную единственную цель увеличить эффективность бизнеса. Сегодня каждая компания стремится стать первоклассной цифровой компанией. Все мы каждый день выступаем пользователями всё большего количества ПО. Скорость инноваций возрастает.<br/>
<br/>
Если хотите идти в ногу со временем, нужно искать более быстрые способы доставки ПО, не жертвуя его качеством. В это может помочь непрерывная доставка — это практика, которая автоматически гарантирует, что ПО может быть выпущено в продакшн в любое время. При непрерывной доставке используется конвейер сборки для автоматического тестирования ПО и его развёртывания в тестовой и рабочей средах.<br/>
<br/>
Вскоре сборка, тестирование и развёртывание постоянно растущего количества ПО вручную становится невозможной — если только вы не хотите тратить всё своё время на выполнение вручную рутинных задач вместо доставки рабочего софта. Единственный путь — автоматизировать всё, от сборки до тестирования, развёртывания и инфраструктуры.<br/>
<br/>
<img src="https://habrastorage.org/r/w1560/getpro/habr/post_images/a3a/60c/b8b/a3a60cb8b4d4f10699cc6862d5bcf8fc.png" data-src="https://habrastorage.org/getpro/habr/post_images/a3a/60c/b8b/a3a60cb8b4d4f10699cc6862d5bcf8fc.png"/><br/>
<br/>
<i><font color="gray">Рис. 1. Использование конвейеров сборки для автоматического и надёжного ввода ПО в эксплуатацию</font></i><br/>
<br/>
Традиционно тестирование требовало чрезмерной ручной работы через развертывание в тестовой среде, а затем тестов в стиле чёрного ящика, например, кликанием повсюду в пользовательском интерфейсе с наблюдением, появляются ли баги. Часто эти тесты задаются тестовыми сценариями, чтобы гарантировать, что тестировщики всё последовательно проверят.<br/>
<br/>
Очевидно, что тестирование всех изменений вручную занимает много времени, оно однообразное и утомительное. Однообразие скучно, а скука приводит к ошибкам.<br/>
<br/>
К счастью, есть прекрасный инструмент для однообразных задач: <i>автоматизация</i>.<br/>
<br/>
Автоматизация однообразных тестов изменит вашу жизнь как разработчика. Автоматизируйте тесты, и вам больше не придётся бездумно следовать клик-протоколам, проверяя корректность работы программы. Автоматизируйте тесты, и вы не моргнув глазом измените кодовую базу. Если вы когда-либо пробовали делать крупномасштабный рефакторинг без надлежащего набора тестов, я уверен, вы знаете, в какой ужас это может превратиться. Как вы узнаете, если случайно сделаете ошибку в процессе? Ну, придётся щёлкать вручную по всем тестовым случаям, как же ещё. Но будем честными: вам это действительно нравится? Как насчёт того, чтобы даже после крупномасштабных изменений любые баги проявляли себя в течение нескольких секунд, пока вы пьёте кофе? По-моему, это гораздо приятнее.<br/>
<br/>
<a name="TheTestPyramid"></a><h1>Пирамида тестов</h1><br/>
Если серьёзно подходить к автоматическим тестам, то есть одна ключевая концепция: <b>пирамида тестов</b>. Её представил Майк Кон в своей книге <i>«Scrum: гибкая разработка ПО»</i> (Succeeding With Agile. Software Development Using Scrum). Это отличная визуальная метафора, наталкивающая на мысль о разных уровнях тестов. Она также показывает объём тестов на каждом уровне.<br/>
<br/>
<div style="text-align:center;"><img src="https://habrastorage.org/r/w1560/getpro/habr/post_images/f6c/930/f2d/f6c930f2d4ae8a6068696ace34e9566e.png" data-src="https://habrastorage.org/getpro/habr/post_images/f6c/930/f2d/f6c930f2d4ae8a6068696ace34e9566e.png"/></div><br/>
<i><font color="gray">Рис. 2. Пирамида тестов</font></i><br/>
<br/>
Оригинальная пирамида тестов Майка Кона состоит из трёх уровней (снизу вверх):<br/>
<br/>
<ol>
<li>Юнит-тесты.</li>
<li>Сервисные тесты.</li>
<li>Тесты пользовательского интерфейса.</li>
</ol><br/>
К сожалению, при более тщательном концепция кажется недостаточной. Некоторые утверждают, что либо именования, либо некоторые концептуальные аспекты пирамиды тестов Майка Кона не идеальны, и я должен согласиться. С современной точки зрения пирамида тестов кажется чрезмерно упрощённой и поэтому может вводить в заблуждение.<br/>
<br/>
Тем не менее, из-за своей простоты суть тестовой пирамиды представляет хорошее эмпирическое правило, когда дело доходит до создания собственного набора тестов. Из этой пирамиды главное запомнить два принципа:<br/>
<br/>
<ol>
<li>Писать тесты разной детализации.</li>
<li>Чем выше уровень, тем меньше тестов.</li>
</ol><br/>
Придерживайтесь формы пирамиды, чтобы придумать здоровый, быстрый и поддерживаемый набор тестов. Напишите <i>много</i> маленьких и быстрых <i>юнит-тестов</i>. Напишите <i>несколько</i> более общих тестов и <i>совсем мало</i> высокоуровневых сквозных тестов, которые проверяют приложение от начала до конца. Следите, что у вас в итоге не получился <a href="https://watirmelon.blog/testing-pyramids/">тестовый рожок мороженого</a>, который станет кошмаром в поддержке и будет слишком долго выполняться.<br/>
<br/>
Не привязывайтесь слишком сильно к названиям отдельных уровней пирамиды тестов. На самом деле они могут ввести в заблуждение: термин «сервисный тест» трудно понять (сам Кон заметил, что <a href="https://www.mountaingoatsoftware.com/blog/the-forgotten-layer-of-the-test-automation-pyramid">многие разработчики полностью игнорируют этот уровень</a>). В наше время фреймворков для одностраничных приложений вроде React, Angular, Ember.js и других становится очевидным, что тестам UI не место на вершине пирамиды — вы прекрасно можете протестировать UI во всех этих фреймворках.<br/>
<br/>
Учитывая недостатки оригинальных названий в пирамиде, вполне нормально придумать другие имена для своих уровней тестов. Главное, чтобы они соответствовали вашему коду и терминологии, принятой в вашей команде.<br/>
<br/>
<a name="ToolsAndLibrariesWellLookAt"></a><h1>Какие инструменты и библиотеки мы рассмотрим</h1><br/>
<ul>
<li><a href="http://junit.org/">JUnit</a>: для запуска тестов</li>
<li><a href="http://site.mockito.org/">Mockito</a>: для зависимостей имитаций</li>
<li><a href="http://wiremock.org/">Wiremock</a>: для заглушек внешних сервисов</li>
<li><a href="https://docs.pact.io/">Pact</a>: для написания CDC-тестов</li>
<li><a href="http://docs.seleniumhq.org/">Selenium</a>: для написания сквозных тестов UI</li>
<li><a href="https://github.com/rest-assured/rest-assured">REST-assured</a>: для написания сквозных тестов REST API</li>
</ul><br/>
<a name="TheSampleApplication"></a><h1>Пример приложения</h1><br/>
Я написал <a href="https://github.com/hamvocke/spring-testing">простой микросервис</a> с тестами из разных уровней пирамиды.<br/>
<br/>
Это пример типичного микросервиса. Он предоставляет интерфейс REST, общается с БД и извлекает информацию из стороннего сервиса REST. Он реализован на <a href="https://projects.spring.io/spring-boot/">Spring Boot</a> и должен быть понятен даже если вы никогда не работали со Spring Boot.<br/>
<br/>
Обязательно проверьте <a href="https://github.com/hamvocke/spring-testing">код на Github</a>. В файле readme инструкции для запуска приложения и автоматических тестов на вашем компьютере.<br/>
<br/>
<a name="Functionality"></a><h3>Функциональность</h3><br/>
У приложения простая функциональность. Оно обеспечивает интерфейс REST с тремя конечными точками:<br/>
<br/>
<code>GET /hello<br/>
Возвращает <i>"Hello World"</i>. Всегда.<br/>
<br/>
GET /hello /{lastname}<br/>
Ищет человека с указанной фамилией. Если человек известен, возвращает <i>"Hello {Firstname} {Lastname}"</i>.<br/>
<br/>
GET /weather <br/>
Возвращает текущие погодные условия в <i>Гамбурге, Германия</i>.</code><br/>
<br/>
<a name="High-levelStructure"></a><h3>Высокоуровневые структуры</h3><br/>
На высоком уровне у системы следующая структура:<br/>
<br/>
<div style="text-align:center;"><img src="https://habrastorage.org/r/w1560/getpro/habr/post_images/813/284/1c5/8132841c5c334aad6d292c69c1807de3.png" data-src="https://habrastorage.org/getpro/habr/post_images/813/284/1c5/8132841c5c334aad6d292c69c1807de3.png"/></div><br/>
<i><font color="gray">Рис. 3. Высокоуровневая структура микросервиса</font></i><br/>
<br/>
Наш микросервис обеспечивает интерфейс REST по HTTP. Для некоторых конечных точек сервис получает информацию из БД. В других случаях обращается по HTTP к внешнему <a href="https://darksky.net/">API</a> для получения и отображения текущей погоды.<br/>
<br/>
<a name="InternalArchitecture"></a><h3>Внутренняя архитектура</h3><br/>
Изнутри у Spring Service типичная архитектура для Spring:<br/>
<br/>
<div style="text-align:center;"><img src="https://habrastorage.org/r/w1560/getpro/habr/post_images/ae4/727/6e6/ae47276e66f80ee73f38ea2a995b8c13.png" data-src="https://habrastorage.org/getpro/habr/post_images/ae4/727/6e6/ae47276e66f80ee73f38ea2a995b8c13.png"/></div><br/>
<i><font color="gray">Рис. 4. Внутренняя структура микросервиса</font></i><br/>
<br/>
<ul>
<li>Классы <code>Controller</code> предоставляют конечные точки <i>REST</i>, обрабатывают запросы <i>HTTP</i> и ответы.</li>
<li>Классы <code>Repository</code> взаимодействуют с <i>базой данных</i>, отвечают за запись и чтение данных в/из постоянного хранилища.</li>
<li>Классы <code>Client</code> взаимодействуют с другими API, в нашем случае — забирают данные <i>JSON</i> по <i>HTTPS</i> с погодного API на darksky.net.</li>
<li>Классы <code>Domain</code> захватывают <a href="https://en.wikipedia.org/wiki/Domain_model">модель домена</a>, включая логику домена (которая, честно говоря, в нашем случае довольно тривиальна).</li>
</ul><br/>
Опытные разработчики Spring могут заметить, что здесь отсутствует часто используемый слой: многие вдохновлённые <a href="https://en.wikipedia.org/wiki/Domain-driven_design">проблемно-ориентированным проектированием</a> разработчики создают <i>слой сервисов</i>, состоящий из классов <i>сервисов</i>. Я решил не включать его в приложение. Одна из причин в том, что наше приложение достаточно простое, а слой сервисов станет ненужным уровнем косвенности. Другая причина в том, что на мой взгляд люди часто переусердствуют с этими слоями. Нередко приходится видеть кодовые базы, где классы сервисов охватывают всю бизнес-логику. Модель домена становится просто слоем для данных, а не для поведения (<a href="https://en.wikipedia.org/wiki/Anemic_domain_model">анемичная модель домена</a>). Для каждого нетривиального приложения так теряются большие возможности для хорошей структуризации кода и тестируемости, а также не в полной мере используется мощь объектной ориентации.<br/>
<br/>
Наши репозитории просты и обеспечивают простую функциональность <abbr title="create, read, update, delete">CRUD</abbr>. Для простоты кода я использовал <a href="http://projects.spring.io/spring-data/">Spring Data</a>. Он даёт простую и универсальную реализацию репозитория CRUD, а также заботится о том, чтобы развернуть для наших тестов БД в памяти, а не использовать реальную PostgreSQL, как это было бы в продакшне.<br/>
<br/>
Взгляните на кодовую базу и познакомьтесь с внутренней структурой. Это полезно для следующего шага: тестирования приложения!<br/>
<br/>
<a name="UnitTests"></a><h1>Юнит-тесты</h1><br/>
Основа вашего набора тестов состоит из юнит-тестов (модульных тестов). Они проверяют, что отдельный юнит (<i>тестируемый субъект</i>) кодовой базы работает должным образом. Модульные тесты имеют максимально узкую область среди всех тестов в наборе тестов. Количество юнит-тестов в наборе значительно превышает количество любых других тестов.<br/>
<br/>
<div style="text-align:center;"><img src="https://habrastorage.org/r/w1560/getpro/habr/post_images/9be/489/778/9be48977803c4fd5bd9882450db5b4ff.png" data-src="https://habrastorage.org/getpro/habr/post_images/9be/489/778/9be48977803c4fd5bd9882450db5b4ff.png"/></div><br/>
<i><font color="gray">Рис. 5. Обычно юнит-тест заменяет внешних пользователей тестовыми дублями</font></i><br/>
<br/>
<a name="WhatsAUnit"></a><h3>Что такое юнит?</h3><br/>
Если вы спросите трёх разных людей, что означает <i>«юнит»</i> в контексте юнит-тестов, то вероятно получите четыре разных, слегка отличающихся ответа. В определённой степени это вопрос вашего собственного определения — и это нормально, что здесь нет общепринятого канонического ответа.<br/>
<br/>
Если вы пишете на функциональном языке, то юнитом скорее всего будет отдельная функция. Ваши юнит-тесты вызовут функцию с различными параметрами и обеспечат возврат ожидаемых значений. В объектно-ориентированном языке юнит может варьироваться от отдельного метода до целого класса.<br/>
<br/>
<a name="SociableAndSolitary"></a><h3>Общительные и одинокие тесты</h3><br/>
Некоторые утверждают, что всех участников (например, вызываемые классы) тестируемого субъекта следует заменить на <i>имитации</i> (mocks) или <i>заглушки</i> (stubs), чтобы создать идеальную изоляцию, избежать побочных эффектов и сложной настройки теста. Другие утверждают, что на имитации и заглушки следует заменять только участников, которые замедляют тест или проявляют сильные побочные эффекты (например, классы с доступом к БД или сетевыми вызовами).<br/>
<br/>
<a href="https://martinfowler.com/bliki/UnitTest.html">Иногда</a> эти два вида юнит-тестов называют <b>одинокими</b> (solitary) в случае тотального применения имитаций и заглушек или <b>общительными</b> (sociable) в случае реальных коммуникаций с другими участниками (эти термины придумал Джей Филдс для книги <a href="https://leanpub.com/wewut">«Эффективная работа с юнит-тестами»</a>). Если у вас есть немного свободного времени, можете спуститься в кроличью нору и <a href="https://martinfowler.com/articles/mocksArentStubs.html">разобраться в преимуществах и недостатках</a> разных точек зрения.<br/>
<br/>
Но в итоге не имеет значения, какой тип тестов вы выберете. Что реально важно, так это их автоматизация. Лично я постоянно использую оба подхода. Если неудобно работать с реальными участниками, я буду обильно использовать имитации и заглушки. Если чувствую, что привлечение реального участника даёт больше уверенности в тесте, то заглушу только самые дальние части сервиса.<br/>
<br/>
<a name="MockingAndStubbing"></a><h3>Имитации и заглушки</h3><br/>
Имитации (mocks) и заглушки (stubs) — это два разных типа <a href="https://martinfowler.com/bliki/TestDouble.html">тестовых дублёров</a> (вообще их больше). Многие используют термины взаимозаменяемо. Думаю, что лучше соблюдать точность и держать в уме конкретные свойства каждого из них. К объектам из продакшна тестовые дублёры создают реализацию для тестов.<br/>
<br/>
Проще говоря, вы заменяете реальную вещь (например, класс, модуль или функцию) поддельной копией. Подделка выглядит и действует как оригинал (даёт такие же ответы на те же вызовы методов), но это заранее установленные ответы, которые вы сами определяете для юнит-теста.<br/>
<br/>
Тестовые дублёры используются не только в юнит-тестах. Более сложные дублёры применяются для контролируемой имитации целых частей вашей системы. Однако в юнит-тестах используется особенно много имитаций и заглушек (в зависимости от того, предпочитаете вы общительные или одиночные тесты) просто потому что множество современных языков и библиотек позволяют легко и удобно их создавать.<br/>
<br/>
Независимо от выбранной технологии, в стандартной библиотеке вашего языка или какой-то популярной сторонней библиотеке уже есть элегантный способ настройки имитаций. И даже для написания собственных имитаций с нуля достаточно всего лишь написать поддельный класс/модуль/функцию с той же подписью, что и реальная, и настройки имитации для теста.<br/>
<br/>
Ваши юнит-тесты будут работать очень быстро. На приличной машине можно прогнать тысячи модульных тестов за нескольких минут. Тестируйте изолированно небольшие фрагменты кодовой базы и избегайте контактов с БД, файловой системой и HTTP-запросов (ставя здесь имитации и заглушки), чтобы сохранить высокую скорость.<br/>
<br/>
Поняв основы, со временем вы начнёте всё более свободно и легко писать юнит-тесты. Заглушка внешних участников, настройка входных данных, вызов тестируемого субъекта — и проверка, что возвращаемое значение соответствует ожидаемому. Посмотрите на <a href="https://en.wikipedia.org/wiki/Test-driven_development">разработку через тестирование</a> (TDD), и пусть юнит-тесты направляют вашу разработку; если они применяются правильно, это поможет попасть в мощный поток и создать хорошую поддерживаемую архитектуру, автоматически выдавая всеобъемлющий и полностью автоматизированный набор тестов. Но это не универсальное решение. Попробуйте и посмотрите сами, подходит ли TDD в вашем конкретном случае.<br/>
<br/>
<a name="WhatToTest"></a><h3>Что тестировать?</h3><br/>
Хорошо, что юнит-тесты можно писать для всех классов кода продакшна, независимо от их функциональности или того, к какому уровню внутренней структуры они принадлежат. Юнит-тесты подходят для контроллеров, репозиториев, классов предметной области или программ считывания файлов. Просто придерживайтесь практического правила <b>один тестовый класс на один класс продакшна</b>.<br/>
<br/>
Юнит-тест должен как минимум <b>протестировать <i>открытый</i> интерфейс класса</b>. закрытые методы всё равно нельзя протестировать, потому что их нельзя вызвать из другого тестового класса. <i>Защищённые</i> или <i>доступные</i> лишь в пределах пакета (package-private) методы доступны из тестового класса (учитывая, что структура пакета тестового класса такая же, как на продакшне), но тестирование этих методов может уже зайти слишком далеко.<br/>
<br/>
Когда дело доходит до написания юнит-тестов, есть тонкая черта: они должны гарантировать, что проверены все нетривиальные пути кода, включая дефолтный сценарий и пограничные ситуации. В то же время они не должны быть слишком тесно привязаны к реализации.<br/>
<br/>
Почему так?<br/>
<br/>
Тесты, слишком привязанные к коду продакшна, быстро начинают раздражать. Как только вы осуществляете рефакторинг кода (то есть изменяете внутреннюю структуру кода без изменения внешнего поведения), модульные тесты сразу ломаются.<br/>
<br/>
Таким образом, вы теряете важное преимущество юнит-тестов: действовать в качестве системы безопасности для изменений кода. Вы скорее устанете от этих глупых тестов, которые падают каждый раз после рефакторинга, принося больше проблем, чем пользы; чья вообще была эта дурацкая идея внедрить тесты?<br/>
<br/>
Чем же делать? Не отражайте в модульных тестах внутреннюю структуру кода. Тестируйте наблюдаемое поведение. Например:<br/>
<br/>
<i>если я введу значения x и y, будет ли результат z?</i> <br/>
<br/>
вместо этого:<br/>
<br/>
<i>если я введу x и y, то обратится ли метод сначала к классу А, затем к классу Б, а затем сложит результаты от класса А и класса Б?</i><br/>
<br/>
Как правило, закрытые методы следует рассматривать как деталь реализации. Вот почему даже не должно появляться желание их проверить.<br/>
<br/>
Часто я слышу от противников модульного тестирования (или TDD), что написание юнит-тестов становится бессмысленным, если нужно проверить все методы для большого охвата тестирования. Они часто ссылаются на сценарии, где чрезмерно нетерпеливый тимлид заставил писать модульные тесты для геттеров и сеттеров и прочего тривиального кода, чтобы выйти на 100% тестового покрытия.<br/>
<br/>
Это совершенно неправильно.<br/>
<br/>
Да, вы должны <i>протестировать публичный интерфейс</i>. Но ещё более важно <i>не тестировать тривиальный код</i>. Не волнуйтесь, <a href="https://stackoverflow.com/questions/153234/how-deep-are-your-unit-tests/">Кент Бек это одобряет</a>. Вы ничего не получите от тестирования простых геттеров или сеттеров или других тривиальных реализаций (например, без какой-либо условной логики). И вы сэкономите время, так что сможете посидеть ещё на одном совещании, ура!<br/>
<br/>
<a name="private-methods-sidebar"></a><blockquote><b>Но мне <i>очень</i> нужно проверить этот закрытый метод</b> <br/>
Если вы когда-нибудь окажетесь в ситуации, когда вам <i>очень-очень</i> нужно проверить закрытый метод, нужно сделать шаг назад и спросить себя: почему?<br/>
<br/>
Уверен, что здесь скорее проблема дизайна. Скорее всего, вы чувствуете необходимость протестировать закрытый метод, потому что он сложный, а тестирование метода через открытый интерфейс класса требует слишком неудобной настройки.<br/>
<br/>
Всякий раз, когда я оказываюсь в такой ситуации, я обычно прихожу к выводу, что тестируемый класс переусложнён. Он делает слишком много и нарушает принцип единой ответственности — один из пяти принципов <a href="https://en.wikipedia.org/wiki/SOLID_(object-oriented_design)">SOLID</a>.<br/>
<br/>
Для меня часто работает решение разделить исходный класс на два класса. Часто после минуты-другой размышлений находится хороший способ разбить большой класс на два меньших с индивидуальной ответственностью. Я перемещаю закрытый метод (который срочно надо протестировать) в новый класс и позволяю старому классу вызвать новый метод. Вуаля, неудобный для тестирования закрытый метод теперь публичен и легко тестируется. Кроме того, я улучшил структуру кода, внедрив принцип единой ответственности.</blockquote><br/>
<a name="TestStructure"></a><h3>Cтруктура теста</h3><br/>
Хорошая структура всех ваших тестов (не только модульных) такова:<br/>
<br/>
<ol>
<li>Настройка тестовых данных.</li>
<li>Вызов тестируемого метода.</li>
<li>Проверка, что возвращаются ожидаемые результаты.</li>
</ol><br/>
Есть хорошая мнемоника для запоминания этой структуры: три A (<a href="https://xp123.com/articles/3a-arrange-act-assert/">Arrange, Act, Assert</a>). Можно использовать и другую мнемонику с корнями в BDD (разработка, основанная на описании поведения). Это триада <a href="https://martinfowler.com/bliki/GivenWhenThen.html">дано, когда, тогда</a>, где «дано» отражает настройку, «когда» — вызов метода, а «тогда» — утверждение.<br/>
<br/>
Этот шаблон можно применить и к другим, более высокоуровневым тестам. В каждом случае они гарантируют, что тесты остаются лёгкими и читаемыми. Кроме того, написанные с учётом этой структуры тесты обычно короче и выразительнее.<br/>
<br/>
<a name="ImplementingAUnitTest"></a><h3>Реализация юнит-теста</h3><br/>
Теперь мы знаем, что именно тестировать и как структурировать юнит-тесты. Пришло время посмотреть на реальный пример.<br/>
<br/>
Возьмем упрощённую версию класса <code>ExampleController</code>.<br/>
<br/>
<pre><code class="java">@RestController
public class ExampleController {

    private final PersonRepository personRepo;

    @Autowired
    public ExampleController(final PersonRepository personRepo) {
        this.personRepo = personRepo;
    }

    @GetMapping("/hello/{lastName}")
    public String hello(@PathVariable final String lastName) {
        Optional&lt;Person> foundPerson = personRepo.findByLastName(lastName);

        return foundPerson
                .map(person -> String.format("Hello %s %s!",
                        person.getFirstName(),
                        person.getLastName()))
                .orElse(String.format("Who is this '%s' you're talking about?",
                        lastName));
    }
}</code></pre><br/>
Юнит-тест для метода <code>hello(lastname)</code> может выглядеть таким образом:<br/>
<br/>
<pre><code class="java">public class ExampleControllerTest {

    private ExampleController subject;

    @Mock
    private PersonRepository personRepo;

    @Before
    public void setUp() throws Exception {
        initMocks(this);
        subject = new ExampleController(personRepo);
    }

    @Test
    public void shouldReturnFullNameOfAPerson() throws Exception {
        Person peter = new Person("Peter", "Pan");
        given(personRepo.findByLastName("Pan"))
            .willReturn(Optional.of(peter));

        String greeting = subject.hello("Pan");

        assertThat(greeting, is("Hello Peter Pan!"));
    }

    @Test
    public void shouldTellIfPersonIsUnknown() throws Exception {
        given(personRepo.findByLastName(anyString()))
            .willReturn(Optional.empty());

        String greeting = subject.hello("Pan");

        assertThat(greeting, is("Who is this 'Pan' you're talking about?"));
    }
}</code></pre><br/>
Мы пишем юнит-тесты в <a href="http://junit.org/">JUnit</a>, стандартном фреймворке тестирования Java. Используем <a href="http://site.mockito.org/">Mockito</a> для замены реального класса <code>PersonRepository</code> на класс с заглушкой для теста. Эта заглушка позволяет указать предустановленные ответы, которые вернёт метод-заглушка. Подобный подход делает тест более простым и предсказуемым, позволяя легко настроить проверку данных.<br/>
<br/>
Следуя структуре «трёх А» пишем два юнит-теста для положительного и отрицательного случаев, когда искомое лицо не может быть найдено. Положительный тестовый случай создаёт новый объект person и сообщает имитации репозитория возвращать этот объект, когда параметр <code>lastName</code> вызывается со значением <i>Pan</i>. Затем тест вызывает тестируемый метод. Наконец, он сравнивает ответ с ожидаемым.<br/>
<br/>
Второй тест работает аналогично, но тестирует сценарий, в котором тестируемый метод не находит объект person для данного параметра.<br/>
<br/>
<a name="SpecialisedTestHelpers"></a><blockquote><b>Специализированные тестовые хелперы</b><br/>
Замечательно, что вы можете писать юнит-тесты для всей кодовой базы независимо от уровня архитектуры вашего приложения. Пример ниже показывает простой юнит-тест для контроллера. К сожалению, когда дело доходит до контроллеров Spring, у этого подхода есть недостаток: контроллер Spring MVC интенсивно использует аннотации с объявлениями прослушиваемых путей, используемых команд HTTP, параметров парсинга URL, параметров запросов и так далее. Простой вызов метода контроллера в юнит-тесте не проверит все эти важные вещи. К счастью, сообщество Spring придумало хороший тестовый хелпер, который можно использовать для улучшенного тестирования контроллера. Обязательно посмотрите <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/testing.html#spring-mvc-test-server">MockMVC</a>. Это даст отличный DSL для генерации поддельных запросов к контроллеру и проверки, что всё работает отлично. Я включил <a href="https://github.com/hamvocke/spring-testing/blob/master/src/test/java/example/ExampleControllerAPITest.java">пример</a> в код. Во многих фреймворках есть тестовые хелперы для упрощения тестов конкретных частей кода. Ознакомьтесь с документацией по своему фреймворку и посмотрите, предлагает ли там какие-либо полезные хелперы для ваших автоматизированных тестов.</blockquote><br/>
<a name="IntegrationTests"></a><h1>Интеграционные тесты</h1><br/>
Все нетривиальные приложения интегрированы с некоторыми другими частями (базы данных, файловые системы, сетевые вызовы к другим приложениям). В юнит-тестах вы обычно имитируете их для лучшей изоляции и повышения скорости. Тем не менее, ваше приложение будет реально взаимодействовать с другими частями — и это следует протестировать. Для этого предназначены <a href="https://martinfowler.com/bliki/IntegrationTest.html">интеграционные тесты</a>. Они проверяют интеграцию приложения со всеми компонентами вне приложения.<br/>
<br/>
Для автоматизированных тестов это означает, что нужно запустить не только собственное приложение, но и интегрируемый компонент. Если вы тестируете интеграцию с БД, то при выполнении тестов надо запустить БД. Чтобы проверить чтение файлов с диска нужно сохранить файл на диск и загрузить его в интеграционный тест.<br/>
<br/>
Я ранее упоминал, что юнит-тесты — неопределённый термин. Ещё в большей степени это относится к интеграционным тестам. Для кого-то «интеграция» означает тестирование всего стека вашего приложения в комплексе с другими. Мне нравится более узкое определение и тестирование каждой точки интеграции по отдельности, заменяя остальные сервисы и базы данных тестовыми дублёрами. Вместе с контрактным тестированием и выполнением контрактных тестов на дублёрах и реальных реализациях можно придумать интеграционные тесты, которые быстрее, более независимы и обычно проще в понимании.<br/>
<br/>
Узкие интеграционные тесты живут на границе вашего сервиса. Концептуально они всегда запускают действие, которое приводит к интеграции с внешней частью (файловой системой, базой данных, отдельным сервисом). Тест интеграции БД выглядит следующим образом:<br/>
<br/>
<div style="text-align:center;"><img src="https://habrastorage.org/r/w1560/getpro/habr/post_images/089/6ef/aaf/0896efaaf776a8d308a008d0d2ef625e.png" data-src="https://habrastorage.org/getpro/habr/post_images/089/6ef/aaf/0896efaaf776a8d308a008d0d2ef625e.png"/></div><br/>
<i><font color="gray">Рис. 6. Тест на интеграцию БД интегрирует ваш код с реальной базой данных</font></i> <br/>
<br/>
<ol>
<li>Запуск базы данных.</li>
<li>Подключение приложения к БД.</li>
<li>Запуск функции в коде, которая записывает данные в БД.</li>
<li>Проверка, что ожидаемые данные записаны в базу путём их чтения из БД.</li>
</ol><br/>
Другой пример. Тест интеграции вашего сервиса с отдельной службой через REST API может выглядеть следующим образом:<br/>
<br/>
<div style="text-align:center;"><img src="https://habrastorage.org/r/w1560/getpro/habr/post_images/15b/98f/5bd/15b98f5bd52634719eff1280a4117f3b.png" data-src="https://habrastorage.org/getpro/habr/post_images/15b/98f/5bd/15b98f5bd52634719eff1280a4117f3b.png"/></div><br/>
<i><font color="gray">Рис. 7. Этот вид интеграционного теста проверяет, что приложение способно правильно взаимодействовать с отдельными службами</font></i> <br/>
<br/>
<ol>
<li>Запуск приложения.</li>
<li>Запуск инстанса отдельной службы (или тестового дублёра с тем же интерфейсом).</li>
<li>Запуск функции в коде, которая считывает данные из API внешней службы.</li>
<li>Проверка, что приложение правильно разбирает ответ.</li>
</ol><br/>
Как и модульные тесты, ваши интеграционные тесты можно делать вполне прозрачно (whitebox). Некоторые фреймворки позволяют одновременно запустить и ваше приложение, и имитации отдельных его частей для проверки правильного взаимодействия.<br/>
<br/>
Напишите интеграционные тесты для всех фрагментов кода, где выполняется <i>сериализация</i> или <i>десериализация</i> данных. Это происходит чаще, чем вы думаете. Подумайте о следующем:<br/>
<br/>
<ul>
<li>Вызовы REST API своих сервисов.</li>
<li>Чтение и запись в БД.</li>
<li>Вызовы API других приложений.</li>
<li>Чтение из очереди и запись туда.</li>
<li>Запись в файловую систему.</li>
</ul><br/>
Написание интеграционных тестов вокруг этих границ гарантирует, что запись данных и чтение данных от этих внешних участников работает нормально.<br/>
<br/>
При написании <i>узких интеграционных тестов</i> стремитесь локально запускать внешние зависимости: локальную базу данных MySQL, тест на локальной файловой системе ext4. Если интегрируетесь с отдельной службой, то или запустите экземпляр этой службы локально, или создайте и запустите поддельную версию, которая имитирует поведение реальной службы.<br/>
<br/>
Если нет возможности локально запустить стороннюю службу, то лучше запустить выделенный тестовый инстанс и указать на него в интеграционным тесте. В автоматизированных тестах избегайте интеграции с реальной системой продакшна. Запуск тысяч тестовых запросов на систему продакшна — верный способ разозлить людей, потому что вы забиваете их логи (в лучшем случае) или просто ддосите их сервис (в худшем случае). Интеграция с сервисом по сети — типичное свойство <i>широкого интеграционного теста</i>. Обычно из-за неё тесты труднее писать и они медленнее работают.<br/>
<br/>
Что касается пирамиды тестов, то интеграционные тесты находятся на более высоком уровне, чем модульные. Интеграция файловых систем и БД обычно гораздо медленнее, чем выполнение юнит-тестов с их имитациями. Их также труднее писать, чем маленькие изолированные модульные тесты. В конце концов, нужно думать о работе внешней части теста. Тем не менее, они имеют преимущество, потому что дают уверенность в правильной работе приложения со всеми внешними частями, с какими нужно. Юнит-тесты тут бесполезны.<br/>
<br/>
<a name="DatabaseIntegration"></a><h3>Интеграция БД</h3><br/>
<code>PersonRepository</code> — единственный класс репозитория во всей кодовой базе. Он опирается на <i>Spring Data</i> и не имеет фактической реализации. Он просто расширяет интерфейс <code>CrudRepository</code> и предоставляет единственный заголовок метода. Остальное — магия Spring.<br/>
<br/>
<pre><code class="java">public interface PersonRepository extends CrudRepository&lt;Person, String> {
    Optional&lt;Person> findByLastName(String lastName);
}</code></pre><br/>
Через интерфейс <code>CrudRepository</code> Spring Boot предоставляет полностью функциональное хранилище CRUD с методами <code>findOne</code>, <code>findAll</code>, <code>save</code>, <code>update</code> и <code>delete</code>. Наше собственное определение метода <code>findByLastName ()</code> расширяет эту базовую функциональность и даёт возможность получать людей, то есть объекты <code>Person</code>, по их фамилиям. Spring Data анализирует возвращаемый тип метода, имя метода и проверяет его на соответствие конвенциям именования для выяснения, что он должен делать.<br/>
<br/>
Хотя Spring Data выполняет большую работу по реализации репозиториев БД, я всё равно написал тест интеграции БД. Вы можете сказать, что это <i>тест фреймворка</i>, которого следует избегать, ведь мы тестируем чужой код. Тем не менее, я считаю, что здесь очень важно наличие хотя бы одного интеграционного теста. Во-первых, он проверяет нормальную работу нашего метода <code>findByLastName</code>. Во-вторых, это доказывает, что наш репозиторий правильно использует Spring и способен подключиться к БД.<br/>
<br/>
Чтобы облегчить выполнение тестов на вашем компьютере (без установки базы данных PostgreSQL), наш тест подключается к базе данных в памяти <i>H2</i>.<br/>
<br/>
Я определил H2 как тестовую зависимость в файле <code>build.gradle</code>. Файл <code>application.properties</code> в каталоге теста не определяет никаких свойств <code>spring.datasource</code>. Это указывает Spring Data использовать базу данных в памяти. Поскольку он находит H2 в пути к классу, то просто использует H2.<br/>
<br/>
Реальное приложение с профилем <code>int</code> (например, после установки в качестве переменной среды <code>SPRING_PROFILES_ACTIVE=int</code>) будет подключаться к базе данных PostgreSQL, как определено в <code>application-int.properties</code>.<br/>
<br/>
Понимаю, что здесь нужно знать и понимать кучу особенностей Spring. Придётся перелопатить <a href="https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-sql.html#boot-features-embedded-database-support">кучу документации</a>. Финальный код простой с виду, но его трудно понять, если вы не знаете конкретных особенностей Spring.<br/>
<br/>
Кроме того, работа с базой данных в памяти — рискованное дело. В конце концов, наши интеграционные тесты работают с БД другого типа, чем в продакшне. Попробуйте и решите сами, предпочесть ли магию Spring и простой код — или явную, но более подробную реализацию.<br/>
<br/>
Ну, хватит объяснений. Вот простой интеграционный тест, который сохраняет объект Person в базу данных и находит его по фамилии.<br/>
<br/>
<pre><code class="java">@RunWith(SpringRunner.class)
@DataJpaTest
public class PersonRepositoryIntegrationTest {
    @Autowired
    private PersonRepository subject;

    @After
    public void tearDown() throws Exception {
        subject.deleteAll();
    }

    @Test
    public void shouldSaveAndFetchPerson() throws Exception {
        Person peter = new Person("Peter", "Pan");
        subject.save(peter);

        Optional&lt;Person> maybePeter = subject.findByLastName("Pan");

        assertThat(maybePeter, is(Optional.of(peter)));
    }
}</code></pre><br/>
Как видите, наш интеграционный тест следует той же структуре «трёх А», что и юнит-тесты. Говорил же, что это универсальная концепция!<br/>
<br/>
<a name="IntegrationWithSeparateServices"></a><h3>Интеграция с отдельными сервисами</h3><br/>
Наш микросервис получает погодные данные с darksky.net через REST API. Конечно, мы хотим убедиться, что сервис правильно отправляет запросы и разбирает ответы.<br/>
<br/>
При выполнении автоматических тестов желательно избежать взаимодействия с настоящими серверами <i>darksky</i>. Лимиты на нашем бесплатном тарифе — лишь одна из причин. Главное — это <i>отвязка</i>. Наши тесты должны запускаться независимо от того, какие справляются со своей работой милые люди в darksky.net. Даже если наша машина не может достучаться до серверов <i>darksky</i> или они закрылись на обслуживание.<br/>
<br/>
Чтобы избежать взаимодействия с реальными серверами <i>darksky</i>, мы для интеграционных тестов запускаем собственный, поддельный сервер <i>darksky</i>. Это может показаться очень трудной задачей. Но она упрощается благодаря таким инструментам, как <a href="http://wiremock.org/">Wiremock</a>. Смотрите сами:<br/>
<br/>
<pre><code class="java">@RunWith(SpringRunner.class)
@SpringBootTest
public class WeatherClientIntegrationTest {

    @Autowired
    private WeatherClient subject;

    @Rule
    public WireMockRule wireMockRule = new WireMockRule(8089);

    @Test
    public void shouldCallWeatherService() throws Exception {
        wireMockRule.stubFor(get(urlPathEqualTo("/some-test-api-key/53.5511,9.9937"))
                .willReturn(aResponse()
                        .withBody(FileLoader.read("classpath:weatherApiResponse.json"))
                        .withHeader(CONTENT_TYPE, MediaType.APPLICATION_JSON_VALUE)
                        .withStatus(200)));

        Optional&lt;WeatherResponse> weatherResponse = subject.fetchWeather();

        Optional&lt;WeatherResponse> expectedResponse = Optional.of(new WeatherResponse("Rain"));
        assertThat(weatherResponse, is(expectedResponse));
    }
}</code></pre><br/>
Для Wiremock создаем инстанс <code>WireMockRule</code> на фиксированном порту (<code>8089</code>). С помощью DSL можно настроить сервер Wiremock, определить конечные точки для прослушивания и предустановленные ответы.<br/>
<br/>
Далее вызываем тестируемый метод — тот, который обращается к сторонней службе — и проверяем, что результат правильно парсится.<br/>
<br/>
Важно понимать, как тест определяет, что должен обратиться к поддельному сервер Wiremock вместо реального API <i>darksky</i>. Секрет в файле <code>application.properties</code>, который располагается в <code>src/test/resources</code>. Его Spring загружает при выполнении тестов. В этом файле мы переопределяем конфигурацию вроде ключей API и URL-адресов со значениями, подходящими для тестов. В том числе назначаем вызов поддельного сервера Wiremock вместо реального:<br/>
<br/>
<pre><code>weather.url = http://localhost:8089</code></pre><br/>
Обратите внимание, что определённый здесь порт должен быть тем же, что мы указали при создании инстанса WireMockRule для теста. Замена URL-адреса реального API на поддельный стала возможной благодаря введению URL-адреса в конструктор класса <code>WeatherClient</code>:<br/>
<br/>
<pre><code class="java">@Autowired
public WeatherClient(final RestTemplate restTemplate,
                     @Value("${weather.url}") final String weatherServiceUrl,
                     @Value("${weather.api_key}") final String weatherServiceApiKey) {
    this.restTemplate = restTemplate;
    this.weatherServiceUrl = weatherServiceUrl;
    this.weatherServiceApiKey = weatherServiceApiKey;
}</code></pre><br/>
Так мы сообщаем нашему <code>WeatherClient</code> прочитать значение параметра <code>weatherUrl</code> свойства <code>weather.url</code>, которое мы определили в свойствах нашего приложения.<br/>
<br/>
С инструментами вроде Wiremock написание <i>узких интеграционных тестов</i> для отдельного сервиса становится достаточно простой задачей. К сожалению, у такого подхода есть недостаток: как гарантировать, что созданный нами поддельный сервер ведёт себя как настоящий? При текущей реализации отдельный сервис может изменить свой API, и наши тесты всё равно пройдут как ни в чём ни бывало. Сейчас мы просто тестируем, что <code>WeatherClient</code> способен воспринимать ответы от поддельного сервера. Это начало, но оно очень хрупкое. Проблему решают <i>сквозные тесты</i> и тестирование на реальном сервисе, но так мы становимся зависимы от его доступности. К счастью, есть лучшее решение этой дилеммы — контрактные тесты с участием и имитации, и реального сервера гарантируют, что имитация в наших интеграционных тестах точно соответствует оригиналу. Посмотрим, как это работает.<br/>
<br/>
<a name="ContractTests"></a><h1>Контрактные тесты</h1><br/>
Более современные компании нашли способ масштабирования разработки путём распределения работ среди разных команд. Они создают отдельные, слабо связанные службы, не мешая друг на другу, и интегрируют их в большую, цельную систему. Именно с этим связана недавняя шумиха вокруг микросервисов.<br/>
<br/>
Разделение системы на множество небольших сервисов часто означает, что эти сервисы должны взаимодействовать друг с другом через определённые (желательно чётко определенные, но иногда случайно созданные) интерфейсы.<br/>
<br/>
Интерфейсы между разными приложения могут быть реализованы в разных форматах и технологиях. Самые распространённые:<br/>
<br/>
<ul>
<li>REST и JSON через HTTPS;</li>
<li>RPC с использованием чего-то вроде <a href="https://grpc.io/">gRPC</a>;</li>
<li>построение событийно-ориентированной архитектуры с использованием очередей.</li>
</ul><br/>
Каждый интерфейс задействует две стороны: поставщика и потребителя. <b>Поставщик</b> предоставляет данные потребителям. <b>Потребитель</b> обрабатывает данные, полученные от поставщика. В мире REST поставщик создаёт REST API со всеми необходимыми конечными точками, а потребитель обращается к этому REST API, чтобы получить данные или инициировать изменения в другой службе. В асинхронном мире событийно-ориентированной архитектуры поставщик (часто именуемый издателем) публикует данные в очередь; а потребитель (часто называемый подписчиком) подписывается на эти очереди, считывает и обрабатывает данные.<br/>
<br/>
<div style="text-align:center;"><img src="https://habrastorage.org/r/w1560/getpro/habr/post_images/420/a0f/17c/420a0f17c800a1ac4a65a883813da8ae.png" data-src="https://habrastorage.org/getpro/habr/post_images/420/a0f/17c/420a0f17c800a1ac4a65a883813da8ae.png"/></div><br/>
<i><font color="gray">Рис. 8. Каждый интерфейс задействует поставщика (или издателя) и потребителя (или подписчика). Спецификацией интерфейса можно считать контракт.</font></i><br/>
<br/>
Поскольку сервисы поставщика и потребителя распределяются по разным командам, то вы оказываетесь в ситуации, когда нужно чётко указать интерфейс между ними (так называемый контракт). Традиционно компании подходят к этой проблеме следующим образом:<br/>
<br/>
<ol>
<li>Написать длинную и подробную спецификацию интерфейса (<i>контракт</i>).</li>
<li>Реализовать сервис поставщика согласно определённому контракту.</li>
<li>Передать спецификации интерфейса стороне потребителя.</li>
<li>Подождать, пока они реализуют свою часть интерфейса.</li>
<li>Запустить крупномасштабный ручной системный тест, чтобы всё проверить.</li>
<li>Надеяться, что обе команды будут всегда соблюдать определения интерфейса и не облажаются.</li>
</ol><br/>
Более современные компании заменили шаги 5 и 6 на автоматизированные <a href="https://martinfowler.com/bliki/ContractTest.html">контрактные тесты</a>, которые проверяют, что реализации на стороне потребителя и поставщика всё ещё придерживаются определённого контракта. Они выступают хорошим набором регрессионных тестов и гарантируют раннее обнаружение отклонения от контракта.<br/>
<br/>
В более гибкой организации следует выбрать более эффективный и менее расточительный маршрут. Приложение создаётся в рамках одной организации. Не должно быть проблемой переговорить с разработчиками других сервисов вместо того, чтобы забрасывать им чрезмерно подробную готовую документацию. В конце концов, это ваши сотрудники, а не сторонний вендор, с которым можно общаться только через службу поддержки клиентов или пуленепробиваемые юридические контракты.<br/>
<br/>
<b>Ориентированные на пользователя контрактные тесты</b> (CDC-тесты) позволяют <a href="https://martinfowler.com/articles/consumerDrivenContracts.html">потребителям управлять реализацией контракта</a>. С помощью CDC потребители пишут тесты, которые проверяют интерфейс для всех данных, которые им нужны. Затем команда публикует эти тесты, чтобы разработчики службы поставщика могли легко получить и запустить эти тесты. Теперь они могут разработать свой API, запустив тесты CDC. После прогона всех тестов они знают, что удовлетворили все потребности команды на стороне потребителя.<br/>
<br/>
<div style="text-align:center;"><img src="https://habrastorage.org/r/w1560/getpro/habr/post_images/25e/dba/1c2/25edba1c2090bc04cf76e018a53ee451.png" data-src="https://habrastorage.org/getpro/habr/post_images/25e/dba/1c2/25edba1c2090bc04cf76e018a53ee451.png"/></div><br/>
<i><font color="gray">Рис. 9. Контрактные тесты гарантируют, что поставщик и все потребители интерфейса придерживаются определённого контракта интерфейса. С помощью CDC-тестов потребители интерфейса публикуют свои требования в виде автоматизированных тестов; поставщики непрерывно получают и выполняют эти тесты</font></i><br/>
<br/>
Такой подход позволяет команде поставщика интерфейса реализовать только то, что действительно необходимо (сохраняя простоту, <abbr title="You aren't gonna need it">YAGNI</abbr> и всё такое). Команда поставщика должна непрерывно получать и выполнять эти CDC-тесты (в своём конвейере сборки), чтобы немедленно замечать любые критические изменения. Если они нарушают интерфейс, то их CDC-тесты не пройдут, предотвращая критические изменения. Пока тесты проходят, команда может вносить любые изменения, какие хочет, не беспокоясь о других командах. Ориентированный на потребителя контрактный подход сокращает процесс разработки до следующего:<br/>
<br/>
<ol>
<li>Команда потребителя пишет автоматизированные тесты со всеми ожиданиями со стороны потребителей.</li>
<li>Они публикуют тесты для команды поставщика.</li>
<li>Команда поставщика непрерывно запускает CDC-тесты и следит за ними.</li>
<li>Команды немедленно вступают в переговоры, когда CDC-тесты ломаются.</li>
</ol><br/>
Если ваша организация внедрит подход микросервисов, то проведение CDC-тестов — важный шаг к созданию автономных групп. CDC-тесты — это автоматизированный способ поощрить общение в коллективе. Они гарантируют, что интерфейсы между командами работают в любое время. Неудачный CDC-тест — хороший повод пойти к пострадавшей команде, поговорить о предстоящих изменениях API и выяснить, куда двигаться дальше.<br/>
<br/>
Наивная реализация CDC-тестов настолько же проста, как запросы к API и оценка ответов на предмет наличия всего необходимого. Затем эти тесты упаковываются в исполняемый файл (.gem, .jar, .sh) и загружаются куда-нибудь для другой команды (например, репозиторий вроде <a href="https://www.jfrog.com/artifactory/">Artifactory</a>).<br/>
<br/>
В последние годы подход CDC становится более популярным и создано несколько инструментов для упрощения написания и обмена тестами.<br/>
<br/>
<a href="https://github.com/realestate-com-au/pact">Pact</a>, вероятно, самый известный среди них. Он предлагает утончённый подход к написанию тестов для потребителя и поставщика, предоставляет заглушки для отдельных служб и позволяет обмениваться CDC-тестами с другими командами. Pact портирован на множество платформ и может использоваться с языками JVM, Ruby, .NET, JavaScript и многими другими.<br/>
<br/>
Pact — разумный выбор, чтобы начать работу с CDC. <a href="https://docs.pact.io/">Документация</a> сначала ошеломляет, но если набраться терпения, то её можно одолеть. Она помогает получить твёрдое понимание CDC, что в свою очередь облегчает вам задачу пропагандировать CDC для работы с другими командами.<br/>
<br/>
Ориентированные на пользователя контрактные тесты могут кардинально упростить работу автономных команд, которые начнут действовать быстро и уверенно. Сделайте одолжение, ознакомьтесь и попробуйте эту концепцию. Качественный набор CDC-тестов неоценим, чтобы быстро продолжать разработку, не ломая прочие сервисы и не огорчая другие команды.<br/>
<br/>
<a name="ConsumerTestourTeam"></a><h3>Тест потребителя (наша команда)</h3><br/>
Наш микросервис использует погодный API. Так что наша обязанность — написать <b>тест потребителя</b>, который определяет наши ожидания по контракту (API) между нашим микросервисом и погодной службой.<br/>
<br/>
Сначала включаем библиотеку для написания тестов потребителя в нашу <code>build.gradle</code>:<br/>
<br/>
<pre><code>testCompile('au.com.dius:pact-jvm-consumer-junit_2.11:3.5.5')</code></pre><br/>
Благодаря этой библиотеке мы можем реализовать тест потребителя и использовать сервисы имитации Pact:<br/>
<br/>
<pre><code class="java">@RunWith(SpringRunner.class)
@SpringBootTest
public class WeatherClientConsumerTest {

    @Autowired
    private WeatherClient weatherClient;

    @Rule
    public PactProviderRuleMk2 weatherProvider =
            new PactProviderRuleMk2("weather_provider", "localhost", 8089, this);

    @Pact(consumer="test_consumer")
    public RequestResponsePact createPact(PactDslWithProvider builder) throws IOException {
        return builder
                .given("weather forecast data")
                .uponReceiving("a request for a weather request for Hamburg")
                    .path("/some-test-api-key/53.5511,9.9937")
                    .method("GET")
                .willRespondWith()
                    .status(200)
                    .body(FileLoader.read("classpath:weatherApiResponse.json"),
                            ContentType.APPLICATION_JSON)
                .toPact();
    }

    @Test
    @PactVerification("weather_provider")
    public void shouldFetchWeatherInformation() throws Exception {
        Optional&lt;WeatherResponse> weatherResponse = weatherClient.fetchWeather();
        assertThat(weatherResponse.isPresent(), is(true));
        assertThat(weatherResponse.get().getSummary(), is("Rain"));
    }
}</code></pre><br/>
Если внимательно посмотреть, то <code>WeatherClientConsumerTest</code> очень похож на <code>WeatherClientIntegrationTest</code>. Только для серверной заглушки вместо Wiremock на этот раз мы используем Pact. На самом тест потребителя работает точно так же, как интеграционный: мы заменяем реальный сторонний сервер заглушкой, определяем ожидаемый ответ и проверяем, что клиент может правильно его разобрать. В этом смысле <code>WeatherClientConsumerTest</code> представляет собой узкий интеграционный тест. Преимущество по сравнению с тестом на основе Wiremock в том, что он при каждом запуске генерирует <i>файл Pact</i> (находится в <code>target/pacts/&amp;pact-name>.json</code>). Он описывает наши ожидания по контракту в специальном формате JSON. Затем этот файл можно использовать для проверки, что сервер-заглушка ведёт себя как настоящий. Мы можем взять pact-файл и передать его команде, предоставляющей интерфейс. Они берут pact-файл и пишут тест провайдера, используя указанные там ожидания. Так они проверяют, соответствует ли их API всем нашим ожиданиям.<br/>
<br/>
Как можно понять, именно отсюда взялась часть <i>«ориентирование на потребителя»</i> в определении CDC. Потребитель управляет реализацией интерфейса, описывая свои ожидания. Поставщик должен убедиться, что он выполняет все ожидания. Никаких лишних спецификаций, YAGNI и все дела.<br/>
<br/>
Передача pact-файла в команду поставщика может пройти несколькими путями. Простой — зарегистрировать его в системе управления версиями и сказать команде поставщика всегда брать последнюю версию файла. Более продвинутый способ — использовать репозиторий артефактов вроде Amazon S3 или Pact Broker. Начинайте с простого и растите по мере необходимости.<br/>
<br/>
В реальном приложении вам не нужны одновременно и <i>интеграционный тест</i>, и <i>тест потребителя</i> для клиентского класса. Наш пример кода содержит оба только для демонстрации, как использовать каждый из них. Если вы хотите написать CDC-тесты на Pact, я рекомендую оставаться с ним. В этом случае преимущество в том, что вы автоматически получаете pact-файл с ожиданиями от контракта, которые другие команды могут использовать, чтобы легко сделать свои тесты поставщика. Конечно, это имеет смысл только если вы сможете убедить другую команду использовать Pact. Если нет, то используйте интеграционный тест интеграции в сочетании с Wiremock как достойную альтернативу.<br/>
<br/>
<a name="ProviderTesttheOtherTeam"></a><h3>Тест поставщика (другая команда)</h3><br/>
Тесты поставщика должны реализовать те, кто предоставляет погодный API. Мы используем публичный API от darksky.net. Теоретически, команда darksky со своей стороны должна выполнить тест поставщика и убедиться, что не нарушает контракт между своим приложением и нашим сервисом.<br/>
<br/>
Очевидно, что их не волнует наше скромное тестовое приложение — и они не будут делать для нас CDC-тест. Есть большая разница между публичным API и организацией, использующей микросервисы. Общедоступный API не может учитывать нужды каждого отдельного потребителя, иначе не сможет нормально работать. Внутри своей организации вы можете и должны их учитывать. Скорее всего, ваше приложение будет обслуживать несколько, ну может пару десятков потребителей. Ничего не мешает написать тесты поставщика для этих интерфейсов, чтобы сохранить стабильную систему.<br/>
<br/>
Команда поставщика получает pact-файл и запускает его на своём сервисе. Для этого она реализует тест, который считывает pact-файл, ставит несколько заглушек и проверяет на своём сервисе ожидания, определённые в pact-файле.<br/>
<br/>
Сообщество проекта Pact написало несколько библиотек для реализации тестов поставщика. В их <a href="https://github.com/DiUS/pact-jvm">основном репозитории GitHub</a> неплохой выбор библиотек для потребителей и провайдеров. Выберите ту, которая лучше всего соответствует вашему стеку технологий.<br/>
<br/>
Для простоты предположим, что API darksky тоже реализован в Spring Boot. В этом случае они могут использовать <a href="https://github.com/DiUS/pact-jvm/tree/master/pact-jvm-provider-spring">библиотеку Pact Spring</a>, которая хорошо подключается к механизмам MockMVC Spring. Гипотетический тест поставщика, который могла бы реализовать команда darksky.net, выглядит так:<br/>
<br/>
<pre><code class="java">@RunWith(RestPactRunner.class)
@Provider("weather_provider") // same as the "provider_name" in our clientConsumerTest
@PactFolder("target/pacts") // tells pact where to load the pact files from
public class WeatherProviderTest {
    @InjectMocks
    private ForecastController forecastController = new ForecastController();

    @Mock
    private ForecastService forecastService;

    @TestTarget
    public final MockMvcTarget target = new MockMvcTarget();

    @Before
    public void before() {
        initMocks(this);
        target.setControllers(forecastController);
    }

    @State("weather forecast data") // same as the "given()" in our clientConsumerTest
    public void weatherForecastData() {
        when(forecastService.fetchForecastFor(any(String.class), any(String.class)))
                .thenReturn(weatherForecast("Rain"));
    }
}</code></pre><br/>
Как видите, от поставщика требуется лишь загрузить pact-файл (например, <code>@PactFolder</code> определяет, откуда загружать полученные pact-файлы), а затем определить, как обеспечить тестовые данные для предопределённых состояний (например, с помощью имитаций Mockito). Не нужно писать какой-то специальный тест. Всё берётся из pact-файла. Важно, чтобы тест поставщика соответствовал <i>имени поставщика</i> и <i>состоянию</i>, объявленным в тесте потребителя.<br/>
<br/>
<a name="ProviderTestourTeam"></a><h3>Тест поставщика (наша команда)</h3><br/>
Мы посмотрели, как тестировать контракт между нашим сервисом и поставщиком погодной информации. В этом интерфейсе наш сервис выступает в качестве потребителя, а метеорологическая служба — в качестве поставщика. Подумав ещё, мы увидим, что наш сервис тоже выступает в роли поставщика для других: мы предоставляем REST API с несколькими конечными точками для других потребителей.<br/>
<br/>
Поскольку мы знаем важность контрактных тестов, то конечно напишем тест и для этого контракта. К счастью, наши контракты ориентированы на потребителя, так что все команды-потребители присылают нам свои pact-файлы, которые мы можем использовать для реализации тестов поставщика для нашего REST API.<br/>
<br/>
Сначала добавим в наш проект библиотеку поставщика Pact для Spring:<br/>
<br/>
<code>testCompile('au.com.dius:pact-jvm-provider-spring_2.12:3.5.5')</code> <br/>
<br/>
Реализация теста поставщика следует той же описанной схеме. Для простоты я зарегистрирую pact-файл от нашего <a href="https://github.com/hamvocke/spring-testing-consumer">простого потребителя</a> в репозитории нашего сервиса. Для нашего случая так проще, а в реальной жизни, вероятно, придётся использовать более сложный механизм для распространения pact-файлов.<br/>
<br/>
<pre><code class="java">@RunWith(RestPactRunner.class)
@Provider("person_provider")// same as in the "provider_name" part in our pact file
@PactFolder("target/pacts") // tells pact where to load the pact files from
public class ExampleProviderTest {

    @Mock
    private PersonRepository personRepository;

    @Mock
    private WeatherClient weatherClient;

    private ExampleController exampleController;

    @TestTarget
    public final MockMvcTarget target = new MockMvcTarget();

    @Before
    public void before() {
        initMocks(this);
        exampleController = new ExampleController(personRepository, weatherClient);
        target.setControllers(exampleController);
    }

    @State("person data") // same as the "given()" part in our consumer test
    public void personData() {
        Person peterPan = new Person("Peter", "Pan");
        when(personRepository.findByLastName("Pan")).thenReturn(Optional.of
                (peterPan));
    }
}</code></pre><br/>
Показанный <code>ExampleProviderTest</code> должен предоставить состояние в соответствии с полученным pact-файлом, вот и всё. Когда мы запустим тест, Pact подберёт pact-файл и отправит HTTP-запрос к нашему сервису, который ответит в соответствии с заданным состоянием.<br/>
<br/>
<a name="UiTests"></a><h1>Тесты UI</h1><br/>
У большинства приложений есть какой-то пользовательский интерфейс. Обычно мы говорим о веб-интерфейсе в контексте веб-приложений. Люди часто забывают, что REST API или интерфейс командной строки — это такой же UI, как и причудливый веб-интерфейс.<br/>
<br/>
<i>Тесты UI</i> проверяют правильность работы пользовательского интерфейса приложения. Действия пользователя должны инициировать правильные события, данные должны представляться пользователю, состояние UI должно изменяться ожидаемым образом.<br/>
<br/>
<div style="text-align:center;"><img src="https://habrastorage.org/r/w1560/getpro/habr/post_images/1e1/d34/9b2/1e1d349b260edb4f442fac4bcbabb8b1.png" data-src="https://habrastorage.org/getpro/habr/post_images/1e1/d34/9b2/1e1d349b260edb4f442fac4bcbabb8b1.png"/></div><br/>
<br/>
Иногда говорят, что тесты UI и сквозные тесты — это одно и то же (как говорит Майк Кон). Для меня это отождествление двух вещей с весьма ортогональными концепциями.<br/>
<br/>
Да, тестирование приложения от начала до конца часто означает прохождение через пользовательский интерфейс. Но обратное неверно.<br/>
<br/>
Тестирование пользовательского интерфейса необязательно должно проводиться в сквозном режиме. В зависимости от используемой технологии, тестирование UI может оказаться таким же простым, как написание некоторых модульных тестов для фронтенда JavaScript с заглушенным бэкендом.<br/>
<br/>
Для тестирования UI традиционных веб-приложений предназначены специальные инструменты вроде <a href="http://docs.seleniumhq.org/">Selenium</a>. Если вы считаете пользовательским интерфейсом REST API, то достаточно правильных интеграционных тестов вокруг API.<br/>
<br/>
В веб-интерфейсах желательно проверить несколько аспектов UI, в том числе поведение, вёрстка, юзабилити, соблюдение фирменного стиля и др.<br/>
<br/>
К счастью, тестирование поведения UI довольно простое. Щёлкаете здесь, вводите данные там — и проверяете, что состояние UI меняется соответствующим образом. Современные фреймворки для одностраничных приложений (<a href="https://facebook.github.io/react/">react</a>, <a href="https://vuejs.org/">vue.js</a>, <a href="https://angular.io/">Angular</a> и прочие) часто поставляются с инструментами и хелперами для тщательного тестирования этих взаимодействий на довольно низком уровне (в юнит-тесте). Даже если выкатить собственную реализацию фронтенда на ванильном JavaScript, всё равно можно использовать обычные инструменты тестирования, такие как <a href="https://jasmine.github.io/">Jasmine</a> и <a href="http://mochajs.org/">Mocha</a>. Для более традиционного приложения с рендерингом на стороне сервера наилучшим выбором станут тесты на основе Selenium.<br/>
<br/>
Цельность <i>вёрстки</i> веб-приложения проверить немного сложнее. В зависимости от приложения и потребностей пользователей может возникнуть необходимость убедиться, что изменения кода случайно не нарушают вёрстку сайта.<br/>
<br/>
Но компьютеры плохо справляются с проверкой, что всё «нормально выглядит» (возможно, в будущем какой-то умный алгоритм машинного обучения изменит это).<br/>
<br/>
Есть некоторые инструменты, чтобы попробовать автоматическую проверку дизайна веб-приложения в конвейере сборки. Большинство из них используют Selenium для открытия веб-приложения в разных браузерах и форматах, произведения скриншотов и сравнения с ранее сделанными скриншотами. Если старый и новый скриншоты отличаются неожиданным образом, то инструмент подаст сигнал.<br/>
<br/>
Один из таких инструментов — <a href="http://galenframework.com/">Galen</a>. Некоторые команды используют <a href="https://github.com/otto-de/lineup">lineup</a> и его брата jlineup на основе Java для достижения аналогичного результата. Оба инструмента применяют тот же подход на основе Selenium.<br/>
<br/>
Как только вы хотите проверить <i>удобство использования</i> и <i>приятный дизайн</i> — вы покидаете пространство автоматизированного тестирования. Здесь придётся полагаться на <a href="https://en.wikipedia.org/wiki/Exploratory_testing">исследовательские тесты</a>, тесты юзабилити (вплоть до простейших <a href="https://en.wikipedia.org/wiki/Usability_testing#Hallway_testing">холл-тестов</a> на случайных людях). Придётся проводить демонстрации пользователям и проверять, нравится ли им продукт и могут ли они использовать все функции без разочарования или раздражения.<br/>
<br/>
<a name="End-to-endTests"></a><h1>Сквозные тесты</h1><br/>
Тестирование развёрнутого приложения через UI — это самый полный тест, какой только можно провести. Описанные выше тесты UI через WebDriver — хорошие примеры сквозных тестов.<br/>
<br/>
<div style="text-align:center;"><img src="https://habrastorage.org/r/w1560/getpro/habr/post_images/91a/118/3e7/91a1183e77f1850a1df00b819503b109.png" data-src="https://habrastorage.org/getpro/habr/post_images/91a/118/3e7/91a1183e77f1850a1df00b819503b109.png"/></div><br/>
<i><font color="gray">Рис. 11. Сквозные тесты проверяют полностью интегрированную систему целиком</font></i><br/>
<br/>
Сквозные тесты (также называемые <a href="https://martinfowler.com/bliki/BroadStackTest.html">тестами широкого стека</a>) дают максимальную уверенность, работает программное обеспечение или нет. <a href="http://docs.seleniumhq.org/">Selenium</a> и <a href="https://www.w3.org/TR/webdriver/">протокол WebDriver</a> позволяют автоматизировать тесты, автоматически отправляя headless-браузер на развёрнутые сервисы для выполнения кликов, ввода данных и проверки состояния UI. Можно использовать Selenium напрямую или применить инструменты на его основе, такие как <a href="http://nightwatchjs.org/">Nightwatch</a>.<br/>
<br/>
У сквозных тесты другие проблемы. Они известны своей ненадёжностью, сбоями по неожиданным и непредвиденным причинам. Довольно часто это ложноположительные сбои. Чем более сложный UI, тем более хрупкими становятся тесты. Причуды браузера, проблемы с синхронизацией, анимация и неожиданные всплывающие диалоги — лишь некоторые из причин, из-за которых я потратил больше времени на отладку, чем хотелось бы.<br/>
<br/>
В мире микросервисов также непонятно, кто отвечает за написание этих тестов. Поскольку они охватывают несколько сервисов (всю систему), то нет одной конкретной команды, ответственной за написание сквозных тестов.<br/>
<br/>
Если есть централизованная команда <i>обеспечения качества</i>, они выглядят хорошим кандидатом. Опять же, заводить централизованную команду QA строго не рекомендуется, такого не должно быть в мире DevOps, где все команды по-настоящему универсальны. Нет простого ответа, кто должен владеть сквозными тестами. Может, в вашей организации есть какая-то инициативная группа или <i>гильдия качества</i>, чтобы позаботиться о них. Здесь многое зависит от конкретной организации.<br/>
<br/>
Кроме того, сквозные тесты требуют серьёзной поддержки и выполняются довольно медленно. Если у вас много микросервисов, то вы даже не сможете запускать сквозные тесты локально, потому что тогда понадобится и все микросервисы запускать локально. Попробуйте запустить сотни приложений на своём компьютере, тут никакой оперативки не хватит.<br/>
<br/>
Из-за высоких расходов на обслуживание следует свести число сквозных тестов к абсолютному минимуму.<br/>
<br/>
Подумайте о самых главных взаимодействиях пользователей с приложением. Придумайте главные «маршруты» пользователей от экрана к экрану, чтобы автоматизировать самые важные из этих шагов в сквозных тестах.<br/>
<br/>
Если вы делаете интернет-магазин, то самым ценным «маршрутом» будет поиск продукта — помещение его в корзину — оформление заказа. Вот и всё. Пока этот маршрут работает, нет особых проблем. Возможно, вы найдёте еще пару важных маршрутов для сквозных тестов. Всё остальное, вероятно, принесёт больше проблем, чем пользы.<br/>
<br/>
Помните: в вашей пирамиде тестов много низкоуровневых тестов, где мы уже протестировали все варианты пограничных ситуаций и интеграции с другими частями системы. Нет необходимости повторять эти тесты на более высоком уровне. Большие усилия по техническому обслуживанию и много ложных срабатываний слишком замедлит вашу работу, а рано или поздно лишит вас доверия к тестам вообще.<br/>
<br/>
<a name="UserInterfaceEnd-to-endTest"></a><h3>Сквозные тесты UI</h3><br/>
Для сквозных тестов многие разработчики выбирают <a href="http://docs.seleniumhq.org/">Selenium</a> и протокол <a href="https://www.w3.org/TR/webdriver/">WebDriver</a>. С Selenium можете выбрать любой браузер и натравить его на сайт. Пусть нажимает повсюду кнопки и ссылки, вводит данные и проверяет изменения в UI.<br/>
<br/>
К Selenium нужен браузер, который можно запустить и использовать для тестов. Есть несколько так называемых <i>«драйверов»</i> к разным браузерам. Выберите один (или несколько) и добавьте его в свой <code>build.gradle</code>. Какой бы браузер вы ни выбрали, следует убедиться, что у всех разработчиков и на сервере CI установлена правильная версия браузера. Может оказаться трудно обспечить такую синхронизацию. Для Java есть небольшая библиотека <a href="https://github.com/bonigarcia/webdrivermanager">webdrivermanager</a>, которая автоматизирует загрузку и настройку правильной версии браузера. Добавьте две такие зависимости в <code>build.gradle</code>:<br/>
<br/>
<pre><code class="java">testCompile('org.seleniumhq.selenium:selenium-chrome-driver:2.53.1')
testCompile('io.github.bonigarcia:webdrivermanager:1.7.2')</code></pre><br/>
Запуск полноценного браузера в тестовом наборе может стать проблемой. Особенно если сервер непрерывной доставки, где работает наш конвейер, не способен развернуть браузер с UI (например, потому что X-Server недоступен). В этом случае можно запустить виртуальный X-Server вроде <a href="https://en.wikipedia.org/wiki/Xvfb">xvfb</a>.<br/>
<br/>
Более новый подход заключается в использовании <i>headless</i>-браузера (т.е. браузера без пользовательского интерфейса) для тестов WebDriver. До недавнего времени чаще всего для автоматизации браузерных задач использовался PhantomJS. Но когда <a href="https://developers.google.com/web/updates/2017/04/headless-chrome">Chromium</a> и <a href="https://developer.mozilla.org/en-US/Firefox/Headless_mode">Firefox</a> внедрили headless-режим из коробки, PhantomJS внезапно устарел. В конце концов, лучше протестировать сайт с помощью реального браузера, который действительно есть у пользователей (например, Firefox и Chrome), а не с помощью искусственного браузера только потому что это удобно вам как разработчику.<br/>
<br/>
Оба headless-браузера Firefox и Chrome совершенно новые и ещё не получили широкого распространения для тестов WebDriver. Мы не хотим ничего усложнять. Вместо возни со свеженькими headless-режимами давайте придерживаться классического способа, то есть Selenium в связке с обычным браузером. Вот как выглядит простой сквозной тест, который запускает Chrome, переходит к нашему сервису и проверяет содержимое сайта:<br/>
<br/>
<pre><code class="java">@RunWith(SpringRunner.class)
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
public class HelloE2ESeleniumTest {

    private WebDriver driver;

    @LocalServerPort
    private int port;

    @BeforeClass
    public static void setUpClass() throws Exception {
        ChromeDriverManager.getInstance().setup();
    }

    @Before
    public void setUp() throws Exception {
        driver = new ChromeDriver();
    }

    @After
    public void tearDown() {
        driver.close();
    }

    @Test
    public void helloPageHasTextHelloWorld() {
        driver.get(String.format("http://127.0.0.1:%s/hello", port));

        assertThat(driver.findElement(By.tagName("body")).getText(), containsString("Hello World!"));
    }
}</code></pre><br/>
Обратите внимание, что этот тест будет работать, только если Chrome установлен на машине, где запускается тест (ваш локальный компьютер, сервер CI).<br/>
<br/>
Тест простой. Он запускает приложение Spring на случайном порту с помощью <code>@SpringBootTest</code>. Затем создаётся новый «веб-драйвер» Chrome, он получает указание перейти к конечной точке <code>/hello</code> нашего микросервиса и проверить, что в окне браузера печатается «Hello World!». Классно!<br/>
<br/>
<a name="RestApiEnd-to-endTest"></a><h3>Сквозной тест REST API</h3><br/>
Для повышения надёжности тестов хорошая идея — избегать GUI. Такие тесты более стабильны, чем полноценные сквозные тесты, и в то же время покрывают значительную часть стека приложения. Это может пригодиться, если тестировать приложение через веб-интерфейс особенно сложно. Может, у вас даже нет веб-интерфейса, а только REST API (потому что одностраничное приложение где-то общается с этим API или просто потому что вы презираете всё красивое и блестящее). В любом случае ситуация подходит для <a href="https://martinfowler.com/bliki/SubcutaneousTest.html">подкожного теста</a> (subcutaneous test), который тестирует всё, что находится под GUI. Если вы обслуживаете REST API, то такой тест будет правильным, как в нашем примере:<br/>
<br/>
<pre><code class="java">@RestController
public class ExampleController {
    private final PersonRepository personRepository;

    // shortened for clarity

    @GetMapping("/hello/{lastName}")
    public String hello(@PathVariable final String lastName) {
        Optional&lt;Person> foundPerson = personRepository.findByLastName(lastName);

        return foundPerson
             .map(person -> String.format("Hello %s %s!",
                     person.getFirstName(),
                     person.getLastName()))
             .orElse(String.format("Who is this '%s' you're talking about?",
                     lastName));
    }
}</code></pre><br/>
Позвольте показать ещё одну библиотеку, которая пригодится при тестировании сервиса, предоставляющего REST API. Библиотека <a href="https://github.com/rest-assured/rest-assured">REST-assured</a> даёт хороший DSL для запуска реальных HTTP-запросов к API и оценки полученных ответов.<br/>
<br/>
Прежде всего, добавьте зависимость в свой <code>build.gradle</code>.<br/>
<br/>
<pre><code class="java">testCompile('io.rest-assured:rest-assured:3.0.3')</code></pre><br/>
С помощью этой библиотеки можно реализовать сквозной тест для нашего REST API:<br/>
<br/>
<pre><code class="java">@RunWith(SpringRunner.class)
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
public class HelloE2ERestTest {

    @Autowired
    private PersonRepository personRepository;

    @LocalServerPort
    private int port;

    @After
    public void tearDown() throws Exception {
        personRepository.deleteAll();
    }

    @Test
    public void shouldReturnGreeting() throws Exception {
        Person peter = new Person("Peter", "Pan");
        personRepository.save(peter);

        when()
                .get(String.format("http://localhost:%s/hello/Pan", port))
        .then()
                .statusCode(is(200))
                .body(containsString("Hello Peter Pan!"));
    }
}</code></pre><br/>
Мы опять запускаем всё приложение Spring с помощью <code>@SpringBootTest</code>. В этом случае мы делаем <code>@Autowire</code> для <code>PersonRepository</code>, чтобы легко записывать тестовые данные в БД. Теперь когда просим REST API сказать «привет» нашему другу “Mr Pan”, то видим приятное приветствие. Потрясающе! И более чем достаточно для сквозного теста, если веб-интерфейс вообще отсутствует.<br/>
<br/>
<a name="acceptance"></a><h1>Приёмочные тесты — ваши фичи правильно работают?</h1><br/>
Чем выше вы поднимаетесь в пирамиде тестов, тем больше вероятность возникновения вопросов: правильно ли работают фичи с точки зрения пользователя. Вы можете рассматривать приложение как чёрный ящик и изменить направленность тестов от прошлого:<br/>
<br/>
<blockquote>когда я ввожу x и y, возвращаемое значение должно быть z</blockquote><br/>
к следующему:<br/>
<br/>
<blockquote><i>учитывая</i>, что есть авторизованный пользователь<br/>
<br/>
<i>и</i> есть изделие «велосипед»<br/>
<br/>
<i>когда</i> пользователь переходит на страницу описания изделия «велосипед»<br/>
<br/>
<i>и</i> нажимает кнопку «Добавить в корзину»<br/>
<br/>
<i>тогда</i> изделие «велосипед» должно быть в его корзине</blockquote><br/>
Бывает, что такие тесты называют <a href="https://en.wikipedia.org/wiki/Functional_testing">функциональными</a> или <a href="https://en.wikipedia.org/wiki/Acceptance_testing#Acceptance_testing_in_extreme_programming">приёмочными</a>. Некоторые говорят, что функциональные и приёмочные тесты — это разные вещи. Иногда термины объединяют. Иногда люди бесконечно спорят о формулировках и определениях. Часто такие обсуждения вводят ещё бóльшую путаницу.<br/>
<br/>
Вот что: в какой-то момент следует убедиться, что ваша программа правильно работает с точки зрения <i>пользователя</i>, а не только с технической точки зрения. Как вы называете эти тесты — на самом деле не так важно. А вот наличие этих тестов важно. Выберите любой термин, придерживайтесь его и напишите эти тесты.<br/>
<br/>
Можно ещё упомянуть BDD (разработка, основанная на описании поведения) и инструменты для нее. BDD и соответствующий стиль написания тестов — хороший трюк, чтобы изменить своё мышление от деталей реализации к потребностям пользователей. Не бойтесь и попробуйте.<br/>
<br/>
Вам даже не обязательно внедрять полномасштабные инструменты BDD, такие как <a href="https://cucumber.io/">Cucumber</a> (хотя можно и внедрить). Некоторые assertion-библиотеки вроде <a href="http://chaijs.com/guide/styles/#should">chai.js</a> позволяют писать утверждения (assertions) с ключевыми словами в стиле <code>should</code>, которые приближают тесты к BDD. И даже если вы не используете библиотеку, которая предоставляет такую нотацию, умный и хорошо продуманный код позволит писать тесты, ориентированные на поведение пользователей. Некоторые методы/функции хелперов могут оказаться очень успешными:<br/>
<br/>
<pre><code class="python"># a sample acceptance test in Python

def test_add_to_basket():
    # given
    user = a_user_with_empty_basket()
    user.login()
    bicycle = article(name="bicycle", price=100)

    # when
    article_page.add_to_.basket(bicycle)

    # then
    assert user.basket.contains(bicycle)</code></pre><br/>
Приёмочные тесты могут проводиться на разных уровнях детализации. В основном они будут достаточно высокого уровня и тестировать сервис через UI. Но важно понимать, что технически нет обязательного требования писать приёмочные тесты именно на самом высоком уровне пирамиды тестов. Если структура приложения и имеющийся сценарий позволяют написать приёмочный тест на более низком уровне, сделайте это. Тест низкого уровня лучше, чем высокого. Концепция приёмочных тестов — доказать, что фичи приложения правильно работают для пользователя — полностью ортогональна вашей пирамиде тестов.<br/>
<br/>
<a name="ExploratoryTesting"></a><h1>Исследовательское тестирование</h1><br/>
Даже самые прилежные усилия по автоматизации тестов не идеальны. Иногда в автоматических тестах вы пропускаете определённые пограничные случаи. Иногда просто невозможно обнаружить определённую ошибку, написав модульный тест. Некоторые проблемы качества вообще не проявятся в автоматизированных тестах (подумайте о дизайне или юзабилити). Несмотря на самые лучшие намерения в отношении автоматизации тестов, ручные тесты в некоторых отношениях по-прежнему незаменимы.<br/>
<br/>
<div style="text-align:center;"><img src="https://habrastorage.org/r/w1560/getpro/habr/post_images/65d/c55/38f/65dc5538f1f4ff98c973d5cc43f6a152.png" data-src="https://habrastorage.org/getpro/habr/post_images/65d/c55/38f/65dc5538f1f4ff98c973d5cc43f6a152.png"/></div><br/>
<i><font color="gray">Рис. 12. Исследовательское тестирование выявит проблемы качества, незамеченные в процессе сборки</font></i><br/>
<br/>
Включите <a href="https://en.wikipedia.org/wiki/Exploratory_testing">исследовательские тесты</a> в свой набор тестов. Эта процедура тестирования вручную подчёркивает свободу и творческие способности тестировщика, который способен найти проблемы качества в работающей системе. Просто выделите немного времени в расписании, засучите рукава и постарайтесь вызвать сбой приложения каким-нибудь способом. Включите деструктивное мышление и придумывайте способы, как спровоцировать проблемы и ошибки в программе. Документируйте всё, что найдёте. Ищите баги, проблемы дизайна, медленное время отклика, отсутствующие или вводящие в заблуждение сообщения об ошибках и всё остальное, что вас раздражает как пользователя.<br/>
<br/>
Хорошая новость в том, что вы легко можете автоматизировать тесты для большинства найденных ошибок. Написание автоматизированных тестов для найденных ошибок гарантирует, что в будущем не будет регрессий этой ошибки. Кроме того, это помогает выяснить корневую причину проблемы при исправлении бага.<br/>
<br/>
Во время исследовательского тестирования вы обнаружите проблемы, которые незаметно проскользнули через конвейер сборки. Не расстраивайтесь. Это хорошая обратная связь для улучшения конвейера сборки. Как и с любой обратной связью, обязательно отреагируйте со своей стороны: подумайте, какие действия предпринять, чтобы избежать такого рода проблем в будущем. Может, вы пропустили определённый набор автоматических тестов. Возможно, были небрежны с автоматизированными тестами на этом этапе и следует более тщательно проводить тесты в будущем. Возможно, есть какой-то блестящий новый инструмент или подход, который можно использовать в своем конвейере, чтобы избежать таких проблем. Обязательно отреагируйте так, чтобы ваш конвейер и вся система поставки программного обеспечения стали лучше и совершенствовались с каждым шагом.<br/>
<br/>
<a name="TheConfusionAboutTestingTerminology"></a><h1>Путаница с терминологией в тестировании</h1><br/>
Всегда сложно говорить о разных классификациях тестов. Моё понимание <i>юнит-тестов</i> (модульных тестов) может слегка отличаться от вашего. С интеграционными тестами ещё хуже. Для некоторых людей интеграционное тестирование — это очень широкая деятельность, которая тестирует множество различных частей всей системы. Для меня это довольно узкая вещь: тестирование только интеграции с одной внешней частью за раз. Некоторые называют это <i>интеграционными</i> тестами, некоторые — <i>компонентными</i>, другие предпочитают термин <i>сервисный тест</i>. Кто-то заявит, что это вообще три совершенно разные вещи. Нет правильного или неправильного определения. Сообщество разработчиков ПО просто не установило чётко определённых терминов в тестировании.<br/>
<br/>
Не зацикливайтесь на двусмысленных терминах. Не имеет значения, называете вы это сквозным тестом, тестом широкого стека или функциональным тестом. Неважно, если ваши интеграционные тесты означают для вас не то, что для людей в другой компании. Да, было бы очень хорошо, если бы наша отрасль могла чётко определить термины и все бы их придерживались. К сожалению, этого ещё не произошло. И поскольку в тестировании много нюансов, то всё равно мы имеем дело скорее с широким спектром тестов, чем с кучей дискретных множеств, что ещё больше усложняет чёткую терминологию.<br/>
<br/>
Важно воспринимать это так: вы просто находите термины, которые работают для вас и вашей команды. Ясно определите для себя различные типы тестов, которые хотите написать. Согласуйте термины в своей команде и найдите консенсус относительно охвата каждого типа теста. Если в своей команде (или даже во всей организации) вы будете последовательны с этими терминами, то это всё, о чем нужно позаботиться. <a href="https://testing.googleblog.com/2010/12/test-sizes.html">Саймон Стюарт</a> хорошо подытожил это в подходе, который используется в Google. Думаю, это прекрасная демонстрация, что не стоит слишком зацикливаться на названиях и конвенциях по терминам.<br/>
<br/>
<a name="PuttingTestsIntoYourDeploymentPipeline"></a><h1>Внедрение тестов в конвейер развёртывания</h1><br/>
Если вы используете непрерывную интеграцию или непрерывную доставку, то ваш <a href="https://martinfowler.com/bliki/DeploymentPipeline.html">конвейер развёртывания</a> запускает автоматические тесты каждый раз при внесении изменений в ПО. Обычно конвейер разделяется на несколько этапов, которые постепенно дают всё больше уверенности, что ваша программа готова к развёртыванию в рабочей среде. Услышав обо всех разновидностях тестов, возможно, вы задаётесь вопросом, как поместить их в конвейер развёртывания. Чтобы ответить на это, следует просто подумать об одной из самых основополагающих ценностей непрерывной доставки (это одна из ключевых ценностей <a href="http://www.extremeprogramming.org/values.html">экстремального программирования</a> и гибкой разработки): о <b>быстрой обратной связи</b>.<br/>
<br/>
Хороший конвейер сборки максимально быстро сообщает об ошибках. Вы не хотите ждать целый час, чтобы узнать, что последнее изменение сломало некоторые простые модульные тесты. Если конвейер работает так медленно, то вы могли уже уйти домой, когда поступила обратная связь. Информация должна приходить в течение нескольких секунд или нескольких минут с быстрых тестов на ранних этапах конвейера. И наоборот, более длительные тесты — обычно с более широкой областью — размещаются на более поздних этапах, чтобы не тормозить фидбек от быстрых тестов. Как видите, этапы конвейера развёртывания определяются не типами тестов, а их скоростью и областью действия. Поэтому очень разумно может быть разместить некоторые из самых узких и быстрых интеграционных тестов на ту же стадию, что и юнит-тесты — просто потому что они дают более быструю обратную связь. И необязательно проводить строгую линию по формальному типу тестов.<br/>
<br/>
<a name="AvoidTestDuplication"></a><h1>Избегайте дублирования тестов</h1><br/>
Есть ещё одна ловушка, которую следует избегать: дублирование тестов на разных уровнях пирамиды. Чутьё говорит, что тестов много не бывает, но позвольте вас заверить: бывает. Каждый тест в тестовом наборе — дополнительный багаж, который не обходится бесплатно. Написание и ведение тестов требует времени. Чтение и понимание чужого теста требует времени. И конечно, выполнение тестов тоже требует времени.<br/>
<br/>
Как и с производственным кодом, следует стремиться к простоте и избегать дублирования. В контексте реализации пирамиды тестов есть два эмпирических правила:<br/>
<br/>
<ol>
<li>Если в тесте более высокого уровня обнаружена ошибка, а в тестах более низкого уровня нет, то необходимо писать тест более низкого уровня.</li>
<li>Сдвигайте тесты как можно ниже по уровням пирамиды.</li>
</ol><br/>
Первое правило важно, потому что тесты более низкого уровня лучше позволяют сузить область и изолированно воспроизвести ошибку. Они работают быстрее и менее раздуты, что помогает при отладке вручную. И в будущем послужат хорошим регрессионным тестом. Второе правило важно для быстрого выполнения набора тестов. Если вы уверенно протестировали все условия на тестах более низкого уровня, то в тесте более высокого уровня нет необходимости. Он просто не добавляет уверенности, что всё работает. Избыточные тесты станут обузой и начнут раздражать в повседневной работе. Набор тестов будет работать медленнее, и при изменении кода потребуется изменить больше тестов.<br/>
<br/>
Сформулируем иначе: если тест более высокого уровня даёт больше уверенности, что приложение работает правильно, то нужно иметь такой тест. Написание модульного теста для класса контроллера помогает проверить логику внутри самого контроллера. Тем не менее, это не скажет вам, действительно ли конечная точка REST, которую предоставляет этот контроллер, отвечает на запросы HTTP. Таким образом, вы продвигаетесь вверх по пирамиде тестов и добавляете тест, который проверяет именно это, но не более того. В тесте более высокого уровня вы не тестируете всю условную логику и пограничные случаи, которые уже покрыты юнит-тестами более низкого уровня. Убедитесь, что тест высокого уровня фокусируется только на том, что не покрыто тестами более низкого уровня.<br/>
<br/>
Я строго отношусь к исключению тестов, не имеющих ценности. Удаляю высокоуровневые тесты, которые уже покрыты на более низком уровне (учитывая, что они не дают дополнительной ценности). Заменяю тесты более высокого уровня тестами более низкого уровня, если это возможно. Иногда трудно удалить лишний тест, особенно если придумать его было непросто. Но вы рискуете создать <a href="https://ru.wikipedia.org/wiki/%D0%9D%D0%B5%D0%B2%D0%BE%D0%B7%D0%B2%D1%80%D0%B0%D1%82%D0%BD%D1%8B%D0%B5_%D0%B7%D0%B0%D1%82%D1%80%D0%B0%D1%82%D1%8B">невозвратные затраты</a>, так что смело жмите Delete. Нет причин тратить драгоценное время на тест, который перестал приносить пользу.<br/>
<br/>
<a name="WritingCleanTestCode"></a><h1>Пишите чистый код для тестов</h1><br/>
Как и в отношении обычного кода, следует позаботиться о хорошем и чистом коде тестов. Вот ещё несколько советов для создания поддерживаемого тестового кода, прежде чем начинать работу и создавать автоматизированный набор тестов:<br/>
<br/>
<ol>
<li>Тестовый код так же важен, как и код в продакшне. Уделите ему столько же заботы и внимания. «Это всего лишь тест» — не оправдание для небрежного кода.</li>
<li>Проверяйте только одно условие в каждом тесте. Тогда тесты останутся лаконичными и понятными.</li>
<li>Правило трёх А (arrange, act, assert) или триада «дано, когда, тогда» — хорошая мнемоника, чтобы поддерживать хорошую структуру тестов.</li>
<li>Читаемость имеет значение. Не злоупотребляйте DRY (правило «не повторяйся»). Повторение хорошо, если улучшает читаемость. Попробуйте найти баланс между кодом <a href="https://stackoverflow.com/questions/6453235/what-does-damp-not-dry-mean-when-talking-about-unit-tests">DRY и DAMP</a> (DAMP — Descriptive And Meaningful Phrases, содержательные и осмысленные фразы).</li>
<li>Если сомневаетесь насчёт рефакторинга или повторного использования кода, применяйте <a href="https://blog.codinghorror.com/rule-of-three/">Правило Трёх</a>. <i>Use before reuse</i>.</li>
</ol><br/>
<a name="Conclusion"></a><h1>Заключение</h1><br/>
Вот и всё! Знаю, это было долгое и трудное объяснение, почему и как следует проводить тестирование. Отличная новость в том, что эта информация практически не имеет срока давности и не зависит от того, какую программу вы создаёте. Работаете вы над микросервисами, устройствами IoT, мобильными приложениями или веб-приложениями, уроки из этой статьи применимы ко всему.<br/>
<br/>
Надеюсь, что в статье есть что-то полезное. Теперь вперёд, изучите <a href="https://github.com/hamvocke/spring-testing">пример кода</a> и примените усвоенные понятия в своём наборе тестов. Создание крепкого набора тестов требует определённых усилий. Это окупится в долгосрочной перспективе и сделает вашу жизнь разработчика более спокойной, поверьте мне.<br/>
<br/>
<b>См. также:</b><br/>
<a href="https://habr.com/post/358178/">«Антипаттерны тестирования ПО»</a></div></div></div> <DIV class="v-portal" style="display:none;"></DIV></div> <!----> <!----></div> <div class="tm-article-presenter__meta"><div class="tm-separated-list tm-article-presenter__meta-list"><span class="tm-separated-list__title">Теги:</span> <ul class="tm-separated-list__list"><li class="tm-separated-list__item"><a href="https://habr.com/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5BDevOps%5D" class="tm-tags-list__link">DevOps</a></li><li class="tm-separated-list__item"><a href="https://habr.com/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5B%D0%BF%D0%B8%D1%80%D0%B0%D0%BC%D0%B8%D0%B4%D0%B0%20%D1%82%D0%B5%D1%81%D1%82%D0%BE%D0%B2%5D" class="tm-tags-list__link">пирамида тестов</a></li><li class="tm-separated-list__item"><a href="https://habr.com/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5BJunit%5D" class="tm-tags-list__link">Junit</a></li><li class="tm-separated-list__item"><a href="https://habr.com/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5BMockito%5D" class="tm-tags-list__link">Mockito</a></li><li class="tm-separated-list__item"><a href="https://habr.com/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5BWiremock%5D" class="tm-tags-list__link">Wiremock</a></li><li class="tm-separated-list__item"><a href="https://habr.com/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5BPact%5D" class="tm-tags-list__link">Pact</a></li><li class="tm-separated-list__item"><a href="https://habr.com/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5BSelenium%5D" class="tm-tags-list__link">Selenium</a></li><li class="tm-separated-list__item"><a href="https://habr.com/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5BREST-assured%5D" class="tm-tags-list__link">REST-assured</a></li><li class="tm-separated-list__item"><a href="https://habr.com/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5BSpring%5D" class="tm-tags-list__link">Spring</a></li><li class="tm-separated-list__item"><a href="https://habr.com/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5BTDD%5D" class="tm-tags-list__link">TDD</a></li><li class="tm-separated-list__item"><a href="https://habr.com/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5BSOLID%5D" class="tm-tags-list__link">SOLID</a></li><li class="tm-separated-list__item"><a href="https://habr.com/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5BCDC-%D1%82%D0%B5%D1%81%D1%82%D1%8B%5D" class="tm-tags-list__link">CDC-тесты</a></li><li class="tm-separated-list__item"><a href="https://habr.com/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5B%D0%B8%D0%BD%D1%82%D0%B5%D0%B3%D1%80%D0%B0%D1%86%D0%B8%D0%BE%D0%BD%D0%BD%D1%8B%D0%B5%20%D1%82%D0%B5%D1%81%D1%82%D1%8B%5D" class="tm-tags-list__link">интеграционные тесты</a></li><li class="tm-separated-list__item"><a href="https://habr.com/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5B%D0%BC%D0%BE%D0%B4%D1%83%D0%BB%D1%8C%D0%BD%D1%8B%D0%B5%20%D1%82%D0%B5%D1%81%D1%82%D1%8B%5D" class="tm-tags-list__link">модульные тесты</a></li><li class="tm-separated-list__item"><a href="https://habr.com/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5B%D1%8E%D0%BD%D0%B8%D1%82-%D1%82%D0%B5%D1%81%D1%82%D1%8B%5D" class="tm-tags-list__link">юнит-тесты</a></li><li class="tm-separated-list__item"><a href="https://habr.com/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5B%D0%BA%D0%BE%D0%BD%D1%82%D1%80%D0%B0%D0%BA%D1%82%D0%BD%D1%8B%D0%B5%20%D1%82%D0%B5%D1%81%D1%82%D1%8B%5D" class="tm-tags-list__link">контрактные тесты</a></li><li class="tm-separated-list__item"><a href="https://habr.com/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5BYAGNI%5D" class="tm-tags-list__link">YAGNI</a></li><li class="tm-separated-list__item"><a href="https://habr.com/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5BJSON%5D" class="tm-tags-list__link">JSON</a></li><li class="tm-separated-list__item"><a href="https://habr.com/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5BGalen%5D" class="tm-tags-list__link">Galen</a></li><li class="tm-separated-list__item"><a href="https://habr.com/ru/search/?target_type=posts&amp;order=relevance&amp;q=%5Bheadless-%D0%B1%D1%80%D0%B0%D1%83%D0%B7%D0%B5%D1%80%5D" class="tm-tags-list__link">headless-браузер</a></li></ul></div> <div class="tm-separated-list tm-article-presenter__meta-list"><span class="tm-separated-list__title">Хабы:</span> <ul class="tm-separated-list__list"><li class="tm-separated-list__item"><a href="https://habr.com/ru/hub/microformats/" class="tm-hubs-list__link">
    Микроформаты
  </a></li><li class="tm-separated-list__item"><a href="https://habr.com/ru/hub/it_testing/" class="tm-hubs-list__link">
    Тестирование IT-систем
  </a></li><li class="tm-separated-list__item"><a href="https://habr.com/ru/hub/web_testing/" class="tm-hubs-list__link">
    Тестирование веб-сервисов
  </a></li><li class="tm-separated-list__item"><a href="https://habr.com/ru/hub/dev_management/" class="tm-hubs-list__link">
    Управление разработкой
  </a></li><li class="tm-separated-list__item"><a href="https://habr.com/ru/hub/devops/" class="tm-hubs-list__link">
    DevOps
  </a></li></ul></div></div></article></div> <!----></div> <div class="tm-article-sticky-panel"><div class="tm-data-icons tm-article-sticky-panel__icons"><div class="tm-article-rating tm-data-icons__item"><div class="tm-votes-meter tm-article-rating__votes-switcher"><svg height="24" width="24" class="tm-svg-img tm-votes-meter__icon tm-votes-meter__icon_appearance-article"><title>Всего голосов 14: ↑14 и ↓0</title> <use xlink:href="/img/megazord-v25.4b679db1.svg#counter-rating"></use></svg> <span title="Всего голосов 14: ↑14 и ↓0" class="tm-votes-meter__value tm-votes-meter__value_positive tm-votes-meter__value_appearance-article tm-votes-meter__value_rating">+14</span></div> <DIV class="v-portal" style="display:none;"></DIV></div> <!----> <span title="Количество просмотров" class="tm-icon-counter tm-data-icons__item"><svg height="24" width="24" class="tm-svg-img tm-icon-counter__icon"><title>Просмотры</title> <use xlink:href="/img/megazord-v25.4b679db1.svg#counter-views"></use></svg> <span class="tm-icon-counter__value">167K</span></span> <button title="Добавить в закладки" type="button" class="bookmarks-button tm-data-icons__item"><span title="Добавить в закладки" class="tm-svg-icon__wrapper bookmarks-button__icon"><svg height="24" width="24" class="tm-svg-img tm-svg-icon"><title>Добавить в закладки</title> <use xlink:href="/img/megazord-v25.4b679db1.svg#counter-favorite"></use></svg></span> <span title="Количество пользователей, добавивших публикацию в закладки" class="bookmarks-button__counter">
    381
  </span></button> <!----> <div title="Поделиться" class="tm-sharing tm-data-icons__item"><button type="button" class="tm-sharing__button"><svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" class="tm-sharing__icon"><path fill="currentColor" d="M13.8 13.8V18l7.2-6.6L13.8 5v3.9C5 8.9 3 18.6 3 18.6c2.5-4.4 6-4.8 10.8-4.8z"></path></svg></button> <DIV class="v-portal" style="display:none;"></DIV></div> <DIV class="v-portal" style="display:none;"></DIV></div> </div></div> <DIV class="v-portal" style="display:none;"></DIV> <div class="tm-article-presenter__footer"><div class="tm-article-blocks"><!----> <section class="tm-block tm-block_spacing-bottom"><!----> <div class="tm-block__body tm-block__body_variant-balanced"><div class="tm-article-author"> <div class="tm-user-card tm-article-author__user-card tm-user-card_variant-article"><div class="tm-user-card__info-container"><div class="tm-user-card__header"><div class="tm-user-card__header-data"><a href="https://habr.com/ru/users/m1rko/" class="tm-user-card__userpic tm-user-card__userpic_size-40"><div class="tm-entity-image"><img alt="" src="https://habrastorage.org/getpro/habr/avatars/4ec/bd0/85d/4ecbd085d692835a931d03174ff19539.png" class="tm-entity-image__pic"></div></a> <div class="tm-user-card__meta"><div title=" 1515 голосов " class="tm-karma tm-user-card__karma"><div class="tm-karma__votes tm-karma__votes_positive">
    1243
  </div> <div class="tm-karma__text">
    Карма
  </div></div> <div title="Рейтинг пользователя" class="tm-rating tm-user-card__rating"><div class="tm-rating__header"> <div class="tm-rating__counter">0</div></div> <div class="tm-rating__text">
    Рейтинг
  </div></div></div></div></div> <div class="tm-user-card__info tm-user-card__info_variant-article"><div class="tm-user-card__title tm-user-card__title_variant-article"><span class="tm-user-card__name tm-user-card__name_variant-article">Анатолий Ализар</span> <a href="https://habr.com/ru/users/m1rko/" class="tm-user-card__nickname tm-user-card__nickname_variant-article">
          @m1rko
        </a> <!----></div> <p class="tm-user-card__short-info tm-user-card__short-info_variant-article">автор, переводчик, редактор</p></div></div> <div class="tm-user-card__buttons tm-user-card__buttons_variant-article"><!----> <!----> <!----> <!----> <!----></div></div> <!----></div> <DIV class="v-portal" style="display:none;"></DIV></div> <!----></section> <div class="tm-article-blocks__comments"><div class="tm-article-page-comments"><div class="tm-article-comments-counter-link tm-article-comments-counter-button"><a href="https://habr.com/ru/post/358950/comments/" class="tm-article-comments-counter-link__link tm-article-comments-counter-link__link_button-style"><svg height="24" width="24" class="tm-svg-img tm-article-comments-counter-link__icon tm-article-comments-counter-link__icon_contrasted"><title>Комментарии</title> <use xlink:href="/img/megazord-v25.4b679db1.svg#counter-comments"></use></svg> <span class="tm-article-comments-counter-link__value tm-article-comments-counter-link__value_contrasted">
       Комментарии 4 
    </span></a> <!----></div></div></div> <div class="tm-ad-banner__container tm-page-article__banner"><!----> <div id="articleBottomBanner5128" class="tm-ad-banner"></div></div> <!----> <!----> <!----> <!----> </div></div></div></div></div> <div class="tm-page__sidebar"><div class="tm-layout-sidebar"><div class="tm-layout-sidebar__ads tm-layout-sidebar__ads_initial"><div class="tm-ad-banner__container tm-layout-sidebar__banner"><!----> <div id="sidebarBanner5129" class="tm-ad-banner"></div></div></div> <div class="tm-sexy-sidebar tm-sexy-sidebar_initial" style="margin-top:0px;"><!----> <section data-async-called="true" class="tm-block tm-block_spacing-bottom"><header class="tm-block__header"><h2 class="tm-block__title">Работа</h2> <!----></header> <div class="tm-block__body"><div class="tm-vacancies-block__item"><a href="https://career.habr.com/vacancies/testirovshik_programmnogo_obespecheniya" target="_blank" class="tm-vacancies-block__vacancy-title">
        Тестировщик программного обеспечения
      </a> <div class="tm-vacancies-block__vacancies-count">
        127
    вакансий
      </div></div><div class="tm-vacancies-block__item"><a href="https://career.habr.com/vacancies/devops" target="_blank" class="tm-vacancies-block__vacancy-title">
        DevOps инженер
      </a> <div class="tm-vacancies-block__vacancies-count">
        87
    вакансий
      </div></div><div class="tm-vacancies-block__item"><a href="https://career.habr.com/vacancies/rukovoditel_razrabotki" target="_blank" class="tm-vacancies-block__vacancy-title">
        Руководитель разработки
      </a> <div class="tm-vacancies-block__vacancies-count">
        151
    вакансия
      </div></div></div> <footer class="tm-block__footer"><a href="https://career.habr.com/catalog" class="tm-block-extralink">
      Все вакансии
    </a></footer></section></div></div></div></div></div></div></main> <!----></div> <div class="tm-footer-menu"><div class="tm-page-width"><div class="tm-footer-menu__container"><div class="tm-footer-menu__block"><h3 class="tm-footer-menu__block-title">
          Ваш аккаунт
        </h3> <div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><li class="tm-footer-menu__list-item"><a href="https://habr.com/kek/v1/auth/habrahabr/?back=/ru/post/358950/&amp;hl=ru" rel="nofollow" target="_self">
                Войти
              </a></li><li class="tm-footer-menu__list-item"><a href="https://habr.com/kek/v1/auth/habrahabr-register/?back=/ru/post/358950/&amp;hl=ru" rel="nofollow" target="_self">
                Регистрация
              </a></li></ul></div></div><div class="tm-footer-menu__block"><h3 class="tm-footer-menu__block-title">
          Разделы
        </h3> <div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><li class="tm-footer-menu__list-item"><a href="https://habr.com/ru/" class="footer-menu__item-link router-link-active">
                Публикации
              </a></li><li class="tm-footer-menu__list-item"><a href="https://habr.com/ru/news/" class="footer-menu__item-link">
                Новости
              </a></li><li class="tm-footer-menu__list-item"><a href="https://habr.com/ru/hubs/" class="footer-menu__item-link">
                Хабы
              </a></li><li class="tm-footer-menu__list-item"><a href="https://habr.com/ru/companies/" class="footer-menu__item-link">
                Компании
              </a></li><li class="tm-footer-menu__list-item"><a href="https://habr.com/ru/users/" class="footer-menu__item-link">
                Авторы
              </a></li><li class="tm-footer-menu__list-item"><a href="https://habr.com/ru/sandbox/" class="footer-menu__item-link">
                Песочница
              </a></li></ul></div></div><div class="tm-footer-menu__block"><h3 class="tm-footer-menu__block-title">
          Информация
        </h3> <div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><li class="tm-footer-menu__list-item"><a href="https://habr.com/ru/docs/help/" class="footer-menu__item-link">
                Устройство сайта
              </a></li><li class="tm-footer-menu__list-item"><a href="https://habr.com/ru/docs/authors/codex/" class="footer-menu__item-link">
                Для авторов
              </a></li><li class="tm-footer-menu__list-item"><a href="https://habr.com/ru/docs/companies/corpblogs/" class="footer-menu__item-link">
                Для компаний
              </a></li><li class="tm-footer-menu__list-item"><a href="https://habr.com/ru/docs/docs/transparency/" class="footer-menu__item-link">
                Документы
              </a></li><li class="tm-footer-menu__list-item"><a href="https://account.habr.com/info/agreement" target="_blank">
                Соглашение
              </a></li><li class="tm-footer-menu__list-item"><a href="https://account.habr.com/info/confidential/" target="_blank">
                Конфиденциальность
              </a></li></ul></div></div><div class="tm-footer-menu__block"><h3 class="tm-footer-menu__block-title">
          Услуги
        </h3> <div class="tm-footer-menu__block-content"><ul class="tm-footer-menu__list"><li class="tm-footer-menu__list-item"><a href="https://docs.google.com/presentation/d/e/2PACX-1vQLwRfQmXibiUlWaRg-BAc38s7oM3lJiaPju7qmdJsp8ysIvZ_G-Npem0njJLMozE2bPHMpDqiI5hhy/pub?start=false&amp;loop=false&amp;delayms=60000&amp;slide=id.g91a03369cd_4_297" target="_blank">
                Реклама
              </a></li><li class="tm-footer-menu__list-item"><a href="https://habrastorage.org/storage/stuff/habr/service_price.pdf" target="_blank">
                Тарифы
              </a></li><li class="tm-footer-menu__list-item"><a href="https://docs.google.com/presentation/d/e/2PACX-1vQJJds8-Di7BQSP_guHxICN7woVYoN5NP_22ra-BIo4bqnTT9FR6fB-Ku2P0AoRpX0Ds-LRkDeAoD8F/pub?start=false&amp;loop=false&amp;delayms=60000" target="_blank">
                Контент
              </a></li><li class="tm-footer-menu__list-item"><a href="https://tmtm.timepad.ru/" target="_blank">
                Семинары
              </a></li><li class="tm-footer-menu__list-item"><a href="https://habr.com/ru/megaprojects/" class="footer-menu__item-link">
                Мегапроекты
              </a></li></ul></div></div></div></div></div> <div class="tm-footer"><div class="tm-page-width"><div class="tm-footer__container"><!----> <div class="tm-footer__social"><a href="https://www.facebook.com/habrahabr.ru" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Facebook</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-facebook"></use></svg></a><a href="https://twitter.com/habr_com" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Twitter</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-twitter"></use></svg></a><a href="https://vk.com/habr" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>VK</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-vkontakte"></use></svg></a><a href="https://telegram.me/habr_com" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Telegram</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-telegram"></use></svg></a><a href="https://www.youtube.com/channel/UCd_sTwKqVrweTt4oAKY5y4w" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Youtube</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-youtube"></use></svg></a><a href="https://zen.yandex.ru/habr" rel="nofollow noopener noreferrer" target="_blank" class="tm-svg-icon__wrapper tm-social-icons__icon"><svg height="16" width="16" class="tm-svg-img tm-svg-icon"><title>Яндекс Дзен</title> <use xlink:href="/img/social-icons-sprite.svg#social-logo-zen"></use></svg></a></div> <DIV class="v-portal" style="display:none;"></DIV> <button class="tm-footer__link"><!---->
        Настройка языка
      </button> <a href="https://habr.com/ru/about" class="tm-footer__link">
        О сайте
      </a> <a href="https://habr.com/ru/feedback/" class="tm-footer__link">
        Техническая поддержка
      </a> <!----> <a href="https://habr.com/berserk-mode-nope" class="tm-footer__link">
        Вернуться на старую версию
      </a> <div class="tm-footer-copyright"><span class="tm-copyright"><span class="tm-copyright__years">© 2006–2022 </span> <span class="tm-copyright__name">«<a href="https://company.habr.com/" rel="noopener" target="_blank" class="tm-copyright__link">Habr</a>»</span></span></div></div></div></div> <!----> <!----></div> <div class="vue-portal-target"></div></div>
<script>window.__INITIAL_STATE__={"adblock":{"hasAcceptableAdsFilter":false,"hasAdblock":false},"articlesList":{"articlesList":{"358950":{"id":"358950","timePublished":"2018-05-20T11:38:20+00:00","isCorporative":false,"lang":"ru","titleHtml":"Пирамида тестов на практике","leadData":{"textHtml":"\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fpost_images\u002F753\u002F224\u002F111\u002F753224111d9c766c7e6040411e6a5cf9.jpg\" align=\"left\"\u003E\u003Cfont color=\"gray\"\u003EОб авторе: \u003Cb\u003E\u003Ca href=\"http:\u002F\u002Fwww.hamvocke.com\u002F\"\u003EХэм Фокке\u003C\u002Fa\u003E\u003C\u002Fb\u003E — разработчик и консультант ThoughtWorks в Германии. Устав от деплоя в три ночи, он добавил в свой инструментарий средства непрерывной доставки и тщательной автоматизации. Сейчас налаживает такие системы другим командам для обеспечения надёжной и эффективной поставки программного обеспечения. Так он экономит компаниям время, которое эти надоедливые людишки тратили на свои выходки.\u003C\u002Ffont\u003E \u003Cbr\u003E\r\n\u003Cbr\u003E\r\n«Пирамида тестов» — метафора, которая означает группировку тестов программного обеспечения по разным уровням детализации. Она также даёт представление, сколько тестов должно быть в каждой из этих групп. Несмотря на то, что концепция тестовой пирамиды существует довольно давно, многие команды разработчиков по-прежнему пытаются неправильно реализовать её на практике должным образом. В этой статье рассматривается первоначальная концепция тестовой пирамиды и показано, как её воплотить в жизнь. Она показывает, какие виды тестов следует искать на разных уровнях пирамиды, и даёт практические примеры, как их можно реализовать.\u003Cbr\u003E\r\n\u003Cbr\u003E\r\n\u003Cdiv class=\"spoiler\"\u003E\u003Cb class=\"spoiler_title\"\u003EСодержание\u003C\u002Fb\u003E\u003Cdiv class=\"spoiler_text\"\u003E\u003Cul\u003E\r\n\u003Cli\u003E\u003Ca href=\"#TheImportanceOftestAutomation\"\u003EВажность автоматизации (тестов)\u003C\u002Fa\u003E\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ca href=\"#TheTestPyramid\"\u003EПирамида тестов\u003C\u002Fa\u003E\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ca href=\"#ToolsAndLibrariesWellLookAt\"\u003EКакие инструменты и библиотеки мы рассмотрим\u003C\u002Fa\u003E\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ca href=\"#TheSampleApplication\"\u003EПример приложения\u003C\u002Fa\u003E\u003Cbr\u003E\r\n\u003Cul\u003E\r\n\u003Cli\u003E\u003Ca href=\"#Functionality\"\u003EФункциональность\u003C\u002Fa\u003E\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ca href=\"#High-levelStructure\"\u003EВысокоуровневые структуры\u003C\u002Fa\u003E\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ca href=\"#InternalArchitecture\"\u003EВнутренняя архитектура\u003C\u002Fa\u003E\u003C\u002Fli\u003E\r\n\u003C\u002Ful\u003E\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ca href=\"#UnitTests\"\u003EЮнит-тесты\u003C\u002Fa\u003E\u003Cbr\u003E\r\n\u003Cul\u003E\r\n\u003Cli\u003E\u003Ca href=\"#WhatsAUnit\"\u003EЧто такое юнит?\u003C\u002Fa\u003E\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ca href=\"#SociableAndSolitary\"\u003EОбщительные и одинокие тесты\u003C\u002Fa\u003E\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ca href=\"#MockingAndStubbing\"\u003EИмитации и заглушки\u003C\u002Fa\u003E\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ca href=\"#WhatToTest\"\u003EЧто тестировать?\u003C\u002Fa\u003E\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ca href=\"#TestStructure\"\u003EСтруктура теста\u003C\u002Fa\u003E\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ca href=\"#ImplementingAUnitTest\"\u003EРеализация юнит-теста\u003C\u002Fa\u003E\u003C\u002Fli\u003E\r\n\u003C\u002Ful\u003E\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ca href=\"#IntegrationTests\"\u003EИнтеграционные тесты\u003C\u002Fa\u003E\u003Cbr\u003E\r\n\u003Cul\u003E\r\n\u003Cli\u003E\u003Ca href=\"#DatabaseIntegration\"\u003EИнтеграция БД\u003C\u002Fa\u003E\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ca href=\"#IntegrationWithSeparateServices\"\u003EИнтеграция с отдельными сервисами\u003C\u002Fa\u003E\u003C\u002Fli\u003E\r\n\u003C\u002Ful\u003E\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ca href=\"#ContractTests\"\u003EКонтрактные тесты\u003C\u002Fa\u003E\u003Cbr\u003E\r\n\u003Cul\u003E\r\n\u003Cli\u003E\u003Ca href=\"#ConsumerTestourTeam\"\u003EТест потребителя (наша команда)\u003C\u002Fa\u003E\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ca href=\"#ProviderTesttheOtherTeam\"\u003EТест поставщика (другая команда)\u003C\u002Fa\u003E\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ca href=\"#ProviderTestourTeam\"\u003EТест поставщика (наша команда)\u003C\u002Fa\u003E\u003C\u002Fli\u003E\r\n\u003C\u002Ful\u003E\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ca href=\"#UiTests\"\u003EТесты UI\u003C\u002Fa\u003E\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ca href=\"#End-to-endTests\"\u003EСквозные тесты\u003C\u002Fa\u003E\u003Cbr\u003E\r\n\u003Cul\u003E\r\n\u003Cli\u003E\u003Ca href=\"#UserInterfaceEnd-to-endTest\"\u003EСквозные тесты пользовательского интерфейса\u003C\u002Fa\u003E\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ca href=\"#RestApiEnd-to-endTest\"\u003EСквозной тест REST API\u003C\u002Fa\u003E\u003C\u002Fli\u003E\r\n\u003C\u002Ful\u003E\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ca href=\"#acceptance\"\u003EПриёмочные тесты — ваши фичи правильно работают?\u003C\u002Fa\u003E\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ca href=\"#ExploratoryTesting\"\u003EИсследовательское тестирование\u003C\u002Fa\u003E\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ca href=\"#TheConfusionAboutTestingTerminology\"\u003EПутаница с терминологией в тестировании\u003C\u002Fa\u003E\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ca href=\"#PuttingTestsIntoYourDeploymentPipeline\"\u003EВнедрение тестов в конвейер развёртывания\u003C\u002Fa\u003E\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ca href=\"#AvoidTestDuplication\"\u003EИзбегайте дублирования тестов\u003C\u002Fa\u003E\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ca href=\"#WritingCleanTestCode\"\u003EПишите чистый код для тестов\u003C\u002Fa\u003E\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ca href=\"#Conclusion\"\u003EЗаключение\u003C\u002Fa\u003E\u003C\u002Fli\u003E\r\n\u003C\u002Ful\u003E\u003Cbr\u003E\r\n\u003Cb\u003EПримечания\u003C\u002Fb\u003E\u003Cbr\u003E\r\n\u003Cbr\u003E\r\n\u003Cul\u003E\r\n\u003Cli\u003E\u003Ca href=\"#private-methods-sidebar\"\u003EНо мне действительно нужно протестировать этот закрытый метод\u003C\u002Fa\u003E\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ca href=\"#SpecialisedTestHelpers\"\u003EСпециализированные тестовые хелперы\u003C\u002Fa\u003E\u003C\u002Fli\u003E\r\n\u003C\u002Ful\u003E\u003C\u002Fdiv\u003E\u003C\u002Fdiv\u003E","imageUrl":null,"buttonTextHtml":"Читать дальше →","image":null},"editorVersion":"1.0","postType":"article","postLabels":[{"type":"translation","data":{"originalAuthorName":"Ham Vocke","originalUrl":"https:\u002F\u002Fmartinfowler.com\u002Farticles\u002Fpractical-test-pyramid.html"}}],"author":{"scoreStats":{"score":1243,"votesCount":1515},"rating":0,"relatedData":null,"contacts":[],"authorContacts":[],"paymentDetails":{"paymentYandexMoney":null,"paymentPayPalMe":null,"paymentWebmoney":null},"id":"1371978","alias":"m1rko","fullname":"Анатолий Ализар","avatarUrl":"\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Favatars\u002F4ec\u002Fbd0\u002F85d\u002F4ecbd085d692835a931d03174ff19539.png","speciality":"автор, переводчик, редактор"},"statistics":{"commentsCount":4,"favoritesCount":381,"readingCount":166707,"score":14,"votesCount":14},"hubs":[{"relatedData":null,"id":"19","alias":"microformats","type":"collective","title":"Микроформаты","titleHtml":"Микроформаты","isProfiled":true},{"relatedData":null,"id":"210","alias":"it_testing","type":"collective","title":"Тестирование IT-систем","titleHtml":"Тестирование IT-систем","isProfiled":true},{"relatedData":null,"id":"19279","alias":"web_testing","type":"collective","title":"Тестирование веб-сервисов","titleHtml":"Тестирование веб-сервисов","isProfiled":true},{"relatedData":null,"id":"19583","alias":"dev_management","type":"collective","title":"Управление разработкой","titleHtml":"Управление разработкой","isProfiled":true},{"relatedData":null,"id":"20788","alias":"devops","type":"collective","title":"DevOps","titleHtml":"DevOps","isProfiled":true}],"flows":[{"id":"1","alias":"develop","title":"Разработка"},{"id":"3","alias":"management","title":"Менеджмент"},{"id":"6","alias":"admin","title":"Администрирование"}],"relatedData":null,"textHtml":"\u003Cdiv xmlns=\"http:\u002F\u002Fwww.w3.org\u002F1999\u002Fxhtml\"\u003E\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw780q1\u002Fgetpro\u002Fhabr\u002Fpost_images\u002F753\u002F224\u002F111\u002F753224111d9c766c7e6040411e6a5cf9.jpg\" align=\"left\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fpost_images\u002F753\u002F224\u002F111\u002F753224111d9c766c7e6040411e6a5cf9.jpg\" data-blurred=\"true\"\u002F\u003E\u003Cfont color=\"gray\"\u003EОб авторе: \u003Cb\u003E\u003Ca href=\"http:\u002F\u002Fwww.hamvocke.com\u002F\"\u003EХэм Фокке\u003C\u002Fa\u003E\u003C\u002Fb\u003E — разработчик и консультант ThoughtWorks в Германии. Устав от деплоя в три ночи, он добавил в свой инструментарий средства непрерывной доставки и тщательной автоматизации. Сейчас налаживает такие системы другим командам для обеспечения надёжной и эффективной поставки программного обеспечения. Так он экономит компаниям время, которое эти надоедливые людишки тратили на свои выходки.\u003C\u002Ffont\u003E \u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n«Пирамида тестов» — метафора, которая означает группировку тестов программного обеспечения по разным уровням детализации. Она также даёт представление, сколько тестов должно быть в каждой из этих групп. Несмотря на то, что концепция тестовой пирамиды существует довольно давно, многие команды разработчиков по-прежнему пытаются неправильно реализовать её на практике должным образом. В этой статье рассматривается первоначальная концепция тестовой пирамиды и показано, как её воплотить в жизнь. Она показывает, какие виды тестов следует искать на разных уровнях пирамиды, и даёт практические примеры, как их можно реализовать.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cdiv class=\"spoiler\"\u003E\u003Cb class=\"spoiler_title\"\u003EСодержание\u003C\u002Fb\u003E\u003Cdiv class=\"spoiler_text\"\u003E\u003Cul\u003E\r\n\u003Cli\u003E\u003Ca href=\"#TheImportanceOftestAutomation\"\u003EВажность автоматизации (тестов)\u003C\u002Fa\u003E\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ca href=\"#TheTestPyramid\"\u003EПирамида тестов\u003C\u002Fa\u003E\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ca href=\"#ToolsAndLibrariesWellLookAt\"\u003EКакие инструменты и библиотеки мы рассмотрим\u003C\u002Fa\u003E\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ca href=\"#TheSampleApplication\"\u003EПример приложения\u003C\u002Fa\u003E\u003Cbr\u002F\u003E\r\n\u003Cul\u003E\r\n\u003Cli\u003E\u003Ca href=\"#Functionality\"\u003EФункциональность\u003C\u002Fa\u003E\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ca href=\"#High-levelStructure\"\u003EВысокоуровневые структуры\u003C\u002Fa\u003E\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ca href=\"#InternalArchitecture\"\u003EВнутренняя архитектура\u003C\u002Fa\u003E\u003C\u002Fli\u003E\r\n\u003C\u002Ful\u003E\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ca href=\"#UnitTests\"\u003EЮнит-тесты\u003C\u002Fa\u003E\u003Cbr\u002F\u003E\r\n\u003Cul\u003E\r\n\u003Cli\u003E\u003Ca href=\"#WhatsAUnit\"\u003EЧто такое юнит?\u003C\u002Fa\u003E\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ca href=\"#SociableAndSolitary\"\u003EОбщительные и одинокие тесты\u003C\u002Fa\u003E\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ca href=\"#MockingAndStubbing\"\u003EИмитации и заглушки\u003C\u002Fa\u003E\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ca href=\"#WhatToTest\"\u003EЧто тестировать?\u003C\u002Fa\u003E\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ca href=\"#TestStructure\"\u003EСтруктура теста\u003C\u002Fa\u003E\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ca href=\"#ImplementingAUnitTest\"\u003EРеализация юнит-теста\u003C\u002Fa\u003E\u003C\u002Fli\u003E\r\n\u003C\u002Ful\u003E\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ca href=\"#IntegrationTests\"\u003EИнтеграционные тесты\u003C\u002Fa\u003E\u003Cbr\u002F\u003E\r\n\u003Cul\u003E\r\n\u003Cli\u003E\u003Ca href=\"#DatabaseIntegration\"\u003EИнтеграция БД\u003C\u002Fa\u003E\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ca href=\"#IntegrationWithSeparateServices\"\u003EИнтеграция с отдельными сервисами\u003C\u002Fa\u003E\u003C\u002Fli\u003E\r\n\u003C\u002Ful\u003E\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ca href=\"#ContractTests\"\u003EКонтрактные тесты\u003C\u002Fa\u003E\u003Cbr\u002F\u003E\r\n\u003Cul\u003E\r\n\u003Cli\u003E\u003Ca href=\"#ConsumerTestourTeam\"\u003EТест потребителя (наша команда)\u003C\u002Fa\u003E\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ca href=\"#ProviderTesttheOtherTeam\"\u003EТест поставщика (другая команда)\u003C\u002Fa\u003E\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ca href=\"#ProviderTestourTeam\"\u003EТест поставщика (наша команда)\u003C\u002Fa\u003E\u003C\u002Fli\u003E\r\n\u003C\u002Ful\u003E\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ca href=\"#UiTests\"\u003EТесты UI\u003C\u002Fa\u003E\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ca href=\"#End-to-endTests\"\u003EСквозные тесты\u003C\u002Fa\u003E\u003Cbr\u002F\u003E\r\n\u003Cul\u003E\r\n\u003Cli\u003E\u003Ca href=\"#UserInterfaceEnd-to-endTest\"\u003EСквозные тесты пользовательского интерфейса\u003C\u002Fa\u003E\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ca href=\"#RestApiEnd-to-endTest\"\u003EСквозной тест REST API\u003C\u002Fa\u003E\u003C\u002Fli\u003E\r\n\u003C\u002Ful\u003E\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ca href=\"#acceptance\"\u003EПриёмочные тесты — ваши фичи правильно работают?\u003C\u002Fa\u003E\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ca href=\"#ExploratoryTesting\"\u003EИсследовательское тестирование\u003C\u002Fa\u003E\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ca href=\"#TheConfusionAboutTestingTerminology\"\u003EПутаница с терминологией в тестировании\u003C\u002Fa\u003E\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ca href=\"#PuttingTestsIntoYourDeploymentPipeline\"\u003EВнедрение тестов в конвейер развёртывания\u003C\u002Fa\u003E\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ca href=\"#AvoidTestDuplication\"\u003EИзбегайте дублирования тестов\u003C\u002Fa\u003E\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ca href=\"#WritingCleanTestCode\"\u003EПишите чистый код для тестов\u003C\u002Fa\u003E\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ca href=\"#Conclusion\"\u003EЗаключение\u003C\u002Fa\u003E\u003C\u002Fli\u003E\r\n\u003C\u002Ful\u003E\u003Cbr\u002F\u003E\r\n\u003Cb\u003EПримечания\u003C\u002Fb\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cul\u003E\r\n\u003Cli\u003E\u003Ca href=\"#private-methods-sidebar\"\u003EНо мне действительно нужно протестировать этот закрытый метод\u003C\u002Fa\u003E\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ca href=\"#SpecialisedTestHelpers\"\u003EСпециализированные тестовые хелперы\u003C\u002Fa\u003E\u003C\u002Fli\u003E\r\n\u003C\u002Ful\u003E\u003C\u002Fdiv\u003E\u003C\u002Fdiv\u003E\u003Ca name=\"habracut\"\u003E\u003C\u002Fa\u003E\u003Cdiv style=\"text-align:center;\"\u003E\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw1560\u002Fgetpro\u002Fhabr\u002Fpost_images\u002Fea3\u002F308\u002F1dd\u002Fea33081ddc613a817b10881041035a29.png\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fpost_images\u002Fea3\u002F308\u002F1dd\u002Fea33081ddc613a817b10881041035a29.png\"\u002F\u003E\u003C\u002Fdiv\u003EПеред выпуском программное обеспечение нужно тестировать. По мере взросления софтверной отрасли созрели и подходы к тестированию. Вместо мириадов живых тестировщиков разработчики перешли к автоматизации большей части тестов. Автоматизация тестов позволяет узнать о баге в считанные секунды и минуты после его внесения в код, а не через несколько дней или недель.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nРезко сокращённый цикл обратной связи, подпитываемый автоматизированными тестами, идёт рука об руку с гибкими практиками разработки, непрерывной доставкой и культурой DevOps. Эффективный подход к тестированию обеспечивает быструю и уверенную разработку.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nВ этой статье рассматривается, как должен выглядеть хорошо сформированный набор тестов, чтобы быть гибким, надёжным и поддерживаемым — независимо от того, создаете ли вы архитектуру микросервисов, мобильные приложения или экосистемы IoT. Мы также детально рассмотрим создание эффективных и удобочитаемых автоматизированных тестов.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ca name=\"TheImportanceOftestAutomation\"\u003E\u003C\u002Fa\u003E\u003Ch1\u003EВажность автоматизации (тестов)\u003C\u002Fh1\u003E\u003Cbr\u002F\u003E\r\nПрограммное обеспечение стало неотъемлемой частью мира, в котором мы живём. Оно переросло первоначальную единственную цель увеличить эффективность бизнеса. Сегодня каждая компания стремится стать первоклассной цифровой компанией. Все мы каждый день выступаем пользователями всё большего количества ПО. Скорость инноваций возрастает.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nЕсли хотите идти в ногу со временем, нужно искать более быстрые способы доставки ПО, не жертвуя его качеством. В это может помочь непрерывная доставка — это практика, которая автоматически гарантирует, что ПО может быть выпущено в продакшн в любое время. При непрерывной доставке используется конвейер сборки для автоматического тестирования ПО и его развёртывания в тестовой и рабочей средах.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nВскоре сборка, тестирование и развёртывание постоянно растущего количества ПО вручную становится невозможной — если только вы не хотите тратить всё своё время на выполнение вручную рутинных задач вместо доставки рабочего софта. Единственный путь — автоматизировать всё, от сборки до тестирования, развёртывания и инфраструктуры.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw1560\u002Fgetpro\u002Fhabr\u002Fpost_images\u002Fa3a\u002F60c\u002Fb8b\u002Fa3a60cb8b4d4f10699cc6862d5bcf8fc.png\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fpost_images\u002Fa3a\u002F60c\u002Fb8b\u002Fa3a60cb8b4d4f10699cc6862d5bcf8fc.png\"\u002F\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ci\u003E\u003Cfont color=\"gray\"\u003EРис. 1. Использование конвейеров сборки для автоматического и надёжного ввода ПО в эксплуатацию\u003C\u002Ffont\u003E\u003C\u002Fi\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nТрадиционно тестирование требовало чрезмерной ручной работы через развертывание в тестовой среде, а затем тестов в стиле чёрного ящика, например, кликанием повсюду в пользовательском интерфейсе с наблюдением, появляются ли баги. Часто эти тесты задаются тестовыми сценариями, чтобы гарантировать, что тестировщики всё последовательно проверят.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nОчевидно, что тестирование всех изменений вручную занимает много времени, оно однообразное и утомительное. Однообразие скучно, а скука приводит к ошибкам.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nК счастью, есть прекрасный инструмент для однообразных задач: \u003Ci\u003Eавтоматизация\u003C\u002Fi\u003E.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nАвтоматизация однообразных тестов изменит вашу жизнь как разработчика. Автоматизируйте тесты, и вам больше не придётся бездумно следовать клик-протоколам, проверяя корректность работы программы. Автоматизируйте тесты, и вы не моргнув глазом измените кодовую базу. Если вы когда-либо пробовали делать крупномасштабный рефакторинг без надлежащего набора тестов, я уверен, вы знаете, в какой ужас это может превратиться. Как вы узнаете, если случайно сделаете ошибку в процессе? Ну, придётся щёлкать вручную по всем тестовым случаям, как же ещё. Но будем честными: вам это действительно нравится? Как насчёт того, чтобы даже после крупномасштабных изменений любые баги проявляли себя в течение нескольких секунд, пока вы пьёте кофе? По-моему, это гораздо приятнее.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ca name=\"TheTestPyramid\"\u003E\u003C\u002Fa\u003E\u003Ch1\u003EПирамида тестов\u003C\u002Fh1\u003E\u003Cbr\u002F\u003E\r\nЕсли серьёзно подходить к автоматическим тестам, то есть одна ключевая концепция: \u003Cb\u003Eпирамида тестов\u003C\u002Fb\u003E. Её представил Майк Кон в своей книге \u003Ci\u003E«Scrum: гибкая разработка ПО»\u003C\u002Fi\u003E (Succeeding With Agile. Software Development Using Scrum). Это отличная визуальная метафора, наталкивающая на мысль о разных уровнях тестов. Она также показывает объём тестов на каждом уровне.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cdiv style=\"text-align:center;\"\u003E\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw1560\u002Fgetpro\u002Fhabr\u002Fpost_images\u002Ff6c\u002F930\u002Ff2d\u002Ff6c930f2d4ae8a6068696ace34e9566e.png\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fpost_images\u002Ff6c\u002F930\u002Ff2d\u002Ff6c930f2d4ae8a6068696ace34e9566e.png\"\u002F\u003E\u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\n\u003Ci\u003E\u003Cfont color=\"gray\"\u003EРис. 2. Пирамида тестов\u003C\u002Ffont\u003E\u003C\u002Fi\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nОригинальная пирамида тестов Майка Кона состоит из трёх уровней (снизу вверх):\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Col\u003E\r\n\u003Cli\u003EЮнит-тесты.\u003C\u002Fli\u003E\r\n\u003Cli\u003EСервисные тесты.\u003C\u002Fli\u003E\r\n\u003Cli\u003EТесты пользовательского интерфейса.\u003C\u002Fli\u003E\r\n\u003C\u002Fol\u003E\u003Cbr\u002F\u003E\r\nК сожалению, при более тщательном концепция кажется недостаточной. Некоторые утверждают, что либо именования, либо некоторые концептуальные аспекты пирамиды тестов Майка Кона не идеальны, и я должен согласиться. С современной точки зрения пирамида тестов кажется чрезмерно упрощённой и поэтому может вводить в заблуждение.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nТем не менее, из-за своей простоты суть тестовой пирамиды представляет хорошее эмпирическое правило, когда дело доходит до создания собственного набора тестов. Из этой пирамиды главное запомнить два принципа:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Col\u003E\r\n\u003Cli\u003EПисать тесты разной детализации.\u003C\u002Fli\u003E\r\n\u003Cli\u003EЧем выше уровень, тем меньше тестов.\u003C\u002Fli\u003E\r\n\u003C\u002Fol\u003E\u003Cbr\u002F\u003E\r\nПридерживайтесь формы пирамиды, чтобы придумать здоровый, быстрый и поддерживаемый набор тестов. Напишите \u003Ci\u003Eмного\u003C\u002Fi\u003E маленьких и быстрых \u003Ci\u003Eюнит-тестов\u003C\u002Fi\u003E. Напишите \u003Ci\u003Eнесколько\u003C\u002Fi\u003E более общих тестов и \u003Ci\u003Eсовсем мало\u003C\u002Fi\u003E высокоуровневых сквозных тестов, которые проверяют приложение от начала до конца. Следите, что у вас в итоге не получился \u003Ca href=\"https:\u002F\u002Fwatirmelon.blog\u002Ftesting-pyramids\u002F\"\u003Eтестовый рожок мороженого\u003C\u002Fa\u003E, который станет кошмаром в поддержке и будет слишком долго выполняться.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nНе привязывайтесь слишком сильно к названиям отдельных уровней пирамиды тестов. На самом деле они могут ввести в заблуждение: термин «сервисный тест» трудно понять (сам Кон заметил, что \u003Ca href=\"https:\u002F\u002Fwww.mountaingoatsoftware.com\u002Fblog\u002Fthe-forgotten-layer-of-the-test-automation-pyramid\"\u003Eмногие разработчики полностью игнорируют этот уровень\u003C\u002Fa\u003E). В наше время фреймворков для одностраничных приложений вроде React, Angular, Ember.js и других становится очевидным, что тестам UI не место на вершине пирамиды — вы прекрасно можете протестировать UI во всех этих фреймворках.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nУчитывая недостатки оригинальных названий в пирамиде, вполне нормально придумать другие имена для своих уровней тестов. Главное, чтобы они соответствовали вашему коду и терминологии, принятой в вашей команде.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ca name=\"ToolsAndLibrariesWellLookAt\"\u003E\u003C\u002Fa\u003E\u003Ch1\u003EКакие инструменты и библиотеки мы рассмотрим\u003C\u002Fh1\u003E\u003Cbr\u002F\u003E\r\n\u003Cul\u003E\r\n\u003Cli\u003E\u003Ca href=\"http:\u002F\u002Fjunit.org\u002F\"\u003EJUnit\u003C\u002Fa\u003E: для запуска тестов\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ca href=\"http:\u002F\u002Fsite.mockito.org\u002F\"\u003EMockito\u003C\u002Fa\u003E: для зависимостей имитаций\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ca href=\"http:\u002F\u002Fwiremock.org\u002F\"\u003EWiremock\u003C\u002Fa\u003E: для заглушек внешних сервисов\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fdocs.pact.io\u002F\"\u003EPact\u003C\u002Fa\u003E: для написания CDC-тестов\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ca href=\"http:\u002F\u002Fdocs.seleniumhq.org\u002F\"\u003ESelenium\u003C\u002Fa\u003E: для написания сквозных тестов UI\u003C\u002Fli\u003E\r\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fgithub.com\u002Frest-assured\u002Frest-assured\"\u003EREST-assured\u003C\u002Fa\u003E: для написания сквозных тестов REST API\u003C\u002Fli\u003E\r\n\u003C\u002Ful\u003E\u003Cbr\u002F\u003E\r\n\u003Ca name=\"TheSampleApplication\"\u003E\u003C\u002Fa\u003E\u003Ch1\u003EПример приложения\u003C\u002Fh1\u003E\u003Cbr\u002F\u003E\r\nЯ написал \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fhamvocke\u002Fspring-testing\"\u003Eпростой микросервис\u003C\u002Fa\u003E с тестами из разных уровней пирамиды.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nЭто пример типичного микросервиса. Он предоставляет интерфейс REST, общается с БД и извлекает информацию из стороннего сервиса REST. Он реализован на \u003Ca href=\"https:\u002F\u002Fprojects.spring.io\u002Fspring-boot\u002F\"\u003ESpring Boot\u003C\u002Fa\u003E и должен быть понятен даже если вы никогда не работали со Spring Boot.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nОбязательно проверьте \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fhamvocke\u002Fspring-testing\"\u003Eкод на Github\u003C\u002Fa\u003E. В файле readme инструкции для запуска приложения и автоматических тестов на вашем компьютере.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ca name=\"Functionality\"\u003E\u003C\u002Fa\u003E\u003Ch3\u003EФункциональность\u003C\u002Fh3\u003E\u003Cbr\u002F\u003E\r\nУ приложения простая функциональность. Оно обеспечивает интерфейс REST с тремя конечными точками:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ccode\u003EGET \u002Fhello\u003Cbr\u002F\u003E\r\nВозвращает \u003Ci\u003E\"Hello World\"\u003C\u002Fi\u003E. Всегда.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nGET \u002Fhello \u002F{lastname}\u003Cbr\u002F\u003E\r\nИщет человека с указанной фамилией. Если человек известен, возвращает \u003Ci\u003E\"Hello {Firstname} {Lastname}\"\u003C\u002Fi\u003E.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nGET \u002Fweather \u003Cbr\u002F\u003E\r\nВозвращает текущие погодные условия в \u003Ci\u003EГамбурге, Германия\u003C\u002Fi\u003E.\u003C\u002Fcode\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ca name=\"High-levelStructure\"\u003E\u003C\u002Fa\u003E\u003Ch3\u003EВысокоуровневые структуры\u003C\u002Fh3\u003E\u003Cbr\u002F\u003E\r\nНа высоком уровне у системы следующая структура:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cdiv style=\"text-align:center;\"\u003E\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw1560\u002Fgetpro\u002Fhabr\u002Fpost_images\u002F813\u002F284\u002F1c5\u002F8132841c5c334aad6d292c69c1807de3.png\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fpost_images\u002F813\u002F284\u002F1c5\u002F8132841c5c334aad6d292c69c1807de3.png\"\u002F\u003E\u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\n\u003Ci\u003E\u003Cfont color=\"gray\"\u003EРис. 3. Высокоуровневая структура микросервиса\u003C\u002Ffont\u003E\u003C\u002Fi\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nНаш микросервис обеспечивает интерфейс REST по HTTP. Для некоторых конечных точек сервис получает информацию из БД. В других случаях обращается по HTTP к внешнему \u003Ca href=\"https:\u002F\u002Fdarksky.net\u002F\"\u003EAPI\u003C\u002Fa\u003E для получения и отображения текущей погоды.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ca name=\"InternalArchitecture\"\u003E\u003C\u002Fa\u003E\u003Ch3\u003EВнутренняя архитектура\u003C\u002Fh3\u003E\u003Cbr\u002F\u003E\r\nИзнутри у Spring Service типичная архитектура для Spring:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cdiv style=\"text-align:center;\"\u003E\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw1560\u002Fgetpro\u002Fhabr\u002Fpost_images\u002Fae4\u002F727\u002F6e6\u002Fae47276e66f80ee73f38ea2a995b8c13.png\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fpost_images\u002Fae4\u002F727\u002F6e6\u002Fae47276e66f80ee73f38ea2a995b8c13.png\"\u002F\u003E\u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\n\u003Ci\u003E\u003Cfont color=\"gray\"\u003EРис. 4. Внутренняя структура микросервиса\u003C\u002Ffont\u003E\u003C\u002Fi\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cul\u003E\r\n\u003Cli\u003EКлассы \u003Ccode\u003EController\u003C\u002Fcode\u003E предоставляют конечные точки \u003Ci\u003EREST\u003C\u002Fi\u003E, обрабатывают запросы \u003Ci\u003EHTTP\u003C\u002Fi\u003E и ответы.\u003C\u002Fli\u003E\r\n\u003Cli\u003EКлассы \u003Ccode\u003ERepository\u003C\u002Fcode\u003E взаимодействуют с \u003Ci\u003Eбазой данных\u003C\u002Fi\u003E, отвечают за запись и чтение данных в\u002Fиз постоянного хранилища.\u003C\u002Fli\u003E\r\n\u003Cli\u003EКлассы \u003Ccode\u003EClient\u003C\u002Fcode\u003E взаимодействуют с другими API, в нашем случае — забирают данные \u003Ci\u003EJSON\u003C\u002Fi\u003E по \u003Ci\u003EHTTPS\u003C\u002Fi\u003E с погодного API на darksky.net.\u003C\u002Fli\u003E\r\n\u003Cli\u003EКлассы \u003Ccode\u003EDomain\u003C\u002Fcode\u003E захватывают \u003Ca href=\"https:\u002F\u002Fen.wikipedia.org\u002Fwiki\u002FDomain_model\"\u003Eмодель домена\u003C\u002Fa\u003E, включая логику домена (которая, честно говоря, в нашем случае довольно тривиальна).\u003C\u002Fli\u003E\r\n\u003C\u002Ful\u003E\u003Cbr\u002F\u003E\r\nОпытные разработчики Spring могут заметить, что здесь отсутствует часто используемый слой: многие вдохновлённые \u003Ca href=\"https:\u002F\u002Fen.wikipedia.org\u002Fwiki\u002FDomain-driven_design\"\u003Eпроблемно-ориентированным проектированием\u003C\u002Fa\u003E разработчики создают \u003Ci\u003Eслой сервисов\u003C\u002Fi\u003E, состоящий из классов \u003Ci\u003Eсервисов\u003C\u002Fi\u003E. Я решил не включать его в приложение. Одна из причин в том, что наше приложение достаточно простое, а слой сервисов станет ненужным уровнем косвенности. Другая причина в том, что на мой взгляд люди часто переусердствуют с этими слоями. Нередко приходится видеть кодовые базы, где классы сервисов охватывают всю бизнес-логику. Модель домена становится просто слоем для данных, а не для поведения (\u003Ca href=\"https:\u002F\u002Fen.wikipedia.org\u002Fwiki\u002FAnemic_domain_model\"\u003Eанемичная модель домена\u003C\u002Fa\u003E). Для каждого нетривиального приложения так теряются большие возможности для хорошей структуризации кода и тестируемости, а также не в полной мере используется мощь объектной ориентации.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nНаши репозитории просты и обеспечивают простую функциональность \u003Cabbr title=\"create, read, update, delete\"\u003ECRUD\u003C\u002Fabbr\u003E. Для простоты кода я использовал \u003Ca href=\"http:\u002F\u002Fprojects.spring.io\u002Fspring-data\u002F\"\u003ESpring Data\u003C\u002Fa\u003E. Он даёт простую и универсальную реализацию репозитория CRUD, а также заботится о том, чтобы развернуть для наших тестов БД в памяти, а не использовать реальную PostgreSQL, как это было бы в продакшне.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nВзгляните на кодовую базу и познакомьтесь с внутренней структурой. Это полезно для следующего шага: тестирования приложения!\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ca name=\"UnitTests\"\u003E\u003C\u002Fa\u003E\u003Ch1\u003EЮнит-тесты\u003C\u002Fh1\u003E\u003Cbr\u002F\u003E\r\nОснова вашего набора тестов состоит из юнит-тестов (модульных тестов). Они проверяют, что отдельный юнит (\u003Ci\u003Eтестируемый субъект\u003C\u002Fi\u003E) кодовой базы работает должным образом. Модульные тесты имеют максимально узкую область среди всех тестов в наборе тестов. Количество юнит-тестов в наборе значительно превышает количество любых других тестов.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cdiv style=\"text-align:center;\"\u003E\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw1560\u002Fgetpro\u002Fhabr\u002Fpost_images\u002F9be\u002F489\u002F778\u002F9be48977803c4fd5bd9882450db5b4ff.png\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fpost_images\u002F9be\u002F489\u002F778\u002F9be48977803c4fd5bd9882450db5b4ff.png\"\u002F\u003E\u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\n\u003Ci\u003E\u003Cfont color=\"gray\"\u003EРис. 5. Обычно юнит-тест заменяет внешних пользователей тестовыми дублями\u003C\u002Ffont\u003E\u003C\u002Fi\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ca name=\"WhatsAUnit\"\u003E\u003C\u002Fa\u003E\u003Ch3\u003EЧто такое юнит?\u003C\u002Fh3\u003E\u003Cbr\u002F\u003E\r\nЕсли вы спросите трёх разных людей, что означает \u003Ci\u003E«юнит»\u003C\u002Fi\u003E в контексте юнит-тестов, то вероятно получите четыре разных, слегка отличающихся ответа. В определённой степени это вопрос вашего собственного определения — и это нормально, что здесь нет общепринятого канонического ответа.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nЕсли вы пишете на функциональном языке, то юнитом скорее всего будет отдельная функция. Ваши юнит-тесты вызовут функцию с различными параметрами и обеспечат возврат ожидаемых значений. В объектно-ориентированном языке юнит может варьироваться от отдельного метода до целого класса.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ca name=\"SociableAndSolitary\"\u003E\u003C\u002Fa\u003E\u003Ch3\u003EОбщительные и одинокие тесты\u003C\u002Fh3\u003E\u003Cbr\u002F\u003E\r\nНекоторые утверждают, что всех участников (например, вызываемые классы) тестируемого субъекта следует заменить на \u003Ci\u003Eимитации\u003C\u002Fi\u003E (mocks) или \u003Ci\u003Eзаглушки\u003C\u002Fi\u003E (stubs), чтобы создать идеальную изоляцию, избежать побочных эффектов и сложной настройки теста. Другие утверждают, что на имитации и заглушки следует заменять только участников, которые замедляют тест или проявляют сильные побочные эффекты (например, классы с доступом к БД или сетевыми вызовами).\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ca href=\"https:\u002F\u002Fmartinfowler.com\u002Fbliki\u002FUnitTest.html\"\u003EИногда\u003C\u002Fa\u003E эти два вида юнит-тестов называют \u003Cb\u003Eодинокими\u003C\u002Fb\u003E (solitary) в случае тотального применения имитаций и заглушек или \u003Cb\u003Eобщительными\u003C\u002Fb\u003E (sociable) в случае реальных коммуникаций с другими участниками (эти термины придумал Джей Филдс для книги \u003Ca href=\"https:\u002F\u002Fleanpub.com\u002Fwewut\"\u003E«Эффективная работа с юнит-тестами»\u003C\u002Fa\u003E). Если у вас есть немного свободного времени, можете спуститься в кроличью нору и \u003Ca href=\"https:\u002F\u002Fmartinfowler.com\u002Farticles\u002FmocksArentStubs.html\"\u003Eразобраться в преимуществах и недостатках\u003C\u002Fa\u003E разных точек зрения.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nНо в итоге не имеет значения, какой тип тестов вы выберете. Что реально важно, так это их автоматизация. Лично я постоянно использую оба подхода. Если неудобно работать с реальными участниками, я буду обильно использовать имитации и заглушки. Если чувствую, что привлечение реального участника даёт больше уверенности в тесте, то заглушу только самые дальние части сервиса.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ca name=\"MockingAndStubbing\"\u003E\u003C\u002Fa\u003E\u003Ch3\u003EИмитации и заглушки\u003C\u002Fh3\u003E\u003Cbr\u002F\u003E\r\nИмитации (mocks) и заглушки (stubs) — это два разных типа \u003Ca href=\"https:\u002F\u002Fmartinfowler.com\u002Fbliki\u002FTestDouble.html\"\u003Eтестовых дублёров\u003C\u002Fa\u003E (вообще их больше). Многие используют термины взаимозаменяемо. Думаю, что лучше соблюдать точность и держать в уме конкретные свойства каждого из них. К объектам из продакшна тестовые дублёры создают реализацию для тестов.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nПроще говоря, вы заменяете реальную вещь (например, класс, модуль или функцию) поддельной копией. Подделка выглядит и действует как оригинал (даёт такие же ответы на те же вызовы методов), но это заранее установленные ответы, которые вы сами определяете для юнит-теста.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nТестовые дублёры используются не только в юнит-тестах. Более сложные дублёры применяются для контролируемой имитации целых частей вашей системы. Однако в юнит-тестах используется особенно много имитаций и заглушек (в зависимости от того, предпочитаете вы общительные или одиночные тесты) просто потому что множество современных языков и библиотек позволяют легко и удобно их создавать.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nНезависимо от выбранной технологии, в стандартной библиотеке вашего языка или какой-то популярной сторонней библиотеке уже есть элегантный способ настройки имитаций. И даже для написания собственных имитаций с нуля достаточно всего лишь написать поддельный класс\u002Fмодуль\u002Fфункцию с той же подписью, что и реальная, и настройки имитации для теста.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nВаши юнит-тесты будут работать очень быстро. На приличной машине можно прогнать тысячи модульных тестов за нескольких минут. Тестируйте изолированно небольшие фрагменты кодовой базы и избегайте контактов с БД, файловой системой и HTTP-запросов (ставя здесь имитации и заглушки), чтобы сохранить высокую скорость.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nПоняв основы, со временем вы начнёте всё более свободно и легко писать юнит-тесты. Заглушка внешних участников, настройка входных данных, вызов тестируемого субъекта — и проверка, что возвращаемое значение соответствует ожидаемому. Посмотрите на \u003Ca href=\"https:\u002F\u002Fen.wikipedia.org\u002Fwiki\u002FTest-driven_development\"\u003Eразработку через тестирование\u003C\u002Fa\u003E (TDD), и пусть юнит-тесты направляют вашу разработку; если они применяются правильно, это поможет попасть в мощный поток и создать хорошую поддерживаемую архитектуру, автоматически выдавая всеобъемлющий и полностью автоматизированный набор тестов. Но это не универсальное решение. Попробуйте и посмотрите сами, подходит ли TDD в вашем конкретном случае.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ca name=\"WhatToTest\"\u003E\u003C\u002Fa\u003E\u003Ch3\u003EЧто тестировать?\u003C\u002Fh3\u003E\u003Cbr\u002F\u003E\r\nХорошо, что юнит-тесты можно писать для всех классов кода продакшна, независимо от их функциональности или того, к какому уровню внутренней структуры они принадлежат. Юнит-тесты подходят для контроллеров, репозиториев, классов предметной области или программ считывания файлов. Просто придерживайтесь практического правила \u003Cb\u003Eодин тестовый класс на один класс продакшна\u003C\u002Fb\u003E.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nЮнит-тест должен как минимум \u003Cb\u003Eпротестировать \u003Ci\u003Eоткрытый\u003C\u002Fi\u003E интерфейс класса\u003C\u002Fb\u003E. закрытые методы всё равно нельзя протестировать, потому что их нельзя вызвать из другого тестового класса. \u003Ci\u003EЗащищённые\u003C\u002Fi\u003E или \u003Ci\u003Eдоступные\u003C\u002Fi\u003E лишь в пределах пакета (package-private) методы доступны из тестового класса (учитывая, что структура пакета тестового класса такая же, как на продакшне), но тестирование этих методов может уже зайти слишком далеко.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nКогда дело доходит до написания юнит-тестов, есть тонкая черта: они должны гарантировать, что проверены все нетривиальные пути кода, включая дефолтный сценарий и пограничные ситуации. В то же время они не должны быть слишком тесно привязаны к реализации.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nПочему так?\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nТесты, слишком привязанные к коду продакшна, быстро начинают раздражать. Как только вы осуществляете рефакторинг кода (то есть изменяете внутреннюю структуру кода без изменения внешнего поведения), модульные тесты сразу ломаются.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nТаким образом, вы теряете важное преимущество юнит-тестов: действовать в качестве системы безопасности для изменений кода. Вы скорее устанете от этих глупых тестов, которые падают каждый раз после рефакторинга, принося больше проблем, чем пользы; чья вообще была эта дурацкая идея внедрить тесты?\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nЧем же делать? Не отражайте в модульных тестах внутреннюю структуру кода. Тестируйте наблюдаемое поведение. Например:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ci\u003Eесли я введу значения x и y, будет ли результат z?\u003C\u002Fi\u003E \u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nвместо этого:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ci\u003Eесли я введу x и y, то обратится ли метод сначала к классу А, затем к классу Б, а затем сложит результаты от класса А и класса Б?\u003C\u002Fi\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nКак правило, закрытые методы следует рассматривать как деталь реализации. Вот почему даже не должно появляться желание их проверить.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nЧасто я слышу от противников модульного тестирования (или TDD), что написание юнит-тестов становится бессмысленным, если нужно проверить все методы для большого охвата тестирования. Они часто ссылаются на сценарии, где чрезмерно нетерпеливый тимлид заставил писать модульные тесты для геттеров и сеттеров и прочего тривиального кода, чтобы выйти на 100% тестового покрытия.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nЭто совершенно неправильно.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nДа, вы должны \u003Ci\u003Eпротестировать публичный интерфейс\u003C\u002Fi\u003E. Но ещё более важно \u003Ci\u003Eне тестировать тривиальный код\u003C\u002Fi\u003E. Не волнуйтесь, \u003Ca href=\"https:\u002F\u002Fstackoverflow.com\u002Fquestions\u002F153234\u002Fhow-deep-are-your-unit-tests\u002F\"\u003EКент Бек это одобряет\u003C\u002Fa\u003E. Вы ничего не получите от тестирования простых геттеров или сеттеров или других тривиальных реализаций (например, без какой-либо условной логики). И вы сэкономите время, так что сможете посидеть ещё на одном совещании, ура!\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ca name=\"private-methods-sidebar\"\u003E\u003C\u002Fa\u003E\u003Cblockquote\u003E\u003Cb\u003EНо мне \u003Ci\u003Eочень\u003C\u002Fi\u003E нужно проверить этот закрытый метод\u003C\u002Fb\u003E \u003Cbr\u002F\u003E\r\nЕсли вы когда-нибудь окажетесь в ситуации, когда вам \u003Ci\u003Eочень-очень\u003C\u002Fi\u003E нужно проверить закрытый метод, нужно сделать шаг назад и спросить себя: почему?\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nУверен, что здесь скорее проблема дизайна. Скорее всего, вы чувствуете необходимость протестировать закрытый метод, потому что он сложный, а тестирование метода через открытый интерфейс класса требует слишком неудобной настройки.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nВсякий раз, когда я оказываюсь в такой ситуации, я обычно прихожу к выводу, что тестируемый класс переусложнён. Он делает слишком много и нарушает принцип единой ответственности — один из пяти принципов \u003Ca href=\"https:\u002F\u002Fen.wikipedia.org\u002Fwiki\u002FSOLID_(object-oriented_design)\"\u003ESOLID\u003C\u002Fa\u003E.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nДля меня часто работает решение разделить исходный класс на два класса. Часто после минуты-другой размышлений находится хороший способ разбить большой класс на два меньших с индивидуальной ответственностью. Я перемещаю закрытый метод (который срочно надо протестировать) в новый класс и позволяю старому классу вызвать новый метод. Вуаля, неудобный для тестирования закрытый метод теперь публичен и легко тестируется. Кроме того, я улучшил структуру кода, внедрив принцип единой ответственности.\u003C\u002Fblockquote\u003E\u003Cbr\u002F\u003E\r\n\u003Ca name=\"TestStructure\"\u003E\u003C\u002Fa\u003E\u003Ch3\u003ECтруктура теста\u003C\u002Fh3\u003E\u003Cbr\u002F\u003E\r\nХорошая структура всех ваших тестов (не только модульных) такова:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Col\u003E\r\n\u003Cli\u003EНастройка тестовых данных.\u003C\u002Fli\u003E\r\n\u003Cli\u003EВызов тестируемого метода.\u003C\u002Fli\u003E\r\n\u003Cli\u003EПроверка, что возвращаются ожидаемые результаты.\u003C\u002Fli\u003E\r\n\u003C\u002Fol\u003E\u003Cbr\u002F\u003E\r\nЕсть хорошая мнемоника для запоминания этой структуры: три A (\u003Ca href=\"https:\u002F\u002Fxp123.com\u002Farticles\u002F3a-arrange-act-assert\u002F\"\u003EArrange, Act, Assert\u003C\u002Fa\u003E). Можно использовать и другую мнемонику с корнями в BDD (разработка, основанная на описании поведения). Это триада \u003Ca href=\"https:\u002F\u002Fmartinfowler.com\u002Fbliki\u002FGivenWhenThen.html\"\u003Eдано, когда, тогда\u003C\u002Fa\u003E, где «дано» отражает настройку, «когда» — вызов метода, а «тогда» — утверждение.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nЭтот шаблон можно применить и к другим, более высокоуровневым тестам. В каждом случае они гарантируют, что тесты остаются лёгкими и читаемыми. Кроме того, написанные с учётом этой структуры тесты обычно короче и выразительнее.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ca name=\"ImplementingAUnitTest\"\u003E\u003C\u002Fa\u003E\u003Ch3\u003EРеализация юнит-теста\u003C\u002Fh3\u003E\u003Cbr\u002F\u003E\r\nТеперь мы знаем, что именно тестировать и как структурировать юнит-тесты. Пришло время посмотреть на реальный пример.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nВозьмем упрощённую версию класса \u003Ccode\u003EExampleController\u003C\u002Fcode\u003E.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"java\"\u003E@RestController\npublic class ExampleController {\n\n    private final PersonRepository personRepo;\n\n    @Autowired\n    public ExampleController(final PersonRepository personRepo) {\n        this.personRepo = personRepo;\n    }\n\n    @GetMapping(\"\u002Fhello\u002F{lastName}\")\n    public String hello(@PathVariable final String lastName) {\n        Optional&lt;Person\u003E foundPerson = personRepo.findByLastName(lastName);\n\n        return foundPerson\n                .map(person -\u003E String.format(\"Hello %s %s!\",\n                        person.getFirstName(),\n                        person.getLastName()))\n                .orElse(String.format(\"Who is this '%s' you're talking about?\",\n                        lastName));\n    }\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nЮнит-тест для метода \u003Ccode\u003Ehello(lastname)\u003C\u002Fcode\u003E может выглядеть таким образом:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"java\"\u003Epublic class ExampleControllerTest {\n\n    private ExampleController subject;\n\n    @Mock\n    private PersonRepository personRepo;\n\n    @Before\n    public void setUp() throws Exception {\n        initMocks(this);\n        subject = new ExampleController(personRepo);\n    }\n\n    @Test\n    public void shouldReturnFullNameOfAPerson() throws Exception {\n        Person peter = new Person(\"Peter\", \"Pan\");\n        given(personRepo.findByLastName(\"Pan\"))\n            .willReturn(Optional.of(peter));\n\n        String greeting = subject.hello(\"Pan\");\n\n        assertThat(greeting, is(\"Hello Peter Pan!\"));\n    }\n\n    @Test\n    public void shouldTellIfPersonIsUnknown() throws Exception {\n        given(personRepo.findByLastName(anyString()))\n            .willReturn(Optional.empty());\n\n        String greeting = subject.hello(\"Pan\");\n\n        assertThat(greeting, is(\"Who is this 'Pan' you're talking about?\"));\n    }\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nМы пишем юнит-тесты в \u003Ca href=\"http:\u002F\u002Fjunit.org\u002F\"\u003EJUnit\u003C\u002Fa\u003E, стандартном фреймворке тестирования Java. Используем \u003Ca href=\"http:\u002F\u002Fsite.mockito.org\u002F\"\u003EMockito\u003C\u002Fa\u003E для замены реального класса \u003Ccode\u003EPersonRepository\u003C\u002Fcode\u003E на класс с заглушкой для теста. Эта заглушка позволяет указать предустановленные ответы, которые вернёт метод-заглушка. Подобный подход делает тест более простым и предсказуемым, позволяя легко настроить проверку данных.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nСледуя структуре «трёх А» пишем два юнит-теста для положительного и отрицательного случаев, когда искомое лицо не может быть найдено. Положительный тестовый случай создаёт новый объект person и сообщает имитации репозитория возвращать этот объект, когда параметр \u003Ccode\u003ElastName\u003C\u002Fcode\u003E вызывается со значением \u003Ci\u003EPan\u003C\u002Fi\u003E. Затем тест вызывает тестируемый метод. Наконец, он сравнивает ответ с ожидаемым.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nВторой тест работает аналогично, но тестирует сценарий, в котором тестируемый метод не находит объект person для данного параметра.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ca name=\"SpecialisedTestHelpers\"\u003E\u003C\u002Fa\u003E\u003Cblockquote\u003E\u003Cb\u003EСпециализированные тестовые хелперы\u003C\u002Fb\u003E\u003Cbr\u002F\u003E\r\nЗамечательно, что вы можете писать юнит-тесты для всей кодовой базы независимо от уровня архитектуры вашего приложения. Пример ниже показывает простой юнит-тест для контроллера. К сожалению, когда дело доходит до контроллеров Spring, у этого подхода есть недостаток: контроллер Spring MVC интенсивно использует аннотации с объявлениями прослушиваемых путей, используемых команд HTTP, параметров парсинга URL, параметров запросов и так далее. Простой вызов метода контроллера в юнит-тесте не проверит все эти важные вещи. К счастью, сообщество Spring придумало хороший тестовый хелпер, который можно использовать для улучшенного тестирования контроллера. Обязательно посмотрите \u003Ca href=\"https:\u002F\u002Fdocs.spring.io\u002Fspring\u002Fdocs\u002Fcurrent\u002Fspring-framework-reference\u002Ftesting.html#spring-mvc-test-server\"\u003EMockMVC\u003C\u002Fa\u003E. Это даст отличный DSL для генерации поддельных запросов к контроллеру и проверки, что всё работает отлично. Я включил \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fhamvocke\u002Fspring-testing\u002Fblob\u002Fmaster\u002Fsrc\u002Ftest\u002Fjava\u002Fexample\u002FExampleControllerAPITest.java\"\u003Eпример\u003C\u002Fa\u003E в код. Во многих фреймворках есть тестовые хелперы для упрощения тестов конкретных частей кода. Ознакомьтесь с документацией по своему фреймворку и посмотрите, предлагает ли там какие-либо полезные хелперы для ваших автоматизированных тестов.\u003C\u002Fblockquote\u003E\u003Cbr\u002F\u003E\r\n\u003Ca name=\"IntegrationTests\"\u003E\u003C\u002Fa\u003E\u003Ch1\u003EИнтеграционные тесты\u003C\u002Fh1\u003E\u003Cbr\u002F\u003E\r\nВсе нетривиальные приложения интегрированы с некоторыми другими частями (базы данных, файловые системы, сетевые вызовы к другим приложениям). В юнит-тестах вы обычно имитируете их для лучшей изоляции и повышения скорости. Тем не менее, ваше приложение будет реально взаимодействовать с другими частями — и это следует протестировать. Для этого предназначены \u003Ca href=\"https:\u002F\u002Fmartinfowler.com\u002Fbliki\u002FIntegrationTest.html\"\u003Eинтеграционные тесты\u003C\u002Fa\u003E. Они проверяют интеграцию приложения со всеми компонентами вне приложения.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nДля автоматизированных тестов это означает, что нужно запустить не только собственное приложение, но и интегрируемый компонент. Если вы тестируете интеграцию с БД, то при выполнении тестов надо запустить БД. Чтобы проверить чтение файлов с диска нужно сохранить файл на диск и загрузить его в интеграционный тест.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nЯ ранее упоминал, что юнит-тесты — неопределённый термин. Ещё в большей степени это относится к интеграционным тестам. Для кого-то «интеграция» означает тестирование всего стека вашего приложения в комплексе с другими. Мне нравится более узкое определение и тестирование каждой точки интеграции по отдельности, заменяя остальные сервисы и базы данных тестовыми дублёрами. Вместе с контрактным тестированием и выполнением контрактных тестов на дублёрах и реальных реализациях можно придумать интеграционные тесты, которые быстрее, более независимы и обычно проще в понимании.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nУзкие интеграционные тесты живут на границе вашего сервиса. Концептуально они всегда запускают действие, которое приводит к интеграции с внешней частью (файловой системой, базой данных, отдельным сервисом). Тест интеграции БД выглядит следующим образом:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cdiv style=\"text-align:center;\"\u003E\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw1560\u002Fgetpro\u002Fhabr\u002Fpost_images\u002F089\u002F6ef\u002Faaf\u002F0896efaaf776a8d308a008d0d2ef625e.png\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fpost_images\u002F089\u002F6ef\u002Faaf\u002F0896efaaf776a8d308a008d0d2ef625e.png\"\u002F\u003E\u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\n\u003Ci\u003E\u003Cfont color=\"gray\"\u003EРис. 6. Тест на интеграцию БД интегрирует ваш код с реальной базой данных\u003C\u002Ffont\u003E\u003C\u002Fi\u003E \u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Col\u003E\r\n\u003Cli\u003EЗапуск базы данных.\u003C\u002Fli\u003E\r\n\u003Cli\u003EПодключение приложения к БД.\u003C\u002Fli\u003E\r\n\u003Cli\u003EЗапуск функции в коде, которая записывает данные в БД.\u003C\u002Fli\u003E\r\n\u003Cli\u003EПроверка, что ожидаемые данные записаны в базу путём их чтения из БД.\u003C\u002Fli\u003E\r\n\u003C\u002Fol\u003E\u003Cbr\u002F\u003E\r\nДругой пример. Тест интеграции вашего сервиса с отдельной службой через REST API может выглядеть следующим образом:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cdiv style=\"text-align:center;\"\u003E\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw1560\u002Fgetpro\u002Fhabr\u002Fpost_images\u002F15b\u002F98f\u002F5bd\u002F15b98f5bd52634719eff1280a4117f3b.png\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fpost_images\u002F15b\u002F98f\u002F5bd\u002F15b98f5bd52634719eff1280a4117f3b.png\"\u002F\u003E\u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\n\u003Ci\u003E\u003Cfont color=\"gray\"\u003EРис. 7. Этот вид интеграционного теста проверяет, что приложение способно правильно взаимодействовать с отдельными службами\u003C\u002Ffont\u003E\u003C\u002Fi\u003E \u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Col\u003E\r\n\u003Cli\u003EЗапуск приложения.\u003C\u002Fli\u003E\r\n\u003Cli\u003EЗапуск инстанса отдельной службы (или тестового дублёра с тем же интерфейсом).\u003C\u002Fli\u003E\r\n\u003Cli\u003EЗапуск функции в коде, которая считывает данные из API внешней службы.\u003C\u002Fli\u003E\r\n\u003Cli\u003EПроверка, что приложение правильно разбирает ответ.\u003C\u002Fli\u003E\r\n\u003C\u002Fol\u003E\u003Cbr\u002F\u003E\r\nКак и модульные тесты, ваши интеграционные тесты можно делать вполне прозрачно (whitebox). Некоторые фреймворки позволяют одновременно запустить и ваше приложение, и имитации отдельных его частей для проверки правильного взаимодействия.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nНапишите интеграционные тесты для всех фрагментов кода, где выполняется \u003Ci\u003Eсериализация\u003C\u002Fi\u003E или \u003Ci\u003Eдесериализация\u003C\u002Fi\u003E данных. Это происходит чаще, чем вы думаете. Подумайте о следующем:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cul\u003E\r\n\u003Cli\u003EВызовы REST API своих сервисов.\u003C\u002Fli\u003E\r\n\u003Cli\u003EЧтение и запись в БД.\u003C\u002Fli\u003E\r\n\u003Cli\u003EВызовы API других приложений.\u003C\u002Fli\u003E\r\n\u003Cli\u003EЧтение из очереди и запись туда.\u003C\u002Fli\u003E\r\n\u003Cli\u003EЗапись в файловую систему.\u003C\u002Fli\u003E\r\n\u003C\u002Ful\u003E\u003Cbr\u002F\u003E\r\nНаписание интеграционных тестов вокруг этих границ гарантирует, что запись данных и чтение данных от этих внешних участников работает нормально.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nПри написании \u003Ci\u003Eузких интеграционных тестов\u003C\u002Fi\u003E стремитесь локально запускать внешние зависимости: локальную базу данных MySQL, тест на локальной файловой системе ext4. Если интегрируетесь с отдельной службой, то или запустите экземпляр этой службы локально, или создайте и запустите поддельную версию, которая имитирует поведение реальной службы.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nЕсли нет возможности локально запустить стороннюю службу, то лучше запустить выделенный тестовый инстанс и указать на него в интеграционным тесте. В автоматизированных тестах избегайте интеграции с реальной системой продакшна. Запуск тысяч тестовых запросов на систему продакшна — верный способ разозлить людей, потому что вы забиваете их логи (в лучшем случае) или просто ддосите их сервис (в худшем случае). Интеграция с сервисом по сети — типичное свойство \u003Ci\u003Eширокого интеграционного теста\u003C\u002Fi\u003E. Обычно из-за неё тесты труднее писать и они медленнее работают.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nЧто касается пирамиды тестов, то интеграционные тесты находятся на более высоком уровне, чем модульные. Интеграция файловых систем и БД обычно гораздо медленнее, чем выполнение юнит-тестов с их имитациями. Их также труднее писать, чем маленькие изолированные модульные тесты. В конце концов, нужно думать о работе внешней части теста. Тем не менее, они имеют преимущество, потому что дают уверенность в правильной работе приложения со всеми внешними частями, с какими нужно. Юнит-тесты тут бесполезны.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ca name=\"DatabaseIntegration\"\u003E\u003C\u002Fa\u003E\u003Ch3\u003EИнтеграция БД\u003C\u002Fh3\u003E\u003Cbr\u002F\u003E\r\n\u003Ccode\u003EPersonRepository\u003C\u002Fcode\u003E — единственный класс репозитория во всей кодовой базе. Он опирается на \u003Ci\u003ESpring Data\u003C\u002Fi\u003E и не имеет фактической реализации. Он просто расширяет интерфейс \u003Ccode\u003ECrudRepository\u003C\u002Fcode\u003E и предоставляет единственный заголовок метода. Остальное — магия Spring.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"java\"\u003Epublic interface PersonRepository extends CrudRepository&lt;Person, String\u003E {\n    Optional&lt;Person\u003E findByLastName(String lastName);\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nЧерез интерфейс \u003Ccode\u003ECrudRepository\u003C\u002Fcode\u003E Spring Boot предоставляет полностью функциональное хранилище CRUD с методами \u003Ccode\u003EfindOne\u003C\u002Fcode\u003E, \u003Ccode\u003EfindAll\u003C\u002Fcode\u003E, \u003Ccode\u003Esave\u003C\u002Fcode\u003E, \u003Ccode\u003Eupdate\u003C\u002Fcode\u003E и \u003Ccode\u003Edelete\u003C\u002Fcode\u003E. Наше собственное определение метода \u003Ccode\u003EfindByLastName ()\u003C\u002Fcode\u003E расширяет эту базовую функциональность и даёт возможность получать людей, то есть объекты \u003Ccode\u003EPerson\u003C\u002Fcode\u003E, по их фамилиям. Spring Data анализирует возвращаемый тип метода, имя метода и проверяет его на соответствие конвенциям именования для выяснения, что он должен делать.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nХотя Spring Data выполняет большую работу по реализации репозиториев БД, я всё равно написал тест интеграции БД. Вы можете сказать, что это \u003Ci\u003Eтест фреймворка\u003C\u002Fi\u003E, которого следует избегать, ведь мы тестируем чужой код. Тем не менее, я считаю, что здесь очень важно наличие хотя бы одного интеграционного теста. Во-первых, он проверяет нормальную работу нашего метода \u003Ccode\u003EfindByLastName\u003C\u002Fcode\u003E. Во-вторых, это доказывает, что наш репозиторий правильно использует Spring и способен подключиться к БД.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nЧтобы облегчить выполнение тестов на вашем компьютере (без установки базы данных PostgreSQL), наш тест подключается к базе данных в памяти \u003Ci\u003EH2\u003C\u002Fi\u003E.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nЯ определил H2 как тестовую зависимость в файле \u003Ccode\u003Ebuild.gradle\u003C\u002Fcode\u003E. Файл \u003Ccode\u003Eapplication.properties\u003C\u002Fcode\u003E в каталоге теста не определяет никаких свойств \u003Ccode\u003Espring.datasource\u003C\u002Fcode\u003E. Это указывает Spring Data использовать базу данных в памяти. Поскольку он находит H2 в пути к классу, то просто использует H2.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nРеальное приложение с профилем \u003Ccode\u003Eint\u003C\u002Fcode\u003E (например, после установки в качестве переменной среды \u003Ccode\u003ESPRING_PROFILES_ACTIVE=int\u003C\u002Fcode\u003E) будет подключаться к базе данных PostgreSQL, как определено в \u003Ccode\u003Eapplication-int.properties\u003C\u002Fcode\u003E.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nПонимаю, что здесь нужно знать и понимать кучу особенностей Spring. Придётся перелопатить \u003Ca href=\"https:\u002F\u002Fdocs.spring.io\u002Fspring-boot\u002Fdocs\u002Fcurrent\u002Freference\u002Fhtml\u002Fboot-features-sql.html#boot-features-embedded-database-support\"\u003Eкучу документации\u003C\u002Fa\u003E. Финальный код простой с виду, но его трудно понять, если вы не знаете конкретных особенностей Spring.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nКроме того, работа с базой данных в памяти — рискованное дело. В конце концов, наши интеграционные тесты работают с БД другого типа, чем в продакшне. Попробуйте и решите сами, предпочесть ли магию Spring и простой код — или явную, но более подробную реализацию.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nНу, хватит объяснений. Вот простой интеграционный тест, который сохраняет объект Person в базу данных и находит его по фамилии.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"java\"\u003E@RunWith(SpringRunner.class)\n@DataJpaTest\npublic class PersonRepositoryIntegrationTest {\n    @Autowired\n    private PersonRepository subject;\n\n    @After\n    public void tearDown() throws Exception {\n        subject.deleteAll();\n    }\n\n    @Test\n    public void shouldSaveAndFetchPerson() throws Exception {\n        Person peter = new Person(\"Peter\", \"Pan\");\n        subject.save(peter);\n\n        Optional&lt;Person\u003E maybePeter = subject.findByLastName(\"Pan\");\n\n        assertThat(maybePeter, is(Optional.of(peter)));\n    }\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nКак видите, наш интеграционный тест следует той же структуре «трёх А», что и юнит-тесты. Говорил же, что это универсальная концепция!\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ca name=\"IntegrationWithSeparateServices\"\u003E\u003C\u002Fa\u003E\u003Ch3\u003EИнтеграция с отдельными сервисами\u003C\u002Fh3\u003E\u003Cbr\u002F\u003E\r\nНаш микросервис получает погодные данные с darksky.net через REST API. Конечно, мы хотим убедиться, что сервис правильно отправляет запросы и разбирает ответы.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nПри выполнении автоматических тестов желательно избежать взаимодействия с настоящими серверами \u003Ci\u003Edarksky\u003C\u002Fi\u003E. Лимиты на нашем бесплатном тарифе — лишь одна из причин. Главное — это \u003Ci\u003Eотвязка\u003C\u002Fi\u003E. Наши тесты должны запускаться независимо от того, какие справляются со своей работой милые люди в darksky.net. Даже если наша машина не может достучаться до серверов \u003Ci\u003Edarksky\u003C\u002Fi\u003E или они закрылись на обслуживание.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nЧтобы избежать взаимодействия с реальными серверами \u003Ci\u003Edarksky\u003C\u002Fi\u003E, мы для интеграционных тестов запускаем собственный, поддельный сервер \u003Ci\u003Edarksky\u003C\u002Fi\u003E. Это может показаться очень трудной задачей. Но она упрощается благодаря таким инструментам, как \u003Ca href=\"http:\u002F\u002Fwiremock.org\u002F\"\u003EWiremock\u003C\u002Fa\u003E. Смотрите сами:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"java\"\u003E@RunWith(SpringRunner.class)\n@SpringBootTest\npublic class WeatherClientIntegrationTest {\n\n    @Autowired\n    private WeatherClient subject;\n\n    @Rule\n    public WireMockRule wireMockRule = new WireMockRule(8089);\n\n    @Test\n    public void shouldCallWeatherService() throws Exception {\n        wireMockRule.stubFor(get(urlPathEqualTo(\"\u002Fsome-test-api-key\u002F53.5511,9.9937\"))\n                .willReturn(aResponse()\n                        .withBody(FileLoader.read(\"classpath:weatherApiResponse.json\"))\n                        .withHeader(CONTENT_TYPE, MediaType.APPLICATION_JSON_VALUE)\n                        .withStatus(200)));\n\n        Optional&lt;WeatherResponse\u003E weatherResponse = subject.fetchWeather();\n\n        Optional&lt;WeatherResponse\u003E expectedResponse = Optional.of(new WeatherResponse(\"Rain\"));\n        assertThat(weatherResponse, is(expectedResponse));\n    }\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nДля Wiremock создаем инстанс \u003Ccode\u003EWireMockRule\u003C\u002Fcode\u003E на фиксированном порту (\u003Ccode\u003E8089\u003C\u002Fcode\u003E). С помощью DSL можно настроить сервер Wiremock, определить конечные точки для прослушивания и предустановленные ответы.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nДалее вызываем тестируемый метод — тот, который обращается к сторонней службе — и проверяем, что результат правильно парсится.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nВажно понимать, как тест определяет, что должен обратиться к поддельному сервер Wiremock вместо реального API \u003Ci\u003Edarksky\u003C\u002Fi\u003E. Секрет в файле \u003Ccode\u003Eapplication.properties\u003C\u002Fcode\u003E, который располагается в \u003Ccode\u003Esrc\u002Ftest\u002Fresources\u003C\u002Fcode\u003E. Его Spring загружает при выполнении тестов. В этом файле мы переопределяем конфигурацию вроде ключей API и URL-адресов со значениями, подходящими для тестов. В том числе назначаем вызов поддельного сервера Wiremock вместо реального:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode\u003Eweather.url = http:\u002F\u002Flocalhost:8089\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nОбратите внимание, что определённый здесь порт должен быть тем же, что мы указали при создании инстанса WireMockRule для теста. Замена URL-адреса реального API на поддельный стала возможной благодаря введению URL-адреса в конструктор класса \u003Ccode\u003EWeatherClient\u003C\u002Fcode\u003E:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"java\"\u003E@Autowired\npublic WeatherClient(final RestTemplate restTemplate,\n                     @Value(\"${weather.url}\") final String weatherServiceUrl,\n                     @Value(\"${weather.api_key}\") final String weatherServiceApiKey) {\n    this.restTemplate = restTemplate;\n    this.weatherServiceUrl = weatherServiceUrl;\n    this.weatherServiceApiKey = weatherServiceApiKey;\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nТак мы сообщаем нашему \u003Ccode\u003EWeatherClient\u003C\u002Fcode\u003E прочитать значение параметра \u003Ccode\u003EweatherUrl\u003C\u002Fcode\u003E свойства \u003Ccode\u003Eweather.url\u003C\u002Fcode\u003E, которое мы определили в свойствах нашего приложения.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nС инструментами вроде Wiremock написание \u003Ci\u003Eузких интеграционных тестов\u003C\u002Fi\u003E для отдельного сервиса становится достаточно простой задачей. К сожалению, у такого подхода есть недостаток: как гарантировать, что созданный нами поддельный сервер ведёт себя как настоящий? При текущей реализации отдельный сервис может изменить свой API, и наши тесты всё равно пройдут как ни в чём ни бывало. Сейчас мы просто тестируем, что \u003Ccode\u003EWeatherClient\u003C\u002Fcode\u003E способен воспринимать ответы от поддельного сервера. Это начало, но оно очень хрупкое. Проблему решают \u003Ci\u003Eсквозные тесты\u003C\u002Fi\u003E и тестирование на реальном сервисе, но так мы становимся зависимы от его доступности. К счастью, есть лучшее решение этой дилеммы — контрактные тесты с участием и имитации, и реального сервера гарантируют, что имитация в наших интеграционных тестах точно соответствует оригиналу. Посмотрим, как это работает.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ca name=\"ContractTests\"\u003E\u003C\u002Fa\u003E\u003Ch1\u003EКонтрактные тесты\u003C\u002Fh1\u003E\u003Cbr\u002F\u003E\r\nБолее современные компании нашли способ масштабирования разработки путём распределения работ среди разных команд. Они создают отдельные, слабо связанные службы, не мешая друг на другу, и интегрируют их в большую, цельную систему. Именно с этим связана недавняя шумиха вокруг микросервисов.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nРазделение системы на множество небольших сервисов часто означает, что эти сервисы должны взаимодействовать друг с другом через определённые (желательно чётко определенные, но иногда случайно созданные) интерфейсы.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nИнтерфейсы между разными приложения могут быть реализованы в разных форматах и технологиях. Самые распространённые:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cul\u003E\r\n\u003Cli\u003EREST и JSON через HTTPS;\u003C\u002Fli\u003E\r\n\u003Cli\u003ERPC с использованием чего-то вроде \u003Ca href=\"https:\u002F\u002Fgrpc.io\u002F\"\u003EgRPC\u003C\u002Fa\u003E;\u003C\u002Fli\u003E\r\n\u003Cli\u003Eпостроение событийно-ориентированной архитектуры с использованием очередей.\u003C\u002Fli\u003E\r\n\u003C\u002Ful\u003E\u003Cbr\u002F\u003E\r\nКаждый интерфейс задействует две стороны: поставщика и потребителя. \u003Cb\u003EПоставщик\u003C\u002Fb\u003E предоставляет данные потребителям. \u003Cb\u003EПотребитель\u003C\u002Fb\u003E обрабатывает данные, полученные от поставщика. В мире REST поставщик создаёт REST API со всеми необходимыми конечными точками, а потребитель обращается к этому REST API, чтобы получить данные или инициировать изменения в другой службе. В асинхронном мире событийно-ориентированной архитектуры поставщик (часто именуемый издателем) публикует данные в очередь; а потребитель (часто называемый подписчиком) подписывается на эти очереди, считывает и обрабатывает данные.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cdiv style=\"text-align:center;\"\u003E\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw1560\u002Fgetpro\u002Fhabr\u002Fpost_images\u002F420\u002Fa0f\u002F17c\u002F420a0f17c800a1ac4a65a883813da8ae.png\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fpost_images\u002F420\u002Fa0f\u002F17c\u002F420a0f17c800a1ac4a65a883813da8ae.png\"\u002F\u003E\u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\n\u003Ci\u003E\u003Cfont color=\"gray\"\u003EРис. 8. Каждый интерфейс задействует поставщика (или издателя) и потребителя (или подписчика). Спецификацией интерфейса можно считать контракт.\u003C\u002Ffont\u003E\u003C\u002Fi\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nПоскольку сервисы поставщика и потребителя распределяются по разным командам, то вы оказываетесь в ситуации, когда нужно чётко указать интерфейс между ними (так называемый контракт). Традиционно компании подходят к этой проблеме следующим образом:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Col\u003E\r\n\u003Cli\u003EНаписать длинную и подробную спецификацию интерфейса (\u003Ci\u003Eконтракт\u003C\u002Fi\u003E).\u003C\u002Fli\u003E\r\n\u003Cli\u003EРеализовать сервис поставщика согласно определённому контракту.\u003C\u002Fli\u003E\r\n\u003Cli\u003EПередать спецификации интерфейса стороне потребителя.\u003C\u002Fli\u003E\r\n\u003Cli\u003EПодождать, пока они реализуют свою часть интерфейса.\u003C\u002Fli\u003E\r\n\u003Cli\u003EЗапустить крупномасштабный ручной системный тест, чтобы всё проверить.\u003C\u002Fli\u003E\r\n\u003Cli\u003EНадеяться, что обе команды будут всегда соблюдать определения интерфейса и не облажаются.\u003C\u002Fli\u003E\r\n\u003C\u002Fol\u003E\u003Cbr\u002F\u003E\r\nБолее современные компании заменили шаги 5 и 6 на автоматизированные \u003Ca href=\"https:\u002F\u002Fmartinfowler.com\u002Fbliki\u002FContractTest.html\"\u003Eконтрактные тесты\u003C\u002Fa\u003E, которые проверяют, что реализации на стороне потребителя и поставщика всё ещё придерживаются определённого контракта. Они выступают хорошим набором регрессионных тестов и гарантируют раннее обнаружение отклонения от контракта.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nВ более гибкой организации следует выбрать более эффективный и менее расточительный маршрут. Приложение создаётся в рамках одной организации. Не должно быть проблемой переговорить с разработчиками других сервисов вместо того, чтобы забрасывать им чрезмерно подробную готовую документацию. В конце концов, это ваши сотрудники, а не сторонний вендор, с которым можно общаться только через службу поддержки клиентов или пуленепробиваемые юридические контракты.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cb\u003EОриентированные на пользователя контрактные тесты\u003C\u002Fb\u003E (CDC-тесты) позволяют \u003Ca href=\"https:\u002F\u002Fmartinfowler.com\u002Farticles\u002FconsumerDrivenContracts.html\"\u003Eпотребителям управлять реализацией контракта\u003C\u002Fa\u003E. С помощью CDC потребители пишут тесты, которые проверяют интерфейс для всех данных, которые им нужны. Затем команда публикует эти тесты, чтобы разработчики службы поставщика могли легко получить и запустить эти тесты. Теперь они могут разработать свой API, запустив тесты CDC. После прогона всех тестов они знают, что удовлетворили все потребности команды на стороне потребителя.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cdiv style=\"text-align:center;\"\u003E\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw1560\u002Fgetpro\u002Fhabr\u002Fpost_images\u002F25e\u002Fdba\u002F1c2\u002F25edba1c2090bc04cf76e018a53ee451.png\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fpost_images\u002F25e\u002Fdba\u002F1c2\u002F25edba1c2090bc04cf76e018a53ee451.png\"\u002F\u003E\u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\n\u003Ci\u003E\u003Cfont color=\"gray\"\u003EРис. 9. Контрактные тесты гарантируют, что поставщик и все потребители интерфейса придерживаются определённого контракта интерфейса. С помощью CDC-тестов потребители интерфейса публикуют свои требования в виде автоматизированных тестов; поставщики непрерывно получают и выполняют эти тесты\u003C\u002Ffont\u003E\u003C\u002Fi\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nТакой подход позволяет команде поставщика интерфейса реализовать только то, что действительно необходимо (сохраняя простоту, \u003Cabbr title=\"You aren't gonna need it\"\u003EYAGNI\u003C\u002Fabbr\u003E и всё такое). Команда поставщика должна непрерывно получать и выполнять эти CDC-тесты (в своём конвейере сборки), чтобы немедленно замечать любые критические изменения. Если они нарушают интерфейс, то их CDC-тесты не пройдут, предотвращая критические изменения. Пока тесты проходят, команда может вносить любые изменения, какие хочет, не беспокоясь о других командах. Ориентированный на потребителя контрактный подход сокращает процесс разработки до следующего:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Col\u003E\r\n\u003Cli\u003EКоманда потребителя пишет автоматизированные тесты со всеми ожиданиями со стороны потребителей.\u003C\u002Fli\u003E\r\n\u003Cli\u003EОни публикуют тесты для команды поставщика.\u003C\u002Fli\u003E\r\n\u003Cli\u003EКоманда поставщика непрерывно запускает CDC-тесты и следит за ними.\u003C\u002Fli\u003E\r\n\u003Cli\u003EКоманды немедленно вступают в переговоры, когда CDC-тесты ломаются.\u003C\u002Fli\u003E\r\n\u003C\u002Fol\u003E\u003Cbr\u002F\u003E\r\nЕсли ваша организация внедрит подход микросервисов, то проведение CDC-тестов — важный шаг к созданию автономных групп. CDC-тесты — это автоматизированный способ поощрить общение в коллективе. Они гарантируют, что интерфейсы между командами работают в любое время. Неудачный CDC-тест — хороший повод пойти к пострадавшей команде, поговорить о предстоящих изменениях API и выяснить, куда двигаться дальше.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nНаивная реализация CDC-тестов настолько же проста, как запросы к API и оценка ответов на предмет наличия всего необходимого. Затем эти тесты упаковываются в исполняемый файл (.gem, .jar, .sh) и загружаются куда-нибудь для другой команды (например, репозиторий вроде \u003Ca href=\"https:\u002F\u002Fwww.jfrog.com\u002Fartifactory\u002F\"\u003EArtifactory\u003C\u002Fa\u003E).\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nВ последние годы подход CDC становится более популярным и создано несколько инструментов для упрощения написания и обмена тестами.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ca href=\"https:\u002F\u002Fgithub.com\u002Frealestate-com-au\u002Fpact\"\u003EPact\u003C\u002Fa\u003E, вероятно, самый известный среди них. Он предлагает утончённый подход к написанию тестов для потребителя и поставщика, предоставляет заглушки для отдельных служб и позволяет обмениваться CDC-тестами с другими командами. Pact портирован на множество платформ и может использоваться с языками JVM, Ruby, .NET, JavaScript и многими другими.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nPact — разумный выбор, чтобы начать работу с CDC. \u003Ca href=\"https:\u002F\u002Fdocs.pact.io\u002F\"\u003EДокументация\u003C\u002Fa\u003E сначала ошеломляет, но если набраться терпения, то её можно одолеть. Она помогает получить твёрдое понимание CDC, что в свою очередь облегчает вам задачу пропагандировать CDC для работы с другими командами.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nОриентированные на пользователя контрактные тесты могут кардинально упростить работу автономных команд, которые начнут действовать быстро и уверенно. Сделайте одолжение, ознакомьтесь и попробуйте эту концепцию. Качественный набор CDC-тестов неоценим, чтобы быстро продолжать разработку, не ломая прочие сервисы и не огорчая другие команды.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ca name=\"ConsumerTestourTeam\"\u003E\u003C\u002Fa\u003E\u003Ch3\u003EТест потребителя (наша команда)\u003C\u002Fh3\u003E\u003Cbr\u002F\u003E\r\nНаш микросервис использует погодный API. Так что наша обязанность — написать \u003Cb\u003Eтест потребителя\u003C\u002Fb\u003E, который определяет наши ожидания по контракту (API) между нашим микросервисом и погодной службой.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nСначала включаем библиотеку для написания тестов потребителя в нашу \u003Ccode\u003Ebuild.gradle\u003C\u002Fcode\u003E:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode\u003EtestCompile('au.com.dius:pact-jvm-consumer-junit_2.11:3.5.5')\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nБлагодаря этой библиотеке мы можем реализовать тест потребителя и использовать сервисы имитации Pact:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"java\"\u003E@RunWith(SpringRunner.class)\n@SpringBootTest\npublic class WeatherClientConsumerTest {\n\n    @Autowired\n    private WeatherClient weatherClient;\n\n    @Rule\n    public PactProviderRuleMk2 weatherProvider =\n            new PactProviderRuleMk2(\"weather_provider\", \"localhost\", 8089, this);\n\n    @Pact(consumer=\"test_consumer\")\n    public RequestResponsePact createPact(PactDslWithProvider builder) throws IOException {\n        return builder\n                .given(\"weather forecast data\")\n                .uponReceiving(\"a request for a weather request for Hamburg\")\n                    .path(\"\u002Fsome-test-api-key\u002F53.5511,9.9937\")\n                    .method(\"GET\")\n                .willRespondWith()\n                    .status(200)\n                    .body(FileLoader.read(\"classpath:weatherApiResponse.json\"),\n                            ContentType.APPLICATION_JSON)\n                .toPact();\n    }\n\n    @Test\n    @PactVerification(\"weather_provider\")\n    public void shouldFetchWeatherInformation() throws Exception {\n        Optional&lt;WeatherResponse\u003E weatherResponse = weatherClient.fetchWeather();\n        assertThat(weatherResponse.isPresent(), is(true));\n        assertThat(weatherResponse.get().getSummary(), is(\"Rain\"));\n    }\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nЕсли внимательно посмотреть, то \u003Ccode\u003EWeatherClientConsumerTest\u003C\u002Fcode\u003E очень похож на \u003Ccode\u003EWeatherClientIntegrationTest\u003C\u002Fcode\u003E. Только для серверной заглушки вместо Wiremock на этот раз мы используем Pact. На самом тест потребителя работает точно так же, как интеграционный: мы заменяем реальный сторонний сервер заглушкой, определяем ожидаемый ответ и проверяем, что клиент может правильно его разобрать. В этом смысле \u003Ccode\u003EWeatherClientConsumerTest\u003C\u002Fcode\u003E представляет собой узкий интеграционный тест. Преимущество по сравнению с тестом на основе Wiremock в том, что он при каждом запуске генерирует \u003Ci\u003Eфайл Pact\u003C\u002Fi\u003E (находится в \u003Ccode\u003Etarget\u002Fpacts\u002F&amp;pact-name\u003E.json\u003C\u002Fcode\u003E). Он описывает наши ожидания по контракту в специальном формате JSON. Затем этот файл можно использовать для проверки, что сервер-заглушка ведёт себя как настоящий. Мы можем взять pact-файл и передать его команде, предоставляющей интерфейс. Они берут pact-файл и пишут тест провайдера, используя указанные там ожидания. Так они проверяют, соответствует ли их API всем нашим ожиданиям.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nКак можно понять, именно отсюда взялась часть \u003Ci\u003E«ориентирование на потребителя»\u003C\u002Fi\u003E в определении CDC. Потребитель управляет реализацией интерфейса, описывая свои ожидания. Поставщик должен убедиться, что он выполняет все ожидания. Никаких лишних спецификаций, YAGNI и все дела.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nПередача pact-файла в команду поставщика может пройти несколькими путями. Простой — зарегистрировать его в системе управления версиями и сказать команде поставщика всегда брать последнюю версию файла. Более продвинутый способ — использовать репозиторий артефактов вроде Amazon S3 или Pact Broker. Начинайте с простого и растите по мере необходимости.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nВ реальном приложении вам не нужны одновременно и \u003Ci\u003Eинтеграционный тест\u003C\u002Fi\u003E, и \u003Ci\u003Eтест потребителя\u003C\u002Fi\u003E для клиентского класса. Наш пример кода содержит оба только для демонстрации, как использовать каждый из них. Если вы хотите написать CDC-тесты на Pact, я рекомендую оставаться с ним. В этом случае преимущество в том, что вы автоматически получаете pact-файл с ожиданиями от контракта, которые другие команды могут использовать, чтобы легко сделать свои тесты поставщика. Конечно, это имеет смысл только если вы сможете убедить другую команду использовать Pact. Если нет, то используйте интеграционный тест интеграции в сочетании с Wiremock как достойную альтернативу.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ca name=\"ProviderTesttheOtherTeam\"\u003E\u003C\u002Fa\u003E\u003Ch3\u003EТест поставщика (другая команда)\u003C\u002Fh3\u003E\u003Cbr\u002F\u003E\r\nТесты поставщика должны реализовать те, кто предоставляет погодный API. Мы используем публичный API от darksky.net. Теоретически, команда darksky со своей стороны должна выполнить тест поставщика и убедиться, что не нарушает контракт между своим приложением и нашим сервисом.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nОчевидно, что их не волнует наше скромное тестовое приложение — и они не будут делать для нас CDC-тест. Есть большая разница между публичным API и организацией, использующей микросервисы. Общедоступный API не может учитывать нужды каждого отдельного потребителя, иначе не сможет нормально работать. Внутри своей организации вы можете и должны их учитывать. Скорее всего, ваше приложение будет обслуживать несколько, ну может пару десятков потребителей. Ничего не мешает написать тесты поставщика для этих интерфейсов, чтобы сохранить стабильную систему.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nКоманда поставщика получает pact-файл и запускает его на своём сервисе. Для этого она реализует тест, который считывает pact-файл, ставит несколько заглушек и проверяет на своём сервисе ожидания, определённые в pact-файле.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nСообщество проекта Pact написало несколько библиотек для реализации тестов поставщика. В их \u003Ca href=\"https:\u002F\u002Fgithub.com\u002FDiUS\u002Fpact-jvm\"\u003Eосновном репозитории GitHub\u003C\u002Fa\u003E неплохой выбор библиотек для потребителей и провайдеров. Выберите ту, которая лучше всего соответствует вашему стеку технологий.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nДля простоты предположим, что API darksky тоже реализован в Spring Boot. В этом случае они могут использовать \u003Ca href=\"https:\u002F\u002Fgithub.com\u002FDiUS\u002Fpact-jvm\u002Ftree\u002Fmaster\u002Fpact-jvm-provider-spring\"\u003Eбиблиотеку Pact Spring\u003C\u002Fa\u003E, которая хорошо подключается к механизмам MockMVC Spring. Гипотетический тест поставщика, который могла бы реализовать команда darksky.net, выглядит так:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"java\"\u003E@RunWith(RestPactRunner.class)\n@Provider(\"weather_provider\") \u002F\u002F same as the \"provider_name\" in our clientConsumerTest\n@PactFolder(\"target\u002Fpacts\") \u002F\u002F tells pact where to load the pact files from\npublic class WeatherProviderTest {\n    @InjectMocks\n    private ForecastController forecastController = new ForecastController();\n\n    @Mock\n    private ForecastService forecastService;\n\n    @TestTarget\n    public final MockMvcTarget target = new MockMvcTarget();\n\n    @Before\n    public void before() {\n        initMocks(this);\n        target.setControllers(forecastController);\n    }\n\n    @State(\"weather forecast data\") \u002F\u002F same as the \"given()\" in our clientConsumerTest\n    public void weatherForecastData() {\n        when(forecastService.fetchForecastFor(any(String.class), any(String.class)))\n                .thenReturn(weatherForecast(\"Rain\"));\n    }\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nКак видите, от поставщика требуется лишь загрузить pact-файл (например, \u003Ccode\u003E@PactFolder\u003C\u002Fcode\u003E определяет, откуда загружать полученные pact-файлы), а затем определить, как обеспечить тестовые данные для предопределённых состояний (например, с помощью имитаций Mockito). Не нужно писать какой-то специальный тест. Всё берётся из pact-файла. Важно, чтобы тест поставщика соответствовал \u003Ci\u003Eимени поставщика\u003C\u002Fi\u003E и \u003Ci\u003Eсостоянию\u003C\u002Fi\u003E, объявленным в тесте потребителя.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ca name=\"ProviderTestourTeam\"\u003E\u003C\u002Fa\u003E\u003Ch3\u003EТест поставщика (наша команда)\u003C\u002Fh3\u003E\u003Cbr\u002F\u003E\r\nМы посмотрели, как тестировать контракт между нашим сервисом и поставщиком погодной информации. В этом интерфейсе наш сервис выступает в качестве потребителя, а метеорологическая служба — в качестве поставщика. Подумав ещё, мы увидим, что наш сервис тоже выступает в роли поставщика для других: мы предоставляем REST API с несколькими конечными точками для других потребителей.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nПоскольку мы знаем важность контрактных тестов, то конечно напишем тест и для этого контракта. К счастью, наши контракты ориентированы на потребителя, так что все команды-потребители присылают нам свои pact-файлы, которые мы можем использовать для реализации тестов поставщика для нашего REST API.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nСначала добавим в наш проект библиотеку поставщика Pact для Spring:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ccode\u003EtestCompile('au.com.dius:pact-jvm-provider-spring_2.12:3.5.5')\u003C\u002Fcode\u003E \u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nРеализация теста поставщика следует той же описанной схеме. Для простоты я зарегистрирую pact-файл от нашего \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fhamvocke\u002Fspring-testing-consumer\"\u003Eпростого потребителя\u003C\u002Fa\u003E в репозитории нашего сервиса. Для нашего случая так проще, а в реальной жизни, вероятно, придётся использовать более сложный механизм для распространения pact-файлов.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"java\"\u003E@RunWith(RestPactRunner.class)\n@Provider(\"person_provider\")\u002F\u002F same as in the \"provider_name\" part in our pact file\n@PactFolder(\"target\u002Fpacts\") \u002F\u002F tells pact where to load the pact files from\npublic class ExampleProviderTest {\n\n    @Mock\n    private PersonRepository personRepository;\n\n    @Mock\n    private WeatherClient weatherClient;\n\n    private ExampleController exampleController;\n\n    @TestTarget\n    public final MockMvcTarget target = new MockMvcTarget();\n\n    @Before\n    public void before() {\n        initMocks(this);\n        exampleController = new ExampleController(personRepository, weatherClient);\n        target.setControllers(exampleController);\n    }\n\n    @State(\"person data\") \u002F\u002F same as the \"given()\" part in our consumer test\n    public void personData() {\n        Person peterPan = new Person(\"Peter\", \"Pan\");\n        when(personRepository.findByLastName(\"Pan\")).thenReturn(Optional.of\n                (peterPan));\n    }\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nПоказанный \u003Ccode\u003EExampleProviderTest\u003C\u002Fcode\u003E должен предоставить состояние в соответствии с полученным pact-файлом, вот и всё. Когда мы запустим тест, Pact подберёт pact-файл и отправит HTTP-запрос к нашему сервису, который ответит в соответствии с заданным состоянием.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ca name=\"UiTests\"\u003E\u003C\u002Fa\u003E\u003Ch1\u003EТесты UI\u003C\u002Fh1\u003E\u003Cbr\u002F\u003E\r\nУ большинства приложений есть какой-то пользовательский интерфейс. Обычно мы говорим о веб-интерфейсе в контексте веб-приложений. Люди часто забывают, что REST API или интерфейс командной строки — это такой же UI, как и причудливый веб-интерфейс.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ci\u003EТесты UI\u003C\u002Fi\u003E проверяют правильность работы пользовательского интерфейса приложения. Действия пользователя должны инициировать правильные события, данные должны представляться пользователю, состояние UI должно изменяться ожидаемым образом.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cdiv style=\"text-align:center;\"\u003E\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw1560\u002Fgetpro\u002Fhabr\u002Fpost_images\u002F1e1\u002Fd34\u002F9b2\u002F1e1d349b260edb4f442fac4bcbabb8b1.png\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fpost_images\u002F1e1\u002Fd34\u002F9b2\u002F1e1d349b260edb4f442fac4bcbabb8b1.png\"\u002F\u003E\u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nИногда говорят, что тесты UI и сквозные тесты — это одно и то же (как говорит Майк Кон). Для меня это отождествление двух вещей с весьма ортогональными концепциями.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nДа, тестирование приложения от начала до конца часто означает прохождение через пользовательский интерфейс. Но обратное неверно.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nТестирование пользовательского интерфейса необязательно должно проводиться в сквозном режиме. В зависимости от используемой технологии, тестирование UI может оказаться таким же простым, как написание некоторых модульных тестов для фронтенда JavaScript с заглушенным бэкендом.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nДля тестирования UI традиционных веб-приложений предназначены специальные инструменты вроде \u003Ca href=\"http:\u002F\u002Fdocs.seleniumhq.org\u002F\"\u003ESelenium\u003C\u002Fa\u003E. Если вы считаете пользовательским интерфейсом REST API, то достаточно правильных интеграционных тестов вокруг API.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nВ веб-интерфейсах желательно проверить несколько аспектов UI, в том числе поведение, вёрстка, юзабилити, соблюдение фирменного стиля и др.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nК счастью, тестирование поведения UI довольно простое. Щёлкаете здесь, вводите данные там — и проверяете, что состояние UI меняется соответствующим образом. Современные фреймворки для одностраничных приложений (\u003Ca href=\"https:\u002F\u002Ffacebook.github.io\u002Freact\u002F\"\u003Ereact\u003C\u002Fa\u003E, \u003Ca href=\"https:\u002F\u002Fvuejs.org\u002F\"\u003Evue.js\u003C\u002Fa\u003E, \u003Ca href=\"https:\u002F\u002Fangular.io\u002F\"\u003EAngular\u003C\u002Fa\u003E и прочие) часто поставляются с инструментами и хелперами для тщательного тестирования этих взаимодействий на довольно низком уровне (в юнит-тесте). Даже если выкатить собственную реализацию фронтенда на ванильном JavaScript, всё равно можно использовать обычные инструменты тестирования, такие как \u003Ca href=\"https:\u002F\u002Fjasmine.github.io\u002F\"\u003EJasmine\u003C\u002Fa\u003E и \u003Ca href=\"http:\u002F\u002Fmochajs.org\u002F\"\u003EMocha\u003C\u002Fa\u003E. Для более традиционного приложения с рендерингом на стороне сервера наилучшим выбором станут тесты на основе Selenium.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nЦельность \u003Ci\u003Eвёрстки\u003C\u002Fi\u003E веб-приложения проверить немного сложнее. В зависимости от приложения и потребностей пользователей может возникнуть необходимость убедиться, что изменения кода случайно не нарушают вёрстку сайта.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nНо компьютеры плохо справляются с проверкой, что всё «нормально выглядит» (возможно, в будущем какой-то умный алгоритм машинного обучения изменит это).\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nЕсть некоторые инструменты, чтобы попробовать автоматическую проверку дизайна веб-приложения в конвейере сборки. Большинство из них используют Selenium для открытия веб-приложения в разных браузерах и форматах, произведения скриншотов и сравнения с ранее сделанными скриншотами. Если старый и новый скриншоты отличаются неожиданным образом, то инструмент подаст сигнал.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nОдин из таких инструментов — \u003Ca href=\"http:\u002F\u002Fgalenframework.com\u002F\"\u003EGalen\u003C\u002Fa\u003E. Некоторые команды используют \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fotto-de\u002Flineup\"\u003Elineup\u003C\u002Fa\u003E и его брата jlineup на основе Java для достижения аналогичного результата. Оба инструмента применяют тот же подход на основе Selenium.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nКак только вы хотите проверить \u003Ci\u003Eудобство использования\u003C\u002Fi\u003E и \u003Ci\u003Eприятный дизайн\u003C\u002Fi\u003E — вы покидаете пространство автоматизированного тестирования. Здесь придётся полагаться на \u003Ca href=\"https:\u002F\u002Fen.wikipedia.org\u002Fwiki\u002FExploratory_testing\"\u003Eисследовательские тесты\u003C\u002Fa\u003E, тесты юзабилити (вплоть до простейших \u003Ca href=\"https:\u002F\u002Fen.wikipedia.org\u002Fwiki\u002FUsability_testing#Hallway_testing\"\u003Eхолл-тестов\u003C\u002Fa\u003E на случайных людях). Придётся проводить демонстрации пользователям и проверять, нравится ли им продукт и могут ли они использовать все функции без разочарования или раздражения.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ca name=\"End-to-endTests\"\u003E\u003C\u002Fa\u003E\u003Ch1\u003EСквозные тесты\u003C\u002Fh1\u003E\u003Cbr\u002F\u003E\r\nТестирование развёрнутого приложения через UI — это самый полный тест, какой только можно провести. Описанные выше тесты UI через WebDriver — хорошие примеры сквозных тестов.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cdiv style=\"text-align:center;\"\u003E\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw1560\u002Fgetpro\u002Fhabr\u002Fpost_images\u002F91a\u002F118\u002F3e7\u002F91a1183e77f1850a1df00b819503b109.png\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fpost_images\u002F91a\u002F118\u002F3e7\u002F91a1183e77f1850a1df00b819503b109.png\"\u002F\u003E\u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\n\u003Ci\u003E\u003Cfont color=\"gray\"\u003EРис. 11. Сквозные тесты проверяют полностью интегрированную систему целиком\u003C\u002Ffont\u003E\u003C\u002Fi\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nСквозные тесты (также называемые \u003Ca href=\"https:\u002F\u002Fmartinfowler.com\u002Fbliki\u002FBroadStackTest.html\"\u003Eтестами широкого стека\u003C\u002Fa\u003E) дают максимальную уверенность, работает программное обеспечение или нет. \u003Ca href=\"http:\u002F\u002Fdocs.seleniumhq.org\u002F\"\u003ESelenium\u003C\u002Fa\u003E и \u003Ca href=\"https:\u002F\u002Fwww.w3.org\u002FTR\u002Fwebdriver\u002F\"\u003Eпротокол WebDriver\u003C\u002Fa\u003E позволяют автоматизировать тесты, автоматически отправляя headless-браузер на развёрнутые сервисы для выполнения кликов, ввода данных и проверки состояния UI. Можно использовать Selenium напрямую или применить инструменты на его основе, такие как \u003Ca href=\"http:\u002F\u002Fnightwatchjs.org\u002F\"\u003ENightwatch\u003C\u002Fa\u003E.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nУ сквозных тесты другие проблемы. Они известны своей ненадёжностью, сбоями по неожиданным и непредвиденным причинам. Довольно часто это ложноположительные сбои. Чем более сложный UI, тем более хрупкими становятся тесты. Причуды браузера, проблемы с синхронизацией, анимация и неожиданные всплывающие диалоги — лишь некоторые из причин, из-за которых я потратил больше времени на отладку, чем хотелось бы.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nВ мире микросервисов также непонятно, кто отвечает за написание этих тестов. Поскольку они охватывают несколько сервисов (всю систему), то нет одной конкретной команды, ответственной за написание сквозных тестов.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nЕсли есть централизованная команда \u003Ci\u003Eобеспечения качества\u003C\u002Fi\u003E, они выглядят хорошим кандидатом. Опять же, заводить централизованную команду QA строго не рекомендуется, такого не должно быть в мире DevOps, где все команды по-настоящему универсальны. Нет простого ответа, кто должен владеть сквозными тестами. Может, в вашей организации есть какая-то инициативная группа или \u003Ci\u003Eгильдия качества\u003C\u002Fi\u003E, чтобы позаботиться о них. Здесь многое зависит от конкретной организации.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nКроме того, сквозные тесты требуют серьёзной поддержки и выполняются довольно медленно. Если у вас много микросервисов, то вы даже не сможете запускать сквозные тесты локально, потому что тогда понадобится и все микросервисы запускать локально. Попробуйте запустить сотни приложений на своём компьютере, тут никакой оперативки не хватит.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nИз-за высоких расходов на обслуживание следует свести число сквозных тестов к абсолютному минимуму.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nПодумайте о самых главных взаимодействиях пользователей с приложением. Придумайте главные «маршруты» пользователей от экрана к экрану, чтобы автоматизировать самые важные из этих шагов в сквозных тестах.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nЕсли вы делаете интернет-магазин, то самым ценным «маршрутом» будет поиск продукта — помещение его в корзину — оформление заказа. Вот и всё. Пока этот маршрут работает, нет особых проблем. Возможно, вы найдёте еще пару важных маршрутов для сквозных тестов. Всё остальное, вероятно, принесёт больше проблем, чем пользы.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nПомните: в вашей пирамиде тестов много низкоуровневых тестов, где мы уже протестировали все варианты пограничных ситуаций и интеграции с другими частями системы. Нет необходимости повторять эти тесты на более высоком уровне. Большие усилия по техническому обслуживанию и много ложных срабатываний слишком замедлит вашу работу, а рано или поздно лишит вас доверия к тестам вообще.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ca name=\"UserInterfaceEnd-to-endTest\"\u003E\u003C\u002Fa\u003E\u003Ch3\u003EСквозные тесты UI\u003C\u002Fh3\u003E\u003Cbr\u002F\u003E\r\nДля сквозных тестов многие разработчики выбирают \u003Ca href=\"http:\u002F\u002Fdocs.seleniumhq.org\u002F\"\u003ESelenium\u003C\u002Fa\u003E и протокол \u003Ca href=\"https:\u002F\u002Fwww.w3.org\u002FTR\u002Fwebdriver\u002F\"\u003EWebDriver\u003C\u002Fa\u003E. С Selenium можете выбрать любой браузер и натравить его на сайт. Пусть нажимает повсюду кнопки и ссылки, вводит данные и проверяет изменения в UI.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nК Selenium нужен браузер, который можно запустить и использовать для тестов. Есть несколько так называемых \u003Ci\u003E«драйверов»\u003C\u002Fi\u003E к разным браузерам. Выберите один (или несколько) и добавьте его в свой \u003Ccode\u003Ebuild.gradle\u003C\u002Fcode\u003E. Какой бы браузер вы ни выбрали, следует убедиться, что у всех разработчиков и на сервере CI установлена правильная версия браузера. Может оказаться трудно обспечить такую синхронизацию. Для Java есть небольшая библиотека \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fbonigarcia\u002Fwebdrivermanager\"\u003Ewebdrivermanager\u003C\u002Fa\u003E, которая автоматизирует загрузку и настройку правильной версии браузера. Добавьте две такие зависимости в \u003Ccode\u003Ebuild.gradle\u003C\u002Fcode\u003E:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"java\"\u003EtestCompile('org.seleniumhq.selenium:selenium-chrome-driver:2.53.1')\ntestCompile('io.github.bonigarcia:webdrivermanager:1.7.2')\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nЗапуск полноценного браузера в тестовом наборе может стать проблемой. Особенно если сервер непрерывной доставки, где работает наш конвейер, не способен развернуть браузер с UI (например, потому что X-Server недоступен). В этом случае можно запустить виртуальный X-Server вроде \u003Ca href=\"https:\u002F\u002Fen.wikipedia.org\u002Fwiki\u002FXvfb\"\u003Exvfb\u003C\u002Fa\u003E.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nБолее новый подход заключается в использовании \u003Ci\u003Eheadless\u003C\u002Fi\u003E-браузера (т.е. браузера без пользовательского интерфейса) для тестов WebDriver. До недавнего времени чаще всего для автоматизации браузерных задач использовался PhantomJS. Но когда \u003Ca href=\"https:\u002F\u002Fdevelopers.google.com\u002Fweb\u002Fupdates\u002F2017\u002F04\u002Fheadless-chrome\"\u003EChromium\u003C\u002Fa\u003E и \u003Ca href=\"https:\u002F\u002Fdeveloper.mozilla.org\u002Fen-US\u002FFirefox\u002FHeadless_mode\"\u003EFirefox\u003C\u002Fa\u003E внедрили headless-режим из коробки, PhantomJS внезапно устарел. В конце концов, лучше протестировать сайт с помощью реального браузера, который действительно есть у пользователей (например, Firefox и Chrome), а не с помощью искусственного браузера только потому что это удобно вам как разработчику.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nОба headless-браузера Firefox и Chrome совершенно новые и ещё не получили широкого распространения для тестов WebDriver. Мы не хотим ничего усложнять. Вместо возни со свеженькими headless-режимами давайте придерживаться классического способа, то есть Selenium в связке с обычным браузером. Вот как выглядит простой сквозной тест, который запускает Chrome, переходит к нашему сервису и проверяет содержимое сайта:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"java\"\u003E@RunWith(SpringRunner.class)\n@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)\npublic class HelloE2ESeleniumTest {\n\n    private WebDriver driver;\n\n    @LocalServerPort\n    private int port;\n\n    @BeforeClass\n    public static void setUpClass() throws Exception {\n        ChromeDriverManager.getInstance().setup();\n    }\n\n    @Before\n    public void setUp() throws Exception {\n        driver = new ChromeDriver();\n    }\n\n    @After\n    public void tearDown() {\n        driver.close();\n    }\n\n    @Test\n    public void helloPageHasTextHelloWorld() {\n        driver.get(String.format(\"http:\u002F\u002F127.0.0.1:%s\u002Fhello\", port));\n\n        assertThat(driver.findElement(By.tagName(\"body\")).getText(), containsString(\"Hello World!\"));\n    }\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nОбратите внимание, что этот тест будет работать, только если Chrome установлен на машине, где запускается тест (ваш локальный компьютер, сервер CI).\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nТест простой. Он запускает приложение Spring на случайном порту с помощью \u003Ccode\u003E@SpringBootTest\u003C\u002Fcode\u003E. Затем создаётся новый «веб-драйвер» Chrome, он получает указание перейти к конечной точке \u003Ccode\u003E\u002Fhello\u003C\u002Fcode\u003E нашего микросервиса и проверить, что в окне браузера печатается «Hello World!». Классно!\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ca name=\"RestApiEnd-to-endTest\"\u003E\u003C\u002Fa\u003E\u003Ch3\u003EСквозной тест REST API\u003C\u002Fh3\u003E\u003Cbr\u002F\u003E\r\nДля повышения надёжности тестов хорошая идея — избегать GUI. Такие тесты более стабильны, чем полноценные сквозные тесты, и в то же время покрывают значительную часть стека приложения. Это может пригодиться, если тестировать приложение через веб-интерфейс особенно сложно. Может, у вас даже нет веб-интерфейса, а только REST API (потому что одностраничное приложение где-то общается с этим API или просто потому что вы презираете всё красивое и блестящее). В любом случае ситуация подходит для \u003Ca href=\"https:\u002F\u002Fmartinfowler.com\u002Fbliki\u002FSubcutaneousTest.html\"\u003Eподкожного теста\u003C\u002Fa\u003E (subcutaneous test), который тестирует всё, что находится под GUI. Если вы обслуживаете REST API, то такой тест будет правильным, как в нашем примере:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"java\"\u003E@RestController\npublic class ExampleController {\n    private final PersonRepository personRepository;\n\n    \u002F\u002F shortened for clarity\n\n    @GetMapping(\"\u002Fhello\u002F{lastName}\")\n    public String hello(@PathVariable final String lastName) {\n        Optional&lt;Person\u003E foundPerson = personRepository.findByLastName(lastName);\n\n        return foundPerson\n             .map(person -\u003E String.format(\"Hello %s %s!\",\n                     person.getFirstName(),\n                     person.getLastName()))\n             .orElse(String.format(\"Who is this '%s' you're talking about?\",\n                     lastName));\n    }\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nПозвольте показать ещё одну библиотеку, которая пригодится при тестировании сервиса, предоставляющего REST API. Библиотека \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Frest-assured\u002Frest-assured\"\u003EREST-assured\u003C\u002Fa\u003E даёт хороший DSL для запуска реальных HTTP-запросов к API и оценки полученных ответов.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nПрежде всего, добавьте зависимость в свой \u003Ccode\u003Ebuild.gradle\u003C\u002Fcode\u003E.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"java\"\u003EtestCompile('io.rest-assured:rest-assured:3.0.3')\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nС помощью этой библиотеки можно реализовать сквозной тест для нашего REST API:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"java\"\u003E@RunWith(SpringRunner.class)\n@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)\npublic class HelloE2ERestTest {\n\n    @Autowired\n    private PersonRepository personRepository;\n\n    @LocalServerPort\n    private int port;\n\n    @After\n    public void tearDown() throws Exception {\n        personRepository.deleteAll();\n    }\n\n    @Test\n    public void shouldReturnGreeting() throws Exception {\n        Person peter = new Person(\"Peter\", \"Pan\");\n        personRepository.save(peter);\n\n        when()\n                .get(String.format(\"http:\u002F\u002Flocalhost:%s\u002Fhello\u002FPan\", port))\n        .then()\n                .statusCode(is(200))\n                .body(containsString(\"Hello Peter Pan!\"));\n    }\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nМы опять запускаем всё приложение Spring с помощью \u003Ccode\u003E@SpringBootTest\u003C\u002Fcode\u003E. В этом случае мы делаем \u003Ccode\u003E@Autowire\u003C\u002Fcode\u003E для \u003Ccode\u003EPersonRepository\u003C\u002Fcode\u003E, чтобы легко записывать тестовые данные в БД. Теперь когда просим REST API сказать «привет» нашему другу “Mr Pan”, то видим приятное приветствие. Потрясающе! И более чем достаточно для сквозного теста, если веб-интерфейс вообще отсутствует.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ca name=\"acceptance\"\u003E\u003C\u002Fa\u003E\u003Ch1\u003EПриёмочные тесты — ваши фичи правильно работают?\u003C\u002Fh1\u003E\u003Cbr\u002F\u003E\r\nЧем выше вы поднимаетесь в пирамиде тестов, тем больше вероятность возникновения вопросов: правильно ли работают фичи с точки зрения пользователя. Вы можете рассматривать приложение как чёрный ящик и изменить направленность тестов от прошлого:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cblockquote\u003Eкогда я ввожу x и y, возвращаемое значение должно быть z\u003C\u002Fblockquote\u003E\u003Cbr\u002F\u003E\r\nк следующему:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cblockquote\u003E\u003Ci\u003Eучитывая\u003C\u002Fi\u003E, что есть авторизованный пользователь\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ci\u003Eи\u003C\u002Fi\u003E есть изделие «велосипед»\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ci\u003Eкогда\u003C\u002Fi\u003E пользователь переходит на страницу описания изделия «велосипед»\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ci\u003Eи\u003C\u002Fi\u003E нажимает кнопку «Добавить в корзину»\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ci\u003Eтогда\u003C\u002Fi\u003E изделие «велосипед» должно быть в его корзине\u003C\u002Fblockquote\u003E\u003Cbr\u002F\u003E\r\nБывает, что такие тесты называют \u003Ca href=\"https:\u002F\u002Fen.wikipedia.org\u002Fwiki\u002FFunctional_testing\"\u003Eфункциональными\u003C\u002Fa\u003E или \u003Ca href=\"https:\u002F\u002Fen.wikipedia.org\u002Fwiki\u002FAcceptance_testing#Acceptance_testing_in_extreme_programming\"\u003Eприёмочными\u003C\u002Fa\u003E. Некоторые говорят, что функциональные и приёмочные тесты — это разные вещи. Иногда термины объединяют. Иногда люди бесконечно спорят о формулировках и определениях. Часто такие обсуждения вводят ещё бóльшую путаницу.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nВот что: в какой-то момент следует убедиться, что ваша программа правильно работает с точки зрения \u003Ci\u003Eпользователя\u003C\u002Fi\u003E, а не только с технической точки зрения. Как вы называете эти тесты — на самом деле не так важно. А вот наличие этих тестов важно. Выберите любой термин, придерживайтесь его и напишите эти тесты.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nМожно ещё упомянуть BDD (разработка, основанная на описании поведения) и инструменты для нее. BDD и соответствующий стиль написания тестов — хороший трюк, чтобы изменить своё мышление от деталей реализации к потребностям пользователей. Не бойтесь и попробуйте.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nВам даже не обязательно внедрять полномасштабные инструменты BDD, такие как \u003Ca href=\"https:\u002F\u002Fcucumber.io\u002F\"\u003ECucumber\u003C\u002Fa\u003E (хотя можно и внедрить). Некоторые assertion-библиотеки вроде \u003Ca href=\"http:\u002F\u002Fchaijs.com\u002Fguide\u002Fstyles\u002F#should\"\u003Echai.js\u003C\u002Fa\u003E позволяют писать утверждения (assertions) с ключевыми словами в стиле \u003Ccode\u003Eshould\u003C\u002Fcode\u003E, которые приближают тесты к BDD. И даже если вы не используете библиотеку, которая предоставляет такую нотацию, умный и хорошо продуманный код позволит писать тесты, ориентированные на поведение пользователей. Некоторые методы\u002Fфункции хелперов могут оказаться очень успешными:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cpre\u003E\u003Ccode class=\"python\"\u003E# a sample acceptance test in Python\n\ndef test_add_to_basket():\n    # given\n    user = a_user_with_empty_basket()\n    user.login()\n    bicycle = article(name=\"bicycle\", price=100)\n\n    # when\n    article_page.add_to_.basket(bicycle)\n\n    # then\n    assert user.basket.contains(bicycle)\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\r\nПриёмочные тесты могут проводиться на разных уровнях детализации. В основном они будут достаточно высокого уровня и тестировать сервис через UI. Но важно понимать, что технически нет обязательного требования писать приёмочные тесты именно на самом высоком уровне пирамиды тестов. Если структура приложения и имеющийся сценарий позволяют написать приёмочный тест на более низком уровне, сделайте это. Тест низкого уровня лучше, чем высокого. Концепция приёмочных тестов — доказать, что фичи приложения правильно работают для пользователя — полностью ортогональна вашей пирамиде тестов.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ca name=\"ExploratoryTesting\"\u003E\u003C\u002Fa\u003E\u003Ch1\u003EИсследовательское тестирование\u003C\u002Fh1\u003E\u003Cbr\u002F\u003E\r\nДаже самые прилежные усилия по автоматизации тестов не идеальны. Иногда в автоматических тестах вы пропускаете определённые пограничные случаи. Иногда просто невозможно обнаружить определённую ошибку, написав модульный тест. Некоторые проблемы качества вообще не проявятся в автоматизированных тестах (подумайте о дизайне или юзабилити). Несмотря на самые лучшие намерения в отношении автоматизации тестов, ручные тесты в некоторых отношениях по-прежнему незаменимы.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cdiv style=\"text-align:center;\"\u003E\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw1560\u002Fgetpro\u002Fhabr\u002Fpost_images\u002F65d\u002Fc55\u002F38f\u002F65dc5538f1f4ff98c973d5cc43f6a152.png\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fpost_images\u002F65d\u002Fc55\u002F38f\u002F65dc5538f1f4ff98c973d5cc43f6a152.png\"\u002F\u003E\u003C\u002Fdiv\u003E\u003Cbr\u002F\u003E\r\n\u003Ci\u003E\u003Cfont color=\"gray\"\u003EРис. 12. Исследовательское тестирование выявит проблемы качества, незамеченные в процессе сборки\u003C\u002Ffont\u003E\u003C\u002Fi\u003E\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nВключите \u003Ca href=\"https:\u002F\u002Fen.wikipedia.org\u002Fwiki\u002FExploratory_testing\"\u003Eисследовательские тесты\u003C\u002Fa\u003E в свой набор тестов. Эта процедура тестирования вручную подчёркивает свободу и творческие способности тестировщика, который способен найти проблемы качества в работающей системе. Просто выделите немного времени в расписании, засучите рукава и постарайтесь вызвать сбой приложения каким-нибудь способом. Включите деструктивное мышление и придумывайте способы, как спровоцировать проблемы и ошибки в программе. Документируйте всё, что найдёте. Ищите баги, проблемы дизайна, медленное время отклика, отсутствующие или вводящие в заблуждение сообщения об ошибках и всё остальное, что вас раздражает как пользователя.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nХорошая новость в том, что вы легко можете автоматизировать тесты для большинства найденных ошибок. Написание автоматизированных тестов для найденных ошибок гарантирует, что в будущем не будет регрессий этой ошибки. Кроме того, это помогает выяснить корневую причину проблемы при исправлении бага.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nВо время исследовательского тестирования вы обнаружите проблемы, которые незаметно проскользнули через конвейер сборки. Не расстраивайтесь. Это хорошая обратная связь для улучшения конвейера сборки. Как и с любой обратной связью, обязательно отреагируйте со своей стороны: подумайте, какие действия предпринять, чтобы избежать такого рода проблем в будущем. Может, вы пропустили определённый набор автоматических тестов. Возможно, были небрежны с автоматизированными тестами на этом этапе и следует более тщательно проводить тесты в будущем. Возможно, есть какой-то блестящий новый инструмент или подход, который можно использовать в своем конвейере, чтобы избежать таких проблем. Обязательно отреагируйте так, чтобы ваш конвейер и вся система поставки программного обеспечения стали лучше и совершенствовались с каждым шагом.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ca name=\"TheConfusionAboutTestingTerminology\"\u003E\u003C\u002Fa\u003E\u003Ch1\u003EПутаница с терминологией в тестировании\u003C\u002Fh1\u003E\u003Cbr\u002F\u003E\r\nВсегда сложно говорить о разных классификациях тестов. Моё понимание \u003Ci\u003Eюнит-тестов\u003C\u002Fi\u003E (модульных тестов) может слегка отличаться от вашего. С интеграционными тестами ещё хуже. Для некоторых людей интеграционное тестирование — это очень широкая деятельность, которая тестирует множество различных частей всей системы. Для меня это довольно узкая вещь: тестирование только интеграции с одной внешней частью за раз. Некоторые называют это \u003Ci\u003Eинтеграционными\u003C\u002Fi\u003E тестами, некоторые — \u003Ci\u003Eкомпонентными\u003C\u002Fi\u003E, другие предпочитают термин \u003Ci\u003Eсервисный тест\u003C\u002Fi\u003E. Кто-то заявит, что это вообще три совершенно разные вещи. Нет правильного или неправильного определения. Сообщество разработчиков ПО просто не установило чётко определённых терминов в тестировании.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nНе зацикливайтесь на двусмысленных терминах. Не имеет значения, называете вы это сквозным тестом, тестом широкого стека или функциональным тестом. Неважно, если ваши интеграционные тесты означают для вас не то, что для людей в другой компании. Да, было бы очень хорошо, если бы наша отрасль могла чётко определить термины и все бы их придерживались. К сожалению, этого ещё не произошло. И поскольку в тестировании много нюансов, то всё равно мы имеем дело скорее с широким спектром тестов, чем с кучей дискретных множеств, что ещё больше усложняет чёткую терминологию.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nВажно воспринимать это так: вы просто находите термины, которые работают для вас и вашей команды. Ясно определите для себя различные типы тестов, которые хотите написать. Согласуйте термины в своей команде и найдите консенсус относительно охвата каждого типа теста. Если в своей команде (или даже во всей организации) вы будете последовательны с этими терминами, то это всё, о чем нужно позаботиться. \u003Ca href=\"https:\u002F\u002Ftesting.googleblog.com\u002F2010\u002F12\u002Ftest-sizes.html\"\u003EСаймон Стюарт\u003C\u002Fa\u003E хорошо подытожил это в подходе, который используется в Google. Думаю, это прекрасная демонстрация, что не стоит слишком зацикливаться на названиях и конвенциях по терминам.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ca name=\"PuttingTestsIntoYourDeploymentPipeline\"\u003E\u003C\u002Fa\u003E\u003Ch1\u003EВнедрение тестов в конвейер развёртывания\u003C\u002Fh1\u003E\u003Cbr\u002F\u003E\r\nЕсли вы используете непрерывную интеграцию или непрерывную доставку, то ваш \u003Ca href=\"https:\u002F\u002Fmartinfowler.com\u002Fbliki\u002FDeploymentPipeline.html\"\u003Eконвейер развёртывания\u003C\u002Fa\u003E запускает автоматические тесты каждый раз при внесении изменений в ПО. Обычно конвейер разделяется на несколько этапов, которые постепенно дают всё больше уверенности, что ваша программа готова к развёртыванию в рабочей среде. Услышав обо всех разновидностях тестов, возможно, вы задаётесь вопросом, как поместить их в конвейер развёртывания. Чтобы ответить на это, следует просто подумать об одной из самых основополагающих ценностей непрерывной доставки (это одна из ключевых ценностей \u003Ca href=\"http:\u002F\u002Fwww.extremeprogramming.org\u002Fvalues.html\"\u003Eэкстремального программирования\u003C\u002Fa\u003E и гибкой разработки): о \u003Cb\u003Eбыстрой обратной связи\u003C\u002Fb\u003E.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nХороший конвейер сборки максимально быстро сообщает об ошибках. Вы не хотите ждать целый час, чтобы узнать, что последнее изменение сломало некоторые простые модульные тесты. Если конвейер работает так медленно, то вы могли уже уйти домой, когда поступила обратная связь. Информация должна приходить в течение нескольких секунд или нескольких минут с быстрых тестов на ранних этапах конвейера. И наоборот, более длительные тесты — обычно с более широкой областью — размещаются на более поздних этапах, чтобы не тормозить фидбек от быстрых тестов. Как видите, этапы конвейера развёртывания определяются не типами тестов, а их скоростью и областью действия. Поэтому очень разумно может быть разместить некоторые из самых узких и быстрых интеграционных тестов на ту же стадию, что и юнит-тесты — просто потому что они дают более быструю обратную связь. И необязательно проводить строгую линию по формальному типу тестов.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ca name=\"AvoidTestDuplication\"\u003E\u003C\u002Fa\u003E\u003Ch1\u003EИзбегайте дублирования тестов\u003C\u002Fh1\u003E\u003Cbr\u002F\u003E\r\nЕсть ещё одна ловушка, которую следует избегать: дублирование тестов на разных уровнях пирамиды. Чутьё говорит, что тестов много не бывает, но позвольте вас заверить: бывает. Каждый тест в тестовом наборе — дополнительный багаж, который не обходится бесплатно. Написание и ведение тестов требует времени. Чтение и понимание чужого теста требует времени. И конечно, выполнение тестов тоже требует времени.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nКак и с производственным кодом, следует стремиться к простоте и избегать дублирования. В контексте реализации пирамиды тестов есть два эмпирических правила:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Col\u003E\r\n\u003Cli\u003EЕсли в тесте более высокого уровня обнаружена ошибка, а в тестах более низкого уровня нет, то необходимо писать тест более низкого уровня.\u003C\u002Fli\u003E\r\n\u003Cli\u003EСдвигайте тесты как можно ниже по уровням пирамиды.\u003C\u002Fli\u003E\r\n\u003C\u002Fol\u003E\u003Cbr\u002F\u003E\r\nПервое правило важно, потому что тесты более низкого уровня лучше позволяют сузить область и изолированно воспроизвести ошибку. Они работают быстрее и менее раздуты, что помогает при отладке вручную. И в будущем послужат хорошим регрессионным тестом. Второе правило важно для быстрого выполнения набора тестов. Если вы уверенно протестировали все условия на тестах более низкого уровня, то в тесте более высокого уровня нет необходимости. Он просто не добавляет уверенности, что всё работает. Избыточные тесты станут обузой и начнут раздражать в повседневной работе. Набор тестов будет работать медленнее, и при изменении кода потребуется изменить больше тестов.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nСформулируем иначе: если тест более высокого уровня даёт больше уверенности, что приложение работает правильно, то нужно иметь такой тест. Написание модульного теста для класса контроллера помогает проверить логику внутри самого контроллера. Тем не менее, это не скажет вам, действительно ли конечная точка REST, которую предоставляет этот контроллер, отвечает на запросы HTTP. Таким образом, вы продвигаетесь вверх по пирамиде тестов и добавляете тест, который проверяет именно это, но не более того. В тесте более высокого уровня вы не тестируете всю условную логику и пограничные случаи, которые уже покрыты юнит-тестами более низкого уровня. Убедитесь, что тест высокого уровня фокусируется только на том, что не покрыто тестами более низкого уровня.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nЯ строго отношусь к исключению тестов, не имеющих ценности. Удаляю высокоуровневые тесты, которые уже покрыты на более низком уровне (учитывая, что они не дают дополнительной ценности). Заменяю тесты более высокого уровня тестами более низкого уровня, если это возможно. Иногда трудно удалить лишний тест, особенно если придумать его было непросто. Но вы рискуете создать \u003Ca href=\"https:\u002F\u002Fru.wikipedia.org\u002Fwiki\u002F%D0%9D%D0%B5%D0%B2%D0%BE%D0%B7%D0%B2%D1%80%D0%B0%D1%82%D0%BD%D1%8B%D0%B5_%D0%B7%D0%B0%D1%82%D1%80%D0%B0%D1%82%D1%8B\"\u003Eневозвратные затраты\u003C\u002Fa\u003E, так что смело жмите Delete. Нет причин тратить драгоценное время на тест, который перестал приносить пользу.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Ca name=\"WritingCleanTestCode\"\u003E\u003C\u002Fa\u003E\u003Ch1\u003EПишите чистый код для тестов\u003C\u002Fh1\u003E\u003Cbr\u002F\u003E\r\nКак и в отношении обычного кода, следует позаботиться о хорошем и чистом коде тестов. Вот ещё несколько советов для создания поддерживаемого тестового кода, прежде чем начинать работу и создавать автоматизированный набор тестов:\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Col\u003E\r\n\u003Cli\u003EТестовый код так же важен, как и код в продакшне. Уделите ему столько же заботы и внимания. «Это всего лишь тест» — не оправдание для небрежного кода.\u003C\u002Fli\u003E\r\n\u003Cli\u003EПроверяйте только одно условие в каждом тесте. Тогда тесты останутся лаконичными и понятными.\u003C\u002Fli\u003E\r\n\u003Cli\u003EПравило трёх А (arrange, act, assert) или триада «дано, когда, тогда» — хорошая мнемоника, чтобы поддерживать хорошую структуру тестов.\u003C\u002Fli\u003E\r\n\u003Cli\u003EЧитаемость имеет значение. Не злоупотребляйте DRY (правило «не повторяйся»). Повторение хорошо, если улучшает читаемость. Попробуйте найти баланс между кодом \u003Ca href=\"https:\u002F\u002Fstackoverflow.com\u002Fquestions\u002F6453235\u002Fwhat-does-damp-not-dry-mean-when-talking-about-unit-tests\"\u003EDRY и DAMP\u003C\u002Fa\u003E (DAMP — Descriptive And Meaningful Phrases, содержательные и осмысленные фразы).\u003C\u002Fli\u003E\r\n\u003Cli\u003EЕсли сомневаетесь насчёт рефакторинга или повторного использования кода, применяйте \u003Ca href=\"https:\u002F\u002Fblog.codinghorror.com\u002Frule-of-three\u002F\"\u003EПравило Трёх\u003C\u002Fa\u003E. \u003Ci\u003EUse before reuse\u003C\u002Fi\u003E.\u003C\u002Fli\u003E\r\n\u003C\u002Fol\u003E\u003Cbr\u002F\u003E\r\n\u003Ca name=\"Conclusion\"\u003E\u003C\u002Fa\u003E\u003Ch1\u003EЗаключение\u003C\u002Fh1\u003E\u003Cbr\u002F\u003E\r\nВот и всё! Знаю, это было долгое и трудное объяснение, почему и как следует проводить тестирование. Отличная новость в том, что эта информация практически не имеет срока давности и не зависит от того, какую программу вы создаёте. Работаете вы над микросервисами, устройствами IoT, мобильными приложениями или веб-приложениями, уроки из этой статьи применимы ко всему.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\nНадеюсь, что в статье есть что-то полезное. Теперь вперёд, изучите \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fhamvocke\u002Fspring-testing\"\u003Eпример кода\u003C\u002Fa\u003E и примените усвоенные понятия в своём наборе тестов. Создание крепкого набора тестов требует определённых усилий. Это окупится в долгосрочной перспективе и сделает вашу жизнь разработчика более спокойной, поверьте мне.\u003Cbr\u002F\u003E\r\n\u003Cbr\u002F\u003E\r\n\u003Cb\u003EСм. также:\u003C\u002Fb\u003E\u003Cbr\u002F\u003E\r\n\u003Ca href=\"https:\u002F\u002Fhabr.com\u002Fpost\u002F358178\u002F\"\u003E«Антипаттерны тестирования ПО»\u003C\u002Fa\u003E\u003C\u002Fdiv\u003E","tags":[{"titleHtml":"DevOps"},{"titleHtml":"пирамида тестов"},{"titleHtml":"Junit"},{"titleHtml":"Mockito"},{"titleHtml":"Wiremock"},{"titleHtml":"Pact"},{"titleHtml":"Selenium"},{"titleHtml":"REST-assured"},{"titleHtml":"Spring"},{"titleHtml":"TDD"},{"titleHtml":"SOLID"},{"titleHtml":"CDC-тесты"},{"titleHtml":"интеграционные тесты"},{"titleHtml":"модульные тесты"},{"titleHtml":"юнит-тесты"},{"titleHtml":"контрактные тесты"},{"titleHtml":"YAGNI"},{"titleHtml":"JSON"},{"titleHtml":"Galen"},{"titleHtml":"headless-браузер"}],"metadata":{"stylesUrls":[],"scriptUrls":[],"shareImageUrl":"https:\u002F\u002Fhabr.com\u002Fshare\u002Fpublication\u002F358950\u002F35e3dde4f2d0faf7cd6ce5000dc545b6\u002F","shareImageWidth":1200,"shareImageHeight":630,"vkShareImageUrl":"https:\u002F\u002Fhabr.com\u002Fshare\u002Fpublication\u002F358950\u002F35e3dde4f2d0faf7cd6ce5000dc545b6\u002F?format=vk","schemaJsonLd":"{\"@context\":\"http:\\\u002F\\\u002Fschema.org\",\"@type\":\"Article\",\"mainEntityOfPage\":{\"@type\":\"WebPage\",\"@id\":\"https:\\\u002F\\\u002Fhabr.com\\\u002Fru\\\u002Fpost\\\u002F358950\\\u002F\"},\"headline\":\"Пирамида тестов на практике\",\"datePublished\":\"2018-05-20T14:38:20+03:00\",\"dateModified\":\"2018-05-20T16:26:55+03:00\",\"author\":{\"@type\":\"Person\",\"name\":\"Анатолий Ализар\"},\"publisher\":{\"@type\":\"Organization\",\"name\":\"Habr\",\"logo\":{\"@type\":\"ImageObject\",\"url\":\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fwebt\\\u002Fa_\\\u002Flk\\\u002F9m\\\u002Fa_lk9mjkccjox-zccjrpfolmkmq.png\"}},\"description\":\"Об авторе: Хэм Фокке &mdash; разработчик и консультант ThoughtWorks в Германии. Устав от деплоя в три ночи, он добавил в свой инструментарий средства непрерывной доста...\",\"url\":\"https:\\\u002F\\\u002Fhabr.com\\\u002Fru\\\u002Fpost\\\u002F358950\\\u002F#post-content-body\",\"about\":[\"h_microformats\",\"h_it_testing\",\"h_web_testing\",\"h_dev_management\",\"h_devops\",\"f_develop\",\"f_management\",\"f_admin\"],\"image\":[\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fpost_images\\\u002F753\\\u002F224\\\u002F111\\\u002F753224111d9c766c7e6040411e6a5cf9.jpg\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fpost_images\\\u002Fea3\\\u002F308\\\u002F1dd\\\u002Fea33081ddc613a817b10881041035a29.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fpost_images\\\u002Fa3a\\\u002F60c\\\u002Fb8b\\\u002Fa3a60cb8b4d4f10699cc6862d5bcf8fc.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fpost_images\\\u002Ff6c\\\u002F930\\\u002Ff2d\\\u002Ff6c930f2d4ae8a6068696ace34e9566e.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fpost_images\\\u002F813\\\u002F284\\\u002F1c5\\\u002F8132841c5c334aad6d292c69c1807de3.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fpost_images\\\u002Fae4\\\u002F727\\\u002F6e6\\\u002Fae47276e66f80ee73f38ea2a995b8c13.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fpost_images\\\u002F9be\\\u002F489\\\u002F778\\\u002F9be48977803c4fd5bd9882450db5b4ff.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fpost_images\\\u002F089\\\u002F6ef\\\u002Faaf\\\u002F0896efaaf776a8d308a008d0d2ef625e.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fpost_images\\\u002F15b\\\u002F98f\\\u002F5bd\\\u002F15b98f5bd52634719eff1280a4117f3b.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fpost_images\\\u002F420\\\u002Fa0f\\\u002F17c\\\u002F420a0f17c800a1ac4a65a883813da8ae.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fpost_images\\\u002F25e\\\u002Fdba\\\u002F1c2\\\u002F25edba1c2090bc04cf76e018a53ee451.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fpost_images\\\u002F1e1\\\u002Fd34\\\u002F9b2\\\u002F1e1d349b260edb4f442fac4bcbabb8b1.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fpost_images\\\u002F91a\\\u002F118\\\u002F3e7\\\u002F91a1183e77f1850a1df00b819503b109.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fpost_images\\\u002F65d\\\u002Fc55\\\u002F38f\\\u002F65dc5538f1f4ff98c973d5cc43f6a152.png\"]}","metaDescription":"Об авторе: Хэм Фокке — разработчик и консультант ThoughtWorks в Германии. Устав от деплоя в три ночи, он добавил в свой инструментарий средства непрерывной доставки и тщательной автоматизации. Сейчас...","mainImageUrl":null,"amp":false,"customTrackerLinks":[]},"polls":[],"commentsEnabled":true,"rulesRemindEnabled":false,"votesEnabled":true,"status":"published","plannedPublishTime":null,"checked":null,"isEditorial":false}},"articlesIds":{},"isLoading":false,"pagesCount":{},"route":{},"reasonsList":null,"view":"cards","lastVisitedRoute":{},"ssrCommentsArticleIds":[""],"karma":{}},"authorContribution":{"authors":{}},"betaTest":{"currentAnnouncement":null,"announcements":{},"announcementCards":null,"announcementComments":{},"announcementCommentThreads":{},"announcementCommentingStatuses":{},"archivedList":[]},"authorStatistics":{"articleRefs":{},"articleIds":{},"pagesCount":{},"route":{},"viewsCount":[],"maxStatsCount":{}},"career":{"seoLandings":[{"title":"Тестировщик программного обеспечения","vacanciesCount":127,"itemUrl":"https:\u002F\u002Fcareer.habr.com\u002Fvacancies\u002Ftestirovshik_programmnogo_obespecheniya","itemHubs":["it_testing"]},{"title":"DevOps инженер","vacanciesCount":87,"itemUrl":"https:\u002F\u002Fcareer.habr.com\u002Fvacancies\u002Fdevops","itemHubs":["devops","build_automation","sys_admin","virtualization","kubernetes"]},{"title":"Руководитель разработки","vacanciesCount":151,"itemUrl":"https:\u002F\u002Fcareer.habr.com\u002Fvacancies\u002Frukovoditel_razrabotki","itemHubs":["dev_management"]}],"hubs":"microformats,it_testing,web_testing,dev_management,devops"},"comments":{"articleComments":{},"searchCommentsResults":null,"previewComment":null,"pagesCount":null,"commentAccess":{},"scrollParents":{},"pageArticleComments":{"lastViewedComment":0,"postId":null,"lastCommentTimestamp":"","moderated":[],"moderatedIds":[],"commentRoute":""}},"companies":{"companyRefs":{},"companyIds":{},"companyTopIds":{},"pagesCount":{},"companyProfiles":{},"companiesCategories":[],"companiesCategoriesTotalCount":0,"companiesWidgets":{},"companiesWorkers":{},"companiesFans":{},"route":{},"isLoading":false,"companyWorkersLoading":false,"companyFansLoading":false,"vacancies":{},"workplaceInfo":null},"companyAdmin":{"companyInfo":null,"companyInfoLoading":false,"faqArticles":null,"brandingPreviewImageUrl":null},"companiesContribution":{"hubs":{},"flows":{},"companyRefs":{}},"companyHubsContribution":{"contributionRefs":{"hubRefs":{},"hubIds":{}}},"conversation":{"messages":[],"respondent":null,"isLoadMore":false},"conversations":{"conversations":[],"unreadCount":0,"pagesCount":0,"isLoadMore":false},"desktopState":{"desktopFl":null,"desktopHl":null,"isChecked":false,"isLoginDemanded":false},"docs":{"menu":{},"articles":{},"mainMenu":[],"loading":{"main":false,"dropdown":false,"article":false}},"feature":{"isProbablyVisible":"true"},"flows":{"flows":[{"alias":"develop","id":1,"route":{"name":"FLOW_PAGE","params":{"flowName":"develop"}}},{"alias":"admin","id":6,"route":{"name":"FLOW_PAGE","params":{"flowName":"admin"}}},{"alias":"design","id":2,"route":{"name":"FLOW_PAGE","params":{"flowName":"design"}}},{"alias":"management","id":3,"route":{"name":"FLOW_PAGE","params":{"flowName":"management"}}},{"alias":"marketing","id":4,"route":{"name":"FLOW_PAGE","params":{"flowName":"marketing"}}},{"alias":"popsci","id":7,"route":{"name":"FLOW_PAGE","params":{"flowName":"popsci"}}}]},"global":{"isPwa":false,"device":"desktop","isHabrCom":true},"hubs":{"hubRefs":{},"hubIds":{},"pagesCount":{},"isLoading":false,"route":{}},"hubsBlock":{"hubRefs":{},"hubIds":{}},"i18n":{"fl":"ru","hl":"ru"},"info":{"infoPage":{},"isLoading":true},"location":{"urlStruct":{"protocol":null,"slashes":null,"auth":null,"host":null,"port":null,"hostname":null,"hash":null,"search":null,"query":{},"pathname":null,"path":null,"href":""},"searchQuery":null},"me":{"user":null,"ppgDemanded":false,"karmaResetInfo":{"canReincarnate":null,"wasReincarnated":null,"currentScore":null},"notes":null},"mostReadingList":{"mostReadingListIds":[],"mostReadingListRefs":null,"promoPost":null},"pinnedPost":{"pinnedPost":null},"ppa":{"articles":{},"card":null,"transactions":null,"totalTransactions":null,"isAccessible":null},"projectsBlocks":{"activeBlocks":{}},"promoData":{"isLoading":false,"hasLoaded":false,"featurer":null,"megaposts":null,"promoLinks":null,"promoPosts":null},"pullRefresh":{"shouldRefresh":false},"sandbox":{"articleIds":[],"articleRefs":{},"pagesCount":null,"route":{},"lastVisitedRoute":{},"isLoading":false},"search":{"searchQueryError":null},"settingsOther":{"inputs":{"uiLang":{"errors":[],"ref":null,"value":""},"articlesLangEnglish":{"errors":[],"ref":null,"value":false},"articlesLangRussian":{"errors":[],"ref":null,"value":false},"agreement":{"errors":[],"ref":null,"value":false},"email":{"errors":[],"ref":null,"value":true},"digest":{"errors":[],"ref":null,"value":true}}},"similarList":{"similarListIds":[],"similarListRefs":null},"ssr":{"error":null,"isDataLoaded":false,"isDataLoading":false,"isHydrationFailed":false,"isServer":false},"technotext":{"nominationsList":[]},"userHubsContribution":{"contributionRefs":{"hubRefs":{},"hubIds":{}}},"userInvites":{"availableInvites":0,"usedInvitesIds":[],"usedInvitesRefs":{},"usedInvitesPagesCount":0,"unusedInvitesIds":[],"unusedInvitesRefs":{},"unusedInvitesPagesCount":0},"users":{"authorRefs":{},"authorIds":{},"pagesCount":{},"authorProfiles":{},"userHubs":{},"userInvitations":{},"authorFollowers":{},"authorFollowed":{},"userSpecialization":{},"karmaStats":[],"statistics":null,"isLoading":false,"authorFollowersLoading":false,"authorFollowedLoading":false,"userHubsLoading":false,"userInvitationsLoading":false,"route":{}},"viewport":{"prevScrollY":{},"scrollY":0,"width":0},"tracker":{"items":{},"pagesCache":{},"markedViewedSilently":{},"markedRead":{},"unreadCounters":{"applications":null,"system":null,"mentions":null,"subscribers":null,"posts_and_comments":null},"unviewedCounters":{"applications":null,"system":null,"mentions":null,"subscribers":null,"posts_and_comments":null}}};(function(){var s;(s=document.currentScript||document.scripts[document.scripts.length-1]).parentNode.removeChild(s);}());</script>
<script src="https://assets.habr.com/habr-web/js/chunk-vendors.da6c6b36.js" defer></script><script src="https://assets.habr.com/habr-web/js/app.92df6f6d.js" defer></script>



    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    </script>
  
  <script type="text/javascript" >
    (function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
    m[i].l=1*new Date();k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})
    (window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");

    ym(24049213, "init", {
      defer:true,
      trackLinks:true,
      accurateTrackBounce:true,
      webvisor:false,
    });
  </script>
  <noscript>
    <div>
      <img src="https://mc.yandex.ru/watch/24049213" style="position:absolute; left:-9999px;" alt="" />
    </div>
  </noscript>
  
    <script type="text/javascript">
      window.addEventListener('load', function () {
        setTimeout(() => {
          const img = new Image();
          img.src = 'https://vk.com/rtrg?p=VK-RTRG-421343-57vKE';
        }, 0);
      });
    </script>
  
<script src="https://habr.com/js/ads.js" onload="window['zhY4i4nJ9K'] = true"></script>
</body>
</html>
