## Grade 7

### 1

**Утечки памяти**

### 2
**Garbage collector**

Обычно в стеке хранятся данные, размер и время использования которых компилятор Go может предсказать:  
это локальные переменные функции, аргументы, передаваемые в функцию, возвращаемые значения и т. д.

В отличие от стека, получение данных из кучи и управление ею являются более затратными процессами.


Сборщик мусора, он же GC (Garbage Collector) - это система, специально предназначенная для определения и освобождения  
динамически выделенной памяти. В Go используется алгоритм сборки мусора на основе трассировки и алгоритма  
пометок **Mark and Sweep**.

На этапе маркировки (mark) сборщик мусора помечает данные, которые активно используются приложением, в качестве живых  
(live heap). Затем на этапе очистки (sweep) GC проходит по всей памяти, которая не была помечена как живая,  
и переиспользует ее.

Работа сборщика мусора не является бесплатной, поскольку он потребляет два важных ресурса системы: процессорное время  
и физическую память.


Инструменты:
- escape-анализ Вы можете использовать escape-анализ для определения, где будет храниться определенная переменная. Например,  
вы можете проанализировать ваше приложение, запустив его из командной строки с флагом -gcflags=-m:
- tool trace Используя инструмент go tool trace, мы можем наблюдать за изменениями размера кучи и анализировать  
поведение сборщика мусора в вашей программе.
- GOMEMLIMIT Переменная окружения GOMEMLIMIT устанавливает общий объем памяти, которым может пользоваться среда выполнения Go (Go runtime)


### 3
**Как именно устроена map? (hash table, buckets, эвакуация, коллизии)**

**Хэш-функция(Hash function).** 
Под ней понимают функцию, которая принимает значение (ключ) неопределенного размера и возвращает значение 
фиксированной длины. В случае c Go она возвращает uint64. Одно из главных свойств - стабильность. 
Для одного и того же переданного значения она должна возвращать один и тот же результат;

**Бакет(Bucket/Slot).**
Так называемая структура данных, в которой хранятся ключи и значения в мапе. В некоторых реализациях 
hashmap в одном бакете хранится одно значение, а в других - несколько. Например, в Go данные внутри 
бакета хранятся в массиве, и в одном бакете может быть до восьми элементов;

**Коллизия (Collision)**
Так как хэш-функция не идеальна, передав в нее два разных значения мы можем получить один и тот же 
результат. В случае с бакетами нам нужно два разных значения положить в один и тот же бакет. Это называется 
коллизией. Для реализации hashmap необходимо иметь алгоритм их разрешения. Существует несколько таких алгоритмов (стратегий):

- Closed addressing.
Храним элементы с одинаковым хэшем с помощью дополнительных структур данных, таких как: связный список, двоичное дерево, 
массив и др. Используется в следующих языках: Go, Java, Scala;

- Open addressing.
В бакете хранится только одно значение. При возникновении коллизии выбирается следующий свободный бакет по какой-либо 
формуле. Такая стратегия используется в Python, Ruby, Rust, C++ и др;

- Perfect hashing.
Выбирается такая хэш-функция, при которой не будет коллизий. Подбирается для статичного, заранее известного набора ключей.

**Фактор заполненности мапы (Overload factor).** 
Это число (порог), превысив которое считается, что нужно увеличить количество бакетов (обычно вдвое) 
для сохранения константной скорости O(1)

Интересности реализации:
- В качестве ключа можно использовать любой тип данных для которого определена операция сравнения. Например, 
можно использовать структуру с тем же условием для всех ее полей;

- При отсутствии элемента возвращается нулевое значение для типа. Вторым параметром можно получить флаг 
наличия элемента по ключу;

- Нельзя получить адрес элемента. Потому что при росте мапы оно переедет в другой бакет и адрес у него, 
соответственно, поменяется;

- Мапа не безопасна для конкурентного использования. Для этого можно использовать обертку из 
sync.Map или мьютекс;

- Порядок итерации не сохраняется. При каждой новой итерации мапы последовательность возвращаемых элементов 
может отличаться. Под капотом каждый раз выбирается рандомный бакет, с которого начинается итерация. 
Для сохранения нужного порядка придется сохранять ключи в отдельном массиве и итерироваться по нему;

- При каждом создании мапы генерируется seed для рандомизации хэш-функции. Это сделано для безопасности, 
так как зная хэш-функцию можно подобрать такие ключи, что все значения попадут в один бакет и 
мы получим линейную скорость поиска;

- При коллизиях используется стратегия сlosed addressing. Мы перебираем все ячейки бакета (их 8) и ищем 
первое свободное место;

- OverloadFactor равен 6.5 (~81% заполненности бакетов). Когда бакеты в среднем заполнены больше чем на 
6.5 элементов, тригерится рост мапы, и все элементы перемещаются в новые бакеты, которых создается в два раза больше.

- При росте элементы переносятся в новые бакеты постепенно, а не все сразу;