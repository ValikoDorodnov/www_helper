# Grade 11

## Асимптотический анализ (O большое)

Пытаемся анализировать сложность и скорость роста времени работы алгоритма. 
Сложность - это количество операций (выделения памяти), которые выполняет алгоритм.
Обычно используется "худший случай"

Типы сложностей:
- time complexity (сложность по времени)
- space complexity (сложность по памяти)

Список асимптотических обозначений по возрастанию сложности:
- O(1) - константная сложность
- O(logn) - логарифмическая сложность
- O(n) - линейная сложность
- O(n log n) - линейно-логарифмическая сложность
- O(n^2) - квадратичная сложность
- O(n!) - факториальная сложность

Если сложность составная, берется самая большая из них.
- O(n) + O(1) = O(n)
- O(n) + O(n^2) = O(n^2)
- O(n^2) + O(n log n) = O(n^2)

Если внутри функции 2 цикла последовательно сложность O(n + m)
Если внутри фукнции один цикл итерируется внутри другого, то сложность O(n * m)

### Примеры time complexity (сложность по времени)
```go

// Пример функции со сложность O(n)
// n - количество элементов в массиве (худший случай при поиске)
func inArray(values []int, found int) bool {
	for _, v := range values {
		if v == found {
			return true
		}
	}

	return false
}
```

```go
// Пример функции со сложностью O(1) - констная сложность
// Сложность константа, т.к. не зависит от количества элементов в массиве.
values := map[string]int{"first": 1, "second": 2, "third": 3}

val, ok := values["first"]

if !ok {
	println("not found")
} else {
	println(val)
}
```

```go
// Пример функции со сложностью 0(n + m) так как мы итерируемся по двум массивам
func sum(lhs, rhs []int) int {
    res := 0
    
    for _, v := range lhs {
        res += v
    }
    
    for _, v := range rhs {
        res += v
    }
    
    return res
}
```

```go
// Пример функции со сложностью O(n) за счет горутин
func sum(lhs, rhs []int) int {
	ch := make(chan int)
	res := 0

	calc := func(nums []int) {
		num := 0
		for _, v := range nums {
			num += v
		}
		ch <- num
	}

	go calc(lhs)
	go calc(rhs)
	
	res += <-ch
	res += <-ch

	return res
}
```

### Примеры space complexity (сложность по памяти)
```go
// Пример фукнкции со сложность O(n) 
// Потому что нам потребуется столько же памяти, сколько у входящего массива
func modify(values []int) []int {
	result := make([]int, len(values))
	for i, v := range values {
		result[i] = v * v
	}

	return result
}
```

```go
// Пример фукнкции со сложность O(n) 
// В стек будет помещено кол-во вызово функции равное входящему числу
func sum(value int) int {
    if value <= 0 {
        return value
    }

    return value + sum(value-1)
}
```

## Базовые структуры данных

### Массивы
Массив - структура данных, которая хранит данные в определенном порядке.

```go
vars := []string{"one", "two", "three"}
```

### Односвязный список / Двусвязный список
