## Grade 2

### 1
**Конструкции: make, init(), :=, new()**

**:=**  
оператор короткого объявления переменных. Он одновременно объявляет и инициализирует переменную.  

```go
x := 10
y := "Hello"
```

**make**  
используется для создания и инициализации каналов (channels), срезов (slices) и карт (maps). Эта функция  
выделяет память и возвращает объект, готовый к использованию.

```go
m := make(map[string]int)
ch := make(chan int)
s := make([]int, 10, 10)
```

**new()**  
используется для выделения памяти для любого типа и возвращает указатель на него. Однако память не инициализируется
```go
	p := new(int)

	println(p)  // 0x14000066f60
	println(*p) // 0
```

**init()** 
это специальная функция, которая автоматически вызывается перед началом выполнения основного кода, если указано несколько  
функций init(), они будут выполнены последовательно по стеку вызовов до функции main()

```go
package main

import "fmt"

func init() {
    fmt.Println("Init function called")
}

func main() {
    fmt.Println("Main function called")
}
```

### 2
**Типы данных (array, slice, map)**

| **Тип данных** | **Описание**                                                                                                           | **Пример инициализации**                                                                                         | **Применение**                                                                                             |
|----------------|------------------------------------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------------|
| **Array**      | Массив фиксированной длины, элементы одного типа. Размер массива задается при создании и не может быть изменен.        | `var arr [3]int` <br> `arr := [3]int{1, 2, 3}` <br> `arr := [...]int{1, 2, 3}` (длина вычисляется автоматически) | Используется редко из-за фиксированного размера. Применяется, если длина заранее известна и фиксирована.   |
| **Slice**      | Срез — динамическая последовательность элементов одного типа. Это "обертка" над массивом, позволяющая изменять размер. | `var s []int` <br> `s := []int{1, 2, 3}` <br> `s := make([]int, 5)`                                              | Для работы с последовательностями переменной длины. Это основной инструмент вместо массивов.               |
| **Map**        | Хеш-таблица (ассоциативный массив), где ключи и значения могут быть разного типа (ключи должны быть сравнимыми).       | `m := make(map[string]int)` <br> `m := map[string]int{"key1": 1, "key2": 2}`                                     | Для хранения данных в формате "ключ-значение". Применяется в случаях, когда нужен быстрый доступ по ключу. |

Дополнительные пояснения:
- Array:
   - Размер является частью типа ([3]int и [5]int — это разные типы).
   - Передается по значению, что может быть неэффективным для больших массивов.
- Slice:
   - Может расти и уменьшаться в размере.
   - Хранит ссылку на массив, что позволяет экономить память.
   - Содержит: ссылку на массив, длину (len) и емкость (cap).
- Map:
   - Ключи должны быть сравнимыми (например, string, int, но не slice или map).
   - Доступ по ключу возвращает два значения: само значение и признак наличия ключа.

### 3
**Циклы (forr, fori, break, continue) и Labels (break, continue, goto)**
```go
for i := 0; i < 5; i++ { // Классический цикл с индексом
	fmt.Println("Index:", i)
}

arr := []string{"Go", "Python", "Java"}
for index, value := range arr { // Цикл `for range`
    fmt.Printf("Index: %d, Value: %s\n", index, value)
}

i := 0
for { // Бесконечный цикл
    if i >= 3 {
        break // Прерывание цикла
    }
    fmt.Println("Iteration:", i)
    i++
}

OuterLoop: // Метка для внешнего цикла
    for i := 1; i <= 3; i++ {
        for j := 1; j <= 3; j++ {
            if i == 2 && j == 2 {
                fmt.Println("Breaking to OuterLoop")
                break OuterLoop // Выход из внешнего цикла
            }
        fmt.Printf("i: %d, j: %d\n", i, j)
    }
}
```

### 4
```go
    num := 2
	
    switch num {
    case 1:
        fmt.Println("Case 1")
        fallthrough // Переход к следующему case
    case 2:
        fmt.Println("Case 2")
        fallthrough // Переход к следующему case
    case 3:
        fmt.Println("Case 3")
    default:
        fmt.Println("Default case")
    }
	
    // Case 2
    // Case 3
```