## Грейд 13

### Theory

#### Микросервисная архитектура

Термин «Microservice Architecture» получил распространение в последние несколько лет как описание способа дизайна  
приложений в виде набора независимо развертываемых сервисов. В то время как нет точного описания этого архитектурного  
стиля, существует некий общий набор характеристик: организация сервисов вокруг бизнес-потребностей, автоматическое  
развертывание, перенос логики от шины сообщений к приемникам (endpoints) и децентрализованный контроль над языками  
и данными.  

Если коротко, то архитектурный стиль микросервисов — это подход, при котором единое приложение строится как набор  
небольших сервисов, каждый из которых работает в собственном процессе и коммуницирует с остальными используя  
легковесные механизмы, как правило HTTP. Эти сервисы построены вокруг бизнес-потребностей и развертываются независимо  
с использованием полностью автоматизированной среды.  

Если вы разрабатываете приложение, состоящее из нескольких библиотек, работающих в одном процессе, любое изменение  
в этих библиотеках приводит к переразвертыванию всего приложения. Но если ваше приложение разбито на несколько  
сервисов, то изменения, затрагивающие какой-либо из них, потребуют переразвертывания только изменившегося сервиса  

Наиболее популярным сейчас считается мнение о том, что сервис должен быть настолько большим, чтобы он мог  
полностью «уместиться в голове разработчика», независимо от количества строк кода.

Проектирование под отказ (Design for failure)  
Следствием использования сервисов как компонентов является необходимость проектирования приложений так, чтобы они  
могли работать при отказе отдельных сервисов. Любое обращение к сервису может не сработать из-за его недоступности.  
Клиент должен реагировать на это настолько терпимо, насколько возможно.  


#### JSON API

JSON API - open source спецификация для работы по протоколу HTTP.  

Cпецификация JSON API решает ряд проблем — общее соглашение для всех. Раз есть общее соглашение, то мы не спорим  
внутри команды — велосипедный сарай задокументирован. У нас есть соглашение, из каких материалов делать велосипедный  
сарай и как его красить.  


#### GraphQL

В двух словах, GraphQL это синтаксис, который описывает как запрашивать данные, и, в основном, используется клиентом  
для загрузки данных с сервера. GraphQL имеет три основные характеристики:
- Позволяет клиенту точно указать, какие данные ему нужны.
- Облегчает агрегацию данных из нескольких источников.
- Использует систему типов для описания данных.

Facebook придумал концептуально простое решение: вместо того, чтобы иметь множество "глупых" endpoint, лучше иметь  
один "умный" endpoint, который будет способен работать со сложными запросами и придавать данным такую форму,  
какую запрашивает клиент.  

Фактически, слой GraphQL находится между клиентом и одним или несколькими источниками данных; он принимает запросы  
клиентов и возвращает необходимые данные в соответствии с переданными инструкциями.  

На практике GraphQL API построен на трёх основных строительных блоках: 
- на схеме (schema)
- запросах (queries)
- распознавателях (resolvers)


##### queries
```
query {
  stuff {
    eggs
    shirt
    pizza
  }
}
```

##### resolvers
```
Query: {
    post(root, args) {
        return Posts.find({ id: args.id });
    }
}
```

##### schema
```
import gql from 'graphql-tag'
import mongodb from '/path/to/mongodb’ // Это - лишь пример. Предполагается, что `mongodb` даёт нам подключение к MongoDB.


const schema = {
  typeDefs: gql`
    type Nutrition {
      flavorId: ID
      calories: Int
      fat: Int
      sodium: Int
    }

    type Flavor {
      id: ID
      name: String
      description: String
      nutrition: Nutrition
    }

    type Query {
      flavors(id: ID): [Flavor]
    }

    type Mutation {
      updateFlavor(id: ID!, name: String, description: String): Flavor
    }
  `,
  resolvers: {
    Query: {
      flavors: (parent, args) => {
        // Предполагается, что args равно объекту, наподобие { id: '1' }
        return mongodb.collection('flavors').find(args).toArray()
      },
    },
    Mutation: {
      updateFlavor: (parent, args) => {
        // Предполагается, что args равно объекту наподобие { id: '1', name: 'Movie Theater Clone', description: 'Bring the movie theater taste home!' }

        // Выполняем обновление.

        mongodb.collection('flavors').update(args)

        // Возвращаем flavor после обновления.

        return mongodb.collection('flavors').findOne(args.id)
      },
    },
    Flavor: {
      nutrition: (parent) => {
        return mongodb.collection('nutrition').findOne({
          flavorId: parent.id,
        })
      }
    },
  },
}

export default schema
```