## Грейд 13

### Theory

#### Микросервисная архитектура

Термин «Microservice Architecture» получил распространение в последние несколько лет как описание способа дизайна  
приложений в виде набора независимо развертываемых сервисов. В то время как нет точного описания этого архитектурного  
стиля, существует некий общий набор характеристик: организация сервисов вокруг бизнес-потребностей, автоматическое  
развертывание, перенос логики от шины сообщений к приемникам (endpoints) и децентрализованный контроль над языками  
и данными.  

Если коротко, то архитектурный стиль микросервисов — это подход, при котором единое приложение строится как набор  
небольших сервисов, каждый из которых работает в собственном процессе и коммуницирует с остальными используя  
легковесные механизмы, как правило HTTP. Эти сервисы построены вокруг бизнес-потребностей и развертываются независимо  
с использованием полностью автоматизированной среды.  

Если вы разрабатываете приложение, состоящее из нескольких библиотек, работающих в одном процессе, любое изменение  
в этих библиотеках приводит к переразвертыванию всего приложения. Но если ваше приложение разбито на несколько  
сервисов, то изменения, затрагивающие какой-либо из них, потребуют переразвертывания только изменившегося сервиса  

Наиболее популярным сейчас считается мнение о том, что сервис должен быть настолько большим, чтобы он мог  
полностью «уместиться в голове разработчика», независимо от количества строк кода.

Проектирование под отказ (Design for failure)  
Следствием использования сервисов как компонентов является необходимость проектирования приложений так, чтобы они  
могли работать при отказе отдельных сервисов. Любое обращение к сервису может не сработать из-за его недоступности.  
Клиент должен реагировать на это настолько терпимо, насколько возможно.  


#### JSON API

JSON API - open source спецификация для работы по протоколу HTTP.  

Cпецификация JSON API решает ряд проблем — общее соглашение для всех. Раз есть общее соглашение, то мы не спорим  
внутри команды — велосипедный сарай задокументирован. У нас есть соглашение, из каких материалов делать велосипедный  
сарай и как его красить.  


#### GraphQL

В двух словах, GraphQL это синтаксис, который описывает как запрашивать данные, и, в основном, используется клиентом  
для загрузки данных с сервера. GraphQL имеет три основные характеристики:
- Позволяет клиенту точно указать, какие данные ему нужны.
- Облегчает агрегацию данных из нескольких источников.
- Использует систему типов для описания данных.

Facebook придумал концептуально простое решение: вместо того, чтобы иметь множество "глупых" endpoint, лучше иметь  
один "умный" endpoint, который будет способен работать со сложными запросами и придавать данным такую форму,  
какую запрашивает клиент.  

Фактически, слой GraphQL находится между клиентом и одним или несколькими источниками данных; он принимает запросы  
клиентов и возвращает необходимые данные в соответствии с переданными инструкциями.  

На практике GraphQL API построен на трёх основных строительных блоках: 
- на схеме (schema)
- запросах (queries)
- распознавателях (resolvers)


##### queries
```
query {
  stuff {
    eggs
    shirt
    pizza
  }
}
```

##### resolvers
```
Query: {
    post(root, args) {
        return Posts.find({ id: args.id });
    }
}
```

##### schema
```
import gql from 'graphql-tag'
import mongodb from '/path/to/mongodb’ // Это - лишь пример. Предполагается, что `mongodb` даёт нам подключение к MongoDB.


const schema = {
  typeDefs: gql`
    type Nutrition {
      flavorId: ID
      calories: Int
      fat: Int
      sodium: Int
    }

    type Flavor {
      id: ID
      name: String
      description: String
      nutrition: Nutrition
    }

    type Query {
      flavors(id: ID): [Flavor]
    }

    type Mutation {
      updateFlavor(id: ID!, name: String, description: String): Flavor
    }
  `,
  resolvers: {
    Query: {
      flavors: (parent, args) => {
        // Предполагается, что args равно объекту, наподобие { id: '1' }
        return mongodb.collection('flavors').find(args).toArray()
      },
    },
    Mutation: {
      updateFlavor: (parent, args) => {
        // Предполагается, что args равно объекту наподобие { id: '1', name: 'Movie Theater Clone', description: 'Bring the movie theater taste home!' }

        // Выполняем обновление.

        mongodb.collection('flavors').update(args)

        // Возвращаем flavor после обновления.

        return mongodb.collection('flavors').findOne(args.id)
      },
    },
    Flavor: {
      nutrition: (parent) => {
        return mongodb.collection('nutrition').findOne({
          flavorId: parent.id,
        })
      }
    },
  },
}

export default schema
```

#### Принципы разработки: SOLID

Аббревиатура SOLID была предложена Робертом Мартином, автором нескольких книг, широко известных в сообществе  
разработчиков. Эти принципы позволяют строить на базе ООП масштабируемые и сопровождаемые программные продукты с  
понятной бизнес-логикой.  

- Single responsibility — принцип единственной ответственности
- Open-closed — принцип открытости / закрытости
- Liskov substitution — принцип подстановки Барбары Лисков
- Interface segregation — принцип разделения интерфейса
- Dependency inversion — принцип инверсии зависимостей


##### Single responsibility — принцип единственной ответственности

Принцип декларирует, что каждый объект должен иметь одну обязанность и эта обязанность должна  
быть полностью инкапсулирована в класс, а все его сервисы должны быть направлены исключительно на  
обеспечение этой обязанности.  

Следование принципу заключается обычно в декомпозиции сложных классов, которые делают сразу много вещей,  
на простые, отвественность которых очень специализирована. Но также и объединении в отдельный класс однотипной  
функциональности, которая может оказаться распределённой по многим классам, может рассматриваться как следование  
этому принципу.  

Следование SRP весьма полезная практика с точки зрения повторного использования кода. Сложные объекты с комплексными  
зависимостями обычно очень сложно использовать повторно, особенно если нужна только часть реализованного в них  
функционала. А небольшие классы с чётко очерченным функционалом, напротив, проще использовать повторно,  
так как они не избыточные и редко тянут за собой существенный объём зависимостей.  

Например, часто используемый во фреймворках паттерн ActiveRecord нарушает принцип единственной ответственности.  
ActiveRecord реально объединяет в себе очень много функциональных возможностей и часто смешивает бизнес-логику и работу  
со слоем хранения. При этом использование ActiveRecord часто является удобным и целесообразным. На этом примере  
становится ясно, что SRP — это не догма, а нарушение этого принципа вполне может быть логичным и целесообразным.  

##### Open-closed — принцип открытости / закрытости

Принцип декларирует, что программные сущности (классы, модули, функции и т. п.) должны быть открыты для расширения,  
но закрыты для изменения. Это означает, что эти сущности могут менять свое поведение без изменения их исходного кода.  

Другими словами, нужно избегать случаев, когда появление новых требований к функциональности влечет за собой  
модификацию существующей логики, стараясь реализовать возможность ее расширения.  

Нашей целью является разработка системы, которая будет достаточно просто и безболезненно меняться. Другими словами,  
система должна быть гибкой. Например, внесение изменений в библиотеку общую для 4х проектов не должно быть долгим  
(«долгим» является разным промежутком времени для конкретной ситуации) и уж точно не должно вести к изменениям  
в этих 4х проектах.  

```
//Конкретная реализация
public class Logger
{
    public void Log(string logText)
    {
        // сохранить лог в файле
    }
}
  
public class SmtpMailer
{
    private readonly Logger logger;
  
    public SmtpMailer()
    {
        logger = new Logger();
    }
  
    public void SendMessage(string message)
    {
        // отсылка сообщения
  
        logger.Log(string.Format("Отправлено '{0}'", message));
    }
}

//Конкретная реализация для сохранения логов в базу
public class DatabaseLogger
{
    public void Log(string logText)
    {
        // сохранить лог в базе данных
    }
}


//А теперь самое интересное. Мы должны изменить класс SmptMailer из-за изменившегося бизнес-требования.
//! но следуя принципу open/close мы не должны менять код, а только дополнять
```

##### Решение
```
public interface Logger
{
    void Log(string logText);
}
  
public class FileLogger : Logger
{
    public void Log(string logText)
    {
        // сохранить лог в файле
    }
}
  
public class DatabaseLogger : Logger
{
    public void Log(string logText)
    {
        // сохранить лог в базе данных
    }
}


//Теперь мы не зависим от реализации Logger и можем менять класс, добавляя новые зависимости (новые реализации Logger)
public class SmtpMailer
{
    private readonly Logger logger;
  
    public SmtpMailer(Logger logger)
    {
        this.logger = logger;
    }
  
    public void SendMessage(string message)
    {
        // отсылка сообщения
  
        logger.Log(string.Format("Отправлено '{0}'", message));
    }
}
```