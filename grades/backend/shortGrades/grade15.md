## Грейд 15

### Theory

#### Функциональное программирование

Система Лямбда-исчисления по сути была языком программирования для одной из воображаемых машин. Она была основана на функциях, которые  
принимают в качестве аргументов функции, и возвращают функцию. Такая функция была обозначена греческой буквой Лямбда λ,  
что дало название всей системе. В данном контексте лямбда — это функция. А греческая буква используется для удобства математической записи.  
List Processing language (Lisp). Lisp задумывался как имплементация Лямбда-исчисления  

Функциональное программирование — это практическая реализация идей Алонзо Чёрча. Не все идеи Лямбда-исчисления  
переросли в практическую сферу, так как лямбда-исчисления не учитывали физических ограничений.  
Тем не менее, как и ОО программирование, функциональное программирование — это набор идей, а не набор четких указаний.  

Функция — это базовый элемент функционального программирования. Функции используются почти для всего,  
даже для простейших расчётов. Даже переменные заменяются функциями. В функциональном программировании переменные — это  
просто синонимы (alias) для выражений (чтобы нам не пришлось писать всё в одну строку). Их нельзя изменять.  
В каждую переменную можно записать только один раз.  

Оказывается, что функциональные программы могут хранить состояние, только они не используют для этого переменные.  
Они используют функции. Состояние хранится в параметрах функции, в стеке.  
Если хотите сохранить состояние, чтобы потом изменить его через время, то нужно написать рекурсивную функцию.  

Так как в ФП каждый символ является неизменяемым, то функции не имеют побочных действий. Вы не можете менять  
значения переменных, к тому же функция не может поменять значение вне своей области видимости, и тем самым повлиять  
на другие функции (как это может случится с полями класса или глобальными переменными). Это означает, что  
единственный результат выполнения функции — это возвращаемое значение. А единственное, что может повлиять на  
возвращаемое значение — это аргументы, передаваемые в функцию.  

В ФП ситуация намного проще — если возвращаемое значение неправильное, то оно всегда будет неправильным, не зависимо от  
того, какие куски кода выполнялись прежде.  

Функциональная программа сразу готова к распараллеливанию без каких-либо изменений. Вам не придётся задумываться  
о deadlock-ах или состояниях гонки (race conditions) потому что вам не нужны блокировки! Ни один кусочек данных в  
функциональной программе не меняется дважды одним и тем же потоком или разными.  

В функциональной программе всё состояние хранится в стеке в виде аргументов функций. Это позволяет  
значительно упростить развёртывание по горячему! По сути всё что нужно сделать — это вычислить  
разницу между кодом на рабочем сервере и новой версией, и установить изменения в коде.  
Остальное будет сделано языковыми инструментами автоматически!  

Функции, которые оперируют функциями (принимают их в качестве аргументов) называются функциями высшего порядка  

Функциональная программа — программа, состоящая из чистых функций.  
Функция f является чистой если выражение f(x) является ссылочно прозрачным для всех ссылочно прозрачных x  
Ссылочная прозрачность — свойство, при котором замена выражения на  
вычисленный результат этого выражения не изменяет желаемых свойств программы  

В общем и целом, ФП направлено на то, чтобы можно было судить о поведении функции наблюдая только её одну  

```
//Rust

fn main() {
    let _ = print!("Hello ");
    println!("world!");
}
// Hello world!

//Haskell
main :: IO ()
main = do
  let _ = print "Hello "
  print "world!"
  
// world
```

#### CI/CD

##### Определения

CI - continuous integration - минимизировать расхождение веток (отсутствие долгоживущих веток)  
CD - continuous delivery    - серия практик, направленных на то, чтобы обновления программного обеспечения происходили практически постоянно  
CD - continuous deployment  - запуск всех этапов сборки и автоматический деплой на продакшн  

![cicd.png](../../../assets/images/cicd.png)  

##### Плюсы и минусы ci/cd

Плюсы
- Одинаковый пайплайн для всех разработчиков
- Уменьшение человеческого фактора "если что-то забыли запустить"
- Автоматизация процессов
- Мониторинг ошибок
- Уменьшение рисков при ошибках (автоматический откат)
- Параллельный запуск множества сборок

Минусы
- Усложнение процесса разработки (развертывание и поддержка ci/cd)
- Покупка дополнительных ресурсов для runner`ров

##### Реализация ci/cd на примере gitlab ci.  
![gitlabci.png](../../../assets/images/gitlabci.png)  

1. Build
 - Сборка всех необходимых образов
2. Test
 - Прогон всех тестов
 - Прогон линтера и анализатора кода
3. Deploy
 - Сборка prod образов
4. Production
 - Отправка prod образов на сервер

Если произошла ошибка на каком либо этапе, сборка останавливается и изменения не попадут на  
следующий этап (или прод сервер).  

При деплое изменений структуры БД следует учитывать ее обратную совместимость с кодом. Миграции не принято откатывать.  
Не следует удалять что либо из БД (возможно через год или два предварительно сложив в архивную таблицу).  
