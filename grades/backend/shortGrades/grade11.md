## Грейд 11

### Theory  

#### JWT  
JSON Web Token (JWT) — это JSON объект, который определен в открытом стандарте RFC 7519. Он считается одним из  
безопасных способов передачи информации между двумя участниками. Для его создания необходимо определить заголовок  
(header) с общей информацией по токену, полезные данные (payload), такие как id пользователя, его роль и т.д.  
и подписи (signature).  
Простыми словами, JWT — это лишь строка в следующем формате header.payload.signature.  

Приложение использует JWT для проверки аутентификации пользователя следующим образом:  
- Сперва пользователь заходит на сервер аутентификации с помощью аутентификационного ключа.
- Затем сервер аутентификации создает JWT и отправляет его пользователю.
- Когда пользователь делает запрос к API приложения, он добавляет к нему полученный ранее JWT. 
- Когда пользователь делает API запрос, приложение может проверить по переданному с запросом JWT является ли пользователь тем, за кого себя выдает. В этой схеме сервер приложения сконфигурирован так, что сможет проверить, является ли входящий JWT именно тем, что был создан сервером аутентификации.

header = { "alg": "HS256", "typ": "JWT"}  
alg - алгоритм хеширования  

payload = { "userId": "b08f86af-35da-48f2-8fab-cef3904660bd" }  
iss (issuer) — определяет приложение, из которого отправляется токен.  
sub (subject) — определяет тему токена.  
exp (expiration time) — время жизни токена.  

Очень важно понимать, что использование JWT НЕ скрывает и не маскирует данные автоматически. Причина, почему JWT  
используются — это проверка, что отправленные данные были действительно отправлены авторизованным источником.  
Как было продемонстрировано выше, данные внутри JWT закодированы и подписаны, обратите внимание, это не одно и  
тоже, что зашифрованы. Цель кодирования данных — преобразование структуры.  

#### Oauth  
OAuth 2.0 — это стандарт безопасности, позволяющий одному приложению получить разрешение на доступ к информации в  
другом приложении. Последовательность действий для выдачи разрешения [permission] (или согласия [consent])  
часто называют авторизацией [authorization] или даже делегированной авторизацией [delegated authorization].  
С помощью этого стандарта вы позволяете приложению считать данные или использовать функции другого приложения от  
вашего имени, не сообщая ему свой пароль.  

#### OpenID
OpenID Connect (OIDC) — это тонкий слой поверх OAuth 2.0, добавляющий сведения о логине и профиле пользователя,  
который вошел в учетную запись. Организацию логин-сессии часто называют аутентификацией [authentication], а  
информацию о пользователе, вошедшем в систему (т.е. о Resource Owner'е), — личными данными [identity].  
Если Authorization Server поддерживает OIDC, его иногда называют поставщиком личных данных [identity provider],  
поскольку он предоставляет Client'у информацию о Resource Owner'е.  

OpenID Connect позволяет реализовывать сценарии, когда единственный логин можно использовать во множестве приложений, —  
этот подход также известен как single sign-on (SSO). Например, приложение может поддерживать SSO-интеграцию с  
социальными сетями, такими как Facebook или Twitter, позволяя пользователям использовать учётную запись,  
которая у них уже имеется и которую они предпочитают использовать.  

### Language  

#### ООП в PHP Сериализация объектов  
Функция serialize() возвращает строковое представление любого значения, которое может быть сохранено в PHP. Функция  
unserialize() может использовать эту строку для восстановления исходного значения переменной. Использование  
сериализации для сохранения объекта сохранит все его переменные. Методы в объекте не будут сохранены, а только имя класса.  
```php
<?php

$data = ['test' => 'best', 'gest' => 7777];

$serializedData = serialize($data);

// a:2:{s:4:"test";s:4:"best";s:4:"gest";i:7777;}
```

#### ООП в PHP Магические методы  
Все имена методов, начинающиеся с __, зарезервированы PHP. Не рекомендуется использовать имена методов с __ в PHP,  
если вы не хотите использовать соответствующую магическую функциональность.  

Методы:
- __construct() вызывается при создании объекта
- __destruct() вызывается при завершении работы скрипта 
- __call() запускается при вызове недоступных методов в контексте объект.
- __callStatic() запускается при вызове недоступных методов в статическом контексте.
- __get() будет выполнен при записи данных в недоступные (защищённые или приватные) или несуществующие свойства.
- __set() будет выполнен при чтении данных из недоступных (защищённых или приватных) или несуществующих свойств.
- __isset() будет выполнен при использовании isset() или empty() на недоступных (защищённых или приватных) или несуществующих свойствах.
- __unset() будет выполнен при вызове unset() на недоступном (защищённом или приватном) или несуществующем свойстве.
- __sleep() 
- __wakeup() 
- __serialize() 
- __unserialize() 
- __toString()
- __invoke() вызывается, когда скрипт пытается выполнить объект как функцию.
- __set_state() 
- __clone()
- __debugInfo()

#### PHP Паттерны проектирования: "декоратор"  

### Framework  

#### Yii2 Работа с БД - Active Record связанные данные  
Помимо работы с отдельными таблицами баз данных, Active Record также имеет возможность объединять связные  
данные, что делает их легко-доступными для получения через основные объекты данных.  
```php
class Customer extends ActiveRecord
{
    public function getOrders()
    {
        return $this->hasMany(Order::className(), ['customer_id' => 'id']);
    }
}

class Order extends ActiveRecord
{
    public function getCustomer()
    {
        return $this->hasOne(Customer::className(), ['id' => 'customer_id']);
    }
}
```
Если связь объявлена с помощью метода hasMany(), доступ к свойству связи вернёт массив связных объектов Active Record;  
если связь объявлена с помощью метода hasOne(), доступ к свойству связи вернёт связный Active Record объект или null,  
если связные данные не найдены.  

Связывание посредством промежуточной таблицы
```php
class Order extends ActiveRecord
{
    public function getItems()
    {
        return $this->hasMany(Item::className(), ['id' => 'item_id'])
            ->viaTable('order_item', ['order_id' => 'id']);
    }
}

class Order extends ActiveRecord
{
    public function getOrderItems()
    {
        return $this->hasMany(OrderItem::className(), ['order_id' => 'id']);
    }

    public function getItems()
    {
        return $this->hasMany(Item::className(), ['id' => 'item_id'])
            ->via('orderItems');
    }
}
```
Жадная загрузка with:
```php
$customers = Customer::find()
    ->with('orders')
    ->limit(100)
    ->all();

foreach ($customers as $customer) {
    // SQL-запрос не выполняется
    $orders = $customer->orders;
}
```
#### Yii2 Работа с БД - Active Record транзакции  
Есть два способа использования транзакций при работе с Active Record.
```php
$customer = Customer::findOne(123);

Customer::getDb()->transaction(function($db) use ($customer) {
    $customer->id = 200;
    $customer->save();
    // ...другие операции с базой данных...
});

// или по-другому

$transaction = Customer::getDb()->beginTransaction();
try {
    $customer->id = 200;
    $customer->save();
    // ...другие операции с базой данных...
    $transaction->commit();
} catch(\Exception $e) {
    $transaction->rollBack();
    throw $e;
} catch(\Throwable $e) {
    $transaction->rollBack();
    throw $e;
}
```

Второй способ заключается в том, чтобы перечислить операции с базой данных, которые требуют тразнакционного выполнения,  
в методе yii\db\ActiveRecord::transactions().  
```php
class Customer extends ActiveRecord
{
    public function transactions()
    {
        return [
            'admin' => self::OP_INSERT,
            'api' => self::OP_INSERT | self::OP_UPDATE | self::OP_DELETE,
            // вышеприведённая строка эквивалентна следующей:
            // 'api' => self::OP_ALL,
        ];
    }
}
```
OP_INSERT: операция вставки, осуществляемая с помощью метода insert();  
OP_UPDATE: операция обновления, осуществляемая с помощью метода update();  
OP_DELETE: операция удаления, осуществляемая с помощью метода delete().

### Testing  
#### BDD  
BDD (сокр. от англ. Behavior-driven development, дословно «разработка через поведение») — это методология разработки  
программного обеспечения, являющаяся ответвлением от методологии разработки через тестирование (TDD).  
Основной идеей данной методологии является совмещение в процессе разработки чисто технических интересов и интересов  
бизнеса, позволяя тем самым управляющему персоналу и программистам говорить на одном языке. Для общения между этими  
группами персонала используется предметно-ориентированный язык, основу которого представляют конструкции из  
естественного языка, понятные неспециалисту, обычно выражающие поведение программного продукта и ожидаемые результаты.  

BDD фокусируется на следующих вопросах:
- С чего начинается процесс.
- Что нужно тестировать, а что нет.
- Сколько проверок должно быть совершено за один раз.
- Что можно назвать проверкой.
- Как понять, почему тест не прошёл

Исходя из этих вопросов, BDD требует, чтобы имена тестов были целыми предложениями, которые начинаются с глагола в  
сослагательном наклонении и следовали бизнес целям. Описание приемочных тестов должно вестись на гибком языке  
пользовательской истории.

### Storage  

#### Представления  
Представления или Views представляют виртуальные таблицы. Но в отличии от обычных стандартных таблиц в базе данных  
представления содержат запросы, которые динамически извлекают используемые данные.  

Представления дают нам ряд преимуществ. Они упрощают комплексные SQL-операции. Они защищают данные, так как  
представления могут дать доступ к части таблицы, а не ко всей таблице. Представления также позволяют  
возвращать отформатированные значения из таблиц в нужной и удобной форме.  
CREATE VIEW <name> AS <query>
#### Понятие о партиционировании таблиц  
Секционирование (англ. partitioning) — разделение хранимых объектов баз данных (таких как таблиц, индексов,  
материализованных представлений) на отдельные части с раздельными параметрами физического хранения. Используется в  
целях повышения управляемости, производительности и доступности для больших баз данных.  

В отличие от сегментирования (англ. sharding), где каждый сегмент управляется отдельным экземпляром СУБД, и  
используются средства координации между ними (что позволяет распределить базу данных на несколько вычислительных узлов),  
при секционировании доступ ко всем секциям осуществляется из единого экземпляра СУБД (или симметрично из любого  
экземпляра кластерной СУБД, такого, как Oracle RAC).  

### DB  

#### PostgreSQL Представления  
CREATE VIEW создаёт представление запроса. Создаваемое представление лишено физической материализации, поэтому  
указанный запрос будет выполняться при каждом обращении к представлению.  
Команда CREATE OR REPLACE VIEW действует подобным образом, но если представление с этим именем уже существует, оно заменяется.  
```postgresql
CREATE VIEW comedies AS
    SELECT *
    FROM films
    WHERE kind = 'Comedy';
```

#### PostgreSQL Подзапросы  
Подзапросы (subquery) представляют такие запросы, которые могут быть встроены в другие запросы.  
```postgresql
SELECT *
FROM Products
WHERE Price = (SELECT MIN(Price) FROM Products);
```

Но кроме того есть коррелирующие подзапросы (correlated subquery), результаты которых зависят от строк, которые извлекаются в основном запросе.  
```postgresql
SELECT  CreatedAt,
        Price,
        (SELECT ProductName FROM Products
         WHERE Products.Id = Orders.ProductId) AS Product
FROM Orders;
```

Выражения подзапросов  
- EXISTS (подзапрос)
- выражение IN (подзапрос)
- выражение NOT IN (подзапрос)
- выражение оператор ANY (подзапрос)
- выражение оператор SOME (подзапрос)
- выражение оператор ALL (подзапрос)

#### PostgreSQL Множественное добавление  
```postgresql
INSERT INTO products (product_no, name, price)
VALUES (1, 'Cheese', 9.99),
       (2, 'Bread', 1.99),
       (3, 'Milk', 2.99);
```

```postgresql
INSERT INTO member (barcode_id, promotion_id, created_at)
select user_barcode.id, 68, NOW()
from user_barcode
         left join member on user_barcode.id = member.barcode_id
where user_barcode.created_at
    between '2021-03-15 00:00:00' and '2021-03-29 00:00:00'
  and member.barcode_id is null;
```
COPY перемещает данные между таблицами PostgreSQL и обычными файлами в файловой системе.  
COPY TO копирует содержимое таблицы в файл. 
COPY FROM — из файла в таблицу (добавляет данные к тем, что уже содержались в таблице).  
COPY TO может также скопировать результаты запроса SELECT.  

### Frontend  

#### JS Замыкания  
Замыкание – это функция, которая запоминает свои внешние переменные и может получить к ним доступ. В некоторых языках  
это невозможно, или функция должна быть написана специальным образом, чтобы получилось замыкание.  
в JavaScript, все функции изначально являются замыканиями.  

```js
function makeCounter() {
  let count = 0;

  return function() {
    return count++; // есть доступ к внешней переменной "count"
  };
}

let counter = makeCounter();

alert( counter() ); // 0
alert( counter() ); // 1
alert( counter() ); // 2


let counter1 = makeCounter();
let counter2 = makeCounter();

alert( counter1() ); // 0
alert( counter1() ); // 1

alert( counter2() ); // 0 (независимо)
```


### DevOps  

#### *top  
top (table of processes) — консольная команда, которая выводит список работающих в системе процессов и информацию о них.

#### ps  
ps (от англ. process status) — программа в UNIX, Unix-подобных и других POSIX-совместимых операционных системах, выводящая  
отчёт о работающих процессах.

Каждый из процессов может находиться в одном из таких состояний:
- Запуск - процесс либо уже работает, либо готов к работе и ждет, когда ему будет дано процессорное время;
- Ожидание - процессы в этом состоянии ожидают какого-либо события или освобождения системного ресурса. Ядро делит такие процессы на два типа - те, которые ожидают освобождения аппаратных средств и приостановление с помощью сигнала;
- Остановлено - обычно, в этом состоянии находятся процессы, которые были остановлены с помощью сигнала;
- Зомби - это мертвые процессы, они были остановлены и больше не выполняются, но для них есть запись в таблице процессов, возможно, из-за того, что у процесса остались дочерние процессы.

#### iptables  

$ iptables -t таблица действие цепочка дополнительные_параметры

Подсистема iptables и Netfilter уже достаточно давно встроена в ядро Linux. Все сетевые пакеты, которые проходят через  
компьютер, отправляются компьютером или предназначены компьютеру, ядро направляет через фильтр iptables. Там эти пакеты  
поддаются проверкам и затем для каждой проверки, если она пройдена выполняется указанное в ней действие. Например,  
пакет передается дальше ядру для отправки целевой программе, или отбрасывается.  

Соответственно в фильтре iptables все пакеты делятся на три аналогичные цепочки:
- Input - обрабатывает входящие пакеты и подключения. Например, если какой-либо внешний пользователь пытается подключиться к вашему компьютеру по ssh или любой веб-сайт отправит вам свой контент по запросу браузера. Все эти пакеты попадут в эту цепочку;
- forward - эта цепочка применяется для проходящих соединений. Сюда попадают пакеты, которые отправлены на ваш компьютер, но не предназначены ему, они просто пересылаются по сети к своей цели. Как я уже говорил, такое наблюдается на маршрутизаторах или, например, если ваш компьютер раздает wifi;
- output - эта цепочка используется для исходящих пакетов и соединений. Сюда попадают пакеты, которые были созданы при попытке выполнить ping losst.ru или когда вы запускаете браузер и пытаетесь открыть любой сайт.

Правила и действия
- ACCEPT - разрешить прохождение пакета дальше по цепочке правил;
- DROP - удалить пакет;
- REJECT - отклонить пакет, отправителю будет отправлено сообщение, что пакет был отклонен;
- LOG - сделать запись о пакете в лог файл;
- QUEUE - отправить пакет пользовательскому приложению.

#### netstat  
Команда netstat, входящая в стандартный набор сетевых инструментов UNIX, отображает различную network–related информацию,  
такую как сетевые подключения, статистику интерфейсов, таблицы маршрутизации, masquerade, multicast, и т.п.  

Список всех портов (как прослушиваемых, так и нет)
- Перечислить все порты: netstat -a
- Перечислить все TCP порты: netstat -at
- Перечислить все UDP порты: netstat -au

### Misc  
#### Docker: оптимизация сборки  